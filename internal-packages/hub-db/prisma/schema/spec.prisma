// "Spec" == "Definition" == "Question", a node in the ontology graph that can be responded to with a value.
model Spec {
    id String @id @default(cuid())

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    description String

    specLists   SpecsOnSpecLists[]
    evalResults EvalResult[]
}

model SpecList {
    id String @id @default(cuid())

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    name String

    specs SpecsOnSpecLists[]
    evals Eval[]
}

model SpecsOnSpecLists {
    spec   Spec   @relation(fields: [specId], references: [id], onDelete: Cascade)
    specId String

    specList   SpecList @relation(fields: [specListId], references: [id], onDelete: Cascade)
    specListId String

    @@id([specId, specListId])
    @@index([specId])
    @@index([specListId])
}

enum EvalState {
    Pending
    Running
    Completed
    Failed
}

// "Eval" is a shorthand for "collection of EvalResults on a SpecList"
model Eval {
    id String @id @default(cuid())

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    state     EvalState @default(Pending)
    errorMsg  String?   // Optional error message when state is 'Failed'

    // metadata about the evaluator that was used
    evaluator   Evaluator @relation(fields: [evaluatorId], references: [id])
    evaluatorId String

    specList   SpecList @relation(fields: [specListId], references: [id], onDelete: Cascade)
    specListId String

    evalResults EvalResult[]
}

model EvalResult {
    id String @id @default(cuid())

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    spec   Spec   @relation(fields: [specId], references: [id], onDelete: Cascade)
    specId String

    /**
     * All eval results are Squiggle models.
     * Simple approach, Squiggle code is copy-pasted here from AiWorkflow outputs.
     * Ideally, we should store each result as a Model or a Variable table. But that part of codebase is too complicated to bother for now, because of revisions.
     */
    code String

    eval   Eval   @relation(fields: [evalId], references: [id])
    evalId String

    workflowId String?     @unique
    workflow   AiWorkflow? @relation(fields: [workflowId], references: [id])
}

enum EvaluatorType {
    SquiggleAI
}

/**
 * Evaluators are the configurations that produce evals.
 * The main kind of evaluator is Squiggle AI evaluator, but we can add more (e.g. prompting a human to evaluate, or loading resolved results from Metaforecast database).
 */
model Evaluator {
    id String @id @default(cuid())

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    name String

    type EvaluatorType @default(SquiggleAI)

    // Untyped, for now; validated by zod in the codebase.
    // For AI, this should contain `LlmConfig` object.
    config Json
    evals  Eval[]
}
