export const README = "# Squiggle Documentation\n\nSquiggle is a very simple language. Don't try using language primitives/constructs you don't see below, or that aren't in our documentation. They are likely to fail.\n\nWhen writing Squiggle code, it's important to avoid certain common mistakes:\n\n### Syntax and Structure\n\n1. Variable Expansion: Not supported. Don't use syntax like |v...| or |...v|.\n2. All pipes are \"->\", not \"|>\".\n3. Dict keys and variable names must be lowercase.\n4. The last value in a block/function is returned (no \"return\" keyword).\n5. Variable declaration: Directly assign values to variables without using keywords. For example, use `foo = 3` instead of `let foo = 3`.\n6. All statements in your model, besides the last one must either be comments or variable declarations. You can't do, `4 \\n 5 \\n 6` Similarly, you can't do, `Calculator() ... Table()` - instead, you need to set everything but the last item to a variable.\n\n### Function Definitions and Use\n\n1. Anonymous Functions: Use {|e| e} syntax for anonymous functions.\n2. Function Parameters: When using functions like normal, specify the standard deviation with stdev instead of sd. For example, use normal({mean: 0.3, stdev: 0.1}) instead of normal({mean: 0.3, sd: 0.1}).\n3. There's no recursion.\n4. You can't call functions that accept ranges, with distributions. No, `({|foo: [1,20]| foo}) (4 to 5)`.\n\n### Data Types and Input Handling\n\n1. Input Types: Use Input.text for numeric inputs instead of Input.number or Input.slider.\n2. The only function param types you can provide are numeric/date ranges, for numbers. f(n:[1,10]). Nothing else is valid. You cannot provide regular input type declarations.\n3. Only use Inputs directly inside calculators. They won't return numbers, just input types.\n\n### Looping, Conditionals, and Data Operations\n\n1. Conditional Statements: There are no case or switch statements. Use if/else for conditional logic.\n2. There aren't for loops or mutation. Use immutable code, and List.map / List.reduce / List.reduceWhile.\n3. Remember to use `Number.sum` and `Number.product`, instead of using Reduce in those cases.\n\n### List and Dictionary Operations\n\n1. You can't do \"(0..years)\". Use List.make or List.upTo.\n2. There's no \"List.sort\", but there is \"List.sortBy\", \"Number.sort\".\n\n### Randomness and Distribution Handling\n\n1. There's no random() function. Use alternatives like sample(uniform(0,1)).\n2. When representing percentages, use \"5%\" instead of \"0.05\" for readability.\n3. The `to` syntax only works for >0 values. \"4 to 10\", not \"0 to 10\".\n\n### Units and Scales\n\n1. The only \"units\" are k/m/n/M/t/B, for different orders of magnitude, and \"%\" for percentage (which is equal to 0.01).\n2. If you make a table that contains a column of similar distributions, use a scale to ensure consistent min and max.\n3. Scale.symlog() has support for negative values, Scale.log() doesn't. Scale.symlog() is often a better choice for this reason, though Scale.log() is better when you are sure values are above 0.\n4. Do use Scale.symlog() and Scale.log() on dists/plots that might need it. Many do!\n\n### Documentation and Comments\n\n1. Tags like @name and @doc apply to the following variable, not the full file.\n2. If you use a domain for Years, try to use the Date domain, and pass in Date objects, like Date(2022) instead of 2022.\n\n---\n\nThis format provides a clear and organized view of the guidelines for writing Squiggle code.\n\nHere's are some simple example Squiggle programs:\n\n```squiggle\n//Model for Piano Tuners in New York Over Time\n\n@name(\"ðŸŒ† Population of New York in 2022\")\n@doc(\"I'm really not sure here, this is a quick guess.\")\npopulationOfNewYork2022 = 8.1M to 8.4M\n\n@name(\"ðŸŽ¹ Percentage of Population with Pianos\")\n@format(\".1%\")\nproportionOfPopulationWithPianos = 0.2% to 1%\n\n@name(\"ðŸ”§ Number of Piano Tuners per Piano\")\npianoTunersPerPiano = {\n  pianosPerPianoTuner = 2k to 50k\n  1 / pianosPerPianoTuner\n}\n\n//We only mean to make an estimate for the next 10 years.\n@hide\ndomain = [Date(2024), Date(2034)]\n\n@name(\"Population at Time\")\npopulationAtTime(t: domain) = {\n  dateDiff = Duration.toYears(t - Date(2024))\n  averageYearlyPercentageChange = normal({ p5: -1%, p95: 5% }) // We're expecting NYC to continuously grow with an mean of roughly between -1% and +4% per year\n  populationOfNewYork2022 * (averageYearlyPercentageChange + 1) ^ dateDiff\n}\n\n@name(\"Total Tuners, at Time\")\ntotalTunersAtTime(t: domain) = populationAtTime(t) *\n  proportionOfPopulationWithPianos *\n  pianoTunersPerPiano\n\nmeanTunersAtTime(t: domain) = mean(totalTunersAtTime(t))\n```\n\n```squiggle\ncalculator = Calculator(\n  {|a, b, c, d| [a, b, c, d]},\n  {\n    title: \"Concat()\",\n    description: \"This function takes in 4 arguments, then displays them\",\n    sampleCount: 10000,\n    inputs: [\n      Input.text(\n        {\n          name: \"First Param\",\n          default: \"10 to 13\",\n          description: \"Must be a number or distribution\",\n        }\n      ),\n      Input.textArea(\n        {\n          name: \"Second Param\",\n          default: \"[4,5,2,3,4,5,3,3,2,2,2,3,3,4,45,5,5,2,1]\",\n        }\n      ),\n      Input.select(\n        {\n          name: \"Third Param\",\n          default: \"Option 1\",\n          options: [\"Option 1\", \"Option 2\", \"Option 3\"],\n        }\n      ),\n      Input.checkbox({ name: \"Fourth Param\", default: false }),\n    ],\n  }\n)\n\n```\n\n```squiggle\n// Cost-benefit analysis for a housing addition in berkeley\n\n// Input section\n@name(\"Model Inputs\")\n@doc(\"Key parameters for the housing development project\")\ninputs = {\n  landCost: 1M to 2M,\n  constructionCost: 500k to 800k,\n  permitFees: 50k to 100k,\n  numberOfHomes: 10,\n  monthlyRentalIncome: 3k to 5k,\n  annualPropertyAppreciation: 2% to 5%,\n  annualSocialBenefit: 10k to 30k,\n  yearsToConsider: 30,\n}\n\n// Calculation section\n@name(\"Calculations\")\n@doc(\"Core calculations for the cost-benefit analysis\")\ncalculations(i) = {\n  totalCostPerHome = i.landCost + i.constructionCost + i.permitFees\n  annualRentalIncome = i.numberOfHomes * i.monthlyRentalIncome * 12\n  totalCost = i.numberOfHomes * totalCostPerHome\n\n  annualAppreciation(year) = i.numberOfHomes * totalCostPerHome *\n    ((1 + i.annualPropertyAppreciation) ^ year -\n      (1 + i.annualPropertyAppreciation) ^ (year - 1))\n\n  annualBenefit(year) = annualRentalIncome + annualAppreciation(year) +\n    i.numberOfHomes * i.annualSocialBenefit\n\n  totalBenefit = List.upTo(1, i.yearsToConsider) -> List.map(annualBenefit)\n    -> List.reduce(\n      0,\n      {|acc, val| acc + val}\n    )\n\n  netBenefit = totalBenefit - totalCost\n  probPositiveNetBenefit = 1 - cdf(netBenefit, 0)\n\n  {\n    totalCostPerHome: totalCostPerHome,\n    annualRentalIncome: annualRentalIncome,\n    totalCost: totalCost,\n    totalBenefit: totalBenefit,\n    netBenefit: netBenefit,\n    probPositiveNetBenefit: probPositiveNetBenefit,\n  }\n}\n\n// Apply calculations to inputs\n@name(\"Results\")\n@doc(\"Output of calculations based on input parameters\")\nresults = calculations(inputs)\n\n// Analysis section\n@name(\"Cost-Benefit Analysis\")\n@doc(\"Detailed analysis of the housing development project\")\nanalysis = {\n  costsTable = Table.make(\n    [\n      { name: \"Land Cost per Home\", value: inputs.landCost },\n      { name: \"Construction Cost per Home\", value: inputs.constructionCost },\n      { name: \"Permit Fees per Home\", value: inputs.permitFees },\n      { name: \"Total Cost per Home\", value: results.totalCostPerHome },\n      { name: \"Total Cost for 10 Homes\", value: results.totalCost },\n    ],\n    {\n      columns: [\n        { name: \"Item\", fn: {|r| r.name} },\n        {\n          name: \"Cost\",\n          fn: {\n            |r|\n            Plot.dist(\n              r.value,\n              {\n                xScale: Scale.log({ tickFormat: \"($.1s\", min: 20k, max: 200M }),\n              }\n            )\n          },\n        },\n      ],\n    }\n  )\n\n  benefitTable = Table.make(\n    [\n      {\n        name: \"Monthly Rental Income per Home\",\n        value: inputs.monthlyRentalIncome,\n      },\n      {\n        name: \"Annual Social Benefit per Home\",\n        value: inputs.annualSocialBenefit,\n      },\n      { name: \"Total Benefit over 30 years\", value: results.totalBenefit },\n    ],\n    {\n      columns: [\n        { name: \"Item\", fn: {|r| r.name} },\n        {\n          name: \"Value\",\n          fn: {\n            |r|\n            Plot.dist(\n              r.value,\n              { xScale: Scale.linear({ tickFormat: \"($.1s\" }) }\n            )\n          },\n        },\n      ],\n    }\n  )\n\n  netBenefitPlot = Plot.dist(\n    results.netBenefit,\n    {\n      title: \"Distribution of Net Benefit\",\n      xScale: Scale.log({ tickFormat: \"($.1s\", min: 10M, max: 200M }),\n    }\n  )\n\n  {\n    title: \"Cost-Benefit Analysis: Adding 10 Homes to Berkeley, CA\",\n    costs: costsTable,\n    benefits: benefitTable,\n    netBenefit: netBenefitPlot,\n    probabilityOfPositiveNetBenefit: results.probPositiveNetBenefit,\n  }\n}\n\nanalysis\n\n```\n\n```squiggle\nx = 10\nresult = if x == 1 then {\n  {y: 2, z: 0}\n} else {\n  {y: 0, z: 4}\n}\ny = result.y\nz = result.z\n```\n\n```squiggle\n@showAs({|f| Plot.numericFn(f, { xScale: Scale.log({ min: 1, max: 100 }) })})\nfn(t) = t ^ 2\n```\n\n```squiggle\nplot = {|t| normal(t, 2) * normal(5, 3)}\n  -> Plot.distFn(\n    {\n      title: \"A Function of Value over Time\",\n      xScale: Scale.log({ min: 3, max: 100, title: \"Time (years)\" }),\n      yScale: Scale.linear({ title: \"Value\" }),\n      distXScale: Scale.linear({ tickFormat: \"#x\" }),\n    }\n  )\n```\n\n```squiggle\nf(t: [Date(2020), Date(2040)]) = {\n  yearsPassed = toYears(t - Date(2020))\n  normal({mean: yearsPassed ^ 2, stdev: yearsPassed^1.3+1})\n}\n```\n\n```squiggle\nimport \"hub:ozziegooen/sTest\" as sTest\n@name(\"ðŸ’° Expected Cost\")\n@format(\"($.2s\")\nflightCost = normal({ mean: 600, stdev: 100 })\n\n@name(\"ðŸ¥‡ Expected Benefit\")\n@format(\"($.2s\")\nbenefitEstimate = normal({ mean: 1500, stdev: 300 })\n\n@name(\"ðŸ“Š Net Benefit\")\n@format(\"($.2s\")\nnetBenefit = benefitEstimate - flightCost\n\n@name(\"ðŸš¦ Test Suite\")\n@doc(\n  \"Test suite to validate various aspects of the flight cost and benefits model using sTest.\"\n)\ntestSuite = sTest.describe(\n  \"Flight to London Test Suite\",\n  [\n    // Test for reasonable flight costs\n    sTest.test(\n      \"Flight cost should be reasonable\",\n      {\n        ||\n        meanValue = mean(flightCost)\n        sTest.expect(meanValue).toBeBetween(300, 10k)\n      }\n    ),\n  ]\n)\n\n```\n\n# Language Features\n\n## Program Structure\n\nA Squiggle program consists of a series of definitions (for example, `x = 5`, `f(x) = x * x`). This can optionally conclude with an _end expression_.\n\nIf an end expression is provided, it becomes the evaluated output of the program, and only this result will be displayed in the viewer. Otherwise, all top-level variable definitions will be displayed.\n\n```squiggle\nx = 5\ny = 10\nx + y\n```\n\n```squiggle\nx = 5\ny = 10\n```\n\n## Immutability\n\nAll variables in Squiggle are immutable, similar to other functional programming languages like OCaml or Haskell.\n\nIn the case of container types (lists and dictionaries), this implies that an operation such as myList[3] = 10 is not permitted. Instead, we recommend using `List.map`, `List.reduce` or other [List functions](/docs/Api/List).\n\nIn case of basic types such as numbers or strings, the impact of immutability is more subtle.\n\nConsider this code:\n\n```squiggle\nx = 5\nx = x + 5\n```\n\nWhile it appears that the value of x has changed, what actually occurred is the creation of a new variable with the same name, which [shadowed](https://en.wikipedia.org/wiki/Variable_shadowing) the previous x variable.\n\nIn most cases, shadowing behaves identically to what you'd expect in languages like JavaScript or Python.\n\nOne case where shadowing matters is closures:\n\n```squiggle\nx = 5\nargPlusX(y) = x + y\n\nx = x + 5\n\nargPlusX(5)\n```\n\nIn the above example, the `argPlusX` function captures the value of `x` from line 1, not the newly shadowed `x` from line 4. As a result, `argPlusX(5)` returns 10, not 15.\n\n## Blocks\n\nBlocks are special expressions in Squiggle that can contain any number of local definitions and end with an expression.\n\n```squiggle\nx = { 5 } // same as \"x = 5\"\ny = {\n  t = 10 // local variable, won't be available outside of the block body\n  5 * t // end expression\n}\n```\n\n## Conditionals\n\nIf/then/else statements in Squiggle are values too.\n\n```squiggle\nx = 5\nif x<8 then 10 else 3\n```\n\nSee [Control flow](/docs/Guides/ControlFlow) for more details and examples.\n\n## Comments\n\n```squiggle\n// This is a single-line comment\\n\n/*\nThis is a multiple\n-line comment.\n*/\nfoo = 5\n```\n\n## Pipes\n\nSquiggle features [data-first](https://www.javierchavarri.com/data-first-and-data-last-a-comparison/) pipes. Functions in the standard library are organized to make this convenient.\n\n```squiggle\nnormal(5,2) -> truncateLeft(3) -> SampleSet.fromDist -> SampleSet.map({|r| r + 10})\n```\n\n## Standard Library\n\nSquiggle features a simple [standard libary](/docs/Api/Dist).\n\nMost functions are namespaced under their respective types to keep functionality distinct. Certain popular functions are usable without their namespaces.\n\nFor example,\n\n```squiggle\na = List.upTo(0, 5000) -> SampleSet.fromList // namespaces required\nb = normal(5,2) // namespace not required\nc = 5 to 10 // namespace not required\n```\n\n## Simple Error Handling\n\nSquiggle supports the functions [throw](/docs/Api/Common#throw) and [try](/docs/Api/Common#try) for simple error handling. It does not yet have proper error types.\n\n# Gotchas\n\n## Point Set Distributions Conversions\n\nPoint Set conversions are done with [kernel density estimation](https://en.wikipedia.org/wiki/Kernel_density_estimation), which is lossy. This might be particularly noticeable in cases where distributions should be entirely above zero.\n\nIn this example, we see that the median of this (highly skewed) distribution is positive when it's in a Sample Set format, but negative when it's converted to a Point Set format.\n\n```squiggle\ndist = SampleSet.fromDist(5 to 100000000)\n{\n    sampleSetMedian: quantile(dist, .5),\n    pointSetMedian: quantile(PointSet.fromDist(dist), .5),\n    dist: dist\n}\n```\n\n---\n\nThis can be particularly confusing for visualizations. Visualizations automatically convert distributions into Point Set formats. Therefore, they might often show negative values, even if the underlying distribution is fully positive.\n\nWe plan to later support more configuration of kernel density estimation, and for visualiations of Sample Set distributions to instead use histograms.\n\n## Sample Set Correlations\n\nCorrelations with Sample Set distributions are a bit complicated. Monte Carlo generations with Squiggle are ordered. The first sample in one Sample Set distribution will correspond to the first sample in a distribution that comes from a resulting Monte Carlo generation. Therefore, Sample Set distributions in a chain of Monte Carlo generations are likely to all be correlated with each other. This connection breaks if any node changes to the Point Set or Symbolic format.\n\nIn this example, we subtract all three types of distributions by themselves. Notice that the Sample Set distribution returns 0. The other two return the result of subtracting one normal distribution from a separate uncorrelated distribution. These results are clearly very different to each other.\n\n```squiggle\nsampleSetDist = normal(5, 2)\npointSetDist = sampleSetDist -> PointSet.fromDist\nsymbolicDist = Sym.normal(5, 2)\n[\n  sampleSetDist - sampleSetDist,\n  pointSetDist - pointSetDist,\n  symbolicDist - symbolicDist,\n]\n```\n\n# Functions\n\n## Basic syntax\n\n```squiggle\nmyMultiply(t) = normal(t^2, t^1.2+.01)\nmyMultiply\n```\n\nIn Squiggle, function definitions are treated as values. There's no explicit `return` statement; the result of the last expression in the function body is returned.\nIf you need to define local variables in functions, you can use blocks. The last expression in the block is the value of the block:\n\n```squiggle\nmultiplyBySix(x) = {\n  doubleX = x * 2\n  doubleX * 3\n  }\n```\n\n## Anonymous Functions\n\nIn Squiggle, you can define anonymous functions using the `{|...| ...}` syntax. For example, `myMultiply(x, y) = x * y` and `myMultiply = {|x, y| x * y}` are equivalent.\n\nSquiggle functions are first-class values, meaning you can assign them to variables, pass them as arguments to other functions, and return them from other functions.\n\n```squiggle\n{|t| normal(t^2, t^1.2+.01)}\n```\n\n## Function Visualization\n\nThe Squiggle viewer can automatically visualize functions that take a single number as input and return either a number or a distribution, without the need for manual plots:\n\n1. `(number) => number`\n2. `(number) => distribution`\n\n```squiggle\nnumberToNumber(x) = x * x\nnumberToDistribution(x) = normal(x + 1, 3)\nplaceholderFunction(x, y) = x + y\n```\n\nWhen Squiggle visualizes a function, it automatically selects a range of input values to use.\nThe default range of input values is 0 to 10.\n\nYou can manually set the range in the following ways:\n\n- With `Plot.numericFn` or `Plot.distFn` plots, using the `xScale` parameter\n- Through the chart's settings in the UI (look for a gear icon next to the variable name)\n- With parameter annotations (explained below)\n\n## Parameter Annotations\n\nFunction parameters can be annotated with _domains_ to specify the range of valid input values.\n\nExamples:\n\n- `x: Number.rangeDomain(5, 10)`\n- `x: [5, 10]` â€” shortcut for `Number.rangeDomain(...)`\n\nAnnotations help to document possible values that can be passed as a parameter's value.\n\nAnnotations will affect the parameter range used in the function's chart. For more control over function charts, you can use the [Plot module API](/docs/Api/Plot).\n\nDomains are checked on function calls; `f(x: [1,2]) = x; f(3)` will fail.\n\nWe plan to support other kinds of domains in the future; for now, only numeric ranges are supported.\n\n```squiggle\nyearToValue(year: [2020, 2100]) = 1.04 ^ (year - 2020)\n```\n\n### Annotation Reflection\n\n```squiggle\nmyMultiply(x: [1, 20]) = x * x\nmyMultiply.parameters[0]\n```\n\nDomains and parameter names can be accessed by the `fn.parameters` property.\n\n# Control Flow\n\nThis page documents control flow. Squiggle has if/else statements, but not for loops. But for for loops, you can use reduce/map constructs instead, which are also documented here.\n\n## Conditionals\n\n### If-else\n\n```squiggle\nif condition then result else alternative\n```\n\n```squiggle\nx = 10\nif x == 1 then 1 else 2\n```\n\n### If-else as a ternary operator\n\n```squiggle\ntest ? result : alternative;\n```\n\n```squiggle\nx = 10\nx == 0 ? 1 : 2\n```\n\n### Tips and tricks\n\n#### Use brackets and parenthesis to organize control flow\n\n```squiggle\nx = 10\nif x == 1 then {\n  1\n} else {\n  2\n}\n```\n\nor\n\n```squiggle\nx = 10\ny = 20\nif x == 1 then {\n  (\n    if y == 0 then {\n      1\n    } else {\n      2\n    }\n  )\n} else {\n  3\n}\n```\n\nThis is overkill for simple examples becomes useful when the control conditions are more complex.\n\n#### Save the result to a variable\n\nAssigning a value inside an if/else flow isn't possible:\n\n```squiggle\nx = 10\ny = 20\nif x == 1 then {\n  y = 1\n} else {\n  y = 2 * x\n}\n```\n\nInstead, you can do this:\n\n```squiggle\nx = 10\ny = 20\ny = if x == 1 then {\n  1\n} else {\n  2 * x\n}\n```\n\nLikewise, for assigning more than one value, you can't do this:\n\n```squiggle\ny = 0\nz = 0\nif x == 1 then {\n  y = 2\n} else {\n  z = 4\n}\n```\n\nInstead, do:\n\n```squiggle\nx = 10\nresult = if x == 1 then {\n  {y: 2, z: 0}\n} else {\n  {y: 0, z: 4}\n}\ny = result.y\nz = result.z\n```\n\n## For loops\n\nFor loops aren't supported in Squiggle. Instead, use a [map](/docs/Api/List#map) or a [reduce](/docs/Api/List#reduce) function.\n\nInstead of:\n\n```js\nxs = [];\nfor (i = 0; i < 10; i++) {\n  xs[i] = f(x);\n}\n```\n\ndo:\n\n```squiggle\nf(x) = 2*x\nxs = List.upTo(0,10)\nys = List.map(xs, {|x| f(x)})\n```\n\n# Basic Types\n\n## Numbers\n\nSquiggle numbers are built directly on [Javascript numbers](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number). They can be integers or floats, and support all the usual arithmetic operations.\n[Number API](/docs/Api/Number)\n\nNumbers support a few scientific notation suffixes.\n\n| Suffix | Multiplier |\n| ------ | ---------- |\n| n      | 10^-9      |\n| m      | 10^-3      |\n| %      | 10^-2      |\n| k      | 10^3       |\n| M      | 10^6       |\n| B,G    | 10^9       |\n| T      | 10^12      |\n| P      | 10^15      |\n\nThere's no difference between floats and integers in Squiggle.\n\n```squiggle\nn = 4.32\nkilo = 4.32k\nmicro = 4.32m\nveryLarge = 1e50\nverySmall = 1e-50\n```\n\n## Booleans\n\nBooleans can be `true` or `false`.\n\n```squiggle\nt = true\nf = false\n```\n\n## Strings\n\nStrings can be created with either single or double quotes.\n[String API](/docs/Api/String)\n\n```squiggle\ns = \"Double-quoted\"\ns2 = 'Single-quoted'\n```\n\n## Distributions\n\nDistributions are first-class citizens. Use the syntax `a to b` to create a quick lognormal distribution, or write out the whole distribution name.\n\n```squiggle\na = 10 to 20\nb = normal(4, 2)\nc = lognormal({ mean: 50, stdev: 10 })\nd = mixture(a, b, c, [.3, .3, .4])\nd\n```\n\nSee these pages for more information on distributions:\n\n- [Distribution Creation](/docs/Guides/DistributionCreation)\n- [Distribution Functions Guide](/docs/Guides/Functions)\n- [Distribution API](/docs/Api/Dist)\n\nThere are [3 internal representation formats for distributions](docs/Discussions/Three-Formats-Of-Distributions): [Sample Set](/docs/API/DistSampleSet), [Point Set](/docs/API/DistPointSet), and Symbolic. By default, Squiggle will use sample set distributions, which allow for correlations between parameters. Point Set and Symbolic distributions will be more accurate and fast, but do not support correlations. If you prefer this tradeoff, you can manually use them by adding a `Sym.` before the distribution name, i.e. `Sym.normal(0, 1)`.\n\n## Lists\n\nSquiggle lists can contain items of any type, similar to lists in Python. You can access individual list elements with `[number]` notation, starting from `0`.\n\nSquiggle is an immutable language, so you cannot modify lists in-place. Instead, you can use functions such as `List.map` or `List.reduce` to create new lists.\n[List API](/docs/Api/List)\n\n```squiggle\nmyList = [1, \"hello\", 3 to 5, [\"foo\", \"bar\"]]\nfirst = myList[0] // 1\nbar = myList[3][1] // \"bar\"\n```\n\n## Dictionaries\n\nSquiggle dictionaries work similarly to Python dictionaries or Javascript objects. Like lists, they can contain values of any type. Keys must be strings.\n[Dictionary API](/docs/Api/Dictionary)\n\n```squiggle\nd = {dist: triangular(0, 1, 2), weight: 0.25, innerDict: {foo: \"bar\"}}\n```\n\n## Other types\n\nOther Squiggle types include:\n\n- [Functions](/docs/Guides/Functions)\n- [Plots](/docs/Api/Plot)\n- [Scales](/docs/Api/Plot#scales)\n- [Domains](#parameter-annotations)---\n  description:\n\n---\n\nimport { FnDocumentationFromName } from \"@quri/squiggle-components\";\nimport { SquiggleEditor } from \"../../../components/SquiggleEditor\";\n\n# Common\n\nFunctions that work on many different types of values. Also see the experimental [JSON functions](/docs/Api/Danger#json).\n\nCommon.equal ==: (any, any) => Bool\nReturns true if the two values passed in are equal, false otherwise. Does not work for Squiggle functions, but works for most other types.\n\nCommon.unequal !=: (any, any) => Bool\n\nCommon.typeOf: (any) => String\nReturns the type of the value passed in as a string. This is useful when you want to treat a value differently depending on its type.\nmyString = typeOf(\"foo\")\nmyBool = typeOf(true)\nmyDist = typeOf(5 to 10)\nmyFn = typeOf({|e| e})\n\nCommon.inspect: ('A, message?: String) => 'A\nRuns Console.log() in the [Javascript developer console](https://www.digitalocean.com/community/tutorials/how-to-use-the-javascript-developer-console) and returns the value passed in.\n\nCommon.throw: (message: String?) => any\nThrows an error. You can use `try` to recover from this error.\n\nCommon.try: (fn: () => 'A, fallbackFn: () => 'B) => 'A|'B\nTry to run a function and return its result. If the function throws an error, return the result of the fallback function instead.\n\n---\n\n## description:\n\nimport { FnDocumentationFromName } from \"@quri/squiggle-components\";\nimport { SquiggleEditor } from \"../../../components/SquiggleEditor\";\n\n# Boolean\n\nBoolean.or ||: (Bool, Bool) => Bool\n\nBoolean.and &&: (Bool, Bool) => Bool\n\nBoolean.not !: (Bool) => Bool\n\n---\n\n## description: Dates are a simple date time type.\n\nimport { FnDocumentationFromName } from \"@quri/squiggle-components\";\nimport { SquiggleEditor } from \"../../../components/SquiggleEditor\";\n\n# Date\n\nA simple date type. Dates are stored as milliseconds since the epoch. They are immutable, and all functions that modify dates return a new date. Used with [Duration](./Duration) values.\n\n    Dates can be useful for modeling values that change over time. Below is a simple example of a function that returns a normal distribution that changes over time, based on the number of years passed since 2020.\n\n<SquiggleEditor\ndefaultCode={`f(t: [Date(2020), Date(2040)]) = {\n  yearsPassed = toYears(t - Date(2020))\n  normal({mean: yearsPassed ^ 2, stdev: yearsPassed^1.3+1})\n}`}/>\n\n## Constructors\n\nDate.make: (String) => Date, (year: Number, month: Number, day: Number) => Date, (year: Number) => Date\nd1 = Date.make(\"2020-05-12\")\nd2 = Date.make(2020, 5, 10)\nd3 = Date.make(2020.5)\n\n## Conversions\n\nDate.fromUnixTime: (Number) => Date\nDate.fromUnixTime(1589222400)\n\nDate.toUnixTime: (Date) => Number\nDate.toUnixTime(Date.make(2020, 5, 12))\n\n## Algebra\n\nDate.subtract -: (Date, Date) => Duration\nDate.make(2020, 5, 12) - Date.make(2000, 1, 1)\n\nDate.subtract -: (Date, Date) => Duration\nDate.make(2020, 5, 12) - Date.make(2000, 1, 1)\n\nDate.add +: (Date, Duration) => Date, (Duration, Date) => Date\nDate.make(2020, 5, 12) + 20years\n20years + Date.make(2020, 5, 12)\n\n## Comparison\n\nDate.smaller <: (Date, Date) => Bool\n\nDate.larger >: (Date, Date) => Bool\n\nDate.smallerEq <=: (Date, Date) => Bool\n\nDate.largerEq >=: (Date, Date) => Bool\n\n## Other\n\nDate.rangeDomain: (min: Date, min: Date) => Domain\nDate.rangeDomain(Date(2000), Date(2010))\n\n---\n\n## description: Squiggle dictionaries work similar to Python dictionaries. The syntax is similar to objects in Javascript.\n\nimport { FnDocumentationFromName } from \"@quri/squiggle-components\";\nimport { SquiggleEditor } from \"../../../components/SquiggleEditor\";\n\n# Dict\n\nSquiggle dictionaries work similar to Python dictionaries. The syntax is similar to objects in Javascript.\n\n## Conversions\n\nDict.toList: (Dict('A)) => List([String, 'A])\nDict.toList({a: 1, b: 2})\n\nDict.fromList: (List([String, 'A])) => Dict('A)\nDict.fromList([\n[\"foo\", 3],\n[\"bar\", 20],\n]) // {foo: 3, bar: 20}\n\n## Transformations\n\nDict.set: (Dict('A), key: String, value: 'A) => Dict('A)\nCreates a new dictionary that includes the added element, while leaving the original dictionary unaltered.\nDict.set({a: 1, b: 2}, \"c\", 3)\n\nDict.delete: (Dict('A), key: String) => Dict('A)\nCreates a new dictionary that excludes the deleted element.\nDict.delete({a: 1, b: 2}, \"a\")\n\nDict.merge: (Dict(any), Dict(any)) => Dict(any)\nfirst = { a: 1, b: 2 }\nsnd = { b: 3, c: 5 }\nDict.merge(first, snd)\n\nDict.mergeMany: (List(Dict(any))) => Dict(any)\nfirst = { a: 1, b: 2 }\nsnd = { b: 3, c: 5 }\nDict.mergeMany([first, snd]) // {a: 1, b: 3, c: 5}\n\nDict.map: (Dict('A), fn: ('A) => 'B) => Dict('B)\nDict.map({a: 1, b: 2}, {|x| x + 1})\n\nDict.mapKeys: (Dict('A), fn: (String) => String) => Dict('A)\nDict.mapKeys({a: 1, b: 2, c: 5}, {|x| concat(x, \"-foobar\")})\n\nDict.omit: (Dict('A), List(String)) => keys: Dict('A)\nCreates a new dictionary that excludes the omitted keys.\ndata = { a: 1, b: 2, c: 3, d: 4 }\nDict.omit(data, [\"b\", \"d\"]) // {a: 1, c: 3}\n\n## Queries\n\nDict.has: (Dict(any), key: String) => Bool\nDict.has({a: 1, b: 2}, \"c\")\n\nDict.size: (Dict(any)) => Number\nDict.size({a: 1, b: 2})\n\nDict.keys: (Dict(any)) => List(String)\nDict.keys({a: 1, b: 2})\n\nDict.values: (Dict('A)) => List('A)\nDict.values({ foo: 3, bar: 20 }) // [3, 20]\n\nDict.pick: (Dict('A), keys: List(String)) => Dict('A)\nCreates a new dictionary that only includes the picked keys.\ndata = { a: 1, b: 2, c: 3, d: 4 }\nDict.pick(data, [\"a\", \"c\"]) // {a: 1, c: 3}\n\n---\n\n## description: Distributions are the flagship data type in Squiggle. The distribution type is a generic data type that contains one of three different formats of distributions.\n\nimport { FnDocumentationFromName } from \"@quri/squiggle-components\";\nimport { SquiggleEditor } from \"../../../components/SquiggleEditor\";\n\n# Dist\n\nDistributions are the flagship data type in Squiggle. The distribution type is a generic data type that contains one of three different formats of distributions.\n\nThese subtypes are [point set](/docs/api/DistPointSet), [sample set](/docs/api/DistSampleSet), and [symbolic](/docs/api/Sym). The first two of these have a few custom functions that only work on them. You can read more about the differences between these formats [here](/docs/Discussions/Three-Formats-Of-Distributions).\n\nSeveral functions below only can work on particular distribution formats. For example, scoring and pointwise math requires the point set format. When this happens, the types are automatically converted to the correct format. These conversions are lossy.\n\nDistributions are created as [sample sets](/DistSampleSet) by default. To create a symbolic distribution, use `Sym.` namespace: `Sym.normal`, `Sym.beta` and so on.\n\n## Distributions\n\nThese are functions for creating primitive distributions. Many of these could optionally take in distributions as inputs. In these cases, Monte Carlo Sampling will be used to generate the greater distribution. This can be used for simple hierarchical models.\n\nSee a longer tutorial on creating distributions [here](/docs/Guides/DistributionCreation).\n\nDist.make: (Dist) => Dist, (Number) => SymbolicDist\nDist.make(5)\nDist.make(normal({p5: 4, p95: 10}))\n\nDist.mixture: (List(Dist|Number), weights?: List(Number)) => Dist, (Dist|Number) => Dist, (Dist|Number, Dist|Number, weights?: [Number, Number]) => Dist, (Dist|Number, Dist|Number, Dist|Number, weights?: [Number, Number, Number]) => Dist, (Dist|Number, Dist|Number, Dist|Number, Dist|Number, weights?: [Number, Number, Number, Number]) => Dist, (Dist|Number, Dist|Number, Dist|Number, Dist|Number, Dist|Number, weights?: [Number, Number, Number, Number, Number]) => Dist\nThe `mixture` function takes a list of distributions and a list of weights, and returns a new distribution that is a mixture of the distributions in the list. The weights should be positive numbers that sum to 1. If no weights are provided, the function will assume that all distributions have equal weight.\n\nNote: If you want to pass in over 5 distributions, you must use the list syntax.\nmixture(1,normal(5,2))\nmixture(normal(5,2), normal(10,2), normal(15,2), [0.3, 0.5, 0.2])\nmixture([normal(5,2), normal(10,2), normal(15,2), normal(20,1)], [0.3, 0.5, 0.1, 0.1])\n\nDist.mx: (List(Dist|Number), weights?: List(Number)) => Dist, (Dist|Number) => Dist, (Dist|Number, Dist|Number, weights?: [Number, Number]) => Dist, (Dist|Number, Dist|Number, Dist|Number, weights?: [Number, Number, Number]) => Dist, (Dist|Number, Dist|Number, Dist|Number, Dist|Number, weights?: [Number, Number, Number, Number]) => Dist, (Dist|Number, Dist|Number, Dist|Number, Dist|Number, Dist|Number, weights?: [Number, Number, Number, Number, Number]) => Dist\nAlias for mixture()\nmx(1,normal(5,2))\n\nDist.normal: (mean: Dist|Number, stdev: Dist|Number) => SampleSetDist, ({p5: Number, p95: Number}) => SampleSetDist, ({p10: Number, p90: Number}) => SampleSetDist, ({p25: Number, p75: Number}) => SampleSetDist, ({mean: Number, stdev: Number}) => SampleSetDist\nnormal(5,1)\nnormal({p5: 4, p95: 10})\nnormal({p10: 4, p90: 10})\nnormal({p25: 4, p75: 10})\nnormal({mean: 5, stdev: 2})\n\nDist.lognormal: (mu: Dist|Number, sigma: Dist|Number) => SampleSetDist, ({p5: Number, p95: Number}) => SampleSetDist, ({p10: Number, p90: Number}) => SampleSetDist, ({p25: Number, p75: Number}) => SampleSetDist, ({mean: Number, stdev: Number}) => SampleSetDist\nlognormal(0.5, 0.8)\nlognormal({p5: 4, p95: 10})\nlognormal({p10: 4, p90: 10})\nlognormal({p25: 4, p75: 10})\nlognormal({mean: 5, stdev: 2})\n\nDist.uniform: (low: Dist|Number, high: Dist|Number) => SampleSetDist\nuniform(10, 12)\n\nDist.beta: (alpha: Dist|Number, beta: Dist|Number) => SampleSetDist, ({mean: Number, stdev: Number}) => SampleSetDist\nbeta(20, 25)\nbeta({mean: 0.39, stdev: 0.1})\n\nDist.cauchy: (location: Dist|Number, scale: Dist|Number) => SampleSetDist\ncauchy(5, 1)\n\nDist.gamma: (shape: Dist|Number, scale: Dist|Number) => SampleSetDist\ngamma(5, 1)\n\nDist.logistic: (location: Dist|Number, scale: Dist|Number) => SampleSetDist\nlogistic(5, 1)\n\nDist.to to: (p5: Dist|Number, p95: Dist|Number) => SampleSetDist\nThe \"to\" function is a shorthand for lognormal({p5:min, p95:max}). It does not accept values of 0 or less, as those are not valid for lognormal distributions.\n5 to 10\nto(5,10)\n\nDist.exponential: (rate: Dist|Number) => SampleSetDist\nexponential(2)\n\nDist.bernoulli: (p: Dist|Number) => SampleSetDist\nbernoulli(0.5)\n\nDist.triangular: (min: Number, mode: Number, max: Number) => SampleSetDist\ntriangular(3, 5, 10)\n\n## Basic Functions\n\nDist.mean: (Dist) => Number\n\nDist.median: (Dist) => Number\n\nDist.stdev: (Dist) => Number\n\nDist.variance: (Dist) => Number\n\nDist.min: (Dist) => Number\n\nDist.max: (Dist) => Number\n\nDist.mode: (Dist) => Number\n\nDist.sample: (Dist) => Number\n\nDist.sampleN: (Dist, n: Number) => List(Number)\n\nDist.exp: (Dist) => Dist\n\nDist.cdf: (Dist, Number) => Number\n\nDist.pdf: (Dist, Number) => Number\n\nDist.inv: (Dist, Number) => Number\n\nDist.quantile: (Dist, Number) => Number\n\nDist.truncate: (Dist, left: Number, right: Number) => Dist\nTruncates both the left side and the right side of a distribution.\n\nSample set distributions are truncated by filtering samples, but point set distributions are truncated using direct geometric manipulation. Uniform distributions are truncated symbolically. Symbolic but non-uniform distributions get converted to Point Set distributions.\n\nDist.truncateLeft: (Dist, Number) => Dist\n\nDist.truncateRight: (Dist, Number) => Dist\n\n## Algebra (Dist)\n\nDist.add +: (Dist, Number) => Dist, (Number, Dist) => Dist, (Dist, Dist) => Dist\n\nDist.multiply \\*: (Dist, Number) => Dist, (Number, Dist) => Dist, (Dist, Dist) => Dist\n\nDist.subtract -: (Dist, Number) => Dist, (Number, Dist) => Dist, (Dist, Dist) => Dist\n\nDist.divide /: (Dist, Number) => Dist, (Number, Dist) => Dist, (Dist, Dist) => Dist\n\nDist.pow ^: (Dist, Number) => Dist, (Number, Dist) => Dist, (Dist, Dist) => Dist\n\nDist.log: (Dist, Number) => Dist, (Number, Dist) => Dist, (Dist, Dist) => Dist\n\nDist.log: (Dist, Number) => Dist, (Number, Dist) => Dist, (Dist, Dist) => Dist\n\nDist.log10: (Dist) => Dist\n\nDist.unaryMinus -: (Dist) => Dist\n\n## Algebra (List)\n\nDist.sum: (List(Dist|Number)) => Dist\n\nDist.product: (List(Dist|Number)) => Dist\n\nDist.cumsum: (List(Dist|Number)) => List(Dist)\n\nDist.cumprod: (List(Dist|Number)) => List(Dist)\n\nDist.diff: (List(Dist|Number)) => List(Dist)\n\n## Pointwise Algebra\n\nPointwise arithmetic operations cover the standard arithmetic operations, but work in a different way than the regular operations. These operate on the y-values of the distributions instead of the x-values. A pointwise addition would add the y-values of two distributions.\n\nThe infixes `.+`,`.-`, `.*`, `./`, `.^` are supported for their respective operations. `Mixture` works using pointwise addition.\n\nPointwise operations work on Point Set distributions, so will convert other distributions to Point Set ones first. Pointwise arithmetic operations typically return unnormalized or completely invalid distributions. For example, the operation{\" \"} <code>normal(5,2) .- uniform(10,12)</code> results in a distribution-like object with negative probability mass.\n\nDist.dotAdd: (Dist, Number) => Dist, (Number, Dist) => Dist, (Dist, Dist) => Dist\n\nDist.dotMultiply: (Dist, Number) => Dist, (Number, Dist) => Dist, (Dist, Dist) => Dist\n\nDist.dotSubtract: (Dist, Number) => Dist, (Number, Dist) => Dist, (Dist, Dist) => Dist\n\nDist.dotDivide: (Dist, Number) => Dist, (Number, Dist) => Dist, (Dist, Dist) => Dist\n\nDist.dotPow: (Dist, Number) => Dist, (Number, Dist) => Dist, (Dist, Dist) => Dist\n\n## Normalization\n\nThere are some situations where computation will return unnormalized distributions. This means that their cumulative sums are not equal to 1.0. Unnormalized distributions are not valid for many relevant functions; for example, klDivergence and scoring.\n\nThe only functions that do not return normalized distributions are the pointwise arithmetic operations and the scalewise arithmetic operations. If you use these functions, it is recommended that you consider normalizing the resulting distributions.\n\nDist.normalize: (Dist) => Dist\nNormalize a distribution. This means scaling it appropriately so that it's cumulative sum is equal to 1. This only impacts Point Set distributions, because those are the only ones that can be non-normlized.\n\nDist.isNormalized: (Dist) => Bool\nCheck if a distribution is normalized. This only impacts Point Set distributions, because those are the only ones that can be non-normlized. Most distributions are typically normalized, but there are some commands that could produce non-normalized distributions.\n\nDist.integralSum: (Dist) => Number\nGet the sum of the integral of a distribution. If the distribution is normalized, this will be 1.0. This is useful for understanding unnormalized distributions.\n\n## Utility\n\nDist.sparkline: (Dist, Number?) => String\n\nProduce a sparkline of length `n`. For example, `â–â–â–â–â–â–‚â–„â–†â–‡â–ˆâ–ˆâ–‡â–†â–„â–‚â–â–â–â–â–`. These can be useful for testing or quick visualizations that can be copied and pasted into text.\n\n## Scoring\n\nDist.klDivergence: (Dist, Dist) => Number\n[Kullbackâ€“Leibler divergence](https://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence) between two distributions.\n\nNote that this can be very brittle. If the second distribution has probability mass at areas where the first doesn't, then the result will be infinite. Due to numeric approximations, some probability mass in point set distributions is rounded to zero, leading to infinite results with klDivergence.\nDist.klDivergence(Sym.normal(5,2), Sym.normal(5,1.5))\n\nDist.logScore: ({estimate: Dist, answer: Dist|Number, prior?: Dist}) => Number\nA log loss score. Often that often acts as a [scoring rule](https://en.wikipedia.org/wiki/Scoring_rule). Useful when evaluating the accuracy of a forecast.\n\n    Note that it is fairly slow.\n\nDist.logScore({estimate: Sym.normal(5,2), answer: Sym.normal(5.2,1), prior: Sym.normal(5.5,3)})\nDist.logScore({estimate: Sym.normal(5,2), answer: Sym.normal(5.2,1)})\nDist.logScore({estimate: Sym.normal(5,2), answer: 4.5})\n\n---\n\n## description: Sample set distributions are one of the three distribution formats. Internally, they are stored as a list of numbers.\n\nimport { FnDocumentationFromName } from \"@quri/squiggle-components\";\nimport { SquiggleEditor } from \"../../../components/SquiggleEditor\";\n\n# SampleSet\n\nSample set distributions are one of the three distribution formats. Internally, they are stored as a list of numbers. It's useful to distinguish point set distributions from arbitrary lists of numbers to make it clear which functions are applicable.\n\nMonte Carlo calculations typically result in sample set distributions.\n\nAll regular distribution function work on sample set distributions. In addition, there are several functions that only work on sample set distributions.\n\n## Constructors\n\nSampleSet.make: (Dist) => SampleSetDist, (Number) => SampleSetDist, (List(Number)) => SampleSetDist, ((index?: Number) => Number) => SampleSetDist\nCalls the correct conversion constructor, based on the corresponding input type, to create a sample set distribution\nSampleSet(5)\nSampleSet.make([3,5,2,3,5,2,3,5,2,3,3,5,3,2,3,1,1,3])\nSampleSet.make({|i| sample(normal(5,2))})\n\n## Conversions\n\nSampleSet.fromDist: (Dist) => SampleSetDist\nConverts any distribution type into a sample set distribution.\nSampleSet.fromDist(Sym.normal(5,2))\n\nSampleSet.fromNumber: (Number) => SampleSetDist\nConvert a number into a sample set distribution that contains `n` copies of that number. `n` refers to the model sample count.\nSampleSet.fromNumber(3)\n\nSampleSet.fromList: (List(Number)) => SampleSetDist\nConvert a list of numbers into a sample set distribution.\nSampleSet.fromList([3,5,2,3,5,2,3,5,2,3,3,5,3,2,3,1,1,3])\n\nSampleSet.toList: (SampleSetDist) => List(Number)\nGets the internal samples of a sampleSet distribution. This is separate from the `sampleN()` function, which would shuffle the samples. `toList()` maintains order and length.\nSampleSet.toList(SampleSet.fromDist(normal(5,2)))\n\nSampleSet.fromFn: ((index?: Number) => Number) => SampleSetDist\nConvert a function into a sample set distribution by calling it `n` times.\nSampleSet.fromFn({|i| sample(normal(5,2))})\n\n## Transformations\n\nSampleSet.map: (SampleSetDist, fn: (Number) => Number) => SampleSetDist\nTransforms a sample set distribution by applying a function to each sample. Returns a new sample set distribution.\nSampleSet.map(SampleSet.fromDist(normal(5,2)), {|x| x + 1})\n\nSampleSet.map2: (SampleSetDist, SampleSetDist, fn: (Number, Number) => Number) => SampleSetDist\nTransforms two sample set distributions by applying a function to each pair of samples. Returns a new sample set distribution.\nSampleSet.map2(\nSampleSet.fromDist(normal(5,2)),\nSampleSet.fromDist(normal(5,2)),\n{|x, y| x + y}\n)\n\nSampleSet.map3: (SampleSetDist, SampleSetDist, SampleSetDist, fn: (Number, Number, Number) => Number) => SampleSetDist\nSampleSet.map3(\nSampleSet.fromDist(normal(5,2)),\nSampleSet.fromDist(normal(5,2)),\nSampleSet.fromDist(normal(5,2)),\n{|x, y, z| max([x,y,z])}\n)\n\nSampleSet.mapN: (List(SampleSetDist), fn: (List(Number)) => Number) => SampleSetDist\nSampleSet.mapN(\n[\nSampleSet.fromDist(normal(5,2)),\nSampleSet.fromDist(normal(5,2)),\nSampleSet.fromDist(normal(5,2))\n],\nmax\n)\n\n---\n\n## description: The Sym module provides functions to create some common symbolic distributions.\n\nimport { FnDocumentationFromName } from \"@quri/squiggle-components\";\nimport { SquiggleEditor } from \"../../../components/SquiggleEditor\";\n\n# Sym\n\nSymbolic Distributions. All these functions match the functions for creating sample set distributions, but produce symbolic distributions instead. Symbolic distributions won't capture correlations, but are more performant than sample distributions.\n\nSym.normal: (Number, Number) => SymbolicDist, ({p5: Number, p95: Number}) => SymbolicDist, ({p10: Number, p90: Number}) => SymbolicDist, ({p25: Number, p75: Number}) => SymbolicDist, ({mean: Number, stdev: Number}) => SymbolicDist\nSym.normal(5, 1)\nSym.normal({ p5: 4, p95: 10 })\nSym.normal({ p10: 4, p90: 10 })\nSym.normal({ p25: 4, p75: 10 })\nSym.normal({ mean: 5, stdev: 2 })\n\nSym.lognormal: (Number, Number) => SymbolicDist, ({p5: Number, p95: Number}) => SymbolicDist, ({p10: Number, p90: Number}) => SymbolicDist, ({p25: Number, p75: Number}) => SymbolicDist, ({mean: Number, stdev: Number}) => SymbolicDist\nSym.lognormal(0.5, 0.8)\nSym.lognormal({ p5: 4, p95: 10 })\nSym.lognormal({ p10: 4, p90: 10 })\nSym.lognormal({ p25: 4, p75: 10 })\nSym.lognormal({ mean: 5, stdev: 2 })\n\nSym.uniform: (Number, Number) => SymbolicDist\nSym.uniform(10, 12)\n\nSym.beta: (Number, Number) => SymbolicDist, ({mean: Number, stdev: Number}) => SymbolicDist\nSym.beta(20, 25)\nSym.beta({ mean: 0.39, stdev: 0.1 })\n\nSym.cauchy: (Number, Number) => SymbolicDist\nSym.cauchy(5, 1)\n\nSym.gamma: (Number, Number) => SymbolicDist\nSym.gamma(5, 1)\n\nSym.logistic: (Number, Number) => SymbolicDist\nSym.logistic(5, 1)\n\nSym.exponential: (Number) => SymbolicDist\nSym.exponential(2)\n\nSym.bernoulli: (Number) => SymbolicDist\nSym.bernoulli(0.5)\n\nSym.pointMass: (Number) => SymbolicDist\nPoint mass distributions are already symbolic, so you can use the regular `pointMass` function.\npointMass(0.5)\n\nSym.triangular: (Number, Number, Number) => SymbolicDist\nSym.triangular(3, 5, 10)\n\n---\n\n## description: Point set distributions are one of the three distribution formats. They are stored as a list of x-y coordinates representing both discrete and continuous distributions.\n\nimport { FnDocumentationFromName } from \"@quri/squiggle-components\";\nimport { SquiggleEditor } from \"../../../components/SquiggleEditor\";\n\n# PointSet\n\nPoint set distributions are one of the three distribution formats. They are stored as a list of x-y coordinates representing both discrete and continuous distributions.\n\nOne complication is that it's possible to represent invalid probability distributions in the point set format. For example, you can represent shapes with negative values, or shapes that are not normalized.\n\n## Constructors\n\nPointSet.make: (Dist) => PointSetDist, (Number) => PointSetDist\nPointSet.make(normal(5,10))\nPointSet(3)\n\nPointSet.makeContinuous: (List({x: Number, y: Number})) => PointSetDist\nPointSet.makeContinuous([\n{x: 0, y: 0.2},\n{x: 1, y: 0.7},\n{x: 2, y: 0.8},\n{x: 3, y: 0.2}\n])\n\nPointSet.makeDiscrete: (List({x: Number, y: Number})) => PointSetDist\nPointSet.makeDiscrete([\n{x: 0, y: 0.2},\n{x: 1, y: 0.7},\n{x: 2, y: 0.8},\n{x: 3, y: 0.2}\n])\n\n## Conversions\n\nPointSet.fromDist: (Dist) => PointSetDist\nConverts the distribution in question into a point set distribution. If the distribution is symbolic, then it does this by taking the quantiles. If the distribution is a sample set, then it uses a version of kernel density estimation to approximate the point set format. One complication of this latter process is that if there is a high proportion of overlapping samples (samples that are exactly the same as each other), it will convert these samples into discrete point masses. Eventually we'd like to add further methods to help adjust this process.\nPointSet.fromDist(normal(5,2))\n\nPointSet.fromNumber: (Number) => PointSetDist\nPointSet.fromNumber(3)\n\nPointSet.downsample: (PointSetDist, newLength: Number) => PointSetDist\nPointSet.downsample(PointSet.fromDist(normal(5,2)), 50)\n\nPointSet.support: (PointSetDist) => {points: List(Number), segments: List([Number, Number])}\nPointSet.support(PointSet.fromDist(normal(5,2)))\n\n## Transformations\n\nPointSet.mapY: (PointSetDist, fn: (Number) => Number) => PointSetDist\nPointSet.mapY(mx(Sym.normal(5,2)), {|x| x + 1})\n\n---\n\n## description: Durations are a simple time type, representing a length of time. They are internally stored as milliseconds, but often shown and written using seconds, minutes, hours, days, etc.\n\nimport { FnDocumentationFromName } from \"@quri/squiggle-components\";\nimport { SquiggleEditor } from \"../../../components/SquiggleEditor\";\n\n# Duration\n\nDurations are a simple time type, representing a length of time. They are internally stored as milliseconds, but often shown and written using seconds, minutes, hours, days, etc. Durations are typically used with [Date](./Date) values.\n\n| **Unit Name** | **Example** | **Convert Number to Duration** | **Convert Duration to Number** |\n| ------------- | ----------- | ------------------------------ | ------------------------------ |\n| Minute        | `5minutes`  | `fromMinutes(number)`          | `toMinutes(duration)`          |\n| Hour          | `5hour`     | `fromHours(number)`            | `toHours(duration)`            |\n| Day           | `5days`     | `fromDays(number)`             | `toDays(duration)`             |\n| Year          | `5years`    | `fromYears(number)`            | `toYears(duration)`            |\n\n## Constructors\n\nDuration.fromMinutes: (Number) => Duration\nDuration.fromMinutes(5)\n\nDuration.fromHours: (Number) => Duration\nDuration.fromHours(5)\n\nDuration.fromDays: (Number) => Duration\nDuration.fromDays(5)\n\nDuration.fromYears: (Number) => Duration\nDuration.fromYears(5)\n\n## Conversions\n\nDuration.toMinutes: (Duration) => Number\nDuration.toMinutes(5minutes)\n\nDuration.toHours: (Duration) => Number\nDuration.toHours(5minutes)\n\nDuration.toDays: (Duration) => Number\nDuration.toDays(5minutes)\n\nDuration.toYears: (Duration) => Number\nDuration.toYears(5minutes)\n\n## Algebra\n\nDuration.unaryMinus -: (Duration) => Duration\n-5minutes\n\nDuration.add +: (Duration, Duration) => Duration\n5minutes + 10minutes\n\nDuration.subtract -: (Duration, Duration) => Duration\n5minutes - 10minutes\n\nDuration.multiply _: (Duration, Number) => Duration, (Number, Duration) => Duration\n5minutes _ 10\n10 \\* 5minutes\n\nDuration.divide /: (Duration, Duration) => Number\n5minutes / 2minutes\n\nDuration.divide /: (Duration, Duration) => Number\n5minutes / 2minutes\n\n## Comparison\n\nDuration.smaller <: (Duration, Duration) => Bool\n\nDuration.larger >: (Duration, Duration) => Bool\n\nDuration.smallerEq <=: (Duration, Duration) => Bool\n\nDuration.largerEq >=: (Duration, Duration) => Bool\n\n---\n\n## description: Lists are a simple data structure that can hold any type of value. They are similar to arrays in Javascript or lists in Python.\n\nimport { FnDocumentationFromName } from \"@quri/squiggle-components\";\nimport { SquiggleEditor } from \"../../../components/SquiggleEditor\";\n\n# List\n\nLists are a simple data structure that can hold any type of value. They are similar to arrays in Javascript or lists in Python.\n\n```squiggle\nmyList = [1, 2, 3, normal(5,2), \"hello\"]\n```\n\nLists are immutable, meaning that they cannot be modified. Instead, all list functions return a new list.\n\n## Constructors\n\nList.make: (count: Number, fn: (index?: Number) => 'A) => List('A), (count: Number, value: 'A) => List('A), (SampleSetDist) => List(Number)\nCreates an array of length `count`, with each element being `value`. If `value` is a function, it will be called `count` times, with the index as the argument.\nList.make(2, 3)\nList.make(2, {|| 3})\nList.make(2, {|index| index+1})\n\nList.upTo: (low: Number, high: Number) => List(Number)\nList.upTo(1,4)\n\n## Modifications\n\nList.reverse: (List('A)) => List('A)\nList.reverse([1,4,5]) // [5,4,1]\n\nList.concat: (List('A), List('A)) => List('A)\nList.concat([1,2,3], [4, 5, 6])\n\nList.sortBy: (List('A), fn: ('A) => Number) => List('A)\nList.sortBy([{a:3}, {a:1}], {|f| f.a})\n\nList.append: (List('A), 'A) => List('A)\nList.append([1,4],5)\n\nList.join: (List(String), separator?: String) => String, (List(String)) => String\nList.join([\"a\", \"b\", \"c\"], \",\") // \"a,b,c\"\n\nList.flatten: (List(any)) => List(any)\nList.flatten([[1,2], [3,4]])\n\nList.shuffle: (List('A)) => List('A)\nList.shuffle([1,3,4,20])\n\nList.zip: (List('A), List('B)) => List(['A, 'B])\nList.zip([1,3,4,20], [2,4,5,6])\n\nList.unzip: (List(['A, 'B])) => [List('A), List('B)]\nList.unzip([[1,2], [2,3], [4,5]])\n\n## Filtering\n\nList.slice: (List('A), startIndex: Number, endIndex?: Number) => List('A)\nReturns a copy of the list, between the selected `start` and `end`, end not included. Directly uses the [Javascript implementation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice) underneath.\nList.slice([1,2,5,10],1,3)\n\nList.uniq: (List('A)) => List('A)\nFilters the list for unique elements. Works on select Squiggle types.\nList.uniq([1,2,3,\"hi\",false,\"hi\"])\n\nList.uniqBy: (List('A), ('A) => 'B) => List('A)\nFilters the list for unique elements. Works on select Squiggle types.\nList.uniqBy([[1,5], [3,5], [5,7]], {|x| x[1]})\n\nList.filter: (List('A), fn: ('A) => Bool) => List('A)\nList.filter([1,4,5], {|x| x>3})\n\n## Queries\n\nList.length: (List(any)) => Number\nList.length([1,4,5])\n\nList.first: (List('A)) => 'A\nList.first([1,4,5])\n\nList.last: (List('A)) => 'A\nList.last([1,4,5])\n\nList.minBy: (List('A), fn: ('A) => Number) => 'A\nList.minBy([{a:3}, {a:1}], {|f| f.a})\n\nList.maxBy: (List('A), fn: ('A) => Number) => 'A\nList.maxBy([{a:3}, {a:1}], {|f| f.a})\n\nList.every: (List('A), fn: ('A) => Bool) => Bool\nList.every([1,4,5], {|el| el>3 })\n\nList.some: (List('A), fn: ('A) => Bool) => Bool\nList.some([1,4,5], {|el| el>3 })\n\nList.find: (List('A), fn: ('A) => Bool) => 'A\nReturns an error if there is no value found\nList.find([1,4,5], {|el| el>3 })\n\nList.findIndex: (List('A), fn: ('A) => Bool) => Number\nReturns `-1` if there is no value found\nList.findIndex([1,4,5], {|el| el>3 })\n\n## Functional Transformations\n\nList.map: (List('A), ('A, index?: Number) => 'B) => List('B)\nList.map([1,4,5], {|x| x+1})\nList.map([1,4,5], {|x,i| x+i+1})\n\nList.reduce: (List('B), initialValue: 'A, callbackFn: (accumulator: 'A, currentValue: 'B, currentIndex?: Number) => 'A) => 'A\nApplies `f` to each element of `arr`. The function `f` has two main paramaters, an accumulator and the next value from the array. It can also accept an optional third `index` parameter.\nList.reduce([1,4,5], 2, {|acc, el| acc+el})\n\nList.reduceReverse: (List('B), initialValue: 'A, callbackFn: (accumulator: 'A, currentValue: 'B) => 'A) => 'A\nWorks like `reduce`, but the function is applied to each item from the last back to the first.\nList.reduceReverse([1,4,5], 2, {|acc, el| acc-el})\n\nList.reduceWhile: (List('B), initialValue: 'A, callbackFn: (accumulator: 'A, currentValue: 'B) => 'A, conditionFn: ('A) => Bool) => 'A\nWorks like `reduce`, but stops when the condition is no longer met. This is useful, in part, for simulating processes that need to stop based on the process state.\n\n// Adds first two elements, returns `11`.\nList.reduceWhile([5, 6, 7], 0, {|acc, curr| acc + curr}, {|acc| acc < 15})\n\n// Adds first two elements, returns `{ x: 11 }`.\nList.reduceWhile(\n[5, 6, 7],\n{ x: 0 },\n{|acc, curr| { x: acc.x + curr }},\n{|acc| acc.x < 15}\n)\n\n---\n\n## description: Simple constants and functions for math in Squiggle.\n\nimport { FnDocumentationFromName } from \"@quri/squiggle-components\";\nimport { SquiggleEditor } from \"../../../components/SquiggleEditor\";\n\n# Math\n\n## Constants\n\n| Variable Name  | Number Name                                                                       | Value                |\n| -------------- | --------------------------------------------------------------------------------- | -------------------- |\n| `Math.e`       | Euler's number                                                                    | â‰ˆ 2.718281828459045  |\n| `Math.ln2`     | Natural logarithm of 2                                                            | â‰ˆ 0.6931471805599453 |\n| `Math.ln10`    | Natural logarithm of 10                                                           | â‰ˆ 2.302585092994046  |\n| `Math.log2e`   | Base 2 logarithm of E                                                             | â‰ˆ 1.4426950408889634 |\n| `Math.log10e`  | Base 10 logarithm of E                                                            | â‰ˆ 0.4342944819032518 |\n| `Math.pi`      | Pi - ratio of the circumference to the diameter of a circle                       | â‰ˆ 3.141592653589793  |\n| `Math.sqrt1_2` | Square root of 1/2                                                                | â‰ˆ 0.7071067811865476 |\n| `Math.sqrt2`   | Square root of 2                                                                  | â‰ˆ 1.4142135623730951 |\n| `Math.phi`     | Phi is the golden ratio.                                                          | 1.618033988749895    |\n| `Math.tau`     | Tau is the ratio constant of a circle's circumference to radius, equal to 2 \\* pi | 6.283185307179586    |\n\n## Functions\n\nMath.sqrt: (Number) => Number\n\nMath.sin: (Number) => Number\n\nMath.cos: (Number) => Number\n\nMath.tan: (Number) => Number\n\nMath.asin: (Number) => Number\n\nMath.acos: (Number) => Number\n\nMath.atan: (Number) => Number\n\n---\n\n## description:\n\nimport { FnDocumentationFromName } from \"@quri/squiggle-components\";\nimport { SquiggleEditor } from \"../../../components/SquiggleEditor\";\n\n# MixedSet\n\nThe MixedSet module offers functionality for creating mixed sets, which are sets that can contain both discrete and continuous values. Discrete values are represented as points, while continuous values are represented as ranges. Mixed sets are particularly useful for describing the support of mixed probability distributions.\n\nThe majority of set functions in the MixedSet module are designed to mirror the [upcomming set functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set) in Javascript.\n\nThe primary purpose of mixed sets in Squiggle is to facilitate scoring. For instance, by utilizing mixed sets, you can easily determine if one distribution covers the support of another distribution. If it doesn't, it may be prone to receiving a score of negative infinity.\n\nCurrently, there is no dedicated MixedSet object type. Instead, mixed sets are implemented as dictionaries, where discrete values are stored as points and continuous values are stored as segments.\n\nMixedSet.difference: ({points: List(Number), segments: List([Number, Number])}, {points: List(Number), segments: List([Number, Number])}) => {points: List(Number), segments: List([Number, Number])}\n\nMixedSet.intersection: ({points: List(Number), segments: List([Number, Number])}, {points: List(Number), segments: List([Number, Number])}) => {points: List(Number), segments: List([Number, Number])}\n\nMixedSet.union: ({points: List(Number), segments: List([Number, Number])}, {points: List(Number), segments: List([Number, Number])}) => {points: List(Number), segments: List([Number, Number])}\n\nMixedSet.isSubsetOf: ({points: List(Number), segments: List([Number, Number])}, {points: List(Number), segments: List([Number, Number])}) => Bool\n\nMixedSet.isSupersetOf: ({points: List(Number), segments: List([Number, Number])}, {points: List(Number), segments: List([Number, Number])}) => Bool\n\nMixedSet.isEqual: ({points: List(Number), segments: List([Number, Number])}, {points: List(Number), segments: List([Number, Number])}) => Bool\n\nMixedSet.isEmpty: ({points: List(Number), segments: List([Number, Number])}) => Bool\n\nMixedSet.min: ({points: List(Number), segments: List([Number, Number])}) => Number\nReturns the minimum value in the set\n\nMixedSet.max: ({points: List(Number), segments: List([Number, Number])}) => Number\nReturns the maximum value in the set\n\n---\n\n## description:\n\nimport { FnDocumentationFromName } from \"@quri/squiggle-components\";\nimport { SquiggleEditor } from \"../../../components/SquiggleEditor\";\n\n# Plot\n\nThe Plot module provides functions to create plots of distributions and functions.\n\nRaw functions and distributions are plotted with default parameters, while plot objects created by functions from this module give you more control over chart parameters and access to more complex charts.\n\nPlot.dist: (dist: Dist, params?: {xScale?: Scale, yScale?: Scale, showSummary?: Bool}) => Plot\nPlot.dist(\nnormal(5, 2),\n{\nxScale: Scale.linear({ min: -2, max: 6, title: \"X Axis Title\" }),\nshowSummary: true,\n}\n)\n\nPlot.dists: (dists: List(Dist|Number)|List({name?: String, value: Dist|Number}), {xScale?: Scale, yScale?: Scale, showSummary?: Bool}?) => Plot\nPlot.dists(\n{\ndists: [\n{ name: \"First Dist\", value: normal(0, 1) },\n{ name: \"Second Dist\", value: uniform(2, 4) },\n],\nxScale: Scale.symlog({ min: -2, max: 5 }),\n}\n)\n\nPlot.numericFn: (fn: (Number) => Number, params?: {xScale?: Scale, yScale?: Scale, xPoints?: List(Number)}) => Plot\nPlot.numericFn(\n{|t|t ^ 2},\n{ xScale: Scale.log({ min: 1, max: 100 }), points: 10 }\n)\n\nPlot.distFn: (fn: (Number) => Dist, params?: {xScale?: Scale, yScale?: Scale, distXScale?: Scale, xPoints?: List(Number)}) => Plot\nPlot.distFn(\n{|t|normal(t, 2) \\* normal(5, 3)},\n{\nxScale: Scale.log({ min: 3, max: 100, title: \"Time (years)\" }),\nyScale: Scale.linear({ title: \"Value\" }),\ndistXScale: Scale.linear({ tickFormat: \"#x\" }),\n}\n)\n\nPlot.scatter: ({xDist: SampleSetDist, yDist: SampleSetDist, xScale?: Scale, yScale?: Scale}) => Plot\nxDist = SampleSet.fromDist(2 to 5)\nyDist = normal({p5:-3, p95:3}) _ 5 - xDist ^ 2\nPlot.scatter({\nxDist: xDist,\nyDist: yDist,\nxScale: Scale.log({min: 1.5}),\n})\nxDist = SampleSet.fromDist(normal({p5:-2, p95:5}))\nyDist = normal({p5:-3, p95:3}) _ 5 - xDist\nPlot.scatter({\nxDist: xDist,\nyDist: yDist,\nxScale: Scale.symlog({title: \"X Axis Title\"}),\nyScale: Scale.symlog({title: \"Y Axis Title\"}),\n})\n\n---\n\n## description: Squiggle numbers are Javascript floats.\n\nimport { FnDocumentationFromName } from \"@quri/squiggle-components\";\nimport { SquiggleEditor } from \"../../../components/SquiggleEditor\";\n\n# Number\n\nSquiggle numbers are Javascript floats.\n\n## Comparison\n\nNumber.smaller <: (Number, Number) => Bool\n\nNumber.larger >: (Number, Number) => Bool\n\nNumber.smallerEq <=: (Number, Number) => Bool\n\nNumber.largerEq >=: (Number, Number) => Bool\n\n## Algebra (Number)\n\nNumber.add +: (Number, Number) => Number\n\nNumber.subtract -: (Number, Number) => Number\n\nNumber.multiply \\*: (Number, Number) => Number\n\nNumber.divide /: (Number, Number) => Number\n\nNumber.pow ^: (Number, Number) => Number\n\n## Functions (Number)\n\nNumber.unaryMinus -: (Number) => Number\nexp(3.5)\n\nNumber.exp: (Number) => Number\nexponent\nexp(3.5)\n\nNumber.log: (Number) => Number\nlog(3.5)\n\nNumber.log10: (Number) => Number\nlog10(3.5)\n\nNumber.log2: (Number) => Number\nlog2(3.5)\n\nNumber.floor: (Number) => Number\nfloor(3.5)\n\nNumber.ceil: (Number) => Number\nceil(3.5)\n\nNumber.abs: (Number) => Number\nabsolute value\nabs(3.5)\n\nNumber.round: (Number) => Number\nround(3.5)\n\n## Algebra (List)\n\nNumber.sum: (List(Number)) => Number\nsum([3,5,2])\n\nNumber.product: (List(Number)) => Number\nproduct([3,5,2])\n\nNumber.cumprod: (List(Number)) => List(Number)\ncumulative product\ncumprod([3,5,2,3,5])\n\nNumber.diff: (List(Number)) => List(Number)\ndiff([3,5,2,3,5])\n\n## Functions (List)\n\nNumber.min: (List(Number)) => Number, (Number, Number) => Number\nmin([3,5,2])\n\nNumber.max: (List(Number)) => Number, (Number, Number) => Number\nmax([3,5,2])\n\nNumber.mean: (List(Number)) => Number\nmean([3,5,2])\n\nNumber.quantile: (List(Number), Number) => Number\nquantile([1,5,10,40,2,4], 0.3)\n\nNumber.median: (List(Number)) => Number\nmedian([1,5,10,40,2,4])\n\nNumber.geomean: (List(Number)) => Number\ngeometric mean\ngeomean([3,5,2])\n\nNumber.stdev: (List(Number)) => Number\nstandard deviation\nstdev([3,5,2,3,5])\n\nNumber.variance: (List(Number)) => Number\nvariance([3,5,2,3,5])\n\nNumber.sort: (List(Number)) => List(Number)\nsort([3,5,2,3,5])\n\n## Utils\n\nNumber.rangeDomain: (min: Number, max: Number) => Domain\nNumber.rangeDomain(5, 10)\n\n---\n\n## description: Scales for plots.\n\nimport { FnDocumentationFromName } from \"@quri/squiggle-components\";\nimport { SquiggleEditor } from \"../../../components/SquiggleEditor\";\n\n# Scale\n\nChart axes in [plots](./Plot.mdx) can be scaled using the following functions. Each scale function accepts optional min and max value. Power scale accepts an extra exponent parameter.\n\nSquiggle uses D3 for the tick formats. You can read about d3 tick formats [here](https://github.com/d3/d3-format).\n\n## Numeric Scales\n\nScale.linear: ({min?: Number, max?: Number, tickFormat?: String, title?: String}) => Scale, () => Scale\nScale.linear({ min: 3, max: 10 })\n\nScale.log: ({min?: Number, max?: Number, tickFormat?: String, title?: String}) => Scale, () => Scale\nScale.log({ min: 1, max: 100 })\n\nScale.symlog: ({min?: Number, max?: Number, tickFormat?: String, title?: String, constant?: Number}) => Scale, () => Scale\nSymmetric log scale. Useful for plotting data that includes zero or negative values.\n\nThe function accepts an additional `constant` parameter, used as follows: `Scale.symlog({constant: 0.1})`. This parameter allows you to allocate more pixel space to data with lower or higher absolute values. By adjusting this constant, you effectively control the scale's focus, shifting it between smaller and larger values. For more detailed information on this parameter, refer to the [D3 Documentation](https://d3js.org/d3-scale/symlog).\n\nThe default value for `constant` is `0.0001`.\nScale.symlog({ min: -10, max: 10 })\n\nScale.power: ({min?: Number, max?: Number, tickFormat?: String, title?: String, exponent?: Number}) => Scale, () => Scale\nPower scale. Accepts an extra `exponent` parameter, like, `Scale.power({exponent: 2, min: 0, max: 100})`.\n\nThe default value for `exponent` is `0.1`.\nScale.power({ min: 1, max: 100, exponent: 0.1 })\n\n## Date Scales\n\nScale.date: ({min?: Date, max?: Date, tickFormat?: String, title?: String}) => Scale, () => Scale\nOnly works on Date values. Is a linear scale under the hood.\nScale.date({ min: Date(2022), max: Date(2025) })\n\n---\n\n## description: Function Specifications\n\nimport { FnDocumentationFromName } from \"@quri/squiggle-components\";\nimport { SquiggleEditor } from \"../../../components/SquiggleEditor\";\n\n# Spec\n\nFunction specifications (Specs) are an experimental feature in Squiggle. They are used to specify the structure of functions and verify that they match that structure. They are used primarily as a tag for functions.\n\nSpec.make: ({name: String, documentation: String, validate: Function}) => Specification\nCreate a specification.\n@startClosed\nvalidate(fn) = {\nhasErrors = List.upTo(2020, 2030)\n-> List.some(\n{|e| typeOf(fn(Date(e))) != \"Distribution\"}\n)\nhasErrors ? \"Some results aren't distributions\" : \"\"\n}\n\nspec = Spec.make(\n{\nname: \"Stock market over time\",\ndocumentation: \"A distribution of stock market values over time.\",\nvalidate: validate,\n}\n)\n\n@spec(spec)\nmyEstimate(t: [Date(2020), Date(2030)]) = normal(10, 3)\n\n---\n\n## description: Functions for working with strings in Squiggle\n\nimport { FnDocumentationFromName } from \"@quri/squiggle-components\";\nimport { SquiggleEditor } from \"../../../components/SquiggleEditor\";\n\n# String\n\nStrings support all JSON escape sequences, with addition of escaped single-quotes (for single-quoted strings)\n\n```squiggle\na = \"'\\\" NUL:\\u0000\"\nb = '\\'\" NUL:\\u0000'\n```\n\nString.make: (any) => String\nConverts any value to a string. Some information is often lost.\n\nString.concat: (String, String) => String, (String, any) => String\n\nString.add +: (String, String) => String, (String, any) => String\n\nString.split: (String, separator: String) => List(String)\n\n---\n\n## description: Tables are a simple date time type.\n\nimport { FnDocumentationFromName } from \"@quri/squiggle-components\";\nimport { SquiggleEditor } from \"../../../components/SquiggleEditor\";\n\n# Table\n\nThe Table module allows you to make simple tables for displaying data.\n\nTable.make: (data: List('A), params: {columns: List({fn: ('A) => any, name?: String})}) => Table\nTable.make(\n[\n{ name: \"First Dist\", value: normal(0, 1) },\n{ name: \"Second Dist\", value: uniform(2, 4) },\n{ name: \"Third Dist\", value: uniform(5, 6) },\n],\n{\ncolumns: [\n{ name: \"Name\", fn: {|d|d.name} },\n{ name: \"Mean\", fn: {|d|mean(d.value)} },\n{ name: \"Std Dev\", fn: {|d|variance(d.value)} },\n{ name: \"Dist\", fn: {|d|d.value} },\n],\n}\n)\nTable.make(\n[\n{ name: \"First Dist\", value: Sym.lognormal({ p5: 1, p95: 10 }) },\n{ name: \"Second Dist\", value: Sym.lognormal({ p5: 5, p95: 30 }) },\n{ name: \"Third Dist\", value: Sym.lognormal({ p5: 50, p95: 90 }) },\n],\n{\ncolumns: [\n{ name: \"Name\", fn: {|d|d.name} },\n{\nname: \"Plot\",\nfn: {\n|d|\nPlot.dist(\n{\ndist: d.value,\nxScale: Scale.log({ min: 0.5, max: 100 }),\nshowSummary: false,\n}\n)\n},\n},\n],\n}\n)\n\n---\n\n## description:\n\nimport { FnDocumentationFromName } from \"@quri/squiggle-components\";\nimport { SquiggleEditor } from \"../../../components/SquiggleEditor\";\n\n# System\n\n## Constants\n\n### System.version\n\nReturns the current version of Squiggle.\n\n## Functions\n\nSystem.sampleCount: () => Number\nThe number of samples set in the current environment. This variable can be modified in the Squiggle playground settings.\n\n---\n\n## description: The Tag module handles tags, which allow the additions of metadata to Squiggle variables.\n\nimport { FnDocumentationFromName } from \"@quri/squiggle-components\";\nimport { SquiggleEditor } from \"../../../components/SquiggleEditor\";\n\n# Tag\n\nTags are metadata that can be added to Squiggle variables. They are used to add additional information to variables, such as names, descriptions, and visualization options. While tags can be accessed at runtime, they are primarily meant for use with the Squiggle Playground and other visualizations.\nTags can be added to variables either by using their name `Tag.get[Name]` or by using decorators.\n\n## List of Tags\n\n| Tag Name      | Description                                                                                |\n| ------------- | ------------------------------------------------------------------------------------------ |\n| `name`        | Change the default display name for the variable, in the playground.                       |\n| `doc`         | Adds documentation to the variable in the playground.                                      |\n| `showAs`      | Change the default view for the value when displayed.                                      |\n| `format`      | Format a number, date, or duration when displayed.                                         |\n| `notebook`    | Formats lists as notebooks.                                                                |\n| `hide`        | Don't show the variable in the playground                                                  |\n| `startOpen`   | Start the variable open in the playground                                                  |\n| `startClosed` | Start the variable closed in the playground                                                |\n| `location`    | Store the proper location. Helps when you want to locate code corresponding to a variable. |\n| `exportData`  | Metadata about exported variables. Cannot be added manually.                               |\n\n## Example\n\n<SquiggleEditor\ndefaultCode={`@name(\"My Great Function\") // Decorator syntax to add a name tag\n@doc(\"This is an example function.\")\n@showAs(Calculator) // Show this as a simple calculator in the Playground\nexampleFn(f) = f^2\n\nmyVarTags = Tag.getAll(exampleFn)\n\ndocs = Tag.getDoc(exampleFn)\n\n@hide // Hide this variable in the Playground\nhelperFn(f) = f `}/>\n\n## Tags\n\nTag.name: ('A, String) => 'A\nAdds a user-facing name to a value. This is useful for documenting what a value represents, or how it was calculated.\n\n_Note: While names are shown in the sidebar, you still need to call variables by their regular variable names in code._\n\nTag.getName: (any) => String\n\nTag.doc: ('A, String) => 'A\nAdds text documentation to a value. This is useful for documenting what a value represents or how it was calculated.\n\nTag.getDoc: (any) => String\n\nTag.showAs: (Dist, Plot|(Dist) => Plot) => Dist, (List(any), Table|(List(any)) => Table) => List(any), ((Number) => Dist|Number, Plot|Calculator|((Number) => Dist|Number) => Plot|Calculator) => (Number) => Dist|Number, ((Date) => Dist|Number, Plot|Calculator|((Date) => Dist|Number) => Plot|Calculator) => (Date) => Dist|Number, ((Duration) => Dist|Number, Plot|Calculator|((Duration) => Dist|Number) => Plot|Calculator) => (Duration) => Dist|Number, (Function, Calculator|(Function) => Calculator) => Function\nOverrides the default visualization for a value.\n`showAs()` can take either a visualization, or a function that calls the value and returns a visualization.\n\nDifferent types of values can be displayed in different ways. The following table shows the potential visualization types for each input type. In this table, `Number` can be used with Dates and Durations as well.\n| **Input Type** | **Visualization Types** |\n| ----------------------------------- | ------------------------------------- |\n| **Distribution** | `Plot.dist` |\n| **List** | `Table` |\n| **`(Number -> Number)` Function** | `Plot.numericFn`, `Calculator` |\n| **`(Number -> Dist)` Function** | `Plot.distFn`, `Calculator` |\n| **Function** | `Calculator` |\n\nexample1 = ({|x| x + 1}) -> Tag.showAs(Calculator)\n@showAs({|f| Plot.numericFn(f, { xScale: Scale.symlog() })})\nexample2 = {|x| x + 1}\n\nTag.getShowAs: (any) => any\n\nTag.getExportData: (any) => any\n\nTag.spec: ('A, Specification) => 'A\nAdds a specification to a value. This is useful for documenting how a value was calculated, or what it represents.\n\nTag.getSpec: (any) => any\n\nTag.format: (Dist|Number, numberFormat: String) => Dist|Number, (Duration, numberFormat: String) => Duration, (Date, timeFormat: String) => Date\nSet the display format for a number, distribution, duration, or date. Uses the [d3-format](https://d3js.org/d3-format) syntax on numbers and distributions, and the [d3-time-format](https://d3js.org/d3-time-format) syntax for dates.\n\nTag.getFormat: (Dist|Number) => String, (Duration) => String, (Date) => String\n\nTag.hide: ('A, Bool) => 'A, ('A) => 'A\nHides a value when displayed under Variables. This is useful for hiding intermediate values or helper functions that are used in calculations, but are not directly relevant to the user. Only hides top-level variables.\n\nTag.getHide: (any) => Bool\n\nTag.startOpen: ('A) => 'A\nWhen the value is first displayed, it will begin open in the viewer. Refresh the page to reset.\n\nTag.startClosed: ('A) => 'A\nWhen the value is first displayed, it will begin collapsed in the viewer. Refresh the page to reset.\n\nTag.getStartOpenState: (any) => String\nReturns the startOpenState of a value, which can be \"open\", \"closed\", or \"\" if no startOpenState is set. Set using `Tag.startOpen` and `Tag.startClosed`.\n\nTag.notebook: (List('A), Bool) => List('A), (List('A)) => List('A)\nDisplays the list of values as a notebook. This means that element indices are hidden, and the values are displayed in a vertical list. Useful for displaying combinations of text and values.\nCalculator.make(\n{|f, contents| f ? Tag.notebook(contents) : contents},\n{\ndescription: \"Shows the contents as a notebook if the checkbox is checked.\",\ninputs: [\nInput.checkbox({ name: \"Show as Notebook\", default: true }),\nInput.textArea(\n{\nname: \"Contents to show\",\ndefault: \"[\n\\\"## Distribution 1\\\",\nnormal(5, 2),\n\\\"## Distribution 1\\\",\nnormal(20, 1),\n\\\"This is an opening section. Here is more text.\n\\\",\n]\",\n}\n),\n],\n}\n)\n\nTag.getNotebook: (any) => Bool\n\nTag.location: ('A) => 'A\nSaves the location of a value. Note that this must be called at the point where the location is to be saved. If you use it in a helper function, it will save the location of the helper function, not the location where the helper function is called.\n\nTag.getLocation: (any) => any\n\n## Functions\n\nTag.getAll: (any) => Dict(any)\nReturns a dictionary of all tags on a value.\n\nTag.omit: ('A, List(String)) => 'A\nReturns a copy of the value with the specified tags removed.\n\nTag.clear: ('A) => 'A\nReturns a copy of the value with all tags removed.\n\n---\n\n## description: The Calculator module helps you create custom calculators\n\nimport { FnDocumentationFromName } from \"@quri/squiggle-components\";\nimport { SquiggleEditor } from \"../../../components/SquiggleEditor\";\n\n# Calculator\n\nThe Calculator module allows you to make custom calculators for functions. This is a form that's tied to a specific Squiggle function, where the inputs to the form are passed to that function, and the output of the function gets shown on the bottom.\n\nCalculators can be useful for debugging functions or to present functions to end users.\n\nCalculator.make: ({fn: Function, title?: String, description?: String, inputs?: List(Input), autorun?: Bool, sampleCount?: Number}) => Calculator, (Function, params?: {title?: String, description?: String, inputs?: List(Input), autorun?: Bool, sampleCount?: Number}) => Calculator\n\n`Calculator.make` takes in a function, a description, and a list of inputs. The function should take in the same number of arguments as the number of inputs, and the arguments should be of the same type as the default value of the input.\n\nInputs are created using the `Input` module. The Input module has a few different functions for creating different types of inputs.\n\nFor calculators that take a long time to run, we recommend setting `autorun` to `false`. This will create a button that the user can click to run the calculator.\n\nCalculator.make(\n{|text, textArea, select, checkbox| text + textArea},\n{\ntitle: \"My example calculator\",\ninputs: [\nInput.text({ name: \"text\", default: \"20\" }),\nInput.textArea({ name: \"textArea\", default: \"50 to 80\" }),\nInput.select({ name: \"select\", default: \"second\", options: [\"first\", \"second\", \"third\"] }),\nInput.checkbox({ name: \"checkbox\", default: true }),\n],\nsampleCount: 10k,\n})\n// When a calculator is created with only a function, it will guess the inputs based on the function's parameters. It won't provide default values if it's a user-written function.\n\n({|x| x \\* 5}) -> Calculator\n\n---\n\n## description: Inputs are now only used for describing forms for calculators.\n\nimport { FnDocumentationFromName } from \"@quri/squiggle-components\";\nimport { SquiggleEditor } from \"../../../components/SquiggleEditor\";\n\n# Input\n\nInputs are now only used for describing forms for [calculators](./Calculator.mdx).\n\nInput.text: ({name: String, description?: String, default?: Number|String}) => Input\nCreates a single-line input. This input can be used for all Squiggle types.\nInput.text({ name: \"First\", default: \"John\" })\nInput.text({ name: \"Number of X in Y\", default: '20 to 300' })\n\nInput.textArea: ({name: String, description?: String, default?: Number|String}) => Input\nCreates a multi-line input, sized with the provided input. This input can be used for all Squiggle types.\nInput.textArea({ name: \"people\", default: '{\n\"John\": 20 to 50,\n\"Mary\": 30 to 90,\n}' })\n\nInput.checkbox: ({name: String, description?: String, default?: Bool}) => Input\nCreates a checkbox input. Used for Squiggle booleans.\nInput.checkbox({ name: \"IsTrue?\", default: true })\n\nInput.select: ({name: String, description?: String, options: List(String), default?: String}) => Input\nCreates a dropdown input. Used for Squiggle strings.\nInput.select({ name: \"Name\", default: \"Sue\", options: [\"John\", \"Mary\", \"Sue\"] })\n\n---\n\n## description:\n\nimport { FnDocumentationFromName } from \"@quri/squiggle-components\";\nimport { SquiggleEditor } from \"../../../components/SquiggleEditor\";\n\n# RelativeValues\n\n_Warning: Relative value functions are particularly experimental and subject to change._\n\nRelativeValues.gridPlot: ({ids: List(String), fn: (String, String) => List(Number)}) => Plot\nRelativeValues.gridPlot({\nids: [\"foo\", \"bar\"],\nfn: {|id1, id2| [SampleSet.fromDist(2 to 5), SampleSet.fromDist(3 to 6)]},\n})\n\n---\n\n## description: Newer experimental functions which are less stable than Squiggle as a whole\n\nimport { FnDocumentationFromName } from \"@quri/squiggle-components\";\nimport { SquiggleEditor } from \"../../../components/SquiggleEditor\";\n\n# Danger\n\nThe Danger library contains newer experimental functions which are less stable than Squiggle as a whole. They are not recommended for production use, but are useful for testing out new ideas.,\n\n## JSON\n\nThe JSON module provides JSON-like objects in Squiggle. `Danger.json` is mainly useful for debugging, and `Danger.jsonString` is useful for sending data to other systems. A simple example is shown below.\n\nWe have custom serializers for different Squiggle objects. Note that this API is unstable and might change over time.\n\n<SquiggleEditor\ndefaultCode={`sampleSet = 30 to 50\npointSet = Sym.normal(5, 2)\nplot = Plot.dists([sampleSet, pointSet])\nfn(e) = e\n\n@notebook\nresult = [\n\"### Danger.json()\",\nDanger.json([sampleSet, pointSet, plot, fn]),\n\"### Danger.jsonString\",\n// We don't show sampleSet or plot below because they would be too large, but feel free to try that out\nDanger.jsonString([pointSet, fn]),\n]\nresult\n`}/>\n\nDanger.json: (any) => any\nConverts a value to a simpler form, similar to JSON. This is useful for debugging. Keeps functions and dates, but converts objects like distributions, calculators, and plots to combinations of dictionaries and lists.\nDanger.json({a: 1, b: 2})\nDanger.json([2 to 5, Sym.normal(5, 2), Calculator({|x| x + 1})])\n\nDanger.jsonString: (any) => String\nConverts a value to a stringified JSON, similar to JSON.stringify() in Javasript. Replaces functions with dict summaries.\nDanger.jsonString({a: 1, b: 2})\nDanger.jsonString([2 to 5, Sym.normal(5, 2), Calculator({|x| x + 1})])\n\n## Javascript\n\nNear 1-1 matches of Javascript functions.\n\nDanger.parseFloat: (String) => Number|String\nConverts a string to a number. If the string can't be converted, returns `Parse Failed`. Calls Javascript `parseFloat` under the hood.\nDanger.parseFloat('10.3')\n\nDanger.now: () => Date\nReturns the current date. Internally calls `Date.now()` in JavaScript.\n\n_Caution: This function, which returns the current date, produces varying outputs with each call. As a result, accurately estimating the value of functions that incorporate `Danger.now()` at past time points is challenging. In the future, we intend to implement a feature allowing the input of a simulated time via an environment variable to address this issue._\nDanger.now()\n\n## Math\n\nDanger.laplace: (Number, Number) => Number\nCalculates the probability implied by [Laplace's rule of succession](https://en.wikipedia.org/wiki/Rule_of_succession)\ntrials = 10\nsuccesses = 1\nDanger.laplace(successes, trials) // (successes + 1) / (trials + 2) = 2 / 12 = 0.1666\n\nDanger.yTransform: (PointSetDist) => PointSetDist\nDanger.yTransform(PointSet(Sym.normal(5,2)))\n\n## Combinatorics\n\nDanger.factorial: (Number) => Number\nDanger.factorial(20)\n\nDanger.choose: (Number, Number) => Number\n`Danger.choose(n,k)` returns `factorial(n) / (factorial(n - k) * factorial(k))`, i.e., the number of ways you can choose k items from n choices, without repetition. This function is also known as the [binomial coefficient](https://en.wikipedia.org/wiki/Binomial_coefficient).\nDanger.choose(1, 20)\n\nDanger.binomial: (Number, Number, Number) => Number\n`Danger.binomial(n, k, p)` returns `choose((n, k)) * pow(p, k) * pow(1 - p, n - k)`, i.e., the probability that an event of probability p will happen exactly k times in n draws.\nDanger.binomial(1, 20, 0.5)\n\nDanger.combinations: (List('A), Number) => List(List('A))\nReturns all combinations of the input list taken r elements at a time.\nDanger.combinations([1, 2, 3], 2) // [[1, 2], [1, 3], [2, 3]]\n\nDanger.allCombinations: (List('A)) => List(List('A))\nReturns all possible combinations of the elements in the input list.\nDanger.allCombinations([1, 2, 3]) // [[1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]\n\n## Distributions\n\nDanger.binomialDist: (numberOfTrials: Dist|Number, probabilityOfSuccess: Dist|Number) => SampleSetDist\nA binomial distribution.\n\n`n` must be above 0, and `p` must be between 0 and 1.\n\nNote: The binomial distribution is a discrete distribution. When representing this, the Squiggle distribution component might show it as partially or fully continuous. This is a visual mistake; if you inspect the underlying data, it should be discrete.\nDanger.binomialDist(8, 0.5)\n\nDanger.poissonDist: (rate: Dist|Number) => SampleSetDist\nA Poisson distribution.\n\nNote: The Poisson distribution is a discrete distribution. When representing this, the Squiggle distribution component might show it as partially or fully continuous. This is a visual mistake; if you inspect the underlying data, it should be discrete.\nDanger.poissonDist(10)\n\n## Integration\n\nDanger.integrateFunctionBetweenWithNumIntegrationPoints: (f: Function, min: Number, max: Number, numIntegrationPoints: Number) => Number\nIntegrates the function `f` between `min` and `max`, and computes `numIntegrationPoints` in between to do so.\n\nNote that the function `f` has to take in and return numbers. To integrate a function which returns distributions, use:\n\n```squiggle\nauxiliaryF(x) = mean(f(x))\n\nDanger.integrateFunctionBetweenWithNumIntegrationPoints(auxiliaryF, min, max, numIntegrationPoints)\n```\n\nDanger.integrateFunctionBetweenWithNumIntegrationPoints({|x| x+1}, 1, 10, 10)\n\nDanger.integrateFunctionBetweenWithEpsilon: (f: Function, min: Number, max: Number, epsilon: Number) => Number\nIntegrates the function `f` between `min` and `max`, and uses an interval of `epsilon` between integration points when doing so. This makes its runtime less predictable than `integrateFunctionBetweenWithNumIntegrationPoints`, because runtime will not only depend on `epsilon`, but also on `min` and `max`.\n\nSame caveats as `integrateFunctionBetweenWithNumIntegrationPoints` apply.\nDanger.integrateFunctionBetweenWithEpsilon({|x| x+1}, 1, 10, 0.1)\n\n## Optimization\n\nDanger.optimalAllocationGivenDiminishingMarginalReturnsForManyFunctions: (fs: List(Function), funds: Number, approximateIncrement: Number) => any\nComputes the optimal allocation of $`funds` between `f1` and `f2`. For the answer given to be correct, `f1` and `f2` will have to be decreasing, i.e., if `x > y`, then `f_i(x) < f_i(y)`.\nDanger.optimalAllocationGivenDiminishingMarginalReturnsForManyFunctions(\n[\n{|x| x+1},\n{|y| 10}\n],\n100,\n0.01\n)\n\n```\n\n```\n\n```\n\n```\n";