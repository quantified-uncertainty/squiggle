exports.id = 512;
exports.ids = [512];
exports.modules = {

/***/ 2132:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.AsnConvert = void 0;
const asn1js = __webpack_require__(3457);
const pvtsutils_1 = __webpack_require__(480);
const parser_1 = __webpack_require__(715);
const serializer_1 = __webpack_require__(8414);
class AsnConvert {
    static serialize(obj) {
        return serializer_1.AsnSerializer.serialize(obj);
    }
    static parse(data, target) {
        return parser_1.AsnParser.parse(data, target);
    }
    static toString(data) {
        const buf = pvtsutils_1.BufferSourceConverter.isBufferSource(data) ? pvtsutils_1.BufferSourceConverter.toArrayBuffer(data) : AsnConvert.serialize(data);
        const asn = asn1js.fromBER(buf);
        if (asn.offset === -1) {
            throw new Error(`Cannot decode ASN.1 data. ${asn.result.error}`);
        }
        return asn.result.toString();
    }
}
exports.AsnConvert = AsnConvert;


/***/ }),

/***/ 4942:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.defaultConverter = exports.AsnNullConverter = exports.AsnGeneralizedTimeConverter = exports.AsnUTCTimeConverter = exports.AsnCharacterStringConverter = exports.AsnGeneralStringConverter = exports.AsnVisibleStringConverter = exports.AsnGraphicStringConverter = exports.AsnIA5StringConverter = exports.AsnVideotexStringConverter = exports.AsnTeletexStringConverter = exports.AsnPrintableStringConverter = exports.AsnNumericStringConverter = exports.AsnUniversalStringConverter = exports.AsnBmpStringConverter = exports.AsnUtf8StringConverter = exports.AsnConstructedOctetStringConverter = exports.AsnOctetStringConverter = exports.AsnBooleanConverter = exports.AsnObjectIdentifierConverter = exports.AsnBitStringConverter = exports.AsnIntegerBigIntConverter = exports.AsnIntegerArrayBufferConverter = exports.AsnEnumeratedConverter = exports.AsnIntegerConverter = exports.AsnAnyConverter = void 0;
const asn1js = __webpack_require__(3457);
const enums_1 = __webpack_require__(9478);
const index_1 = __webpack_require__(9702);
exports.AsnAnyConverter = {
    fromASN: (value)=>value instanceof asn1js.Null ? null : value.valueBeforeDecodeView,
    toASN: (value)=>{
        if (value === null) {
            return new asn1js.Null();
        }
        const schema = asn1js.fromBER(value);
        if (schema.result.error) {
            throw new Error(schema.result.error);
        }
        return schema.result;
    }
};
exports.AsnIntegerConverter = {
    fromASN: (value)=>value.valueBlock.valueHexView.byteLength >= 4 ? value.valueBlock.toString() : value.valueBlock.valueDec,
    toASN: (value)=>new asn1js.Integer({
            value: +value
        })
};
exports.AsnEnumeratedConverter = {
    fromASN: (value)=>value.valueBlock.valueDec,
    toASN: (value)=>new asn1js.Enumerated({
            value
        })
};
exports.AsnIntegerArrayBufferConverter = {
    fromASN: (value)=>value.valueBlock.valueHexView,
    toASN: (value)=>new asn1js.Integer({
            valueHex: value
        })
};
exports.AsnIntegerBigIntConverter = {
    fromASN: (value)=>value.toBigInt(),
    toASN: (value)=>asn1js.Integer.fromBigInt(value)
};
exports.AsnBitStringConverter = {
    fromASN: (value)=>value.valueBlock.valueHexView,
    toASN: (value)=>new asn1js.BitString({
            valueHex: value
        })
};
exports.AsnObjectIdentifierConverter = {
    fromASN: (value)=>value.valueBlock.toString(),
    toASN: (value)=>new asn1js.ObjectIdentifier({
            value
        })
};
exports.AsnBooleanConverter = {
    fromASN: (value)=>value.valueBlock.value,
    toASN: (value)=>new asn1js.Boolean({
            value
        })
};
exports.AsnOctetStringConverter = {
    fromASN: (value)=>value.valueBlock.valueHexView,
    toASN: (value)=>new asn1js.OctetString({
            valueHex: value
        })
};
exports.AsnConstructedOctetStringConverter = {
    fromASN: (value)=>new index_1.OctetString(value.getValue()),
    toASN: (value)=>value.toASN()
};
function createStringConverter(Asn1Type) {
    return {
        fromASN: (value)=>value.valueBlock.value,
        toASN: (value)=>new Asn1Type({
                value
            })
    };
}
exports.AsnUtf8StringConverter = createStringConverter(asn1js.Utf8String);
exports.AsnBmpStringConverter = createStringConverter(asn1js.BmpString);
exports.AsnUniversalStringConverter = createStringConverter(asn1js.UniversalString);
exports.AsnNumericStringConverter = createStringConverter(asn1js.NumericString);
exports.AsnPrintableStringConverter = createStringConverter(asn1js.PrintableString);
exports.AsnTeletexStringConverter = createStringConverter(asn1js.TeletexString);
exports.AsnVideotexStringConverter = createStringConverter(asn1js.VideotexString);
exports.AsnIA5StringConverter = createStringConverter(asn1js.IA5String);
exports.AsnGraphicStringConverter = createStringConverter(asn1js.GraphicString);
exports.AsnVisibleStringConverter = createStringConverter(asn1js.VisibleString);
exports.AsnGeneralStringConverter = createStringConverter(asn1js.GeneralString);
exports.AsnCharacterStringConverter = createStringConverter(asn1js.CharacterString);
exports.AsnUTCTimeConverter = {
    fromASN: (value)=>value.toDate(),
    toASN: (value)=>new asn1js.UTCTime({
            valueDate: value
        })
};
exports.AsnGeneralizedTimeConverter = {
    fromASN: (value)=>value.toDate(),
    toASN: (value)=>new asn1js.GeneralizedTime({
            valueDate: value
        })
};
exports.AsnNullConverter = {
    fromASN: ()=>null,
    toASN: ()=>{
        return new asn1js.Null();
    }
};
function defaultConverter(type) {
    switch(type){
        case enums_1.AsnPropTypes.Any:
            return exports.AsnAnyConverter;
        case enums_1.AsnPropTypes.BitString:
            return exports.AsnBitStringConverter;
        case enums_1.AsnPropTypes.BmpString:
            return exports.AsnBmpStringConverter;
        case enums_1.AsnPropTypes.Boolean:
            return exports.AsnBooleanConverter;
        case enums_1.AsnPropTypes.CharacterString:
            return exports.AsnCharacterStringConverter;
        case enums_1.AsnPropTypes.Enumerated:
            return exports.AsnEnumeratedConverter;
        case enums_1.AsnPropTypes.GeneralString:
            return exports.AsnGeneralStringConverter;
        case enums_1.AsnPropTypes.GeneralizedTime:
            return exports.AsnGeneralizedTimeConverter;
        case enums_1.AsnPropTypes.GraphicString:
            return exports.AsnGraphicStringConverter;
        case enums_1.AsnPropTypes.IA5String:
            return exports.AsnIA5StringConverter;
        case enums_1.AsnPropTypes.Integer:
            return exports.AsnIntegerConverter;
        case enums_1.AsnPropTypes.Null:
            return exports.AsnNullConverter;
        case enums_1.AsnPropTypes.NumericString:
            return exports.AsnNumericStringConverter;
        case enums_1.AsnPropTypes.ObjectIdentifier:
            return exports.AsnObjectIdentifierConverter;
        case enums_1.AsnPropTypes.OctetString:
            return exports.AsnOctetStringConverter;
        case enums_1.AsnPropTypes.PrintableString:
            return exports.AsnPrintableStringConverter;
        case enums_1.AsnPropTypes.TeletexString:
            return exports.AsnTeletexStringConverter;
        case enums_1.AsnPropTypes.UTCTime:
            return exports.AsnUTCTimeConverter;
        case enums_1.AsnPropTypes.UniversalString:
            return exports.AsnUniversalStringConverter;
        case enums_1.AsnPropTypes.Utf8String:
            return exports.AsnUtf8StringConverter;
        case enums_1.AsnPropTypes.VideotexString:
            return exports.AsnVideotexStringConverter;
        case enums_1.AsnPropTypes.VisibleString:
            return exports.AsnVisibleStringConverter;
        default:
            return null;
    }
}
exports.defaultConverter = defaultConverter;


/***/ }),

/***/ 3213:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.AsnProp = exports.AsnSequenceType = exports.AsnSetType = exports.AsnChoiceType = exports.AsnType = void 0;
const converters = __webpack_require__(4942);
const enums_1 = __webpack_require__(9478);
const storage_1 = __webpack_require__(6751);
const AsnType = (options)=>(target)=>{
        let schema;
        if (!storage_1.schemaStorage.has(target)) {
            schema = storage_1.schemaStorage.createDefault(target);
            storage_1.schemaStorage.set(target, schema);
        } else {
            schema = storage_1.schemaStorage.get(target);
        }
        Object.assign(schema, options);
    };
exports.AsnType = AsnType;
const AsnChoiceType = ()=>(0, exports.AsnType)({
        type: enums_1.AsnTypeTypes.Choice
    });
exports.AsnChoiceType = AsnChoiceType;
const AsnSetType = (options)=>(0, exports.AsnType)({
        type: enums_1.AsnTypeTypes.Set,
        ...options
    });
exports.AsnSetType = AsnSetType;
const AsnSequenceType = (options)=>(0, exports.AsnType)({
        type: enums_1.AsnTypeTypes.Sequence,
        ...options
    });
exports.AsnSequenceType = AsnSequenceType;
const AsnProp = (options)=>(target, propertyKey)=>{
        let schema;
        if (!storage_1.schemaStorage.has(target.constructor)) {
            schema = storage_1.schemaStorage.createDefault(target.constructor);
            storage_1.schemaStorage.set(target.constructor, schema);
        } else {
            schema = storage_1.schemaStorage.get(target.constructor);
        }
        const copyOptions = Object.assign({}, options);
        if (typeof copyOptions.type === "number" && !copyOptions.converter) {
            const defaultConverter = converters.defaultConverter(options.type);
            if (!defaultConverter) {
                throw new Error(`Cannot get default converter for property '${propertyKey}' of ${target.constructor.name}`);
            }
            copyOptions.converter = defaultConverter;
        }
        schema.items[propertyKey] = copyOptions;
    };
exports.AsnProp = AsnProp;


/***/ }),

/***/ 9478:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.AsnPropTypes = exports.AsnTypeTypes = void 0;
var AsnTypeTypes;
(function(AsnTypeTypes) {
    AsnTypeTypes[AsnTypeTypes["Sequence"] = 0] = "Sequence";
    AsnTypeTypes[AsnTypeTypes["Set"] = 1] = "Set";
    AsnTypeTypes[AsnTypeTypes["Choice"] = 2] = "Choice";
})(AsnTypeTypes = exports.AsnTypeTypes || (exports.AsnTypeTypes = {}));
var AsnPropTypes;
(function(AsnPropTypes) {
    AsnPropTypes[AsnPropTypes["Any"] = 1] = "Any";
    AsnPropTypes[AsnPropTypes["Boolean"] = 2] = "Boolean";
    AsnPropTypes[AsnPropTypes["OctetString"] = 3] = "OctetString";
    AsnPropTypes[AsnPropTypes["BitString"] = 4] = "BitString";
    AsnPropTypes[AsnPropTypes["Integer"] = 5] = "Integer";
    AsnPropTypes[AsnPropTypes["Enumerated"] = 6] = "Enumerated";
    AsnPropTypes[AsnPropTypes["ObjectIdentifier"] = 7] = "ObjectIdentifier";
    AsnPropTypes[AsnPropTypes["Utf8String"] = 8] = "Utf8String";
    AsnPropTypes[AsnPropTypes["BmpString"] = 9] = "BmpString";
    AsnPropTypes[AsnPropTypes["UniversalString"] = 10] = "UniversalString";
    AsnPropTypes[AsnPropTypes["NumericString"] = 11] = "NumericString";
    AsnPropTypes[AsnPropTypes["PrintableString"] = 12] = "PrintableString";
    AsnPropTypes[AsnPropTypes["TeletexString"] = 13] = "TeletexString";
    AsnPropTypes[AsnPropTypes["VideotexString"] = 14] = "VideotexString";
    AsnPropTypes[AsnPropTypes["IA5String"] = 15] = "IA5String";
    AsnPropTypes[AsnPropTypes["GraphicString"] = 16] = "GraphicString";
    AsnPropTypes[AsnPropTypes["VisibleString"] = 17] = "VisibleString";
    AsnPropTypes[AsnPropTypes["GeneralString"] = 18] = "GeneralString";
    AsnPropTypes[AsnPropTypes["CharacterString"] = 19] = "CharacterString";
    AsnPropTypes[AsnPropTypes["UTCTime"] = 20] = "UTCTime";
    AsnPropTypes[AsnPropTypes["GeneralizedTime"] = 21] = "GeneralizedTime";
    AsnPropTypes[AsnPropTypes["DATE"] = 22] = "DATE";
    AsnPropTypes[AsnPropTypes["TimeOfDay"] = 23] = "TimeOfDay";
    AsnPropTypes[AsnPropTypes["DateTime"] = 24] = "DateTime";
    AsnPropTypes[AsnPropTypes["Duration"] = 25] = "Duration";
    AsnPropTypes[AsnPropTypes["TIME"] = 26] = "TIME";
    AsnPropTypes[AsnPropTypes["Null"] = 27] = "Null";
})(AsnPropTypes = exports.AsnPropTypes || (exports.AsnPropTypes = {}));


/***/ }),

/***/ 3575:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(4479);
tslib_1.__exportStar(__webpack_require__(3198), exports);


/***/ }),

/***/ 3198:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.AsnSchemaValidationError = void 0;
class AsnSchemaValidationError extends Error {
    constructor(){
        super(...arguments);
        this.schemas = [];
    }
}
exports.AsnSchemaValidationError = AsnSchemaValidationError;


/***/ }),

/***/ 6213:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.isArrayEqual = exports.isTypeOfArray = exports.isConvertible = void 0;
function isConvertible(target) {
    if (typeof target === "function" && target.prototype) {
        if (target.prototype.toASN && target.prototype.fromASN) {
            return true;
        } else {
            return isConvertible(target.prototype);
        }
    } else {
        return !!(target && typeof target === "object" && "toASN" in target && "fromASN" in target);
    }
}
exports.isConvertible = isConvertible;
function isTypeOfArray(target) {
    var _a;
    if (target) {
        const proto = Object.getPrototypeOf(target);
        if (((_a = proto === null || proto === void 0 ? void 0 : proto.prototype) === null || _a === void 0 ? void 0 : _a.constructor) === Array) {
            return true;
        }
        return isTypeOfArray(proto);
    }
    return false;
}
exports.isTypeOfArray = isTypeOfArray;
function isArrayEqual(bytes1, bytes2) {
    if (!(bytes1 && bytes2)) {
        return false;
    }
    if (bytes1.byteLength !== bytes2.byteLength) {
        return false;
    }
    const b1 = new Uint8Array(bytes1);
    const b2 = new Uint8Array(bytes2);
    for(let i = 0; i < bytes1.byteLength; i++){
        if (b1[i] !== b2[i]) {
            return false;
        }
    }
    return true;
}
exports.isArrayEqual = isArrayEqual;


/***/ }),

/***/ 3174:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.AsnSerializer = exports.AsnParser = exports.AsnPropTypes = exports.AsnTypeTypes = exports.AsnSetType = exports.AsnSequenceType = exports.AsnChoiceType = exports.AsnType = exports.AsnProp = void 0;
const tslib_1 = __webpack_require__(4479);
tslib_1.__exportStar(__webpack_require__(4942), exports);
tslib_1.__exportStar(__webpack_require__(9702), exports);
var decorators_1 = __webpack_require__(3213);
Object.defineProperty(exports, "AsnProp", ({
    enumerable: true,
    get: function() {
        return decorators_1.AsnProp;
    }
}));
Object.defineProperty(exports, "AsnType", ({
    enumerable: true,
    get: function() {
        return decorators_1.AsnType;
    }
}));
Object.defineProperty(exports, "AsnChoiceType", ({
    enumerable: true,
    get: function() {
        return decorators_1.AsnChoiceType;
    }
}));
Object.defineProperty(exports, "AsnSequenceType", ({
    enumerable: true,
    get: function() {
        return decorators_1.AsnSequenceType;
    }
}));
Object.defineProperty(exports, "AsnSetType", ({
    enumerable: true,
    get: function() {
        return decorators_1.AsnSetType;
    }
}));
var enums_1 = __webpack_require__(9478);
Object.defineProperty(exports, "AsnTypeTypes", ({
    enumerable: true,
    get: function() {
        return enums_1.AsnTypeTypes;
    }
}));
Object.defineProperty(exports, "AsnPropTypes", ({
    enumerable: true,
    get: function() {
        return enums_1.AsnPropTypes;
    }
}));
var parser_1 = __webpack_require__(715);
Object.defineProperty(exports, "AsnParser", ({
    enumerable: true,
    get: function() {
        return parser_1.AsnParser;
    }
}));
var serializer_1 = __webpack_require__(8414);
Object.defineProperty(exports, "AsnSerializer", ({
    enumerable: true,
    get: function() {
        return serializer_1.AsnSerializer;
    }
}));
tslib_1.__exportStar(__webpack_require__(3575), exports);
tslib_1.__exportStar(__webpack_require__(6137), exports);
tslib_1.__exportStar(__webpack_require__(2132), exports);


/***/ }),

/***/ 6137:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.AsnArray = void 0;
class AsnArray extends Array {
    constructor(items = []){
        if (typeof items === "number") {
            super(items);
        } else {
            super();
            for (const item of items){
                this.push(item);
            }
        }
    }
}
exports.AsnArray = AsnArray;


/***/ }),

/***/ 715:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.AsnParser = void 0;
const asn1js = __webpack_require__(3457);
const enums_1 = __webpack_require__(9478);
const converters = __webpack_require__(4942);
const errors_1 = __webpack_require__(3575);
const helper_1 = __webpack_require__(6213);
const storage_1 = __webpack_require__(6751);
class AsnParser {
    static parse(data, target) {
        const asn1Parsed = asn1js.fromBER(data);
        if (asn1Parsed.result.error) {
            throw new Error(asn1Parsed.result.error);
        }
        const res = this.fromASN(asn1Parsed.result, target);
        return res;
    }
    static fromASN(asn1Schema, target) {
        var _a;
        try {
            if ((0, helper_1.isConvertible)(target)) {
                const value = new target();
                return value.fromASN(asn1Schema);
            }
            const schema = storage_1.schemaStorage.get(target);
            storage_1.schemaStorage.cache(target);
            let targetSchema = schema.schema;
            if (asn1Schema.constructor === asn1js.Constructed && schema.type !== enums_1.AsnTypeTypes.Choice) {
                targetSchema = new asn1js.Constructed({
                    idBlock: {
                        tagClass: 3,
                        tagNumber: asn1Schema.idBlock.tagNumber
                    },
                    value: schema.schema.valueBlock.value
                });
                for(const key in schema.items){
                    delete asn1Schema[key];
                }
            }
            const asn1ComparedSchema = asn1js.compareSchema({}, asn1Schema, targetSchema);
            if (!asn1ComparedSchema.verified) {
                throw new errors_1.AsnSchemaValidationError(`Data does not match to ${target.name} ASN1 schema. ${asn1ComparedSchema.result.error}`);
            }
            const res = new target();
            if ((0, helper_1.isTypeOfArray)(target)) {
                if (!("value" in asn1Schema.valueBlock && Array.isArray(asn1Schema.valueBlock.value))) {
                    throw new Error(`Cannot get items from the ASN.1 parsed value. ASN.1 object is not constructed.`);
                }
                const itemType = schema.itemType;
                if (typeof itemType === "number") {
                    const converter = converters.defaultConverter(itemType);
                    if (!converter) {
                        throw new Error(`Cannot get default converter for array item of ${target.name} ASN1 schema`);
                    }
                    return target.from(asn1Schema.valueBlock.value, (element)=>converter.fromASN(element));
                } else {
                    return target.from(asn1Schema.valueBlock.value, (element)=>this.fromASN(element, itemType));
                }
            }
            for(const key in schema.items){
                const asn1SchemaValue = asn1ComparedSchema.result[key];
                if (!asn1SchemaValue) {
                    continue;
                }
                const schemaItem = schema.items[key];
                const schemaItemType = schemaItem.type;
                if (typeof schemaItemType === "number" || (0, helper_1.isConvertible)(schemaItemType)) {
                    const converter = (_a = schemaItem.converter) !== null && _a !== void 0 ? _a : (0, helper_1.isConvertible)(schemaItemType) ? new schemaItemType() : null;
                    if (!converter) {
                        throw new Error("Converter is empty");
                    }
                    if (schemaItem.repeated) {
                        if (schemaItem.implicit) {
                            const Container = schemaItem.repeated === "sequence" ? asn1js.Sequence : asn1js.Set;
                            const newItem = new Container();
                            newItem.valueBlock = asn1SchemaValue.valueBlock;
                            const newItemAsn = asn1js.fromBER(newItem.toBER(false));
                            if (newItemAsn.offset === -1) {
                                throw new Error(`Cannot parse the child item. ${newItemAsn.result.error}`);
                            }
                            if (!("value" in newItemAsn.result.valueBlock && Array.isArray(newItemAsn.result.valueBlock.value))) {
                                throw new Error("Cannot get items from the ASN.1 parsed value. ASN.1 object is not constructed.");
                            }
                            const value = newItemAsn.result.valueBlock.value;
                            res[key] = Array.from(value, (element)=>converter.fromASN(element));
                        } else {
                            res[key] = Array.from(asn1SchemaValue, (element)=>converter.fromASN(element));
                        }
                    } else {
                        let value = asn1SchemaValue;
                        if (schemaItem.implicit) {
                            let newItem;
                            if ((0, helper_1.isConvertible)(schemaItemType)) {
                                newItem = new schemaItemType().toSchema("");
                            } else {
                                const Asn1TypeName = enums_1.AsnPropTypes[schemaItemType];
                                const Asn1Type = asn1js[Asn1TypeName];
                                if (!Asn1Type) {
                                    throw new Error(`Cannot get '${Asn1TypeName}' class from asn1js module`);
                                }
                                newItem = new Asn1Type();
                            }
                            newItem.valueBlock = value.valueBlock;
                            value = asn1js.fromBER(newItem.toBER(false)).result;
                        }
                        res[key] = converter.fromASN(value);
                    }
                } else {
                    if (schemaItem.repeated) {
                        if (!Array.isArray(asn1SchemaValue)) {
                            throw new Error("Cannot get list of items from the ASN.1 parsed value. ASN.1 value should be iterable.");
                        }
                        res[key] = Array.from(asn1SchemaValue, (element)=>this.fromASN(element, schemaItemType));
                    } else {
                        res[key] = this.fromASN(asn1SchemaValue, schemaItemType);
                    }
                }
            }
            return res;
        } catch (error) {
            if (error instanceof errors_1.AsnSchemaValidationError) {
                error.schemas.push(target.name);
            }
            throw error;
        }
    }
}
exports.AsnParser = AsnParser;


/***/ }),

/***/ 597:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.AsnSchemaStorage = void 0;
const asn1js = __webpack_require__(3457);
const enums_1 = __webpack_require__(9478);
const helper_1 = __webpack_require__(6213);
class AsnSchemaStorage {
    constructor(){
        this.items = new WeakMap();
    }
    has(target) {
        return this.items.has(target);
    }
    get(target, checkSchema = false) {
        const schema = this.items.get(target);
        if (!schema) {
            throw new Error(`Cannot get schema for '${target.prototype.constructor.name}' target`);
        }
        if (checkSchema && !schema.schema) {
            throw new Error(`Schema '${target.prototype.constructor.name}' doesn't contain ASN.1 schema. Call 'AsnSchemaStorage.cache'.`);
        }
        return schema;
    }
    cache(target) {
        const schema = this.get(target);
        if (!schema.schema) {
            schema.schema = this.create(target, true);
        }
    }
    createDefault(target) {
        const schema = {
            type: enums_1.AsnTypeTypes.Sequence,
            items: {}
        };
        const parentSchema = this.findParentSchema(target);
        if (parentSchema) {
            Object.assign(schema, parentSchema);
            schema.items = Object.assign({}, schema.items, parentSchema.items);
        }
        return schema;
    }
    create(target, useNames) {
        const schema = this.items.get(target) || this.createDefault(target);
        const asn1Value = [];
        for(const key in schema.items){
            const item = schema.items[key];
            const name = useNames ? key : "";
            let asn1Item;
            if (typeof item.type === "number") {
                const Asn1TypeName = enums_1.AsnPropTypes[item.type];
                const Asn1Type = asn1js[Asn1TypeName];
                if (!Asn1Type) {
                    throw new Error(`Cannot get ASN1 class by name '${Asn1TypeName}'`);
                }
                asn1Item = new Asn1Type({
                    name
                });
            } else if ((0, helper_1.isConvertible)(item.type)) {
                const instance = new item.type();
                asn1Item = instance.toSchema(name);
            } else if (item.optional) {
                const itemSchema = this.get(item.type);
                if (itemSchema.type === enums_1.AsnTypeTypes.Choice) {
                    asn1Item = new asn1js.Any({
                        name
                    });
                } else {
                    asn1Item = this.create(item.type, false);
                    asn1Item.name = name;
                }
            } else {
                asn1Item = new asn1js.Any({
                    name
                });
            }
            const optional = !!item.optional || item.defaultValue !== undefined;
            if (item.repeated) {
                asn1Item.name = "";
                const Container = item.repeated === "set" ? asn1js.Set : asn1js.Sequence;
                asn1Item = new Container({
                    name: "",
                    value: [
                        new asn1js.Repeated({
                            name,
                            value: asn1Item
                        })
                    ]
                });
            }
            if (item.context !== null && item.context !== undefined) {
                if (item.implicit) {
                    if (typeof item.type === "number" || (0, helper_1.isConvertible)(item.type)) {
                        const Container = item.repeated ? asn1js.Constructed : asn1js.Primitive;
                        asn1Value.push(new Container({
                            name,
                            optional,
                            idBlock: {
                                tagClass: 3,
                                tagNumber: item.context
                            }
                        }));
                    } else {
                        this.cache(item.type);
                        const isRepeated = !!item.repeated;
                        let value = !isRepeated ? this.get(item.type, true).schema : asn1Item;
                        value = "valueBlock" in value ? value.valueBlock.value : value.value;
                        asn1Value.push(new asn1js.Constructed({
                            name: !isRepeated ? name : "",
                            optional,
                            idBlock: {
                                tagClass: 3,
                                tagNumber: item.context
                            },
                            value: value
                        }));
                    }
                } else {
                    asn1Value.push(new asn1js.Constructed({
                        optional,
                        idBlock: {
                            tagClass: 3,
                            tagNumber: item.context
                        },
                        value: [
                            asn1Item
                        ]
                    }));
                }
            } else {
                asn1Item.optional = optional;
                asn1Value.push(asn1Item);
            }
        }
        switch(schema.type){
            case enums_1.AsnTypeTypes.Sequence:
                return new asn1js.Sequence({
                    value: asn1Value,
                    name: ""
                });
            case enums_1.AsnTypeTypes.Set:
                return new asn1js.Set({
                    value: asn1Value,
                    name: ""
                });
            case enums_1.AsnTypeTypes.Choice:
                return new asn1js.Choice({
                    value: asn1Value,
                    name: ""
                });
            default:
                throw new Error(`Unsupported ASN1 type in use`);
        }
    }
    set(target, schema) {
        this.items.set(target, schema);
        return this;
    }
    findParentSchema(target) {
        const parent = Object.getPrototypeOf(target);
        if (parent) {
            const schema = this.items.get(parent);
            return schema || this.findParentSchema(parent);
        }
        return null;
    }
}
exports.AsnSchemaStorage = AsnSchemaStorage;


/***/ }),

/***/ 8414:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.AsnSerializer = void 0;
const asn1js = __webpack_require__(3457);
const converters = __webpack_require__(4942);
const enums_1 = __webpack_require__(9478);
const helper_1 = __webpack_require__(6213);
const storage_1 = __webpack_require__(6751);
class AsnSerializer {
    static serialize(obj) {
        if (obj instanceof asn1js.BaseBlock) {
            return obj.toBER(false);
        }
        return this.toASN(obj).toBER(false);
    }
    static toASN(obj) {
        if (obj && typeof obj === "object" && (0, helper_1.isConvertible)(obj)) {
            return obj.toASN();
        }
        if (!(obj && typeof obj === "object")) {
            throw new TypeError("Parameter 1 should be type of Object.");
        }
        const target = obj.constructor;
        const schema = storage_1.schemaStorage.get(target);
        storage_1.schemaStorage.cache(target);
        let asn1Value = [];
        if (schema.itemType) {
            if (!Array.isArray(obj)) {
                throw new TypeError("Parameter 1 should be type of Array.");
            }
            if (typeof schema.itemType === "number") {
                const converter = converters.defaultConverter(schema.itemType);
                if (!converter) {
                    throw new Error(`Cannot get default converter for array item of ${target.name} ASN1 schema`);
                }
                asn1Value = obj.map((o)=>converter.toASN(o));
            } else {
                asn1Value = obj.map((o)=>this.toAsnItem({
                        type: schema.itemType
                    }, "[]", target, o));
            }
        } else {
            for(const key in schema.items){
                const schemaItem = schema.items[key];
                const objProp = obj[key];
                if (objProp === undefined || schemaItem.defaultValue === objProp || typeof schemaItem.defaultValue === "object" && typeof objProp === "object" && (0, helper_1.isArrayEqual)(this.serialize(schemaItem.defaultValue), this.serialize(objProp))) {
                    continue;
                }
                const asn1Item = AsnSerializer.toAsnItem(schemaItem, key, target, objProp);
                if (typeof schemaItem.context === "number") {
                    if (schemaItem.implicit) {
                        if (!schemaItem.repeated && (typeof schemaItem.type === "number" || (0, helper_1.isConvertible)(schemaItem.type))) {
                            const value = {};
                            value.valueHex = asn1Item instanceof asn1js.Null ? asn1Item.valueBeforeDecodeView : asn1Item.valueBlock.toBER();
                            asn1Value.push(new asn1js.Primitive({
                                optional: schemaItem.optional,
                                idBlock: {
                                    tagClass: 3,
                                    tagNumber: schemaItem.context
                                },
                                ...value
                            }));
                        } else {
                            asn1Value.push(new asn1js.Constructed({
                                optional: schemaItem.optional,
                                idBlock: {
                                    tagClass: 3,
                                    tagNumber: schemaItem.context
                                },
                                value: asn1Item.valueBlock.value
                            }));
                        }
                    } else {
                        asn1Value.push(new asn1js.Constructed({
                            optional: schemaItem.optional,
                            idBlock: {
                                tagClass: 3,
                                tagNumber: schemaItem.context
                            },
                            value: [
                                asn1Item
                            ]
                        }));
                    }
                } else if (schemaItem.repeated) {
                    asn1Value = asn1Value.concat(asn1Item);
                } else {
                    asn1Value.push(asn1Item);
                }
            }
        }
        let asnSchema;
        switch(schema.type){
            case enums_1.AsnTypeTypes.Sequence:
                asnSchema = new asn1js.Sequence({
                    value: asn1Value
                });
                break;
            case enums_1.AsnTypeTypes.Set:
                asnSchema = new asn1js.Set({
                    value: asn1Value
                });
                break;
            case enums_1.AsnTypeTypes.Choice:
                if (!asn1Value[0]) {
                    throw new Error(`Schema '${target.name}' has wrong data. Choice cannot be empty.`);
                }
                asnSchema = asn1Value[0];
                break;
        }
        return asnSchema;
    }
    static toAsnItem(schemaItem, key, target, objProp) {
        let asn1Item;
        if (typeof schemaItem.type === "number") {
            const converter = schemaItem.converter;
            if (!converter) {
                throw new Error(`Property '${key}' doesn't have converter for type ${enums_1.AsnPropTypes[schemaItem.type]} in schema '${target.name}'`);
            }
            if (schemaItem.repeated) {
                if (!Array.isArray(objProp)) {
                    throw new TypeError("Parameter 'objProp' should be type of Array.");
                }
                const items = Array.from(objProp, (element)=>converter.toASN(element));
                const Container = schemaItem.repeated === "sequence" ? asn1js.Sequence : asn1js.Set;
                asn1Item = new Container({
                    value: items
                });
            } else {
                asn1Item = converter.toASN(objProp);
            }
        } else {
            if (schemaItem.repeated) {
                if (!Array.isArray(objProp)) {
                    throw new TypeError("Parameter 'objProp' should be type of Array.");
                }
                const items = Array.from(objProp, (element)=>this.toASN(element));
                const Container = schemaItem.repeated === "sequence" ? asn1js.Sequence : asn1js.Set;
                asn1Item = new Container({
                    value: items
                });
            } else {
                asn1Item = this.toASN(objProp);
            }
        }
        return asn1Item;
    }
}
exports.AsnSerializer = AsnSerializer;


/***/ }),

/***/ 6751:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.schemaStorage = void 0;
const schema_1 = __webpack_require__(597);
exports.schemaStorage = new schema_1.AsnSchemaStorage();


/***/ }),

/***/ 129:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.BitString = void 0;
const asn1js = __webpack_require__(3457);
const pvtsutils_1 = __webpack_require__(480);
class BitString {
    constructor(params, unusedBits = 0){
        this.unusedBits = 0;
        this.value = new ArrayBuffer(0);
        if (params) {
            if (typeof params === "number") {
                this.fromNumber(params);
            } else if (pvtsutils_1.BufferSourceConverter.isBufferSource(params)) {
                this.unusedBits = unusedBits;
                this.value = pvtsutils_1.BufferSourceConverter.toArrayBuffer(params);
            } else {
                throw TypeError("Unsupported type of 'params' argument for BitString");
            }
        }
    }
    fromASN(asn) {
        if (!(asn instanceof asn1js.BitString)) {
            throw new TypeError("Argument 'asn' is not instance of ASN.1 BitString");
        }
        this.unusedBits = asn.valueBlock.unusedBits;
        this.value = asn.valueBlock.valueHex;
        return this;
    }
    toASN() {
        return new asn1js.BitString({
            unusedBits: this.unusedBits,
            valueHex: this.value
        });
    }
    toSchema(name) {
        return new asn1js.BitString({
            name
        });
    }
    toNumber() {
        let res = "";
        const uintArray = new Uint8Array(this.value);
        for (const octet of uintArray){
            res += octet.toString(2).padStart(8, "0");
        }
        res = res.split("").reverse().join("");
        if (this.unusedBits) {
            res = res.slice(this.unusedBits).padStart(this.unusedBits, "0");
        }
        return parseInt(res, 2);
    }
    fromNumber(value) {
        let bits = value.toString(2);
        const octetSize = bits.length + 7 >> 3;
        this.unusedBits = (octetSize << 3) - bits.length;
        const octets = new Uint8Array(octetSize);
        bits = bits.padStart(octetSize << 3, "0").split("").reverse().join("");
        let index = 0;
        while(index < octetSize){
            octets[index] = parseInt(bits.slice(index << 3, (index << 3) + 8), 2);
            index++;
        }
        this.value = octets.buffer;
    }
}
exports.BitString = BitString;


/***/ }),

/***/ 9702:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(4479);
tslib_1.__exportStar(__webpack_require__(129), exports);
tslib_1.__exportStar(__webpack_require__(2469), exports);


/***/ }),

/***/ 2469:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.OctetString = void 0;
const asn1js = __webpack_require__(3457);
const pvtsutils_1 = __webpack_require__(480);
class OctetString {
    constructor(param){
        if (typeof param === "number") {
            this.buffer = new ArrayBuffer(param);
        } else {
            if (pvtsutils_1.BufferSourceConverter.isBufferSource(param)) {
                this.buffer = pvtsutils_1.BufferSourceConverter.toArrayBuffer(param);
            } else if (Array.isArray(param)) {
                this.buffer = new Uint8Array(param);
            } else {
                this.buffer = new ArrayBuffer(0);
            }
        }
    }
    get byteLength() {
        return this.buffer.byteLength;
    }
    get byteOffset() {
        return 0;
    }
    fromASN(asn) {
        if (!(asn instanceof asn1js.OctetString)) {
            throw new TypeError("Argument 'asn' is not instance of ASN.1 OctetString");
        }
        this.buffer = asn.valueBlock.valueHex;
        return this;
    }
    toASN() {
        return new asn1js.OctetString({
            valueHex: this.buffer
        });
    }
    toSchema(name) {
        return new asn1js.OctetString({
            name
        });
    }
}
exports.OctetString = OctetString;


/***/ }),

/***/ 6066:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/**
 * Copyright (c) 2020, Peculiar Ventures, All rights reserved.
 */ 
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
class JsonError extends Error {
    constructor(message, innerError){
        super(innerError ? `${message}. See the inner exception for more details.` : message);
        this.message = message;
        this.innerError = innerError;
    }
}
class TransformError extends JsonError {
    constructor(schema, message, innerError){
        super(message, innerError);
        this.schema = schema;
    }
}
class ParserError extends TransformError {
    constructor(schema, message, innerError){
        super(schema, `JSON doesn't match to '${schema.target.name}' schema. ${message}`, innerError);
    }
}
class ValidationError extends JsonError {
}
class SerializerError extends JsonError {
    constructor(schemaName, message, innerError){
        super(`Cannot serialize by '${schemaName}' schema. ${message}`, innerError);
        this.schemaName = schemaName;
    }
}
class KeyError extends ParserError {
    constructor(schema, keys, errors = {}){
        super(schema, "Some keys doesn't match to schema");
        this.keys = keys;
        this.errors = errors;
    }
}
(function(JsonPropTypes) {
    JsonPropTypes[JsonPropTypes["Any"] = 0] = "Any";
    JsonPropTypes[JsonPropTypes["Boolean"] = 1] = "Boolean";
    JsonPropTypes[JsonPropTypes["Number"] = 2] = "Number";
    JsonPropTypes[JsonPropTypes["String"] = 3] = "String";
})(exports.JsonPropTypes || (exports.JsonPropTypes = {}));
function checkType(value, type) {
    switch(type){
        case exports.JsonPropTypes.Boolean:
            return typeof value === "boolean";
        case exports.JsonPropTypes.Number:
            return typeof value === "number";
        case exports.JsonPropTypes.String:
            return typeof value === "string";
    }
    return true;
}
function throwIfTypeIsWrong(value, type) {
    if (!checkType(value, type)) {
        throw new TypeError(`Value must be ${exports.JsonPropTypes[type]}`);
    }
}
function isConvertible(target) {
    if (target && target.prototype) {
        if (target.prototype.toJSON && target.prototype.fromJSON) {
            return true;
        } else {
            return isConvertible(target.prototype);
        }
    } else {
        return !!(target && target.toJSON && target.fromJSON);
    }
}
class JsonSchemaStorage {
    constructor(){
        this.items = new Map();
    }
    has(target) {
        return this.items.has(target) || !!this.findParentSchema(target);
    }
    get(target) {
        const schema = this.items.get(target) || this.findParentSchema(target);
        if (!schema) {
            throw new Error("Cannot get schema for current target");
        }
        return schema;
    }
    create(target) {
        const schema = {
            names: {}
        };
        const parentSchema = this.findParentSchema(target);
        if (parentSchema) {
            Object.assign(schema, parentSchema);
            schema.names = {};
            for(const name in parentSchema.names){
                schema.names[name] = Object.assign({}, parentSchema.names[name]);
            }
        }
        schema.target = target;
        return schema;
    }
    set(target, schema) {
        this.items.set(target, schema);
        return this;
    }
    findParentSchema(target) {
        const parent = target.__proto__;
        if (parent) {
            const schema = this.items.get(parent);
            return schema || this.findParentSchema(parent);
        }
        return null;
    }
}
const DEFAULT_SCHEMA = "default";
const schemaStorage = new JsonSchemaStorage();
class PatternValidation {
    constructor(pattern){
        this.pattern = new RegExp(pattern);
    }
    validate(value) {
        const pattern = new RegExp(this.pattern.source, this.pattern.flags);
        if (typeof value !== "string") {
            throw new ValidationError("Incoming value must be string");
        }
        if (!pattern.exec(value)) {
            throw new ValidationError(`Value doesn't match to pattern '${pattern.toString()}'`);
        }
    }
}
class InclusiveValidation {
    constructor(min = Number.MIN_VALUE, max = Number.MAX_VALUE){
        this.min = min;
        this.max = max;
    }
    validate(value) {
        throwIfTypeIsWrong(value, exports.JsonPropTypes.Number);
        if (!(this.min <= value && value <= this.max)) {
            const min = this.min === Number.MIN_VALUE ? "MIN" : this.min;
            const max = this.max === Number.MAX_VALUE ? "MAX" : this.max;
            throw new ValidationError(`Value doesn't match to diapason [${min},${max}]`);
        }
    }
}
class ExclusiveValidation {
    constructor(min = Number.MIN_VALUE, max = Number.MAX_VALUE){
        this.min = min;
        this.max = max;
    }
    validate(value) {
        throwIfTypeIsWrong(value, exports.JsonPropTypes.Number);
        if (!(this.min < value && value < this.max)) {
            const min = this.min === Number.MIN_VALUE ? "MIN" : this.min;
            const max = this.max === Number.MAX_VALUE ? "MAX" : this.max;
            throw new ValidationError(`Value doesn't match to diapason (${min},${max})`);
        }
    }
}
class LengthValidation {
    constructor(length, minLength, maxLength){
        this.length = length;
        this.minLength = minLength;
        this.maxLength = maxLength;
    }
    validate(value) {
        if (this.length !== undefined) {
            if (value.length !== this.length) {
                throw new ValidationError(`Value length must be exactly ${this.length}.`);
            }
            return;
        }
        if (this.minLength !== undefined) {
            if (value.length < this.minLength) {
                throw new ValidationError(`Value length must be more than ${this.minLength}.`);
            }
        }
        if (this.maxLength !== undefined) {
            if (value.length > this.maxLength) {
                throw new ValidationError(`Value length must be less than ${this.maxLength}.`);
            }
        }
    }
}
class EnumerationValidation {
    constructor(enumeration){
        this.enumeration = enumeration;
    }
    validate(value) {
        throwIfTypeIsWrong(value, exports.JsonPropTypes.String);
        if (!this.enumeration.includes(value)) {
            throw new ValidationError(`Value must be one of ${this.enumeration.map((v)=>`'${v}'`).join(", ")}`);
        }
    }
}
class JsonTransform {
    static checkValues(data, schemaItem) {
        const values = Array.isArray(data) ? data : [
            data
        ];
        for (const value of values){
            for (const validation of schemaItem.validations){
                if (validation instanceof LengthValidation && schemaItem.repeated) {
                    validation.validate(data);
                } else {
                    validation.validate(value);
                }
            }
        }
    }
    static checkTypes(value, schemaItem) {
        if (schemaItem.repeated && !Array.isArray(value)) {
            throw new TypeError("Value must be Array");
        }
        if (typeof schemaItem.type === "number") {
            const values = Array.isArray(value) ? value : [
                value
            ];
            for (const v of values){
                throwIfTypeIsWrong(v, schemaItem.type);
            }
        }
    }
    static getSchemaByName(schema, name = DEFAULT_SCHEMA) {
        return {
            ...schema.names[DEFAULT_SCHEMA],
            ...schema.names[name]
        };
    }
}
class JsonSerializer extends JsonTransform {
    static serialize(obj, options, replacer, space) {
        const json = this.toJSON(obj, options);
        return JSON.stringify(json, replacer, space);
    }
    static toJSON(obj, options = {}) {
        let res;
        let targetSchema = options.targetSchema;
        const schemaName = options.schemaName || DEFAULT_SCHEMA;
        if (isConvertible(obj)) {
            return obj.toJSON();
        }
        if (Array.isArray(obj)) {
            res = [];
            for (const item of obj){
                res.push(this.toJSON(item, options));
            }
        } else if (typeof obj === "object") {
            if (targetSchema && !schemaStorage.has(targetSchema)) {
                throw new JsonError("Cannot get schema for `targetSchema` param");
            }
            targetSchema = targetSchema || obj.constructor;
            if (schemaStorage.has(targetSchema)) {
                const schema = schemaStorage.get(targetSchema);
                res = {};
                const namedSchema = this.getSchemaByName(schema, schemaName);
                for(const key in namedSchema){
                    try {
                        const item = namedSchema[key];
                        const objItem = obj[key];
                        let value;
                        if (item.optional && objItem === undefined || item.defaultValue !== undefined && objItem === item.defaultValue) {
                            continue;
                        }
                        if (!item.optional && objItem === undefined) {
                            throw new SerializerError(targetSchema.name, `Property '${key}' is required.`);
                        }
                        if (typeof item.type === "number") {
                            if (item.converter) {
                                if (item.repeated) {
                                    value = objItem.map((el)=>item.converter.toJSON(el, obj));
                                } else {
                                    value = item.converter.toJSON(objItem, obj);
                                }
                            } else {
                                value = objItem;
                            }
                        } else {
                            if (item.repeated) {
                                value = objItem.map((el)=>this.toJSON(el, {
                                        schemaName
                                    }));
                            } else {
                                value = this.toJSON(objItem, {
                                    schemaName
                                });
                            }
                        }
                        this.checkTypes(value, item);
                        this.checkValues(value, item);
                        res[item.name || key] = value;
                    } catch (e) {
                        if (e instanceof SerializerError) {
                            throw e;
                        } else {
                            throw new SerializerError(schema.target.name, `Property '${key}' is wrong. ${e.message}`, e);
                        }
                    }
                }
            } else {
                res = {};
                for(const key in obj){
                    res[key] = this.toJSON(obj[key], {
                        schemaName
                    });
                }
            }
        } else {
            res = obj;
        }
        return res;
    }
}
class JsonParser extends JsonTransform {
    static parse(data, options) {
        const obj = JSON.parse(data);
        return this.fromJSON(obj, options);
    }
    static fromJSON(target, options) {
        const targetSchema = options.targetSchema;
        const schemaName = options.schemaName || DEFAULT_SCHEMA;
        const obj = new targetSchema();
        if (isConvertible(obj)) {
            return obj.fromJSON(target);
        }
        const schema = schemaStorage.get(targetSchema);
        const namedSchema = this.getSchemaByName(schema, schemaName);
        const keyErrors = {};
        if (options.strictProperty && !Array.isArray(target)) {
            JsonParser.checkStrictProperty(target, namedSchema, schema);
        }
        for(const key in namedSchema){
            try {
                const item = namedSchema[key];
                const name = item.name || key;
                const value = target[name];
                if (value === undefined && (item.optional || item.defaultValue !== undefined)) {
                    continue;
                }
                if (!item.optional && value === undefined) {
                    throw new ParserError(schema, `Property '${name}' is required.`);
                }
                this.checkTypes(value, item);
                this.checkValues(value, item);
                if (typeof item.type === "number") {
                    if (item.converter) {
                        if (item.repeated) {
                            obj[key] = value.map((el)=>item.converter.fromJSON(el, obj));
                        } else {
                            obj[key] = item.converter.fromJSON(value, obj);
                        }
                    } else {
                        obj[key] = value;
                    }
                } else {
                    const newOptions = {
                        ...options,
                        targetSchema: item.type,
                        schemaName
                    };
                    if (item.repeated) {
                        obj[key] = value.map((el)=>this.fromJSON(el, newOptions));
                    } else {
                        obj[key] = this.fromJSON(value, newOptions);
                    }
                }
            } catch (e) {
                if (!(e instanceof ParserError)) {
                    e = new ParserError(schema, `Property '${key}' is wrong. ${e.message}`, e);
                }
                if (options.strictAllKeys) {
                    keyErrors[key] = e;
                } else {
                    throw e;
                }
            }
        }
        const keys = Object.keys(keyErrors);
        if (keys.length) {
            throw new KeyError(schema, keys, keyErrors);
        }
        return obj;
    }
    static checkStrictProperty(target, namedSchema, schema) {
        const jsonProps = Object.keys(target);
        const schemaProps = Object.keys(namedSchema);
        const keys = [];
        for (const key of jsonProps){
            if (schemaProps.indexOf(key) === -1) {
                keys.push(key);
            }
        }
        if (keys.length) {
            throw new KeyError(schema, keys);
        }
    }
}
function getValidations(item) {
    const validations = [];
    if (item.pattern) {
        validations.push(new PatternValidation(item.pattern));
    }
    if (item.type === exports.JsonPropTypes.Number || item.type === exports.JsonPropTypes.Any) {
        if (item.minInclusive !== undefined || item.maxInclusive !== undefined) {
            validations.push(new InclusiveValidation(item.minInclusive, item.maxInclusive));
        }
        if (item.minExclusive !== undefined || item.maxExclusive !== undefined) {
            validations.push(new ExclusiveValidation(item.minExclusive, item.maxExclusive));
        }
        if (item.enumeration !== undefined) {
            validations.push(new EnumerationValidation(item.enumeration));
        }
    }
    if (item.type === exports.JsonPropTypes.String || item.repeated || item.type === exports.JsonPropTypes.Any) {
        if (item.length !== undefined || item.minLength !== undefined || item.maxLength !== undefined) {
            validations.push(new LengthValidation(item.length, item.minLength, item.maxLength));
        }
    }
    return validations;
}
const JsonProp = (options = {})=>(target, propertyKey)=>{
        const errorMessage = `Cannot set type for ${propertyKey} property of ${target.constructor.name} schema`;
        let schema;
        if (!schemaStorage.has(target.constructor)) {
            schema = schemaStorage.create(target.constructor);
            schemaStorage.set(target.constructor, schema);
        } else {
            schema = schemaStorage.get(target.constructor);
            if (schema.target !== target.constructor) {
                schema = schemaStorage.create(target.constructor);
                schemaStorage.set(target.constructor, schema);
            }
        }
        const defaultSchema = {
            type: exports.JsonPropTypes.Any,
            validations: []
        };
        const copyOptions = Object.assign(defaultSchema, options);
        copyOptions.validations = getValidations(copyOptions);
        if (typeof copyOptions.type !== "number") {
            if (!schemaStorage.has(copyOptions.type) && !isConvertible(copyOptions.type)) {
                throw new Error(`${errorMessage}. Assigning type doesn't have schema.`);
            }
        }
        let schemaNames;
        if (Array.isArray(options.schema)) {
            schemaNames = options.schema;
        } else {
            schemaNames = [
                options.schema || DEFAULT_SCHEMA
            ];
        }
        for (const schemaName of schemaNames){
            if (!schema.names[schemaName]) {
                schema.names[schemaName] = {};
            }
            const namedSchema = schema.names[schemaName];
            namedSchema[propertyKey] = copyOptions;
        }
    };
exports.JsonError = JsonError;
exports.JsonParser = JsonParser;
exports.JsonProp = JsonProp;
exports.JsonSerializer = JsonSerializer;
exports.KeyError = KeyError;
exports.ParserError = ParserError;
exports.SerializerError = SerializerError;
exports.TransformError = TransformError;
exports.ValidationError = ValidationError;


/***/ }),

/***/ 7356:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*!
 Copyright (c) Peculiar Ventures, LLC
*/ 
var core = __webpack_require__(6021);
var crypto = __webpack_require__(6113);
var process = __webpack_require__(6168);
var tslib = __webpack_require__(4479);
var jsonSchema = __webpack_require__(6066);
var pvtsutils = __webpack_require__(480);
var asn1Schema = __webpack_require__(3174);
function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function(k) {
            if (k !== "default") {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function() {
                        return e[k];
                    }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}
var core__namespace = /*#__PURE__*/ _interopNamespaceDefault(core);
var crypto__namespace = /*#__PURE__*/ _interopNamespaceDefault(crypto);
var process__namespace = /*#__PURE__*/ _interopNamespaceDefault(process);
const JsonBase64UrlConverter = {
    fromJSON: (value)=>Buffer.from(pvtsutils.Convert.FromBase64Url(value)),
    toJSON: (value)=>pvtsutils.Convert.ToBase64Url(value)
};
class CryptoKey extends core__namespace.CryptoKey {
    constructor(){
        super(...arguments);
        this.data = Buffer.alloc(0);
        this.algorithm = {
            name: ""
        };
        this.extractable = false;
        this.type = "secret";
        this.usages = [];
        this.kty = "oct";
        this.alg = "";
    }
}
tslib.__decorate([
    jsonSchema.JsonProp({
        name: "ext",
        type: jsonSchema.JsonPropTypes.Boolean,
        optional: true
    })
], CryptoKey.prototype, "extractable", void 0);
tslib.__decorate([
    jsonSchema.JsonProp({
        name: "key_ops",
        type: jsonSchema.JsonPropTypes.String,
        repeated: true,
        optional: true
    })
], CryptoKey.prototype, "usages", void 0);
tslib.__decorate([
    jsonSchema.JsonProp({
        type: jsonSchema.JsonPropTypes.String
    })
], CryptoKey.prototype, "kty", void 0);
tslib.__decorate([
    jsonSchema.JsonProp({
        type: jsonSchema.JsonPropTypes.String,
        optional: true
    })
], CryptoKey.prototype, "alg", void 0);
class SymmetricKey extends CryptoKey {
    constructor(){
        super(...arguments);
        this.kty = "oct";
        this.type = "secret";
    }
}
class AsymmetricKey extends CryptoKey {
}
class AesCryptoKey extends SymmetricKey {
    get alg() {
        switch(this.algorithm.name.toUpperCase()){
            case "AES-CBC":
                return `A${this.algorithm.length}CBC`;
            case "AES-CTR":
                return `A${this.algorithm.length}CTR`;
            case "AES-GCM":
                return `A${this.algorithm.length}GCM`;
            case "AES-KW":
                return `A${this.algorithm.length}KW`;
            case "AES-CMAC":
                return `A${this.algorithm.length}CMAC`;
            case "AES-ECB":
                return `A${this.algorithm.length}ECB`;
            default:
                throw new core__namespace.AlgorithmError("Unsupported algorithm name");
        }
    }
    set alg(value) {}
}
tslib.__decorate([
    jsonSchema.JsonProp({
        name: "k",
        converter: JsonBase64UrlConverter
    })
], AesCryptoKey.prototype, "data", void 0);
class AesCrypto {
    static async generateKey(algorithm, extractable, keyUsages) {
        const key = new AesCryptoKey();
        key.algorithm = algorithm;
        key.extractable = extractable;
        key.usages = keyUsages;
        key.data = crypto.randomBytes(algorithm.length >> 3);
        return key;
    }
    static async exportKey(format, key) {
        if (!(key instanceof AesCryptoKey)) {
            throw new Error("key: Is not AesCryptoKey");
        }
        switch(format.toLowerCase()){
            case "jwk":
                return jsonSchema.JsonSerializer.toJSON(key);
            case "raw":
                return new Uint8Array(key.data).buffer;
            default:
                throw new core__namespace.OperationError("format: Must be 'jwk' or 'raw'");
        }
    }
    static async importKey(format, keyData, algorithm, extractable, keyUsages) {
        let key;
        switch(format.toLowerCase()){
            case "jwk":
                key = jsonSchema.JsonParser.fromJSON(keyData, {
                    targetSchema: AesCryptoKey
                });
                break;
            case "raw":
                key = new AesCryptoKey();
                key.data = Buffer.from(keyData);
                break;
            default:
                throw new core__namespace.OperationError("format: Must be 'jwk' or 'raw'");
        }
        key.algorithm = algorithm;
        key.algorithm.length = key.data.length << 3;
        key.extractable = extractable;
        key.usages = keyUsages;
        switch(key.algorithm.length){
            case 128:
            case 192:
            case 256:
                break;
            default:
                throw new core__namespace.OperationError("keyData: Is wrong key length");
        }
        return key;
    }
    static async encrypt(algorithm, key, data) {
        switch(algorithm.name.toUpperCase()){
            case "AES-CBC":
                return this.encryptAesCBC(algorithm, key, Buffer.from(data));
            case "AES-CTR":
                return this.encryptAesCTR(algorithm, key, Buffer.from(data));
            case "AES-GCM":
                return this.encryptAesGCM(algorithm, key, Buffer.from(data));
            case "AES-KW":
                return this.encryptAesKW(algorithm, key, Buffer.from(data));
            case "AES-ECB":
                return this.encryptAesECB(algorithm, key, Buffer.from(data));
            default:
                throw new core__namespace.OperationError("algorithm: Is not recognized");
        }
    }
    static async decrypt(algorithm, key, data) {
        if (!(key instanceof AesCryptoKey)) {
            throw new Error("key: Is not AesCryptoKey");
        }
        switch(algorithm.name.toUpperCase()){
            case "AES-CBC":
                return this.decryptAesCBC(algorithm, key, Buffer.from(data));
            case "AES-CTR":
                return this.decryptAesCTR(algorithm, key, Buffer.from(data));
            case "AES-GCM":
                return this.decryptAesGCM(algorithm, key, Buffer.from(data));
            case "AES-KW":
                return this.decryptAesKW(algorithm, key, Buffer.from(data));
            case "AES-ECB":
                return this.decryptAesECB(algorithm, key, Buffer.from(data));
            default:
                throw new core__namespace.OperationError("algorithm: Is not recognized");
        }
    }
    static async encryptAesCBC(algorithm, key, data) {
        const cipher = crypto.createCipheriv(`aes-${key.algorithm.length}-cbc`, key.data, new Uint8Array(algorithm.iv));
        let enc = cipher.update(data);
        enc = Buffer.concat([
            enc,
            cipher.final()
        ]);
        const res = new Uint8Array(enc).buffer;
        return res;
    }
    static async decryptAesCBC(algorithm, key, data) {
        const decipher = crypto.createDecipheriv(`aes-${key.algorithm.length}-cbc`, key.data, new Uint8Array(algorithm.iv));
        let dec = decipher.update(data);
        dec = Buffer.concat([
            dec,
            decipher.final()
        ]);
        return new Uint8Array(dec).buffer;
    }
    static async encryptAesCTR(algorithm, key, data) {
        const cipher = crypto.createCipheriv(`aes-${key.algorithm.length}-ctr`, key.data, Buffer.from(algorithm.counter));
        let enc = cipher.update(data);
        enc = Buffer.concat([
            enc,
            cipher.final()
        ]);
        const res = new Uint8Array(enc).buffer;
        return res;
    }
    static async decryptAesCTR(algorithm, key, data) {
        const decipher = crypto.createDecipheriv(`aes-${key.algorithm.length}-ctr`, key.data, new Uint8Array(algorithm.counter));
        let dec = decipher.update(data);
        dec = Buffer.concat([
            dec,
            decipher.final()
        ]);
        return new Uint8Array(dec).buffer;
    }
    static async encryptAesGCM(algorithm, key, data) {
        const cipher = crypto.createCipheriv(`aes-${key.algorithm.length}-gcm`, key.data, Buffer.from(algorithm.iv), {
            authTagLength: (algorithm.tagLength || 128) >> 3
        });
        if (algorithm.additionalData) {
            cipher.setAAD(Buffer.from(algorithm.additionalData));
        }
        let enc = cipher.update(data);
        enc = Buffer.concat([
            enc,
            cipher.final(),
            cipher.getAuthTag()
        ]);
        const res = new Uint8Array(enc).buffer;
        return res;
    }
    static async decryptAesGCM(algorithm, key, data) {
        const decipher = crypto.createDecipheriv(`aes-${key.algorithm.length}-gcm`, key.data, new Uint8Array(algorithm.iv));
        const tagLength = (algorithm.tagLength || 128) >> 3;
        const enc = data.slice(0, data.length - tagLength);
        const tag = data.slice(data.length - tagLength);
        if (algorithm.additionalData) {
            decipher.setAAD(Buffer.from(algorithm.additionalData));
        }
        decipher.setAuthTag(tag);
        let dec = decipher.update(enc);
        dec = Buffer.concat([
            dec,
            decipher.final()
        ]);
        return new Uint8Array(dec).buffer;
    }
    static async encryptAesKW(algorithm, key, data) {
        const cipher = crypto.createCipheriv(`id-aes${key.algorithm.length}-wrap`, key.data, this.AES_KW_IV);
        let enc = cipher.update(data);
        enc = Buffer.concat([
            enc,
            cipher.final()
        ]);
        return new Uint8Array(enc).buffer;
    }
    static async decryptAesKW(algorithm, key, data) {
        const decipher = crypto.createDecipheriv(`id-aes${key.algorithm.length}-wrap`, key.data, this.AES_KW_IV);
        let dec = decipher.update(data);
        dec = Buffer.concat([
            dec,
            decipher.final()
        ]);
        return new Uint8Array(dec).buffer;
    }
    static async encryptAesECB(algorithm, key, data) {
        const cipher = crypto.createCipheriv(`aes-${key.algorithm.length}-ecb`, key.data, new Uint8Array(0));
        let enc = cipher.update(data);
        enc = Buffer.concat([
            enc,
            cipher.final()
        ]);
        const res = new Uint8Array(enc).buffer;
        return res;
    }
    static async decryptAesECB(algorithm, key, data) {
        const decipher = crypto.createDecipheriv(`aes-${key.algorithm.length}-ecb`, key.data, new Uint8Array(0));
        let dec = decipher.update(data);
        dec = Buffer.concat([
            dec,
            decipher.final()
        ]);
        return new Uint8Array(dec).buffer;
    }
}
AesCrypto.AES_KW_IV = Buffer.from("A6A6A6A6A6A6A6A6", "hex");
const keyStorage = new WeakMap();
function getCryptoKey(key) {
    const res = keyStorage.get(key);
    if (!res) {
        throw new core__namespace.OperationError("Cannot get CryptoKey from secure storage");
    }
    return res;
}
function setCryptoKey(value) {
    const key = core__namespace.CryptoKey.create(value.algorithm, value.type, value.extractable, value.usages);
    Object.freeze(key);
    keyStorage.set(key, value);
    return key;
}
class AesCbcProvider extends core__namespace.AesCbcProvider {
    async onGenerateKey(algorithm, extractable, keyUsages) {
        const key = await AesCrypto.generateKey({
            name: this.name,
            length: algorithm.length
        }, extractable, keyUsages);
        return setCryptoKey(key);
    }
    async onEncrypt(algorithm, key, data) {
        return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));
    }
    async onDecrypt(algorithm, key, data) {
        return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));
    }
    async onExportKey(format, key) {
        return AesCrypto.exportKey(format, getCryptoKey(key));
    }
    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const key = await AesCrypto.importKey(format, keyData, {
            name: algorithm.name
        }, extractable, keyUsages);
        return setCryptoKey(key);
    }
    checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {
            throw new TypeError("key: Is not a AesCryptoKey");
        }
    }
}
const zero = Buffer.from([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
]);
const rb = Buffer.from([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    135
]);
const blockSize = 16;
function bitShiftLeft(buffer) {
    const shifted = Buffer.alloc(buffer.length);
    const last = buffer.length - 1;
    for(let index = 0; index < last; index++){
        shifted[index] = buffer[index] << 1;
        if (buffer[index + 1] & 0x80) {
            shifted[index] += 0x01;
        }
    }
    shifted[last] = buffer[last] << 1;
    return shifted;
}
function xor(a, b) {
    const length = Math.min(a.length, b.length);
    const output = Buffer.alloc(length);
    for(let index = 0; index < length; index++){
        output[index] = a[index] ^ b[index];
    }
    return output;
}
function aes(key, message) {
    const cipher = crypto__namespace.createCipheriv(`aes${key.length << 3}`, key, zero);
    const result = cipher.update(message);
    cipher.final();
    return result;
}
function getMessageBlock(message, blockIndex) {
    const block = Buffer.alloc(blockSize);
    const start = blockIndex * blockSize;
    const end = start + blockSize;
    message.copy(block, 0, start, end);
    return block;
}
function getPaddedMessageBlock(message, blockIndex) {
    const block = Buffer.alloc(blockSize);
    const start = blockIndex * blockSize;
    const end = message.length;
    block.fill(0);
    message.copy(block, 0, start, end);
    block[end - start] = 0x80;
    return block;
}
function generateSubkeys(key) {
    const l = aes(key, zero);
    let subkey1 = bitShiftLeft(l);
    if (l[0] & 0x80) {
        subkey1 = xor(subkey1, rb);
    }
    let subkey2 = bitShiftLeft(subkey1);
    if (subkey1[0] & 0x80) {
        subkey2 = xor(subkey2, rb);
    }
    return {
        subkey1,
        subkey2
    };
}
function aesCmac(key, message) {
    const subkeys = generateSubkeys(key);
    let blockCount = Math.ceil(message.length / blockSize);
    let lastBlockCompleteFlag;
    let lastBlock;
    if (blockCount === 0) {
        blockCount = 1;
        lastBlockCompleteFlag = false;
    } else {
        lastBlockCompleteFlag = message.length % blockSize === 0;
    }
    const lastBlockIndex = blockCount - 1;
    if (lastBlockCompleteFlag) {
        lastBlock = xor(getMessageBlock(message, lastBlockIndex), subkeys.subkey1);
    } else {
        lastBlock = xor(getPaddedMessageBlock(message, lastBlockIndex), subkeys.subkey2);
    }
    let x = zero;
    let y;
    for(let index = 0; index < lastBlockIndex; index++){
        y = xor(x, getMessageBlock(message, index));
        x = aes(key, y);
    }
    y = xor(lastBlock, x);
    return aes(key, y);
}
class AesCmacProvider extends core__namespace.AesCmacProvider {
    async onGenerateKey(algorithm, extractable, keyUsages) {
        const key = await AesCrypto.generateKey({
            name: this.name,
            length: algorithm.length
        }, extractable, keyUsages);
        return setCryptoKey(key);
    }
    async onSign(algorithm, key, data) {
        const result = aesCmac(getCryptoKey(key).data, Buffer.from(data));
        return new Uint8Array(result).buffer;
    }
    async onVerify(algorithm, key, signature, data) {
        const signature2 = await this.sign(algorithm, key, data);
        return Buffer.from(signature).compare(Buffer.from(signature2)) === 0;
    }
    async onExportKey(format, key) {
        return AesCrypto.exportKey(format, getCryptoKey(key));
    }
    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const res = await AesCrypto.importKey(format, keyData, {
            name: algorithm.name
        }, extractable, keyUsages);
        return setCryptoKey(res);
    }
    checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {
            throw new TypeError("key: Is not a AesCryptoKey");
        }
    }
}
class AesCtrProvider extends core__namespace.AesCtrProvider {
    async onGenerateKey(algorithm, extractable, keyUsages) {
        const key = await AesCrypto.generateKey({
            name: this.name,
            length: algorithm.length
        }, extractable, keyUsages);
        return setCryptoKey(key);
    }
    async onEncrypt(algorithm, key, data) {
        return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));
    }
    async onDecrypt(algorithm, key, data) {
        return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));
    }
    async onExportKey(format, key) {
        return AesCrypto.exportKey(format, getCryptoKey(key));
    }
    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const res = await AesCrypto.importKey(format, keyData, {
            name: algorithm.name
        }, extractable, keyUsages);
        return setCryptoKey(res);
    }
    checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {
            throw new TypeError("key: Is not a AesCryptoKey");
        }
    }
}
class AesGcmProvider extends core__namespace.AesGcmProvider {
    async onGenerateKey(algorithm, extractable, keyUsages) {
        const key = await AesCrypto.generateKey({
            name: this.name,
            length: algorithm.length
        }, extractable, keyUsages);
        return setCryptoKey(key);
    }
    async onEncrypt(algorithm, key, data) {
        return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));
    }
    async onDecrypt(algorithm, key, data) {
        return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));
    }
    async onExportKey(format, key) {
        return AesCrypto.exportKey(format, getCryptoKey(key));
    }
    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const res = await AesCrypto.importKey(format, keyData, {
            name: algorithm.name
        }, extractable, keyUsages);
        return setCryptoKey(res);
    }
    checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {
            throw new TypeError("key: Is not a AesCryptoKey");
        }
    }
}
class AesKwProvider extends core__namespace.AesKwProvider {
    async onGenerateKey(algorithm, extractable, keyUsages) {
        const res = await AesCrypto.generateKey({
            name: this.name,
            length: algorithm.length
        }, extractable, keyUsages);
        return setCryptoKey(res);
    }
    async onExportKey(format, key) {
        return AesCrypto.exportKey(format, getCryptoKey(key));
    }
    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const res = await AesCrypto.importKey(format, keyData, {
            name: algorithm.name
        }, extractable, keyUsages);
        return setCryptoKey(res);
    }
    async onEncrypt(algorithm, key, data) {
        return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));
    }
    async onDecrypt(algorithm, key, data) {
        return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));
    }
    checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {
            throw new TypeError("key: Is not a AesCryptoKey");
        }
    }
}
class AesEcbProvider extends core__namespace.AesEcbProvider {
    async onGenerateKey(algorithm, extractable, keyUsages) {
        const key = await AesCrypto.generateKey({
            name: this.name,
            length: algorithm.length
        }, extractable, keyUsages);
        return setCryptoKey(key);
    }
    async onEncrypt(algorithm, key, data) {
        return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));
    }
    async onDecrypt(algorithm, key, data) {
        return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));
    }
    async onExportKey(format, key) {
        return AesCrypto.exportKey(format, getCryptoKey(key));
    }
    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const res = await AesCrypto.importKey(format, keyData, {
            name: algorithm.name
        }, extractable, keyUsages);
        return setCryptoKey(res);
    }
    checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {
            throw new TypeError("key: Is not a AesCryptoKey");
        }
    }
}
class DesCryptoKey extends SymmetricKey {
    get alg() {
        switch(this.algorithm.name.toUpperCase()){
            case "DES-CBC":
                return `DES-CBC`;
            case "DES-EDE3-CBC":
                return `3DES-CBC`;
            default:
                throw new core__namespace.AlgorithmError("Unsupported algorithm name");
        }
    }
    set alg(value) {}
}
tslib.__decorate([
    jsonSchema.JsonProp({
        name: "k",
        converter: JsonBase64UrlConverter
    })
], DesCryptoKey.prototype, "data", void 0);
class DesCrypto {
    static async generateKey(algorithm, extractable, keyUsages) {
        const key = new DesCryptoKey();
        key.algorithm = algorithm;
        key.extractable = extractable;
        key.usages = keyUsages;
        key.data = crypto.randomBytes(algorithm.length >> 3);
        return key;
    }
    static async exportKey(format, key) {
        switch(format.toLowerCase()){
            case "jwk":
                return jsonSchema.JsonSerializer.toJSON(key);
            case "raw":
                return new Uint8Array(key.data).buffer;
            default:
                throw new core__namespace.OperationError("format: Must be 'jwk' or 'raw'");
        }
    }
    static async importKey(format, keyData, algorithm, extractable, keyUsages) {
        let key;
        switch(format.toLowerCase()){
            case "jwk":
                key = jsonSchema.JsonParser.fromJSON(keyData, {
                    targetSchema: DesCryptoKey
                });
                break;
            case "raw":
                key = new DesCryptoKey();
                key.data = Buffer.from(keyData);
                break;
            default:
                throw new core__namespace.OperationError("format: Must be 'jwk' or 'raw'");
        }
        key.algorithm = algorithm;
        key.extractable = extractable;
        key.usages = keyUsages;
        return key;
    }
    static async encrypt(algorithm, key, data) {
        switch(algorithm.name.toUpperCase()){
            case "DES-CBC":
                return this.encryptDesCBC(algorithm, key, Buffer.from(data));
            case "DES-EDE3-CBC":
                return this.encryptDesEDE3CBC(algorithm, key, Buffer.from(data));
            default:
                throw new core__namespace.OperationError("algorithm: Is not recognized");
        }
    }
    static async decrypt(algorithm, key, data) {
        if (!(key instanceof DesCryptoKey)) {
            throw new Error("key: Is not DesCryptoKey");
        }
        switch(algorithm.name.toUpperCase()){
            case "DES-CBC":
                return this.decryptDesCBC(algorithm, key, Buffer.from(data));
            case "DES-EDE3-CBC":
                return this.decryptDesEDE3CBC(algorithm, key, Buffer.from(data));
            default:
                throw new core__namespace.OperationError("algorithm: Is not recognized");
        }
    }
    static async encryptDesCBC(algorithm, key, data) {
        const cipher = crypto.createCipheriv(`des-cbc`, key.data, new Uint8Array(algorithm.iv));
        let enc = cipher.update(data);
        enc = Buffer.concat([
            enc,
            cipher.final()
        ]);
        const res = new Uint8Array(enc).buffer;
        return res;
    }
    static async decryptDesCBC(algorithm, key, data) {
        const decipher = crypto.createDecipheriv(`des-cbc`, key.data, new Uint8Array(algorithm.iv));
        let dec = decipher.update(data);
        dec = Buffer.concat([
            dec,
            decipher.final()
        ]);
        return new Uint8Array(dec).buffer;
    }
    static async encryptDesEDE3CBC(algorithm, key, data) {
        const cipher = crypto.createCipheriv(`des-ede3-cbc`, key.data, Buffer.from(algorithm.iv));
        let enc = cipher.update(data);
        enc = Buffer.concat([
            enc,
            cipher.final()
        ]);
        const res = new Uint8Array(enc).buffer;
        return res;
    }
    static async decryptDesEDE3CBC(algorithm, key, data) {
        const decipher = crypto.createDecipheriv(`des-ede3-cbc`, key.data, new Uint8Array(algorithm.iv));
        let dec = decipher.update(data);
        dec = Buffer.concat([
            dec,
            decipher.final()
        ]);
        return new Uint8Array(dec).buffer;
    }
}
class DesCbcProvider extends core__namespace.DesProvider {
    constructor(){
        super(...arguments);
        this.keySizeBits = 64;
        this.ivSize = 8;
        this.name = "DES-CBC";
    }
    async onGenerateKey(algorithm, extractable, keyUsages) {
        const key = await DesCrypto.generateKey({
            name: this.name,
            length: this.keySizeBits
        }, extractable, keyUsages);
        return setCryptoKey(key);
    }
    async onEncrypt(algorithm, key, data) {
        return DesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));
    }
    async onDecrypt(algorithm, key, data) {
        return DesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));
    }
    async onExportKey(format, key) {
        return DesCrypto.exportKey(format, getCryptoKey(key));
    }
    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const key = await DesCrypto.importKey(format, keyData, {
            name: this.name,
            length: this.keySizeBits
        }, extractable, keyUsages);
        if (key.data.length !== this.keySizeBits >> 3) {
            throw new core__namespace.OperationError("keyData: Wrong key size");
        }
        return setCryptoKey(key);
    }
    checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        if (!(getCryptoKey(key) instanceof DesCryptoKey)) {
            throw new TypeError("key: Is not a DesCryptoKey");
        }
    }
}
class DesEde3CbcProvider extends core__namespace.DesProvider {
    constructor(){
        super(...arguments);
        this.keySizeBits = 192;
        this.ivSize = 8;
        this.name = "DES-EDE3-CBC";
    }
    async onGenerateKey(algorithm, extractable, keyUsages) {
        const key = await DesCrypto.generateKey({
            name: this.name,
            length: this.keySizeBits
        }, extractable, keyUsages);
        return setCryptoKey(key);
    }
    async onEncrypt(algorithm, key, data) {
        return DesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));
    }
    async onDecrypt(algorithm, key, data) {
        return DesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));
    }
    async onExportKey(format, key) {
        return DesCrypto.exportKey(format, getCryptoKey(key));
    }
    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const key = await DesCrypto.importKey(format, keyData, {
            name: this.name,
            length: this.keySizeBits
        }, extractable, keyUsages);
        if (key.data.length !== this.keySizeBits >> 3) {
            throw new core__namespace.OperationError("keyData: Wrong key size");
        }
        return setCryptoKey(key);
    }
    checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        if (!(getCryptoKey(key) instanceof DesCryptoKey)) {
            throw new TypeError("key: Is not a DesCryptoKey");
        }
    }
}
function getJwkAlgorithm(algorithm) {
    switch(algorithm.name.toUpperCase()){
        case "RSA-OAEP":
            {
                const mdSize = /(\d+)$/.exec(algorithm.hash.name)[1];
                return `RSA-OAEP${mdSize !== "1" ? `-${mdSize}` : ""}`;
            }
        case "RSASSA-PKCS1-V1_5":
            return `RS${/(\d+)$/.exec(algorithm.hash.name)[1]}`;
        case "RSA-PSS":
            return `PS${/(\d+)$/.exec(algorithm.hash.name)[1]}`;
        case "RSA-PKCS1":
            return `RS1`;
        default:
            throw new core__namespace.OperationError("algorithm: Is not recognized");
    }
}
class RsaPrivateKey extends AsymmetricKey {
    constructor(){
        super(...arguments);
        this.type = "private";
    }
    getKey() {
        const keyInfo = asn1Schema.AsnParser.parse(this.data, core__namespace.asn1.PrivateKeyInfo);
        return asn1Schema.AsnParser.parse(keyInfo.privateKey, core__namespace.asn1.RsaPrivateKey);
    }
    toJSON() {
        const key = this.getKey();
        const json = {
            kty: "RSA",
            alg: getJwkAlgorithm(this.algorithm),
            key_ops: this.usages,
            ext: this.extractable
        };
        return Object.assign(json, jsonSchema.JsonSerializer.toJSON(key));
    }
    fromJSON(json) {
        const key = jsonSchema.JsonParser.fromJSON(json, {
            targetSchema: core__namespace.asn1.RsaPrivateKey
        });
        const keyInfo = new core__namespace.asn1.PrivateKeyInfo();
        keyInfo.privateKeyAlgorithm.algorithm = "1.2.840.113549.1.1.1";
        keyInfo.privateKeyAlgorithm.parameters = null;
        keyInfo.privateKey = asn1Schema.AsnSerializer.serialize(key);
        this.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));
    }
}
class RsaPublicKey extends AsymmetricKey {
    constructor(){
        super(...arguments);
        this.type = "public";
    }
    getKey() {
        const keyInfo = asn1Schema.AsnParser.parse(this.data, core__namespace.asn1.PublicKeyInfo);
        return asn1Schema.AsnParser.parse(keyInfo.publicKey, core__namespace.asn1.RsaPublicKey);
    }
    toJSON() {
        const key = this.getKey();
        const json = {
            kty: "RSA",
            alg: getJwkAlgorithm(this.algorithm),
            key_ops: this.usages,
            ext: this.extractable
        };
        return Object.assign(json, jsonSchema.JsonSerializer.toJSON(key));
    }
    fromJSON(json) {
        const key = jsonSchema.JsonParser.fromJSON(json, {
            targetSchema: core__namespace.asn1.RsaPublicKey
        });
        const keyInfo = new core__namespace.asn1.PublicKeyInfo();
        keyInfo.publicKeyAlgorithm.algorithm = "1.2.840.113549.1.1.1";
        keyInfo.publicKeyAlgorithm.parameters = null;
        keyInfo.publicKey = asn1Schema.AsnSerializer.serialize(key);
        this.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));
    }
}
class RsaCrypto {
    static async generateKey(algorithm, extractable, keyUsages) {
        const privateKey = new RsaPrivateKey();
        privateKey.algorithm = algorithm;
        privateKey.extractable = extractable;
        privateKey.usages = keyUsages.filter((usage)=>this.privateKeyUsages.indexOf(usage) !== -1);
        const publicKey = new RsaPublicKey();
        publicKey.algorithm = algorithm;
        publicKey.extractable = true;
        publicKey.usages = keyUsages.filter((usage)=>this.publicKeyUsages.indexOf(usage) !== -1);
        const publicExponent = Buffer.concat([
            Buffer.alloc(4 - algorithm.publicExponent.byteLength, 0),
            Buffer.from(algorithm.publicExponent)
        ]).readInt32BE(0);
        const keys = crypto.generateKeyPairSync("rsa", {
            modulusLength: algorithm.modulusLength,
            publicExponent,
            publicKeyEncoding: {
                format: "der",
                type: "spki"
            },
            privateKeyEncoding: {
                format: "der",
                type: "pkcs8"
            }
        });
        privateKey.data = keys.privateKey;
        publicKey.data = keys.publicKey;
        const res = {
            privateKey,
            publicKey
        };
        return res;
    }
    static async exportKey(format, key) {
        switch(format.toLowerCase()){
            case "jwk":
                return jsonSchema.JsonSerializer.toJSON(key);
            case "pkcs8":
            case "spki":
                return new Uint8Array(key.data).buffer;
            default:
                throw new core__namespace.OperationError("format: Must be 'jwk', 'pkcs8' or 'spki'");
        }
    }
    static async importKey(format, keyData, algorithm, extractable, keyUsages) {
        switch(format.toLowerCase()){
            case "jwk":
                {
                    const jwk = keyData;
                    if (jwk.d) {
                        const asnKey = jsonSchema.JsonParser.fromJSON(keyData, {
                            targetSchema: core__namespace.asn1.RsaPrivateKey
                        });
                        return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);
                    } else {
                        const asnKey = jsonSchema.JsonParser.fromJSON(keyData, {
                            targetSchema: core__namespace.asn1.RsaPublicKey
                        });
                        return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);
                    }
                }
            case "spki":
                {
                    const keyInfo = asn1Schema.AsnParser.parse(new Uint8Array(keyData), core__namespace.asn1.PublicKeyInfo);
                    const asnKey = asn1Schema.AsnParser.parse(keyInfo.publicKey, core__namespace.asn1.RsaPublicKey);
                    return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);
                }
            case "pkcs8":
                {
                    const keyInfo = asn1Schema.AsnParser.parse(new Uint8Array(keyData), core__namespace.asn1.PrivateKeyInfo);
                    const asnKey = asn1Schema.AsnParser.parse(keyInfo.privateKey, core__namespace.asn1.RsaPrivateKey);
                    return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);
                }
            default:
                throw new core__namespace.OperationError("format: Must be 'jwk', 'pkcs8' or 'spki'");
        }
    }
    static async sign(algorithm, key, data) {
        switch(algorithm.name.toUpperCase()){
            case "RSA-PSS":
            case "RSASSA-PKCS1-V1_5":
                return this.signRsa(algorithm, key, data);
            default:
                throw new core__namespace.OperationError("algorithm: Is not recognized");
        }
    }
    static async verify(algorithm, key, signature, data) {
        switch(algorithm.name.toUpperCase()){
            case "RSA-PSS":
            case "RSASSA-PKCS1-V1_5":
                return this.verifySSA(algorithm, key, data, signature);
            default:
                throw new core__namespace.OperationError("algorithm: Is not recognized");
        }
    }
    static async encrypt(algorithm, key, data) {
        switch(algorithm.name.toUpperCase()){
            case "RSA-OAEP":
                return this.encryptOAEP(algorithm, key, data);
            default:
                throw new core__namespace.OperationError("algorithm: Is not recognized");
        }
    }
    static async decrypt(algorithm, key, data) {
        switch(algorithm.name.toUpperCase()){
            case "RSA-OAEP":
                return this.decryptOAEP(algorithm, key, data);
            default:
                throw new core__namespace.OperationError("algorithm: Is not recognized");
        }
    }
    static importPrivateKey(asnKey, algorithm, extractable, keyUsages) {
        const keyInfo = new core__namespace.asn1.PrivateKeyInfo();
        keyInfo.privateKeyAlgorithm.algorithm = "1.2.840.113549.1.1.1";
        keyInfo.privateKeyAlgorithm.parameters = null;
        keyInfo.privateKey = asn1Schema.AsnSerializer.serialize(asnKey);
        const key = new RsaPrivateKey();
        key.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));
        key.algorithm = Object.assign({}, algorithm);
        key.algorithm.publicExponent = new Uint8Array(asnKey.publicExponent);
        key.algorithm.modulusLength = asnKey.modulus.byteLength << 3;
        key.extractable = extractable;
        key.usages = keyUsages;
        return key;
    }
    static importPublicKey(asnKey, algorithm, extractable, keyUsages) {
        const keyInfo = new core__namespace.asn1.PublicKeyInfo();
        keyInfo.publicKeyAlgorithm.algorithm = "1.2.840.113549.1.1.1";
        keyInfo.publicKeyAlgorithm.parameters = null;
        keyInfo.publicKey = asn1Schema.AsnSerializer.serialize(asnKey);
        const key = new RsaPublicKey();
        key.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));
        key.algorithm = Object.assign({}, algorithm);
        key.algorithm.publicExponent = new Uint8Array(asnKey.publicExponent);
        key.algorithm.modulusLength = asnKey.modulus.byteLength << 3;
        key.extractable = extractable;
        key.usages = keyUsages;
        return key;
    }
    static getCryptoAlgorithm(alg) {
        switch(alg.hash.name.toUpperCase()){
            case "SHA-1":
                return "RSA-SHA1";
            case "SHA-256":
                return "RSA-SHA256";
            case "SHA-384":
                return "RSA-SHA384";
            case "SHA-512":
                return "RSA-SHA512";
            case "SHA3-256":
                return "RSA-SHA3-256";
            case "SHA3-384":
                return "RSA-SHA3-384";
            case "SHA3-512":
                return "RSA-SHA3-512";
            default:
                throw new core__namespace.OperationError("algorithm.hash: Is not recognized");
        }
    }
    static signRsa(algorithm, key, data) {
        const cryptoAlg = this.getCryptoAlgorithm(key.algorithm);
        const signer = crypto.createSign(cryptoAlg);
        signer.update(Buffer.from(data));
        if (!key.pem) {
            key.pem = `-----BEGIN PRIVATE KEY-----\n${key.data.toString("base64")}\n-----END PRIVATE KEY-----`;
        }
        const options = {
            key: key.pem
        };
        if (algorithm.name.toUpperCase() === "RSA-PSS") {
            options.padding = crypto.constants.RSA_PKCS1_PSS_PADDING;
            options.saltLength = algorithm.saltLength;
        }
        const signature = signer.sign(options);
        return new Uint8Array(signature).buffer;
    }
    static verifySSA(algorithm, key, data, signature) {
        const cryptoAlg = this.getCryptoAlgorithm(key.algorithm);
        const signer = crypto.createVerify(cryptoAlg);
        signer.update(Buffer.from(data));
        if (!key.pem) {
            key.pem = `-----BEGIN PUBLIC KEY-----\n${key.data.toString("base64")}\n-----END PUBLIC KEY-----`;
        }
        const options = {
            key: key.pem
        };
        if (algorithm.name.toUpperCase() === "RSA-PSS") {
            options.padding = crypto.constants.RSA_PKCS1_PSS_PADDING;
            options.saltLength = algorithm.saltLength;
        }
        const ok = signer.verify(options, signature);
        return ok;
    }
    static encryptOAEP(algorithm, key, data) {
        const options = {
            key: `-----BEGIN PUBLIC KEY-----\n${key.data.toString("base64")}\n-----END PUBLIC KEY-----`,
            padding: crypto.constants.RSA_PKCS1_OAEP_PADDING
        };
        if (algorithm.label) ;
        return new Uint8Array(crypto.publicEncrypt(options, data)).buffer;
    }
    static decryptOAEP(algorithm, key, data) {
        const options = {
            key: `-----BEGIN PRIVATE KEY-----\n${key.data.toString("base64")}\n-----END PRIVATE KEY-----`,
            padding: crypto.constants.RSA_PKCS1_OAEP_PADDING
        };
        if (algorithm.label) ;
        return new Uint8Array(crypto.privateDecrypt(options, data)).buffer;
    }
}
RsaCrypto.publicKeyUsages = [
    "verify",
    "encrypt",
    "wrapKey"
];
RsaCrypto.privateKeyUsages = [
    "sign",
    "decrypt",
    "unwrapKey"
];
class RsaSsaProvider extends core__namespace.RsaSsaProvider {
    constructor(){
        super(...arguments);
        this.hashAlgorithms = [
            "SHA-1",
            "SHA-256",
            "SHA-384",
            "SHA-512",
            "shake128",
            "shake256",
            "SHA3-256",
            "SHA3-384",
            "SHA3-512"
        ];
    }
    async onGenerateKey(algorithm, extractable, keyUsages) {
        const keys = await RsaCrypto.generateKey({
            ...algorithm,
            name: this.name
        }, extractable, keyUsages);
        return {
            privateKey: setCryptoKey(keys.privateKey),
            publicKey: setCryptoKey(keys.publicKey)
        };
    }
    async onSign(algorithm, key, data) {
        return RsaCrypto.sign(algorithm, getCryptoKey(key), new Uint8Array(data));
    }
    async onVerify(algorithm, key, signature, data) {
        return RsaCrypto.verify(algorithm, getCryptoKey(key), new Uint8Array(signature), new Uint8Array(data));
    }
    async onExportKey(format, key) {
        return RsaCrypto.exportKey(format, getCryptoKey(key));
    }
    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const key = await RsaCrypto.importKey(format, keyData, {
            ...algorithm,
            name: this.name
        }, extractable, keyUsages);
        return setCryptoKey(key);
    }
    checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        const internalKey = getCryptoKey(key);
        if (!(internalKey instanceof RsaPrivateKey || internalKey instanceof RsaPublicKey)) {
            throw new TypeError("key: Is not RSA CryptoKey");
        }
    }
}
class RsaPssProvider extends core__namespace.RsaPssProvider {
    constructor(){
        super(...arguments);
        this.hashAlgorithms = [
            "SHA-1",
            "SHA-256",
            "SHA-384",
            "SHA-512",
            "shake128",
            "shake256",
            "SHA3-256",
            "SHA3-384",
            "SHA3-512"
        ];
    }
    async onGenerateKey(algorithm, extractable, keyUsages) {
        const keys = await RsaCrypto.generateKey({
            ...algorithm,
            name: this.name
        }, extractable, keyUsages);
        return {
            privateKey: setCryptoKey(keys.privateKey),
            publicKey: setCryptoKey(keys.publicKey)
        };
    }
    async onSign(algorithm, key, data) {
        return RsaCrypto.sign(algorithm, getCryptoKey(key), new Uint8Array(data));
    }
    async onVerify(algorithm, key, signature, data) {
        return RsaCrypto.verify(algorithm, getCryptoKey(key), new Uint8Array(signature), new Uint8Array(data));
    }
    async onExportKey(format, key) {
        return RsaCrypto.exportKey(format, getCryptoKey(key));
    }
    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const key = await RsaCrypto.importKey(format, keyData, {
            ...algorithm,
            name: this.name
        }, extractable, keyUsages);
        return setCryptoKey(key);
    }
    checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        const internalKey = getCryptoKey(key);
        if (!(internalKey instanceof RsaPrivateKey || internalKey instanceof RsaPublicKey)) {
            throw new TypeError("key: Is not RSA CryptoKey");
        }
    }
}
class ShaCrypto {
    static size(algorithm) {
        switch(algorithm.name.toUpperCase()){
            case "SHA-1":
                return 160;
            case "SHA-256":
            case "SHA3-256":
                return 256;
            case "SHA-384":
            case "SHA3-384":
                return 384;
            case "SHA-512":
            case "SHA3-512":
                return 512;
            default:
                throw new Error("Unrecognized name");
        }
    }
    static getAlgorithmName(algorithm) {
        switch(algorithm.name.toUpperCase()){
            case "SHA-1":
                return "sha1";
            case "SHA-256":
                return "sha256";
            case "SHA-384":
                return "sha384";
            case "SHA-512":
                return "sha512";
            case "SHA3-256":
                return "sha3-256";
            case "SHA3-384":
                return "sha3-384";
            case "SHA3-512":
                return "sha3-512";
            default:
                throw new Error("Unrecognized name");
        }
    }
    static digest(algorithm, data) {
        const hashAlg = this.getAlgorithmName(algorithm);
        const hash = crypto.createHash(hashAlg).update(Buffer.from(data)).digest();
        return new Uint8Array(hash).buffer;
    }
}
class RsaOaepProvider extends core__namespace.RsaOaepProvider {
    async onGenerateKey(algorithm, extractable, keyUsages) {
        const keys = await RsaCrypto.generateKey({
            ...algorithm,
            name: this.name
        }, extractable, keyUsages);
        return {
            privateKey: setCryptoKey(keys.privateKey),
            publicKey: setCryptoKey(keys.publicKey)
        };
    }
    async onEncrypt(algorithm, key, data) {
        const internalKey = getCryptoKey(key);
        const dataView = new Uint8Array(data);
        const keySize = Math.ceil(internalKey.algorithm.modulusLength >> 3);
        const hashSize = ShaCrypto.size(internalKey.algorithm.hash) >> 3;
        const dataLength = dataView.byteLength;
        const psLength = keySize - dataLength - 2 * hashSize - 2;
        if (dataLength > keySize - 2 * hashSize - 2) {
            throw new Error("Data too large");
        }
        const message = new Uint8Array(keySize);
        const seed = message.subarray(1, hashSize + 1);
        const dataBlock = message.subarray(hashSize + 1);
        dataBlock.set(dataView, hashSize + psLength + 1);
        const labelHash = crypto.createHash(internalKey.algorithm.hash.name.replace("-", "")).update(core__namespace.BufferSourceConverter.toUint8Array(algorithm.label || new Uint8Array(0))).digest();
        dataBlock.set(labelHash, 0);
        dataBlock[hashSize + psLength] = 1;
        crypto.randomFillSync(seed);
        const dataBlockMask = this.mgf1(internalKey.algorithm.hash, seed, dataBlock.length);
        for(let i = 0; i < dataBlock.length; i++){
            dataBlock[i] ^= dataBlockMask[i];
        }
        const seedMask = this.mgf1(internalKey.algorithm.hash, dataBlock, seed.length);
        for(let i = 0; i < seed.length; i++){
            seed[i] ^= seedMask[i];
        }
        if (!internalKey.pem) {
            internalKey.pem = `-----BEGIN PUBLIC KEY-----\n${internalKey.data.toString("base64")}\n-----END PUBLIC KEY-----`;
        }
        const pkcs0 = crypto.publicEncrypt({
            key: internalKey.pem,
            padding: crypto.constants.RSA_NO_PADDING
        }, Buffer.from(message));
        return new Uint8Array(pkcs0).buffer;
    }
    async onDecrypt(algorithm, key, data) {
        const internalKey = getCryptoKey(key);
        const keySize = Math.ceil(internalKey.algorithm.modulusLength >> 3);
        const hashSize = ShaCrypto.size(internalKey.algorithm.hash) >> 3;
        const dataLength = data.byteLength;
        if (dataLength !== keySize) {
            throw new Error("Bad data");
        }
        if (!internalKey.pem) {
            internalKey.pem = `-----BEGIN PRIVATE KEY-----\n${internalKey.data.toString("base64")}\n-----END PRIVATE KEY-----`;
        }
        let pkcs0 = crypto.privateDecrypt({
            key: internalKey.pem,
            padding: crypto.constants.RSA_NO_PADDING
        }, Buffer.from(data));
        const z = pkcs0[0];
        const seed = pkcs0.subarray(1, hashSize + 1);
        const dataBlock = pkcs0.subarray(hashSize + 1);
        if (z !== 0) {
            throw new Error("Decryption failed");
        }
        const seedMask = this.mgf1(internalKey.algorithm.hash, dataBlock, seed.length);
        for(let i = 0; i < seed.length; i++){
            seed[i] ^= seedMask[i];
        }
        const dataBlockMask = this.mgf1(internalKey.algorithm.hash, seed, dataBlock.length);
        for(let i = 0; i < dataBlock.length; i++){
            dataBlock[i] ^= dataBlockMask[i];
        }
        const labelHash = crypto.createHash(internalKey.algorithm.hash.name.replace("-", "")).update(core__namespace.BufferSourceConverter.toUint8Array(algorithm.label || new Uint8Array(0))).digest();
        for(let i = 0; i < hashSize; i++){
            if (labelHash[i] !== dataBlock[i]) {
                throw new Error("Decryption failed");
            }
        }
        let psEnd = hashSize;
        for(; psEnd < dataBlock.length; psEnd++){
            const psz = dataBlock[psEnd];
            if (psz === 1) {
                break;
            }
            if (psz !== 0) {
                throw new Error("Decryption failed");
            }
        }
        if (psEnd === dataBlock.length) {
            throw new Error("Decryption failed");
        }
        pkcs0 = dataBlock.subarray(psEnd + 1);
        return new Uint8Array(pkcs0).buffer;
    }
    async onExportKey(format, key) {
        return RsaCrypto.exportKey(format, getCryptoKey(key));
    }
    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const key = await RsaCrypto.importKey(format, keyData, {
            ...algorithm,
            name: this.name
        }, extractable, keyUsages);
        return setCryptoKey(key);
    }
    checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        const internalKey = getCryptoKey(key);
        if (!(internalKey instanceof RsaPrivateKey || internalKey instanceof RsaPublicKey)) {
            throw new TypeError("key: Is not RSA CryptoKey");
        }
    }
    mgf1(algorithm, seed, length = 0) {
        const hashSize = ShaCrypto.size(algorithm) >> 3;
        const mask = new Uint8Array(length);
        const counter = new Uint8Array(4);
        const chunks = Math.ceil(length / hashSize);
        for(let i = 0; i < chunks; i++){
            counter[0] = i >>> 24;
            counter[1] = i >>> 16 & 255;
            counter[2] = i >>> 8 & 255;
            counter[3] = i & 255;
            const submask = mask.subarray(i * hashSize);
            let chunk = crypto.createHash(algorithm.name.replace("-", "")).update(seed).update(counter).digest();
            if (chunk.length > submask.length) {
                chunk = chunk.subarray(0, submask.length);
            }
            submask.set(chunk);
        }
        return mask;
    }
}
class RsaEsProvider extends core__namespace.ProviderCrypto {
    constructor(){
        super(...arguments);
        this.name = "RSAES-PKCS1-v1_5";
        this.usages = {
            publicKey: [
                "encrypt",
                "wrapKey"
            ],
            privateKey: [
                "decrypt",
                "unwrapKey"
            ]
        };
    }
    async onGenerateKey(algorithm, extractable, keyUsages) {
        const keys = await RsaCrypto.generateKey({
            ...algorithm,
            name: this.name
        }, extractable, keyUsages);
        return {
            privateKey: setCryptoKey(keys.privateKey),
            publicKey: setCryptoKey(keys.publicKey)
        };
    }
    checkGenerateKeyParams(algorithm) {
        this.checkRequiredProperty(algorithm, "publicExponent");
        if (!(algorithm.publicExponent && algorithm.publicExponent instanceof Uint8Array)) {
            throw new TypeError("publicExponent: Missing or not a Uint8Array");
        }
        const publicExponent = pvtsutils.Convert.ToBase64(algorithm.publicExponent);
        if (!(publicExponent === "Aw==" || publicExponent === "AQAB")) {
            throw new TypeError("publicExponent: Must be [3] or [1,0,1]");
        }
        this.checkRequiredProperty(algorithm, "modulusLength");
        switch(algorithm.modulusLength){
            case 1024:
            case 2048:
            case 4096:
                break;
            default:
                throw new TypeError("modulusLength: Must be 1024, 2048, or 4096");
        }
    }
    async onEncrypt(algorithm, key, data) {
        const options = this.toCryptoOptions(key);
        const enc = crypto__namespace.publicEncrypt(options, new Uint8Array(data));
        return new Uint8Array(enc).buffer;
    }
    async onDecrypt(algorithm, key, data) {
        const options = this.toCryptoOptions(key);
        const dec = crypto__namespace.privateDecrypt(options, new Uint8Array(data));
        return new Uint8Array(dec).buffer;
    }
    async onExportKey(format, key) {
        return RsaCrypto.exportKey(format, getCryptoKey(key));
    }
    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const key = await RsaCrypto.importKey(format, keyData, {
            ...algorithm,
            name: this.name
        }, extractable, keyUsages);
        return setCryptoKey(key);
    }
    checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        const internalKey = getCryptoKey(key);
        if (!(internalKey instanceof RsaPrivateKey || internalKey instanceof RsaPublicKey)) {
            throw new TypeError("key: Is not RSA CryptoKey");
        }
    }
    toCryptoOptions(key) {
        const type = key.type.toUpperCase();
        return {
            key: `-----BEGIN ${type} KEY-----\n${getCryptoKey(key).data.toString("base64")}\n-----END ${type} KEY-----`,
            padding: crypto__namespace.constants.RSA_PKCS1_PADDING
        };
    }
}
const namedOIDs = {
    "1.2.840.10045.3.1.7": "P-256",
    "P-256": "1.2.840.10045.3.1.7",
    "1.3.132.0.34": "P-384",
    "P-384": "1.3.132.0.34",
    "1.3.132.0.35": "P-521",
    "P-521": "1.3.132.0.35",
    "1.3.132.0.10": "K-256",
    "K-256": "1.3.132.0.10",
    "brainpoolP160r1": "1.3.36.3.3.2.8.1.1.1",
    "1.3.36.3.3.2.8.1.1.1": "brainpoolP160r1",
    "brainpoolP160t1": "1.3.36.3.3.2.8.1.1.2",
    "1.3.36.3.3.2.8.1.1.2": "brainpoolP160t1",
    "brainpoolP192r1": "1.3.36.3.3.2.8.1.1.3",
    "1.3.36.3.3.2.8.1.1.3": "brainpoolP192r1",
    "brainpoolP192t1": "1.3.36.3.3.2.8.1.1.4",
    "1.3.36.3.3.2.8.1.1.4": "brainpoolP192t1",
    "brainpoolP224r1": "1.3.36.3.3.2.8.1.1.5",
    "1.3.36.3.3.2.8.1.1.5": "brainpoolP224r1",
    "brainpoolP224t1": "1.3.36.3.3.2.8.1.1.6",
    "1.3.36.3.3.2.8.1.1.6": "brainpoolP224t1",
    "brainpoolP256r1": "1.3.36.3.3.2.8.1.1.7",
    "1.3.36.3.3.2.8.1.1.7": "brainpoolP256r1",
    "brainpoolP256t1": "1.3.36.3.3.2.8.1.1.8",
    "1.3.36.3.3.2.8.1.1.8": "brainpoolP256t1",
    "brainpoolP320r1": "1.3.36.3.3.2.8.1.1.9",
    "1.3.36.3.3.2.8.1.1.9": "brainpoolP320r1",
    "brainpoolP320t1": "1.3.36.3.3.2.8.1.1.10",
    "1.3.36.3.3.2.8.1.1.10": "brainpoolP320t1",
    "brainpoolP384r1": "1.3.36.3.3.2.8.1.1.11",
    "1.3.36.3.3.2.8.1.1.11": "brainpoolP384r1",
    "brainpoolP384t1": "1.3.36.3.3.2.8.1.1.12",
    "1.3.36.3.3.2.8.1.1.12": "brainpoolP384t1",
    "brainpoolP512r1": "1.3.36.3.3.2.8.1.1.13",
    "1.3.36.3.3.2.8.1.1.13": "brainpoolP512r1",
    "brainpoolP512t1": "1.3.36.3.3.2.8.1.1.14",
    "1.3.36.3.3.2.8.1.1.14": "brainpoolP512t1"
};
function getOidByNamedCurve$1(namedCurve) {
    const oid = namedOIDs[namedCurve];
    if (!oid) {
        throw new core__namespace.OperationError(`Cannot convert WebCrypto named curve '${namedCurve}' to OID`);
    }
    return oid;
}
class EcPrivateKey extends AsymmetricKey {
    constructor(){
        super(...arguments);
        this.type = "private";
    }
    getKey() {
        const keyInfo = asn1Schema.AsnParser.parse(this.data, core__namespace.asn1.PrivateKeyInfo);
        return asn1Schema.AsnParser.parse(keyInfo.privateKey, core__namespace.asn1.EcPrivateKey);
    }
    toJSON() {
        const key = this.getKey();
        const json = {
            kty: "EC",
            crv: this.algorithm.namedCurve,
            key_ops: this.usages,
            ext: this.extractable
        };
        return Object.assign(json, jsonSchema.JsonSerializer.toJSON(key));
    }
    fromJSON(json) {
        if (!json.crv) {
            throw new core__namespace.OperationError(`Cannot get named curve from JWK. Property 'crv' is required`);
        }
        const keyInfo = new core__namespace.asn1.PrivateKeyInfo();
        keyInfo.privateKeyAlgorithm.algorithm = "1.2.840.10045.2.1";
        keyInfo.privateKeyAlgorithm.parameters = asn1Schema.AsnSerializer.serialize(new core__namespace.asn1.ObjectIdentifier(getOidByNamedCurve$1(json.crv)));
        const key = jsonSchema.JsonParser.fromJSON(json, {
            targetSchema: core__namespace.asn1.EcPrivateKey
        });
        keyInfo.privateKey = asn1Schema.AsnSerializer.serialize(key);
        this.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));
        return this;
    }
}
class EcPublicKey extends AsymmetricKey {
    constructor(){
        super(...arguments);
        this.type = "public";
    }
    getKey() {
        const keyInfo = asn1Schema.AsnParser.parse(this.data, core__namespace.asn1.PublicKeyInfo);
        return new core__namespace.asn1.EcPublicKey(keyInfo.publicKey);
    }
    toJSON() {
        const key = this.getKey();
        const json = {
            kty: "EC",
            crv: this.algorithm.namedCurve,
            key_ops: this.usages,
            ext: this.extractable
        };
        return Object.assign(json, jsonSchema.JsonSerializer.toJSON(key));
    }
    fromJSON(json) {
        if (!json.crv) {
            throw new core__namespace.OperationError(`Cannot get named curve from JWK. Property 'crv' is required`);
        }
        const key = jsonSchema.JsonParser.fromJSON(json, {
            targetSchema: core__namespace.asn1.EcPublicKey
        });
        const keyInfo = new core__namespace.asn1.PublicKeyInfo();
        keyInfo.publicKeyAlgorithm.algorithm = "1.2.840.10045.2.1";
        keyInfo.publicKeyAlgorithm.parameters = asn1Schema.AsnSerializer.serialize(new core__namespace.asn1.ObjectIdentifier(getOidByNamedCurve$1(json.crv)));
        keyInfo.publicKey = asn1Schema.AsnSerializer.toASN(key).valueHex;
        this.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));
        return this;
    }
}
class Sha1Provider extends core__namespace.ProviderCrypto {
    constructor(){
        super(...arguments);
        this.name = "SHA-1";
        this.usages = [];
    }
    async onDigest(algorithm, data) {
        return ShaCrypto.digest(algorithm, data);
    }
}
class Sha256Provider extends core__namespace.ProviderCrypto {
    constructor(){
        super(...arguments);
        this.name = "SHA-256";
        this.usages = [];
    }
    async onDigest(algorithm, data) {
        return ShaCrypto.digest(algorithm, data);
    }
}
class Sha384Provider extends core__namespace.ProviderCrypto {
    constructor(){
        super(...arguments);
        this.name = "SHA-384";
        this.usages = [];
    }
    async onDigest(algorithm, data) {
        return ShaCrypto.digest(algorithm, data);
    }
}
class Sha512Provider extends core__namespace.ProviderCrypto {
    constructor(){
        super(...arguments);
        this.name = "SHA-512";
        this.usages = [];
    }
    async onDigest(algorithm, data) {
        return ShaCrypto.digest(algorithm, data);
    }
}
class Sha3256Provider extends core__namespace.ProviderCrypto {
    constructor(){
        super(...arguments);
        this.name = "SHA3-256";
        this.usages = [];
    }
    async onDigest(algorithm, data) {
        return ShaCrypto.digest(algorithm, data);
    }
}
class Sha3384Provider extends core__namespace.ProviderCrypto {
    constructor(){
        super(...arguments);
        this.name = "SHA3-384";
        this.usages = [];
    }
    async onDigest(algorithm, data) {
        return ShaCrypto.digest(algorithm, data);
    }
}
class Sha3512Provider extends core__namespace.ProviderCrypto {
    constructor(){
        super(...arguments);
        this.name = "SHA3-512";
        this.usages = [];
    }
    async onDigest(algorithm, data) {
        return ShaCrypto.digest(algorithm, data);
    }
}
class EcCrypto {
    static async generateKey(algorithm, extractable, keyUsages) {
        const privateKey = new EcPrivateKey();
        privateKey.algorithm = algorithm;
        privateKey.extractable = extractable;
        privateKey.usages = keyUsages.filter((usage)=>this.privateKeyUsages.indexOf(usage) !== -1);
        const publicKey = new EcPublicKey();
        publicKey.algorithm = algorithm;
        publicKey.extractable = true;
        publicKey.usages = keyUsages.filter((usage)=>this.publicKeyUsages.indexOf(usage) !== -1);
        const keys = crypto.generateKeyPairSync("ec", {
            namedCurve: this.getOpenSSLNamedCurve(algorithm.namedCurve),
            publicKeyEncoding: {
                format: "der",
                type: "spki"
            },
            privateKeyEncoding: {
                format: "der",
                type: "pkcs8"
            }
        });
        privateKey.data = keys.privateKey;
        publicKey.data = keys.publicKey;
        const res = {
            privateKey,
            publicKey
        };
        return res;
    }
    static async sign(algorithm, key, data) {
        const cryptoAlg = ShaCrypto.getAlgorithmName(algorithm.hash);
        const signer = crypto.createSign(cryptoAlg);
        signer.update(Buffer.from(data));
        if (!key.pem) {
            key.pem = `-----BEGIN PRIVATE KEY-----\n${key.data.toString("base64")}\n-----END PRIVATE KEY-----`;
        }
        const options = {
            key: key.pem
        };
        const signature = signer.sign(options);
        const ecSignature = asn1Schema.AsnParser.parse(signature, core__namespace.asn1.EcDsaSignature);
        const signatureRaw = core__namespace.EcUtils.encodeSignature(ecSignature, core__namespace.EcCurves.get(key.algorithm.namedCurve).size);
        return signatureRaw.buffer;
    }
    static async verify(algorithm, key, signature, data) {
        const cryptoAlg = ShaCrypto.getAlgorithmName(algorithm.hash);
        const signer = crypto.createVerify(cryptoAlg);
        signer.update(Buffer.from(data));
        if (!key.pem) {
            key.pem = `-----BEGIN PUBLIC KEY-----\n${key.data.toString("base64")}\n-----END PUBLIC KEY-----`;
        }
        const options = {
            key: key.pem
        };
        const ecSignature = new core__namespace.asn1.EcDsaSignature();
        const namedCurve = core__namespace.EcCurves.get(key.algorithm.namedCurve);
        const signaturePoint = core__namespace.EcUtils.decodeSignature(signature, namedCurve.size);
        ecSignature.r = pvtsutils.BufferSourceConverter.toArrayBuffer(signaturePoint.r);
        ecSignature.s = pvtsutils.BufferSourceConverter.toArrayBuffer(signaturePoint.s);
        const ecSignatureRaw = Buffer.from(asn1Schema.AsnSerializer.serialize(ecSignature));
        const ok = signer.verify(options, ecSignatureRaw);
        return ok;
    }
    static async deriveBits(algorithm, baseKey, length) {
        const cryptoAlg = this.getOpenSSLNamedCurve(baseKey.algorithm.namedCurve);
        const ecdh = crypto.createECDH(cryptoAlg);
        const asnPrivateKey = asn1Schema.AsnParser.parse(baseKey.data, core__namespace.asn1.PrivateKeyInfo);
        const asnEcPrivateKey = asn1Schema.AsnParser.parse(asnPrivateKey.privateKey, core__namespace.asn1.EcPrivateKey);
        ecdh.setPrivateKey(Buffer.from(asnEcPrivateKey.privateKey));
        const asnPublicKey = asn1Schema.AsnParser.parse(algorithm.public.data, core__namespace.asn1.PublicKeyInfo);
        const bits = ecdh.computeSecret(Buffer.from(asnPublicKey.publicKey));
        if (length === null) {
            return bits;
        }
        return new Uint8Array(bits).buffer.slice(0, length >> 3);
    }
    static async exportKey(format, key) {
        switch(format.toLowerCase()){
            case "jwk":
                return jsonSchema.JsonSerializer.toJSON(key);
            case "pkcs8":
            case "spki":
                return new Uint8Array(key.data).buffer;
            case "raw":
                {
                    const publicKeyInfo = asn1Schema.AsnParser.parse(key.data, core__namespace.asn1.PublicKeyInfo);
                    return publicKeyInfo.publicKey;
                }
            default:
                throw new core__namespace.OperationError("format: Must be 'jwk', 'raw', pkcs8' or 'spki'");
        }
    }
    static async importKey(format, keyData, algorithm, extractable, keyUsages) {
        switch(format.toLowerCase()){
            case "jwk":
                {
                    const jwk = keyData;
                    if (jwk.d) {
                        const asnKey = jsonSchema.JsonParser.fromJSON(keyData, {
                            targetSchema: core__namespace.asn1.EcPrivateKey
                        });
                        return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);
                    } else {
                        const asnKey = jsonSchema.JsonParser.fromJSON(keyData, {
                            targetSchema: core__namespace.asn1.EcPublicKey
                        });
                        return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);
                    }
                }
            case "raw":
                {
                    const asnKey = new core__namespace.asn1.EcPublicKey(keyData);
                    return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);
                }
            case "spki":
                {
                    const keyInfo = asn1Schema.AsnParser.parse(new Uint8Array(keyData), core__namespace.asn1.PublicKeyInfo);
                    const asnKey = new core__namespace.asn1.EcPublicKey(keyInfo.publicKey);
                    this.assertKeyParameters(keyInfo.publicKeyAlgorithm.parameters, algorithm.namedCurve);
                    return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);
                }
            case "pkcs8":
                {
                    const keyInfo = asn1Schema.AsnParser.parse(new Uint8Array(keyData), core__namespace.asn1.PrivateKeyInfo);
                    const asnKey = asn1Schema.AsnParser.parse(keyInfo.privateKey, core__namespace.asn1.EcPrivateKey);
                    this.assertKeyParameters(keyInfo.privateKeyAlgorithm.parameters, algorithm.namedCurve);
                    return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);
                }
            default:
                throw new core__namespace.OperationError("format: Must be 'jwk', 'raw', 'pkcs8' or 'spki'");
        }
    }
    static assertKeyParameters(parameters, namedCurve) {
        if (!parameters) {
            throw new core__namespace.CryptoError("Key info doesn't have required parameters");
        }
        let namedCurveIdentifier = "";
        try {
            namedCurveIdentifier = asn1Schema.AsnParser.parse(parameters, core__namespace.asn1.ObjectIdentifier).value;
        } catch (e) {
            throw new core__namespace.CryptoError("Cannot read key info parameters");
        }
        if (getOidByNamedCurve$1(namedCurve) !== namedCurveIdentifier) {
            throw new core__namespace.CryptoError("Key info parameter doesn't match to named curve");
        }
    }
    static async importPrivateKey(asnKey, algorithm, extractable, keyUsages) {
        const keyInfo = new core__namespace.asn1.PrivateKeyInfo();
        keyInfo.privateKeyAlgorithm.algorithm = "1.2.840.10045.2.1";
        keyInfo.privateKeyAlgorithm.parameters = asn1Schema.AsnSerializer.serialize(new core__namespace.asn1.ObjectIdentifier(getOidByNamedCurve$1(algorithm.namedCurve)));
        keyInfo.privateKey = asn1Schema.AsnSerializer.serialize(asnKey);
        const key = new EcPrivateKey();
        key.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));
        key.algorithm = Object.assign({}, algorithm);
        key.extractable = extractable;
        key.usages = keyUsages;
        return key;
    }
    static async importPublicKey(asnKey, algorithm, extractable, keyUsages) {
        const keyInfo = new core__namespace.asn1.PublicKeyInfo();
        keyInfo.publicKeyAlgorithm.algorithm = "1.2.840.10045.2.1";
        const namedCurve = getOidByNamedCurve$1(algorithm.namedCurve);
        keyInfo.publicKeyAlgorithm.parameters = asn1Schema.AsnSerializer.serialize(new core__namespace.asn1.ObjectIdentifier(namedCurve));
        keyInfo.publicKey = asnKey.value;
        const key = new EcPublicKey();
        key.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));
        key.algorithm = Object.assign({}, algorithm);
        key.extractable = extractable;
        key.usages = keyUsages;
        return key;
    }
    static getOpenSSLNamedCurve(curve) {
        switch(curve.toUpperCase()){
            case "P-256":
                return "prime256v1";
            case "K-256":
                return "secp256k1";
            case "P-384":
                return "secp384r1";
            case "P-521":
                return "secp521r1";
            default:
                return curve;
        }
    }
}
EcCrypto.publicKeyUsages = [
    "verify"
];
EcCrypto.privateKeyUsages = [
    "sign",
    "deriveKey",
    "deriveBits"
];
class EcdsaProvider extends core__namespace.EcdsaProvider {
    constructor(){
        super(...arguments);
        this.namedCurves = core__namespace.EcCurves.names;
        this.hashAlgorithms = [
            "SHA-1",
            "SHA-256",
            "SHA-384",
            "SHA-512",
            "shake128",
            "shake256",
            "SHA3-256",
            "SHA3-384",
            "SHA3-512"
        ];
    }
    async onGenerateKey(algorithm, extractable, keyUsages) {
        const keys = await EcCrypto.generateKey({
            ...algorithm,
            name: this.name
        }, extractable, keyUsages);
        return {
            privateKey: setCryptoKey(keys.privateKey),
            publicKey: setCryptoKey(keys.publicKey)
        };
    }
    async onSign(algorithm, key, data) {
        return EcCrypto.sign(algorithm, getCryptoKey(key), new Uint8Array(data));
    }
    async onVerify(algorithm, key, signature, data) {
        return EcCrypto.verify(algorithm, getCryptoKey(key), new Uint8Array(signature), new Uint8Array(data));
    }
    async onExportKey(format, key) {
        return EcCrypto.exportKey(format, getCryptoKey(key));
    }
    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const key = await EcCrypto.importKey(format, keyData, {
            ...algorithm,
            name: this.name
        }, extractable, keyUsages);
        return setCryptoKey(key);
    }
    checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        const internalKey = getCryptoKey(key);
        if (!(internalKey instanceof EcPrivateKey || internalKey instanceof EcPublicKey)) {
            throw new TypeError("key: Is not EC CryptoKey");
        }
    }
}
class EcdhProvider extends core__namespace.EcdhProvider {
    constructor(){
        super(...arguments);
        this.namedCurves = core__namespace.EcCurves.names;
    }
    async onGenerateKey(algorithm, extractable, keyUsages) {
        const keys = await EcCrypto.generateKey({
            ...algorithm,
            name: this.name
        }, extractable, keyUsages);
        return {
            privateKey: setCryptoKey(keys.privateKey),
            publicKey: setCryptoKey(keys.publicKey)
        };
    }
    async onExportKey(format, key) {
        return EcCrypto.exportKey(format, getCryptoKey(key));
    }
    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const key = await EcCrypto.importKey(format, keyData, {
            ...algorithm,
            name: this.name
        }, extractable, keyUsages);
        return setCryptoKey(key);
    }
    checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        const internalKey = getCryptoKey(key);
        if (!(internalKey instanceof EcPrivateKey || internalKey instanceof EcPublicKey)) {
            throw new TypeError("key: Is not EC CryptoKey");
        }
    }
    async onDeriveBits(algorithm, baseKey, length) {
        const bits = await EcCrypto.deriveBits({
            ...algorithm,
            public: getCryptoKey(algorithm.public)
        }, getCryptoKey(baseKey), length);
        return bits;
    }
}
const edOIDs = {
    [core__namespace.asn1.idEd448]: "Ed448",
    "ed448": core__namespace.asn1.idEd448,
    [core__namespace.asn1.idX448]: "X448",
    "x448": core__namespace.asn1.idX448,
    [core__namespace.asn1.idEd25519]: "Ed25519",
    "ed25519": core__namespace.asn1.idEd25519,
    [core__namespace.asn1.idX25519]: "X25519",
    "x25519": core__namespace.asn1.idX25519
};
function getOidByNamedCurve(namedCurve) {
    const oid = edOIDs[namedCurve.toLowerCase()];
    if (!oid) {
        throw new core__namespace.OperationError(`Cannot convert WebCrypto named curve '${namedCurve}' to OID`);
    }
    return oid;
}
class EdPrivateKey extends AsymmetricKey {
    constructor(){
        super(...arguments);
        this.type = "private";
    }
    getKey() {
        const keyInfo = asn1Schema.AsnParser.parse(this.data, core__namespace.asn1.PrivateKeyInfo);
        return asn1Schema.AsnParser.parse(keyInfo.privateKey, core__namespace.asn1.CurvePrivateKey);
    }
    toJSON() {
        const key = this.getKey();
        const json = {
            kty: "OKP",
            crv: this.algorithm.namedCurve,
            key_ops: this.usages,
            ext: this.extractable
        };
        return Object.assign(json, jsonSchema.JsonSerializer.toJSON(key));
    }
    fromJSON(json) {
        if (!json.crv) {
            throw new core__namespace.OperationError(`Cannot get named curve from JWK. Property 'crv' is required`);
        }
        const keyInfo = new core__namespace.asn1.PrivateKeyInfo();
        keyInfo.privateKeyAlgorithm.algorithm = getOidByNamedCurve(json.crv);
        const key = jsonSchema.JsonParser.fromJSON(json, {
            targetSchema: core__namespace.asn1.CurvePrivateKey
        });
        keyInfo.privateKey = asn1Schema.AsnSerializer.serialize(key);
        this.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));
        return this;
    }
}
class EdPublicKey extends AsymmetricKey {
    constructor(){
        super(...arguments);
        this.type = "public";
    }
    getKey() {
        const keyInfo = asn1Schema.AsnParser.parse(this.data, core__namespace.asn1.PublicKeyInfo);
        return keyInfo.publicKey;
    }
    toJSON() {
        const key = this.getKey();
        const json = {
            kty: "OKP",
            crv: this.algorithm.namedCurve,
            key_ops: this.usages,
            ext: this.extractable
        };
        return Object.assign(json, {
            x: pvtsutils.Convert.ToBase64Url(key)
        });
    }
    fromJSON(json) {
        if (!json.crv) {
            throw new core__namespace.OperationError(`Cannot get named curve from JWK. Property 'crv' is required`);
        }
        if (!json.x) {
            throw new core__namespace.OperationError(`Cannot get property from JWK. Property 'x' is required`);
        }
        const keyInfo = new core__namespace.asn1.PublicKeyInfo();
        keyInfo.publicKeyAlgorithm.algorithm = getOidByNamedCurve(json.crv);
        keyInfo.publicKey = pvtsutils.Convert.FromBase64Url(json.x);
        this.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));
        return this;
    }
}
class EdCrypto {
    static async generateKey(algorithm, extractable, keyUsages) {
        const privateKey = new EdPrivateKey();
        privateKey.algorithm = algorithm;
        privateKey.extractable = extractable;
        privateKey.usages = keyUsages.filter((usage)=>this.privateKeyUsages.indexOf(usage) !== -1);
        const publicKey = new EdPublicKey();
        publicKey.algorithm = algorithm;
        publicKey.extractable = true;
        publicKey.usages = keyUsages.filter((usage)=>this.publicKeyUsages.indexOf(usage) !== -1);
        const type = algorithm.namedCurve.toLowerCase();
        const keys = crypto.generateKeyPairSync(type, {
            publicKeyEncoding: {
                format: "der",
                type: "spki"
            },
            privateKeyEncoding: {
                format: "der",
                type: "pkcs8"
            }
        });
        privateKey.data = keys.privateKey;
        publicKey.data = keys.publicKey;
        const res = {
            privateKey,
            publicKey
        };
        return res;
    }
    static async sign(algorithm, key, data) {
        if (!key.pem) {
            key.pem = `-----BEGIN PRIVATE KEY-----\n${key.data.toString("base64")}\n-----END PRIVATE KEY-----`;
        }
        const options = {
            key: key.pem
        };
        const signature = crypto.sign(null, Buffer.from(data), options);
        return core__namespace.BufferSourceConverter.toArrayBuffer(signature);
    }
    static async verify(algorithm, key, signature, data) {
        if (!key.pem) {
            key.pem = `-----BEGIN PUBLIC KEY-----\n${key.data.toString("base64")}\n-----END PUBLIC KEY-----`;
        }
        const options = {
            key: key.pem
        };
        const ok = crypto.verify(null, Buffer.from(data), options, Buffer.from(signature));
        return ok;
    }
    static async deriveBits(algorithm, baseKey, length) {
        const publicKey = crypto.createPublicKey({
            key: algorithm.public.data,
            format: "der",
            type: "spki"
        });
        const privateKey = crypto.createPrivateKey({
            key: baseKey.data,
            format: "der",
            type: "pkcs8"
        });
        const bits = crypto.diffieHellman({
            publicKey,
            privateKey
        });
        return new Uint8Array(bits).buffer.slice(0, length >> 3);
    }
    static async exportKey(format, key) {
        switch(format.toLowerCase()){
            case "jwk":
                return jsonSchema.JsonSerializer.toJSON(key);
            case "pkcs8":
            case "spki":
                return new Uint8Array(key.data).buffer;
            case "raw":
                {
                    const publicKeyInfo = asn1Schema.AsnParser.parse(key.data, core__namespace.asn1.PublicKeyInfo);
                    return publicKeyInfo.publicKey;
                }
            default:
                throw new core__namespace.OperationError("format: Must be 'jwk', 'raw', pkcs8' or 'spki'");
        }
    }
    static async importKey(format, keyData, algorithm, extractable, keyUsages) {
        switch(format.toLowerCase()){
            case "jwk":
                {
                    const jwk = keyData;
                    if (jwk.d) {
                        const asnKey = jsonSchema.JsonParser.fromJSON(keyData, {
                            targetSchema: core__namespace.asn1.CurvePrivateKey
                        });
                        return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);
                    } else {
                        if (!jwk.x) {
                            throw new TypeError("keyData: Cannot get required 'x' filed");
                        }
                        return this.importPublicKey(pvtsutils.Convert.FromBase64Url(jwk.x), algorithm, extractable, keyUsages);
                    }
                }
            case "raw":
                {
                    return this.importPublicKey(keyData, algorithm, extractable, keyUsages);
                }
            case "spki":
                {
                    const keyInfo = asn1Schema.AsnParser.parse(new Uint8Array(keyData), core__namespace.asn1.PublicKeyInfo);
                    return this.importPublicKey(keyInfo.publicKey, algorithm, extractable, keyUsages);
                }
            case "pkcs8":
                {
                    const keyInfo = asn1Schema.AsnParser.parse(new Uint8Array(keyData), core__namespace.asn1.PrivateKeyInfo);
                    const asnKey = asn1Schema.AsnParser.parse(keyInfo.privateKey, core__namespace.asn1.CurvePrivateKey);
                    return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);
                }
            default:
                throw new core__namespace.OperationError("format: Must be 'jwk', 'raw', 'pkcs8' or 'spki'");
        }
    }
    static importPrivateKey(asnKey, algorithm, extractable, keyUsages) {
        const key = new EdPrivateKey();
        key.fromJSON({
            crv: algorithm.namedCurve,
            d: pvtsutils.Convert.ToBase64Url(asnKey.d)
        });
        key.algorithm = Object.assign({}, algorithm);
        key.extractable = extractable;
        key.usages = keyUsages;
        return key;
    }
    static async importPublicKey(asnKey, algorithm, extractable, keyUsages) {
        const key = new EdPublicKey();
        key.fromJSON({
            crv: algorithm.namedCurve,
            x: pvtsutils.Convert.ToBase64Url(asnKey)
        });
        key.algorithm = Object.assign({}, algorithm);
        key.extractable = extractable;
        key.usages = keyUsages;
        return key;
    }
}
EdCrypto.publicKeyUsages = [
    "verify"
];
EdCrypto.privateKeyUsages = [
    "sign",
    "deriveKey",
    "deriveBits"
];
class EdDsaProvider extends core__namespace.EdDsaProvider {
    async onGenerateKey(algorithm, extractable, keyUsages) {
        const keys = await EdCrypto.generateKey({
            name: this.name,
            namedCurve: algorithm.namedCurve.replace(/^ed/i, "Ed")
        }, extractable, keyUsages);
        return {
            privateKey: setCryptoKey(keys.privateKey),
            publicKey: setCryptoKey(keys.publicKey)
        };
    }
    async onSign(algorithm, key, data) {
        return EdCrypto.sign(algorithm, getCryptoKey(key), new Uint8Array(data));
    }
    async onVerify(algorithm, key, signature, data) {
        return EdCrypto.verify(algorithm, getCryptoKey(key), new Uint8Array(signature), new Uint8Array(data));
    }
    async onExportKey(format, key) {
        return EdCrypto.exportKey(format, getCryptoKey(key));
    }
    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const key = await EdCrypto.importKey(format, keyData, {
            ...algorithm,
            name: this.name
        }, extractable, keyUsages);
        return setCryptoKey(key);
    }
}
class EcdhEsProvider extends core__namespace.EcdhEsProvider {
    async onGenerateKey(algorithm, extractable, keyUsages) {
        const keys = await EdCrypto.generateKey({
            name: this.name,
            namedCurve: algorithm.namedCurve.toUpperCase()
        }, extractable, keyUsages);
        return {
            privateKey: setCryptoKey(keys.privateKey),
            publicKey: setCryptoKey(keys.publicKey)
        };
    }
    async onDeriveBits(algorithm, baseKey, length) {
        const bits = await EdCrypto.deriveBits({
            ...algorithm,
            public: getCryptoKey(algorithm.public)
        }, getCryptoKey(baseKey), length);
        return bits;
    }
    async onExportKey(format, key) {
        return EdCrypto.exportKey(format, getCryptoKey(key));
    }
    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        const key = await EdCrypto.importKey(format, keyData, {
            ...algorithm,
            name: this.name
        }, extractable, keyUsages);
        return setCryptoKey(key);
    }
}
class PbkdfCryptoKey extends CryptoKey {
}
class Pbkdf2Provider extends core__namespace.Pbkdf2Provider {
    async onDeriveBits(algorithm, baseKey, length) {
        return new Promise((resolve, reject)=>{
            const salt = core__namespace.BufferSourceConverter.toArrayBuffer(algorithm.salt);
            const hash = algorithm.hash.name.replace("-", "");
            crypto.pbkdf2(getCryptoKey(baseKey).data, Buffer.from(salt), algorithm.iterations, length >> 3, hash, (err, derivedBits)=>{
                if (err) {
                    reject(err);
                } else {
                    resolve(new Uint8Array(derivedBits).buffer);
                }
            });
        });
    }
    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        if (format === "raw") {
            const key = new PbkdfCryptoKey();
            key.data = Buffer.from(keyData);
            key.algorithm = {
                name: this.name
            };
            key.extractable = false;
            key.usages = keyUsages;
            return setCryptoKey(key);
        }
        throw new core__namespace.OperationError("format: Must be 'raw'");
    }
    checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        if (!(getCryptoKey(key) instanceof PbkdfCryptoKey)) {
            throw new TypeError("key: Is not PBKDF CryptoKey");
        }
    }
}
class HmacCryptoKey extends CryptoKey {
    get alg() {
        const hash = this.algorithm.hash.name.toUpperCase();
        return `HS${hash.replace("SHA-", "")}`;
    }
    set alg(value) {}
}
tslib.__decorate([
    jsonSchema.JsonProp({
        name: "k",
        converter: JsonBase64UrlConverter
    })
], HmacCryptoKey.prototype, "data", void 0);
class HmacProvider extends core__namespace.HmacProvider {
    async onGenerateKey(algorithm, extractable, keyUsages) {
        const length = (algorithm.length || this.getDefaultLength(algorithm.hash.name)) >> 3 << 3;
        const key = new HmacCryptoKey();
        key.algorithm = {
            ...algorithm,
            length,
            name: this.name
        };
        key.extractable = extractable;
        key.usages = keyUsages;
        key.data = crypto.randomBytes(length >> 3);
        return setCryptoKey(key);
    }
    async onSign(algorithm, key, data) {
        const cryptoAlg = ShaCrypto.getAlgorithmName(key.algorithm.hash);
        const hmac = crypto.createHmac(cryptoAlg, getCryptoKey(key).data).update(Buffer.from(data)).digest();
        return new Uint8Array(hmac).buffer;
    }
    async onVerify(algorithm, key, signature, data) {
        const cryptoAlg = ShaCrypto.getAlgorithmName(key.algorithm.hash);
        const hmac = crypto.createHmac(cryptoAlg, getCryptoKey(key).data).update(Buffer.from(data)).digest();
        return hmac.compare(Buffer.from(signature)) === 0;
    }
    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        let key;
        switch(format.toLowerCase()){
            case "jwk":
                key = jsonSchema.JsonParser.fromJSON(keyData, {
                    targetSchema: HmacCryptoKey
                });
                break;
            case "raw":
                key = new HmacCryptoKey();
                key.data = Buffer.from(keyData);
                break;
            default:
                throw new core__namespace.OperationError("format: Must be 'jwk' or 'raw'");
        }
        key.algorithm = {
            hash: {
                name: algorithm.hash.name
            },
            name: this.name,
            length: key.data.length << 3
        };
        key.extractable = extractable;
        key.usages = keyUsages;
        return setCryptoKey(key);
    }
    async onExportKey(format, key) {
        switch(format.toLowerCase()){
            case "jwk":
                return jsonSchema.JsonSerializer.toJSON(getCryptoKey(key));
            case "raw":
                return new Uint8Array(getCryptoKey(key).data).buffer;
            default:
                throw new core__namespace.OperationError("format: Must be 'jwk' or 'raw'");
        }
    }
    checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        if (!(getCryptoKey(key) instanceof HmacCryptoKey)) {
            throw new TypeError("key: Is not HMAC CryptoKey");
        }
    }
}
class HkdfCryptoKey extends CryptoKey {
}
class HkdfProvider extends core__namespace.HkdfProvider {
    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {
        if (format.toLowerCase() !== "raw") {
            throw new core__namespace.OperationError("Operation not supported");
        }
        const key = new HkdfCryptoKey();
        key.data = Buffer.from(keyData);
        key.algorithm = {
            name: this.name
        };
        key.extractable = extractable;
        key.usages = keyUsages;
        return setCryptoKey(key);
    }
    async onDeriveBits(params, baseKey, length) {
        const hash = params.hash.name.replace("-", "");
        const hashLength = crypto.createHash(hash).digest().length;
        const byteLength = length / 8;
        const info = core.BufferSourceConverter.toUint8Array(params.info);
        const PRK = crypto.createHmac(hash, core.BufferSourceConverter.toUint8Array(params.salt)).update(core.BufferSourceConverter.toUint8Array(getCryptoKey(baseKey).data)).digest();
        const blocks = [
            Buffer.alloc(0)
        ];
        const blockCount = Math.ceil(byteLength / hashLength) + 1;
        for(let i = 1; i < blockCount; ++i){
            blocks.push(crypto.createHmac(hash, PRK).update(Buffer.concat([
                blocks[i - 1],
                info,
                Buffer.from([
                    i
                ])
            ])).digest());
        }
        return Buffer.concat(blocks).slice(0, byteLength);
    }
    checkCryptoKey(key, keyUsage) {
        super.checkCryptoKey(key, keyUsage);
        if (!(getCryptoKey(key) instanceof HkdfCryptoKey)) {
            throw new TypeError("key: Is not HKDF CryptoKey");
        }
    }
}
class ShakeCrypto {
    static digest(algorithm, data) {
        const hash = crypto.createHash(algorithm.name.toLowerCase(), {
            outputLength: algorithm.length
        }).update(Buffer.from(data)).digest();
        return new Uint8Array(hash).buffer;
    }
}
class Shake128Provider extends core__namespace.Shake128Provider {
    async onDigest(algorithm, data) {
        return ShakeCrypto.digest(algorithm, data);
    }
}
class Shake256Provider extends core__namespace.Shake256Provider {
    async onDigest(algorithm, data) {
        return ShakeCrypto.digest(algorithm, data);
    }
}
class SubtleCrypto extends core__namespace.SubtleCrypto {
    constructor(){
        var _a;
        super();
        this.providers.set(new AesCbcProvider());
        this.providers.set(new AesCtrProvider());
        this.providers.set(new AesGcmProvider());
        this.providers.set(new AesCmacProvider());
        this.providers.set(new AesKwProvider());
        this.providers.set(new AesEcbProvider());
        const ciphers = crypto__namespace.getCiphers();
        if (ciphers.includes("des-cbc")) {
            this.providers.set(new DesCbcProvider());
        }
        this.providers.set(new DesEde3CbcProvider());
        this.providers.set(new RsaSsaProvider());
        this.providers.set(new RsaPssProvider());
        this.providers.set(new RsaOaepProvider());
        this.providers.set(new RsaEsProvider());
        this.providers.set(new EcdsaProvider());
        this.providers.set(new EcdhProvider());
        this.providers.set(new Sha1Provider());
        this.providers.set(new Sha256Provider());
        this.providers.set(new Sha384Provider());
        this.providers.set(new Sha512Provider());
        this.providers.set(new Pbkdf2Provider());
        this.providers.set(new HmacProvider());
        this.providers.set(new HkdfProvider());
        const nodeMajorVersion = (_a = /^v(\d+)/.exec(process__namespace.version)) === null || _a === void 0 ? void 0 : _a[1];
        if (nodeMajorVersion && parseInt(nodeMajorVersion, 10) >= 12) {
            this.providers.set(new Shake128Provider());
            this.providers.set(new Shake256Provider());
        }
        const hashes = crypto__namespace.getHashes();
        if (hashes.includes("sha3-256")) {
            this.providers.set(new Sha3256Provider());
        }
        if (hashes.includes("sha3-384")) {
            this.providers.set(new Sha3384Provider());
        }
        if (hashes.includes("sha3-512")) {
            this.providers.set(new Sha3512Provider());
        }
        if (nodeMajorVersion && parseInt(nodeMajorVersion, 10) >= 14) {
            this.providers.set(new EdDsaProvider());
            this.providers.set(new EcdhEsProvider());
        }
    }
}
class Crypto extends core__namespace.Crypto {
    constructor(){
        super(...arguments);
        this.subtle = new SubtleCrypto();
    }
    getRandomValues(array) {
        if (!ArrayBuffer.isView(array)) {
            throw new TypeError("Failed to execute 'getRandomValues' on 'Crypto': parameter 1 is not of type 'ArrayBufferView'");
        }
        const buffer = Buffer.from(array.buffer, array.byteOffset, array.byteLength);
        crypto.randomFillSync(buffer);
        return array;
    }
}
Object.defineProperty(exports, "CryptoKey", ({
    enumerable: true,
    get: function() {
        return core.CryptoKey;
    }
}));
exports.Crypto = Crypto;


/***/ }),

/***/ 1919:
/***/ ((module) => {

"use strict";

module.exports.Event = globalThis.Event;
if (!module.exports.Event) {
    module.exports.Event = class Event {
        constructor(type, options){
            this.bubbles = !!options && !!options.bubbles;
            this.cancelable = !!options && !!options.cancelable;
            this.composed = !!options && !!options.composed;
            this.type = type;
        }
    };
}
module.exports.EventTarget = globalThis.EventTarget;
if (!module.exports.EventTarget) {
    module.exports.EventTarget = class EventTarget {
        constructor(){
            this.__listeners = new Map();
        }
        addEventListener(type, listener, options) {
            if (arguments.length < 2) {
                throw new TypeError(`TypeError: Failed to execute 'addEventListener' on 'EventTarget': 2 arguments required, but only ${arguments.length} present.`);
            }
            const __listeners = this.__listeners;
            const actualType = type.toString();
            if (!__listeners.has(actualType)) {
                __listeners.set(actualType, new Map());
            }
            const listenersForType = __listeners.get(actualType);
            if (!listenersForType.has(listener)) {
                // Any given listener is only registered once
                listenersForType.set(listener, options);
            }
        }
        removeEventListener(type, listener, _options) {
            if (arguments.length < 2) {
                throw new TypeError(`TypeError: Failed to execute 'addEventListener' on 'EventTarget': 2 arguments required, but only ${arguments.length} present.`);
            }
            const __listeners = this.__listeners;
            const actualType = type.toString();
            if (__listeners.has(actualType)) {
                const listenersForType = __listeners.get(actualType);
                if (listenersForType.has(listener)) {
                    listenersForType.delete(listener);
                }
            }
        }
        dispatchEvent(event) {
            if (!(event instanceof module.exports.Event)) {
                throw new TypeError(`Failed to execute 'dispatchEvent' on 'EventTarget': parameter 1 is not of type 'Event'.`);
            }
            const type = event.type;
            const __listeners = this.__listeners;
            const listenersForType = __listeners.get(type);
            if (listenersForType) {
                for (const [listener, options] of listenersForType.entries()){
                    try {
                        if (typeof listener === "function") {
                            // Listener functions must be executed with the EventTarget as the `this` context.
                            listener.call(this, event);
                        } else if (listener && typeof listener.handleEvent === "function") {
                            // Listener objects have their handleEvent method called, if they have one
                            listener.handleEvent(event);
                        }
                    } catch (err) {
                        // We need to report the error to the global error handling event,
                        // but we do not want to break the loop that is executing the events.
                        // Unfortunately, this is the best we can do, which isn't great, because the
                        // native EventTarget will actually do this synchronously before moving to the next
                        // event in the loop.
                        setTimeout(()=>{
                            throw err;
                        });
                    }
                    if (options && options.once) {
                        // If this was registered with { once: true }, we need
                        // to remove it now.
                        listenersForType.delete(listener);
                    }
                }
            }
            // Since there are no cancellable events on a base EventTarget,
            // this should always return true.
            return true;
        }
    };
}
module.exports.CustomEvent = globalThis.CustomEvent;
if (!module.exports.CustomEvent) {
    module.exports.CustomEvent = class CustomEvent extends module.exports.Event {
        constructor(type, options){
            super(type, options);
            this.detail = options && options.detail;
        }
    };
}


/***/ }),

/***/ 8246:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = function createNodePonyfill(opts = {}) {
    const ponyfills = {};
    // We call this previously to patch `Bun`
    if (!ponyfills.URLPattern) {
        const urlPatternModule = __webpack_require__(2956);
        ponyfills.URLPattern = urlPatternModule.URLPattern;
    }
    // Bun and Deno already have a Fetch API
    if (globalThis.Deno || process.versions.bun) {
        return globalThis;
    }
    const newNodeFetch = __webpack_require__(985);
    ponyfills.fetch = newNodeFetch.fetch;
    ponyfills.Request = newNodeFetch.Request;
    ponyfills.Response = newNodeFetch.Response;
    ponyfills.Headers = newNodeFetch.Headers;
    ponyfills.FormData = newNodeFetch.FormData;
    ponyfills.AbortController = newNodeFetch.AbortController;
    ponyfills.ReadableStream = newNodeFetch.ReadableStream;
    ponyfills.URL = newNodeFetch.URL;
    ponyfills.URLSearchParams = newNodeFetch.URLSearchParams;
    ponyfills.WritableStream = globalThis.WritableStream;
    ponyfills.TransformStream = globalThis.TransformStream;
    if (!ponyfills.WritableStream) {
        try {
            const streamsWeb = __webpack_require__(5356);
            ponyfills.WritableStream = streamsWeb.WritableStream;
            ponyfills.TransformStream = streamsWeb.TransformStream;
        } catch (e) {
            const streamsWeb = __webpack_require__(896);
            ponyfills.WritableStream = streamsWeb.WritableStream;
            ponyfills.TransformStream = streamsWeb.TransformStream;
        }
    }
    ponyfills.Blob = newNodeFetch.Blob;
    ponyfills.File = newNodeFetch.File;
    ponyfills.crypto = globalThis.crypto;
    ponyfills.btoa = newNodeFetch.btoa;
    ponyfills.TextEncoder = newNodeFetch.TextEncoder;
    ponyfills.TextDecoder = newNodeFetch.TextDecoder;
    ponyfills.AbortSignal = newNodeFetch.AbortSignal;
    if (opts.formDataLimits) {
        ponyfills.Body = class Body extends newNodeFetch.Body {
            constructor(body, userOpts){
                super(body, {
                    formDataLimits: opts.formDataLimits,
                    ...userOpts
                });
            }
        };
        ponyfills.Request = class Request extends newNodeFetch.Request {
            constructor(input, userOpts){
                super(input, {
                    formDataLimits: opts.formDataLimits,
                    ...userOpts
                });
            }
        };
        ponyfills.Response = class Response extends newNodeFetch.Response {
            constructor(body, userOpts){
                super(body, {
                    formDataLimits: opts.formDataLimits,
                    ...userOpts
                });
            }
        };
    }
    if (!ponyfills.crypto) {
        const cryptoModule = __webpack_require__(6113);
        ponyfills.crypto = cryptoModule.webcrypto;
    }
    if (!ponyfills.crypto) {
        const cryptoPonyfill = __webpack_require__(7356);
        ponyfills.crypto = new cryptoPonyfill.Crypto();
    }
    return ponyfills;
};


/***/ }),

/***/ 8130:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

const createNodePonyfill = __webpack_require__(8246);
const ponyfills = createNodePonyfill();
module.exports.fetch = ponyfills.fetch;
module.exports.Headers = ponyfills.Headers;
module.exports.Request = ponyfills.Request;
module.exports.Response = ponyfills.Response;
module.exports.FormData = ponyfills.FormData;
module.exports.AbortSignal = ponyfills.AbortSignal;
module.exports.AbortController = ponyfills.AbortController;
module.exports.ReadableStream = ponyfills.ReadableStream;
module.exports.WritableStream = ponyfills.WritableStream;
module.exports.TransformStream = ponyfills.TransformStream;
module.exports.Blob = ponyfills.Blob;
module.exports.File = ponyfills.File;
module.exports.crypto = ponyfills.crypto;
module.exports.btoa = ponyfills.btoa;
module.exports.TextEncoder = ponyfills.TextEncoder;
module.exports.TextDecoder = ponyfills.TextDecoder;
module.exports.URLPattern = ponyfills.URLPattern;
module.exports.URL = ponyfills.URL;
module.exports.URLSearchParams = ponyfills.URLSearchParams;
exports.createFetch = createNodePonyfill;


/***/ }),

/***/ 3457:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*!
 * Copyright (c) 2014, GMO GlobalSign
 * Copyright (c) 2015-2022, Peculiar Ventures
 * All rights reserved.
 * 
 * Author 2014-2019, Yury Strozhevsky
 * 
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 * 
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * 
 * * Redistributions in binary form must reproduce the above copyright notice, this
 *   list of conditions and the following disclaimer in the documentation and/or
 *   other materials provided with the distribution.
 * 
 * * Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 */ 
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var pvtsutils = __webpack_require__(480);
var pvutils = __webpack_require__(1745);
function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function(k) {
            if (k !== "default") {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function() {
                        return e[k];
                    }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}
var pvtsutils__namespace = /*#__PURE__*/ _interopNamespace(pvtsutils);
var pvutils__namespace = /*#__PURE__*/ _interopNamespace(pvutils);
function assertBigInt() {
    if (typeof BigInt === "undefined") {
        throw new Error("BigInt is not defined. Your environment doesn't implement BigInt.");
    }
}
function concat(buffers) {
    let outputLength = 0;
    let prevLength = 0;
    for(let i = 0; i < buffers.length; i++){
        const buffer = buffers[i];
        outputLength += buffer.byteLength;
    }
    const retView = new Uint8Array(outputLength);
    for(let i = 0; i < buffers.length; i++){
        const buffer = buffers[i];
        retView.set(new Uint8Array(buffer), prevLength);
        prevLength += buffer.byteLength;
    }
    return retView.buffer;
}
function checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength) {
    if (!(inputBuffer instanceof Uint8Array)) {
        baseBlock.error = "Wrong parameter: inputBuffer must be 'Uint8Array'";
        return false;
    }
    if (!inputBuffer.byteLength) {
        baseBlock.error = "Wrong parameter: inputBuffer has zero length";
        return false;
    }
    if (inputOffset < 0) {
        baseBlock.error = "Wrong parameter: inputOffset less than zero";
        return false;
    }
    if (inputLength < 0) {
        baseBlock.error = "Wrong parameter: inputLength less than zero";
        return false;
    }
    if (inputBuffer.byteLength - inputOffset - inputLength < 0) {
        baseBlock.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
        return false;
    }
    return true;
}
class ViewWriter {
    constructor(){
        this.items = [];
    }
    write(buf) {
        this.items.push(buf);
    }
    final() {
        return concat(this.items);
    }
}
const powers2 = [
    new Uint8Array([
        1
    ])
];
const digitsString = "0123456789";
const NAME = "name";
const VALUE_HEX_VIEW = "valueHexView";
const IS_HEX_ONLY = "isHexOnly";
const ID_BLOCK = "idBlock";
const TAG_CLASS = "tagClass";
const TAG_NUMBER = "tagNumber";
const IS_CONSTRUCTED = "isConstructed";
const FROM_BER = "fromBER";
const TO_BER = "toBER";
const LOCAL = "local";
const EMPTY_STRING = "";
const EMPTY_BUFFER = new ArrayBuffer(0);
const EMPTY_VIEW = new Uint8Array(0);
const END_OF_CONTENT_NAME = "EndOfContent";
const OCTET_STRING_NAME = "OCTET STRING";
const BIT_STRING_NAME = "BIT STRING";
function HexBlock(BaseClass) {
    var _a;
    return _a = class Some extends BaseClass {
        constructor(...args){
            var _a;
            super(...args);
            const params = args[0] || {};
            this.isHexOnly = (_a = params.isHexOnly) !== null && _a !== void 0 ? _a : false;
            this.valueHexView = params.valueHex ? pvtsutils__namespace.BufferSourceConverter.toUint8Array(params.valueHex) : EMPTY_VIEW;
        }
        get valueHex() {
            return this.valueHexView.slice().buffer;
        }
        set valueHex(value) {
            this.valueHexView = new Uint8Array(value);
        }
        fromBER(inputBuffer, inputOffset, inputLength) {
            const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;
            if (!checkBufferParams(this, view, inputOffset, inputLength)) {
                return -1;
            }
            const endLength = inputOffset + inputLength;
            this.valueHexView = view.subarray(inputOffset, endLength);
            if (!this.valueHexView.length) {
                this.warnings.push("Zero buffer length");
                return inputOffset;
            }
            this.blockLength = inputLength;
            return endLength;
        }
        toBER(sizeOnly = false) {
            if (!this.isHexOnly) {
                this.error = "Flag 'isHexOnly' is not set, abort";
                return EMPTY_BUFFER;
            }
            if (sizeOnly) {
                return new ArrayBuffer(this.valueHexView.byteLength);
            }
            return this.valueHexView.byteLength === this.valueHexView.buffer.byteLength ? this.valueHexView.buffer : this.valueHexView.slice().buffer;
        }
        toJSON() {
            return {
                ...super.toJSON(),
                isHexOnly: this.isHexOnly,
                valueHex: pvtsutils__namespace.Convert.ToHex(this.valueHexView)
            };
        }
    }, _a.NAME = "hexBlock", _a;
}
class LocalBaseBlock {
    constructor({ blockLength =0 , error =EMPTY_STRING , warnings =[] , valueBeforeDecode =EMPTY_VIEW  } = {}){
        this.blockLength = blockLength;
        this.error = error;
        this.warnings = warnings;
        this.valueBeforeDecodeView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(valueBeforeDecode);
    }
    static blockName() {
        return this.NAME;
    }
    get valueBeforeDecode() {
        return this.valueBeforeDecodeView.slice().buffer;
    }
    set valueBeforeDecode(value) {
        this.valueBeforeDecodeView = new Uint8Array(value);
    }
    toJSON() {
        return {
            blockName: this.constructor.NAME,
            blockLength: this.blockLength,
            error: this.error,
            warnings: this.warnings,
            valueBeforeDecode: pvtsutils__namespace.Convert.ToHex(this.valueBeforeDecodeView)
        };
    }
}
LocalBaseBlock.NAME = "baseBlock";
class ValueBlock extends LocalBaseBlock {
    fromBER(inputBuffer, inputOffset, inputLength) {
        throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'");
    }
    toBER(sizeOnly, writer) {
        throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'");
    }
}
ValueBlock.NAME = "valueBlock";
class LocalIdentificationBlock extends HexBlock(LocalBaseBlock) {
    constructor({ idBlock ={}  } = {}){
        var _a, _b, _c, _d;
        super();
        if (idBlock) {
            this.isHexOnly = (_a = idBlock.isHexOnly) !== null && _a !== void 0 ? _a : false;
            this.valueHexView = idBlock.valueHex ? pvtsutils__namespace.BufferSourceConverter.toUint8Array(idBlock.valueHex) : EMPTY_VIEW;
            this.tagClass = (_b = idBlock.tagClass) !== null && _b !== void 0 ? _b : -1;
            this.tagNumber = (_c = idBlock.tagNumber) !== null && _c !== void 0 ? _c : -1;
            this.isConstructed = (_d = idBlock.isConstructed) !== null && _d !== void 0 ? _d : false;
        } else {
            this.tagClass = -1;
            this.tagNumber = -1;
            this.isConstructed = false;
        }
    }
    toBER(sizeOnly = false) {
        let firstOctet = 0;
        switch(this.tagClass){
            case 1:
                firstOctet |= 0x00;
                break;
            case 2:
                firstOctet |= 0x40;
                break;
            case 3:
                firstOctet |= 0x80;
                break;
            case 4:
                firstOctet |= 0xC0;
                break;
            default:
                this.error = "Unknown tag class";
                return EMPTY_BUFFER;
        }
        if (this.isConstructed) firstOctet |= 0x20;
        if (this.tagNumber < 31 && !this.isHexOnly) {
            const retView = new Uint8Array(1);
            if (!sizeOnly) {
                let number = this.tagNumber;
                number &= 0x1F;
                firstOctet |= number;
                retView[0] = firstOctet;
            }
            return retView.buffer;
        }
        if (!this.isHexOnly) {
            const encodedBuf = pvutils__namespace.utilToBase(this.tagNumber, 7);
            const encodedView = new Uint8Array(encodedBuf);
            const size = encodedBuf.byteLength;
            const retView = new Uint8Array(size + 1);
            retView[0] = firstOctet | 0x1F;
            if (!sizeOnly) {
                for(let i = 0; i < size - 1; i++)retView[i + 1] = encodedView[i] | 0x80;
                retView[size] = encodedView[size - 1];
            }
            return retView.buffer;
        }
        const retView = new Uint8Array(this.valueHexView.byteLength + 1);
        retView[0] = firstOctet | 0x1F;
        if (!sizeOnly) {
            const curView = this.valueHexView;
            for(let i = 0; i < curView.length - 1; i++)retView[i + 1] = curView[i] | 0x80;
            retView[this.valueHexView.byteLength] = curView[curView.length - 1];
        }
        return retView.buffer;
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        const inputView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer);
        if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
            return -1;
        }
        const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
        if (intBuffer.length === 0) {
            this.error = "Zero buffer length";
            return -1;
        }
        const tagClassMask = intBuffer[0] & 0xC0;
        switch(tagClassMask){
            case 0x00:
                this.tagClass = 1;
                break;
            case 0x40:
                this.tagClass = 2;
                break;
            case 0x80:
                this.tagClass = 3;
                break;
            case 0xC0:
                this.tagClass = 4;
                break;
            default:
                this.error = "Unknown tag class";
                return -1;
        }
        this.isConstructed = (intBuffer[0] & 0x20) === 0x20;
        this.isHexOnly = false;
        const tagNumberMask = intBuffer[0] & 0x1F;
        if (tagNumberMask !== 0x1F) {
            this.tagNumber = tagNumberMask;
            this.blockLength = 1;
        } else {
            let count = 1;
            let intTagNumberBuffer = this.valueHexView = new Uint8Array(255);
            let tagNumberBufferMaxLength = 255;
            while(intBuffer[count] & 0x80){
                intTagNumberBuffer[count - 1] = intBuffer[count] & 0x7F;
                count++;
                if (count >= intBuffer.length) {
                    this.error = "End of input reached before message was fully decoded";
                    return -1;
                }
                if (count === tagNumberBufferMaxLength) {
                    tagNumberBufferMaxLength += 255;
                    const tempBufferView = new Uint8Array(tagNumberBufferMaxLength);
                    for(let i = 0; i < intTagNumberBuffer.length; i++)tempBufferView[i] = intTagNumberBuffer[i];
                    intTagNumberBuffer = this.valueHexView = new Uint8Array(tagNumberBufferMaxLength);
                }
            }
            this.blockLength = count + 1;
            intTagNumberBuffer[count - 1] = intBuffer[count] & 0x7F;
            const tempBufferView = new Uint8Array(count);
            for(let i = 0; i < count; i++)tempBufferView[i] = intTagNumberBuffer[i];
            intTagNumberBuffer = this.valueHexView = new Uint8Array(count);
            intTagNumberBuffer.set(tempBufferView);
            if (this.blockLength <= 9) this.tagNumber = pvutils__namespace.utilFromBase(intTagNumberBuffer, 7);
            else {
                this.isHexOnly = true;
                this.warnings.push("Tag too long, represented as hex-coded");
            }
        }
        if (this.tagClass === 1 && this.isConstructed) {
            switch(this.tagNumber){
                case 1:
                case 2:
                case 5:
                case 6:
                case 9:
                case 13:
                case 14:
                case 23:
                case 24:
                case 31:
                case 32:
                case 33:
                case 34:
                    this.error = "Constructed encoding used for primitive type";
                    return -1;
            }
        }
        return inputOffset + this.blockLength;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            tagClass: this.tagClass,
            tagNumber: this.tagNumber,
            isConstructed: this.isConstructed
        };
    }
}
LocalIdentificationBlock.NAME = "identificationBlock";
class LocalLengthBlock extends LocalBaseBlock {
    constructor({ lenBlock ={}  } = {}){
        var _a, _b, _c;
        super();
        this.isIndefiniteForm = (_a = lenBlock.isIndefiniteForm) !== null && _a !== void 0 ? _a : false;
        this.longFormUsed = (_b = lenBlock.longFormUsed) !== null && _b !== void 0 ? _b : false;
        this.length = (_c = lenBlock.length) !== null && _c !== void 0 ? _c : 0;
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        const view = pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer);
        if (!checkBufferParams(this, view, inputOffset, inputLength)) {
            return -1;
        }
        const intBuffer = view.subarray(inputOffset, inputOffset + inputLength);
        if (intBuffer.length === 0) {
            this.error = "Zero buffer length";
            return -1;
        }
        if (intBuffer[0] === 0xFF) {
            this.error = "Length block 0xFF is reserved by standard";
            return -1;
        }
        this.isIndefiniteForm = intBuffer[0] === 0x80;
        if (this.isIndefiniteForm) {
            this.blockLength = 1;
            return inputOffset + this.blockLength;
        }
        this.longFormUsed = !!(intBuffer[0] & 0x80);
        if (this.longFormUsed === false) {
            this.length = intBuffer[0];
            this.blockLength = 1;
            return inputOffset + this.blockLength;
        }
        const count = intBuffer[0] & 0x7F;
        if (count > 8) {
            this.error = "Too big integer";
            return -1;
        }
        if (count + 1 > intBuffer.length) {
            this.error = "End of input reached before message was fully decoded";
            return -1;
        }
        const lenOffset = inputOffset + 1;
        const lengthBufferView = view.subarray(lenOffset, lenOffset + count);
        if (lengthBufferView[count - 1] === 0x00) this.warnings.push("Needlessly long encoded length");
        this.length = pvutils__namespace.utilFromBase(lengthBufferView, 8);
        if (this.longFormUsed && this.length <= 127) this.warnings.push("Unnecessary usage of long length form");
        this.blockLength = count + 1;
        return inputOffset + this.blockLength;
    }
    toBER(sizeOnly = false) {
        let retBuf;
        let retView;
        if (this.length > 127) this.longFormUsed = true;
        if (this.isIndefiniteForm) {
            retBuf = new ArrayBuffer(1);
            if (sizeOnly === false) {
                retView = new Uint8Array(retBuf);
                retView[0] = 0x80;
            }
            return retBuf;
        }
        if (this.longFormUsed) {
            const encodedBuf = pvutils__namespace.utilToBase(this.length, 8);
            if (encodedBuf.byteLength > 127) {
                this.error = "Too big length";
                return EMPTY_BUFFER;
            }
            retBuf = new ArrayBuffer(encodedBuf.byteLength + 1);
            if (sizeOnly) return retBuf;
            const encodedView = new Uint8Array(encodedBuf);
            retView = new Uint8Array(retBuf);
            retView[0] = encodedBuf.byteLength | 0x80;
            for(let i = 0; i < encodedBuf.byteLength; i++)retView[i + 1] = encodedView[i];
            return retBuf;
        }
        retBuf = new ArrayBuffer(1);
        if (sizeOnly === false) {
            retView = new Uint8Array(retBuf);
            retView[0] = this.length;
        }
        return retBuf;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            isIndefiniteForm: this.isIndefiniteForm,
            longFormUsed: this.longFormUsed,
            length: this.length
        };
    }
}
LocalLengthBlock.NAME = "lengthBlock";
const typeStore = {};
class BaseBlock extends LocalBaseBlock {
    constructor({ name =EMPTY_STRING , optional =false , primitiveSchema , ...parameters } = {}, valueBlockType){
        super(parameters);
        this.name = name;
        this.optional = optional;
        if (primitiveSchema) {
            this.primitiveSchema = primitiveSchema;
        }
        this.idBlock = new LocalIdentificationBlock(parameters);
        this.lenBlock = new LocalLengthBlock(parameters);
        this.valueBlock = valueBlockType ? new valueBlockType(parameters) : new ValueBlock(parameters);
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
        if (resultOffset === -1) {
            this.error = this.valueBlock.error;
            return resultOffset;
        }
        if (!this.idBlock.error.length) this.blockLength += this.idBlock.blockLength;
        if (!this.lenBlock.error.length) this.blockLength += this.lenBlock.blockLength;
        if (!this.valueBlock.error.length) this.blockLength += this.valueBlock.blockLength;
        return resultOffset;
    }
    toBER(sizeOnly, writer) {
        const _writer = writer || new ViewWriter();
        if (!writer) {
            prepareIndefiniteForm(this);
        }
        const idBlockBuf = this.idBlock.toBER(sizeOnly);
        _writer.write(idBlockBuf);
        if (this.lenBlock.isIndefiniteForm) {
            _writer.write(new Uint8Array([
                0x80
            ]).buffer);
            this.valueBlock.toBER(sizeOnly, _writer);
            _writer.write(new ArrayBuffer(2));
        } else {
            const valueBlockBuf = this.valueBlock.toBER(sizeOnly);
            this.lenBlock.length = valueBlockBuf.byteLength;
            const lenBlockBuf = this.lenBlock.toBER(sizeOnly);
            _writer.write(lenBlockBuf);
            _writer.write(valueBlockBuf);
        }
        if (!writer) {
            return _writer.final();
        }
        return EMPTY_BUFFER;
    }
    toJSON() {
        const object = {
            ...super.toJSON(),
            idBlock: this.idBlock.toJSON(),
            lenBlock: this.lenBlock.toJSON(),
            valueBlock: this.valueBlock.toJSON(),
            name: this.name,
            optional: this.optional
        };
        if (this.primitiveSchema) object.primitiveSchema = this.primitiveSchema.toJSON();
        return object;
    }
    toString(encoding = "ascii") {
        if (encoding === "ascii") {
            return this.onAsciiEncoding();
        }
        return pvtsutils__namespace.Convert.ToHex(this.toBER());
    }
    onAsciiEncoding() {
        return `${this.constructor.NAME} : ${pvtsutils__namespace.Convert.ToHex(this.valueBlock.valueBeforeDecodeView)}`;
    }
    isEqual(other) {
        if (this === other) {
            return true;
        }
        if (!(other instanceof this.constructor)) {
            return false;
        }
        const thisRaw = this.toBER();
        const otherRaw = other.toBER();
        return pvutils__namespace.isEqualBuffer(thisRaw, otherRaw);
    }
}
BaseBlock.NAME = "BaseBlock";
function prepareIndefiniteForm(baseBlock) {
    if (baseBlock instanceof typeStore.Constructed) {
        for (const value of baseBlock.valueBlock.value){
            if (prepareIndefiniteForm(value)) {
                baseBlock.lenBlock.isIndefiniteForm = true;
            }
        }
    }
    return !!baseBlock.lenBlock.isIndefiniteForm;
}
class BaseStringBlock extends BaseBlock {
    constructor({ value =EMPTY_STRING , ...parameters } = {}, stringValueBlockType){
        super(parameters, stringValueBlockType);
        if (value) {
            this.fromString(value);
        }
    }
    getValue() {
        return this.valueBlock.value;
    }
    setValue(value) {
        this.valueBlock.value = value;
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
        if (resultOffset === -1) {
            this.error = this.valueBlock.error;
            return resultOffset;
        }
        this.fromBuffer(this.valueBlock.valueHexView);
        if (!this.idBlock.error.length) this.blockLength += this.idBlock.blockLength;
        if (!this.lenBlock.error.length) this.blockLength += this.lenBlock.blockLength;
        if (!this.valueBlock.error.length) this.blockLength += this.valueBlock.blockLength;
        return resultOffset;
    }
    onAsciiEncoding() {
        return `${this.constructor.NAME} : '${this.valueBlock.value}'`;
    }
}
BaseStringBlock.NAME = "BaseStringBlock";
class LocalPrimitiveValueBlock extends HexBlock(ValueBlock) {
    constructor({ isHexOnly =true , ...parameters } = {}){
        super(parameters);
        this.isHexOnly = isHexOnly;
    }
}
LocalPrimitiveValueBlock.NAME = "PrimitiveValueBlock";
var _a$w;
class Primitive extends BaseBlock {
    constructor(parameters = {}){
        super(parameters, LocalPrimitiveValueBlock);
        this.idBlock.isConstructed = false;
    }
}
_a$w = Primitive;
(()=>{
    typeStore.Primitive = _a$w;
})();
Primitive.NAME = "PRIMITIVE";
function localChangeType(inputObject, newType) {
    if (inputObject instanceof newType) {
        return inputObject;
    }
    const newObject = new newType();
    newObject.idBlock = inputObject.idBlock;
    newObject.lenBlock = inputObject.lenBlock;
    newObject.warnings = inputObject.warnings;
    newObject.valueBeforeDecodeView = inputObject.valueBeforeDecodeView;
    return newObject;
}
function localFromBER(inputBuffer, inputOffset = 0, inputLength = inputBuffer.length) {
    const incomingOffset = inputOffset;
    let returnObject = new BaseBlock({}, ValueBlock);
    const baseBlock = new LocalBaseBlock();
    if (!checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength)) {
        returnObject.error = baseBlock.error;
        return {
            offset: -1,
            result: returnObject
        };
    }
    const intBuffer = inputBuffer.subarray(inputOffset, inputOffset + inputLength);
    if (!intBuffer.length) {
        returnObject.error = "Zero buffer length";
        return {
            offset: -1,
            result: returnObject
        };
    }
    let resultOffset = returnObject.idBlock.fromBER(inputBuffer, inputOffset, inputLength);
    if (returnObject.idBlock.warnings.length) {
        returnObject.warnings.concat(returnObject.idBlock.warnings);
    }
    if (resultOffset === -1) {
        returnObject.error = returnObject.idBlock.error;
        return {
            offset: -1,
            result: returnObject
        };
    }
    inputOffset = resultOffset;
    inputLength -= returnObject.idBlock.blockLength;
    resultOffset = returnObject.lenBlock.fromBER(inputBuffer, inputOffset, inputLength);
    if (returnObject.lenBlock.warnings.length) {
        returnObject.warnings.concat(returnObject.lenBlock.warnings);
    }
    if (resultOffset === -1) {
        returnObject.error = returnObject.lenBlock.error;
        return {
            offset: -1,
            result: returnObject
        };
    }
    inputOffset = resultOffset;
    inputLength -= returnObject.lenBlock.blockLength;
    if (!returnObject.idBlock.isConstructed && returnObject.lenBlock.isIndefiniteForm) {
        returnObject.error = "Indefinite length form used for primitive encoding form";
        return {
            offset: -1,
            result: returnObject
        };
    }
    let newASN1Type = BaseBlock;
    switch(returnObject.idBlock.tagClass){
        case 1:
            if (returnObject.idBlock.tagNumber >= 37 && returnObject.idBlock.isHexOnly === false) {
                returnObject.error = "UNIVERSAL 37 and upper tags are reserved by ASN.1 standard";
                return {
                    offset: -1,
                    result: returnObject
                };
            }
            switch(returnObject.idBlock.tagNumber){
                case 0:
                    if (returnObject.idBlock.isConstructed && returnObject.lenBlock.length > 0) {
                        returnObject.error = "Type [UNIVERSAL 0] is reserved";
                        return {
                            offset: -1,
                            result: returnObject
                        };
                    }
                    newASN1Type = typeStore.EndOfContent;
                    break;
                case 1:
                    newASN1Type = typeStore.Boolean;
                    break;
                case 2:
                    newASN1Type = typeStore.Integer;
                    break;
                case 3:
                    newASN1Type = typeStore.BitString;
                    break;
                case 4:
                    newASN1Type = typeStore.OctetString;
                    break;
                case 5:
                    newASN1Type = typeStore.Null;
                    break;
                case 6:
                    newASN1Type = typeStore.ObjectIdentifier;
                    break;
                case 10:
                    newASN1Type = typeStore.Enumerated;
                    break;
                case 12:
                    newASN1Type = typeStore.Utf8String;
                    break;
                case 13:
                    newASN1Type = typeStore.RelativeObjectIdentifier;
                    break;
                case 14:
                    newASN1Type = typeStore.TIME;
                    break;
                case 15:
                    returnObject.error = "[UNIVERSAL 15] is reserved by ASN.1 standard";
                    return {
                        offset: -1,
                        result: returnObject
                    };
                case 16:
                    newASN1Type = typeStore.Sequence;
                    break;
                case 17:
                    newASN1Type = typeStore.Set;
                    break;
                case 18:
                    newASN1Type = typeStore.NumericString;
                    break;
                case 19:
                    newASN1Type = typeStore.PrintableString;
                    break;
                case 20:
                    newASN1Type = typeStore.TeletexString;
                    break;
                case 21:
                    newASN1Type = typeStore.VideotexString;
                    break;
                case 22:
                    newASN1Type = typeStore.IA5String;
                    break;
                case 23:
                    newASN1Type = typeStore.UTCTime;
                    break;
                case 24:
                    newASN1Type = typeStore.GeneralizedTime;
                    break;
                case 25:
                    newASN1Type = typeStore.GraphicString;
                    break;
                case 26:
                    newASN1Type = typeStore.VisibleString;
                    break;
                case 27:
                    newASN1Type = typeStore.GeneralString;
                    break;
                case 28:
                    newASN1Type = typeStore.UniversalString;
                    break;
                case 29:
                    newASN1Type = typeStore.CharacterString;
                    break;
                case 30:
                    newASN1Type = typeStore.BmpString;
                    break;
                case 31:
                    newASN1Type = typeStore.DATE;
                    break;
                case 32:
                    newASN1Type = typeStore.TimeOfDay;
                    break;
                case 33:
                    newASN1Type = typeStore.DateTime;
                    break;
                case 34:
                    newASN1Type = typeStore.Duration;
                    break;
                default:
                    {
                        const newObject = returnObject.idBlock.isConstructed ? new typeStore.Constructed() : new typeStore.Primitive();
                        newObject.idBlock = returnObject.idBlock;
                        newObject.lenBlock = returnObject.lenBlock;
                        newObject.warnings = returnObject.warnings;
                        returnObject = newObject;
                    }
            }
            break;
        case 2:
        case 3:
        case 4:
        default:
            {
                newASN1Type = returnObject.idBlock.isConstructed ? typeStore.Constructed : typeStore.Primitive;
            }
    }
    returnObject = localChangeType(returnObject, newASN1Type);
    resultOffset = returnObject.fromBER(inputBuffer, inputOffset, returnObject.lenBlock.isIndefiniteForm ? inputLength : returnObject.lenBlock.length);
    returnObject.valueBeforeDecodeView = inputBuffer.subarray(incomingOffset, incomingOffset + returnObject.blockLength);
    return {
        offset: resultOffset,
        result: returnObject
    };
}
function fromBER(inputBuffer) {
    if (!inputBuffer.byteLength) {
        const result = new BaseBlock({}, ValueBlock);
        result.error = "Input buffer has zero length";
        return {
            offset: -1,
            result
        };
    }
    return localFromBER(pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer).slice(), 0, inputBuffer.byteLength);
}
function checkLen(indefiniteLength, length) {
    if (indefiniteLength) {
        return 1;
    }
    return length;
}
class LocalConstructedValueBlock extends ValueBlock {
    constructor({ value =[] , isIndefiniteForm =false , ...parameters } = {}){
        super(parameters);
        this.value = value;
        this.isIndefiniteForm = isIndefiniteForm;
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        const view = pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer);
        if (!checkBufferParams(this, view, inputOffset, inputLength)) {
            return -1;
        }
        this.valueBeforeDecodeView = view.subarray(inputOffset, inputOffset + inputLength);
        if (this.valueBeforeDecodeView.length === 0) {
            this.warnings.push("Zero buffer length");
            return inputOffset;
        }
        let currentOffset = inputOffset;
        while(checkLen(this.isIndefiniteForm, inputLength) > 0){
            const returnObject = localFromBER(view, currentOffset, inputLength);
            if (returnObject.offset === -1) {
                this.error = returnObject.result.error;
                this.warnings.concat(returnObject.result.warnings);
                return -1;
            }
            currentOffset = returnObject.offset;
            this.blockLength += returnObject.result.blockLength;
            inputLength -= returnObject.result.blockLength;
            this.value.push(returnObject.result);
            if (this.isIndefiniteForm && returnObject.result.constructor.NAME === END_OF_CONTENT_NAME) {
                break;
            }
        }
        if (this.isIndefiniteForm) {
            if (this.value[this.value.length - 1].constructor.NAME === END_OF_CONTENT_NAME) {
                this.value.pop();
            } else {
                this.warnings.push("No EndOfContent block encoded");
            }
        }
        return currentOffset;
    }
    toBER(sizeOnly, writer) {
        const _writer = writer || new ViewWriter();
        for(let i = 0; i < this.value.length; i++){
            this.value[i].toBER(sizeOnly, _writer);
        }
        if (!writer) {
            return _writer.final();
        }
        return EMPTY_BUFFER;
    }
    toJSON() {
        const object = {
            ...super.toJSON(),
            isIndefiniteForm: this.isIndefiniteForm,
            value: []
        };
        for (const value of this.value){
            object.value.push(value.toJSON());
        }
        return object;
    }
}
LocalConstructedValueBlock.NAME = "ConstructedValueBlock";
var _a$v;
class Constructed extends BaseBlock {
    constructor(parameters = {}){
        super(parameters, LocalConstructedValueBlock);
        this.idBlock.isConstructed = true;
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
        const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
        if (resultOffset === -1) {
            this.error = this.valueBlock.error;
            return resultOffset;
        }
        if (!this.idBlock.error.length) this.blockLength += this.idBlock.blockLength;
        if (!this.lenBlock.error.length) this.blockLength += this.lenBlock.blockLength;
        if (!this.valueBlock.error.length) this.blockLength += this.valueBlock.blockLength;
        return resultOffset;
    }
    onAsciiEncoding() {
        const values = [];
        for (const value of this.valueBlock.value){
            values.push(value.toString("ascii").split("\n").map((o)=>`  ${o}`).join("\n"));
        }
        const blockName = this.idBlock.tagClass === 3 ? `[${this.idBlock.tagNumber}]` : this.constructor.NAME;
        return values.length ? `${blockName} :\n${values.join("\n")}` : `${blockName} :`;
    }
}
_a$v = Constructed;
(()=>{
    typeStore.Constructed = _a$v;
})();
Constructed.NAME = "CONSTRUCTED";
class LocalEndOfContentValueBlock extends ValueBlock {
    fromBER(inputBuffer, inputOffset, inputLength) {
        return inputOffset;
    }
    toBER(sizeOnly) {
        return EMPTY_BUFFER;
    }
}
LocalEndOfContentValueBlock.override = "EndOfContentValueBlock";
var _a$u;
class EndOfContent extends BaseBlock {
    constructor(parameters = {}){
        super(parameters, LocalEndOfContentValueBlock);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 0;
    }
}
_a$u = EndOfContent;
(()=>{
    typeStore.EndOfContent = _a$u;
})();
EndOfContent.NAME = END_OF_CONTENT_NAME;
var _a$t;
class Null extends BaseBlock {
    constructor(parameters = {}){
        super(parameters, ValueBlock);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 5;
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        if (this.lenBlock.length > 0) this.warnings.push("Non-zero length of value block for Null type");
        if (!this.idBlock.error.length) this.blockLength += this.idBlock.blockLength;
        if (!this.lenBlock.error.length) this.blockLength += this.lenBlock.blockLength;
        this.blockLength += inputLength;
        if (inputOffset + inputLength > inputBuffer.byteLength) {
            this.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
            return -1;
        }
        return inputOffset + inputLength;
    }
    toBER(sizeOnly, writer) {
        const retBuf = new ArrayBuffer(2);
        if (!sizeOnly) {
            const retView = new Uint8Array(retBuf);
            retView[0] = 0x05;
            retView[1] = 0x00;
        }
        if (writer) {
            writer.write(retBuf);
        }
        return retBuf;
    }
    onAsciiEncoding() {
        return `${this.constructor.NAME}`;
    }
}
_a$t = Null;
(()=>{
    typeStore.Null = _a$t;
})();
Null.NAME = "NULL";
class LocalBooleanValueBlock extends HexBlock(ValueBlock) {
    constructor({ value , ...parameters } = {}){
        super(parameters);
        if (parameters.valueHex) {
            this.valueHexView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(parameters.valueHex);
        } else {
            this.valueHexView = new Uint8Array(1);
        }
        if (value) {
            this.value = value;
        }
    }
    get value() {
        for (const octet of this.valueHexView){
            if (octet > 0) {
                return true;
            }
        }
        return false;
    }
    set value(value) {
        this.valueHexView[0] = value ? 0xFF : 0x00;
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        const inputView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer);
        if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
            return -1;
        }
        this.valueHexView = inputView.subarray(inputOffset, inputOffset + inputLength);
        if (inputLength > 1) this.warnings.push("Boolean value encoded in more then 1 octet");
        this.isHexOnly = true;
        pvutils__namespace.utilDecodeTC.call(this);
        this.blockLength = inputLength;
        return inputOffset + inputLength;
    }
    toBER() {
        return this.valueHexView.slice();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            value: this.value
        };
    }
}
LocalBooleanValueBlock.NAME = "BooleanValueBlock";
var _a$s;
class Boolean extends BaseBlock {
    constructor(parameters = {}){
        super(parameters, LocalBooleanValueBlock);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 1;
    }
    getValue() {
        return this.valueBlock.value;
    }
    setValue(value) {
        this.valueBlock.value = value;
    }
    onAsciiEncoding() {
        return `${this.constructor.NAME} : ${this.getValue}`;
    }
}
_a$s = Boolean;
(()=>{
    typeStore.Boolean = _a$s;
})();
Boolean.NAME = "BOOLEAN";
class LocalOctetStringValueBlock extends HexBlock(LocalConstructedValueBlock) {
    constructor({ isConstructed =false , ...parameters } = {}){
        super(parameters);
        this.isConstructed = isConstructed;
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        let resultOffset = 0;
        if (this.isConstructed) {
            this.isHexOnly = false;
            resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);
            if (resultOffset === -1) return resultOffset;
            for(let i = 0; i < this.value.length; i++){
                const currentBlockName = this.value[i].constructor.NAME;
                if (currentBlockName === END_OF_CONTENT_NAME) {
                    if (this.isIndefiniteForm) break;
                    else {
                        this.error = "EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only";
                        return -1;
                    }
                }
                if (currentBlockName !== OCTET_STRING_NAME) {
                    this.error = "OCTET STRING may consists of OCTET STRINGs only";
                    return -1;
                }
            }
        } else {
            this.isHexOnly = true;
            resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);
            this.blockLength = inputLength;
        }
        return resultOffset;
    }
    toBER(sizeOnly, writer) {
        if (this.isConstructed) return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly, writer);
        return sizeOnly ? new ArrayBuffer(this.valueHexView.byteLength) : this.valueHexView.slice().buffer;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            isConstructed: this.isConstructed
        };
    }
}
LocalOctetStringValueBlock.NAME = "OctetStringValueBlock";
var _a$r;
class OctetString extends BaseBlock {
    constructor({ idBlock ={} , lenBlock ={} , ...parameters } = {}){
        var _b, _c;
        (_b = parameters.isConstructed) !== null && _b !== void 0 ? _b : parameters.isConstructed = !!((_c = parameters.value) === null || _c === void 0 ? void 0 : _c.length);
        super({
            idBlock: {
                isConstructed: parameters.isConstructed,
                ...idBlock
            },
            lenBlock: {
                ...lenBlock,
                isIndefiniteForm: !!parameters.isIndefiniteForm
            },
            ...parameters
        }, LocalOctetStringValueBlock);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 4;
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        this.valueBlock.isConstructed = this.idBlock.isConstructed;
        this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
        if (inputLength === 0) {
            if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;
            if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;
            return inputOffset;
        }
        if (!this.valueBlock.isConstructed) {
            const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;
            const buf = view.subarray(inputOffset, inputOffset + inputLength);
            try {
                if (buf.byteLength) {
                    const asn = localFromBER(buf, 0, buf.byteLength);
                    if (asn.offset !== -1 && asn.offset === inputLength) {
                        this.valueBlock.value = [
                            asn.result
                        ];
                    }
                }
            } catch (e) {}
        }
        return super.fromBER(inputBuffer, inputOffset, inputLength);
    }
    onAsciiEncoding() {
        if (this.valueBlock.isConstructed || this.valueBlock.value && this.valueBlock.value.length) {
            return Constructed.prototype.onAsciiEncoding.call(this);
        }
        return `${this.constructor.NAME} : ${pvtsutils__namespace.Convert.ToHex(this.valueBlock.valueHexView)}`;
    }
    getValue() {
        if (!this.idBlock.isConstructed) {
            return this.valueBlock.valueHexView.slice().buffer;
        }
        const array = [];
        for (const content of this.valueBlock.value){
            if (content instanceof OctetString) {
                array.push(content.valueBlock.valueHexView);
            }
        }
        return pvtsutils__namespace.BufferSourceConverter.concat(array);
    }
}
_a$r = OctetString;
(()=>{
    typeStore.OctetString = _a$r;
})();
OctetString.NAME = OCTET_STRING_NAME;
class LocalBitStringValueBlock extends HexBlock(LocalConstructedValueBlock) {
    constructor({ unusedBits =0 , isConstructed =false , ...parameters } = {}){
        super(parameters);
        this.unusedBits = unusedBits;
        this.isConstructed = isConstructed;
        this.blockLength = this.valueHexView.byteLength;
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        if (!inputLength) {
            return inputOffset;
        }
        let resultOffset = -1;
        if (this.isConstructed) {
            resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);
            if (resultOffset === -1) return resultOffset;
            for (const value of this.value){
                const currentBlockName = value.constructor.NAME;
                if (currentBlockName === END_OF_CONTENT_NAME) {
                    if (this.isIndefiniteForm) break;
                    else {
                        this.error = "EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only";
                        return -1;
                    }
                }
                if (currentBlockName !== BIT_STRING_NAME) {
                    this.error = "BIT STRING may consists of BIT STRINGs only";
                    return -1;
                }
                const valueBlock = value.valueBlock;
                if (this.unusedBits > 0 && valueBlock.unusedBits > 0) {
                    this.error = 'Using of "unused bits" inside constructive BIT STRING allowed for least one only';
                    return -1;
                }
                this.unusedBits = valueBlock.unusedBits;
            }
            return resultOffset;
        }
        const inputView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer);
        if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
            return -1;
        }
        const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
        this.unusedBits = intBuffer[0];
        if (this.unusedBits > 7) {
            this.error = "Unused bits for BitString must be in range 0-7";
            return -1;
        }
        if (!this.unusedBits) {
            const buf = intBuffer.subarray(1);
            try {
                if (buf.byteLength) {
                    const asn = localFromBER(buf, 0, buf.byteLength);
                    if (asn.offset !== -1 && asn.offset === inputLength - 1) {
                        this.value = [
                            asn.result
                        ];
                    }
                }
            } catch (e) {}
        }
        this.valueHexView = intBuffer.subarray(1);
        this.blockLength = intBuffer.length;
        return inputOffset + inputLength;
    }
    toBER(sizeOnly, writer) {
        if (this.isConstructed) {
            return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly, writer);
        }
        if (sizeOnly) {
            return new ArrayBuffer(this.valueHexView.byteLength + 1);
        }
        if (!this.valueHexView.byteLength) {
            return EMPTY_BUFFER;
        }
        const retView = new Uint8Array(this.valueHexView.length + 1);
        retView[0] = this.unusedBits;
        retView.set(this.valueHexView, 1);
        return retView.buffer;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            unusedBits: this.unusedBits,
            isConstructed: this.isConstructed
        };
    }
}
LocalBitStringValueBlock.NAME = "BitStringValueBlock";
var _a$q;
class BitString extends BaseBlock {
    constructor({ idBlock ={} , lenBlock ={} , ...parameters } = {}){
        var _b, _c;
        (_b = parameters.isConstructed) !== null && _b !== void 0 ? _b : parameters.isConstructed = !!((_c = parameters.value) === null || _c === void 0 ? void 0 : _c.length);
        super({
            idBlock: {
                isConstructed: parameters.isConstructed,
                ...idBlock
            },
            lenBlock: {
                ...lenBlock,
                isIndefiniteForm: !!parameters.isIndefiniteForm
            },
            ...parameters
        }, LocalBitStringValueBlock);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 3;
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        this.valueBlock.isConstructed = this.idBlock.isConstructed;
        this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
        return super.fromBER(inputBuffer, inputOffset, inputLength);
    }
    onAsciiEncoding() {
        if (this.valueBlock.isConstructed || this.valueBlock.value && this.valueBlock.value.length) {
            return Constructed.prototype.onAsciiEncoding.call(this);
        } else {
            const bits = [];
            const valueHex = this.valueBlock.valueHexView;
            for (const byte of valueHex){
                bits.push(byte.toString(2).padStart(8, "0"));
            }
            const bitsStr = bits.join("");
            return `${this.constructor.NAME} : ${bitsStr.substring(0, bitsStr.length - this.valueBlock.unusedBits)}`;
        }
    }
}
_a$q = BitString;
(()=>{
    typeStore.BitString = _a$q;
})();
BitString.NAME = BIT_STRING_NAME;
var _a$p;
function viewAdd(first, second) {
    const c = new Uint8Array([
        0
    ]);
    const firstView = new Uint8Array(first);
    const secondView = new Uint8Array(second);
    let firstViewCopy = firstView.slice(0);
    const firstViewCopyLength = firstViewCopy.length - 1;
    const secondViewCopy = secondView.slice(0);
    const secondViewCopyLength = secondViewCopy.length - 1;
    let value = 0;
    const max = secondViewCopyLength < firstViewCopyLength ? firstViewCopyLength : secondViewCopyLength;
    let counter = 0;
    for(let i = max; i >= 0; i--, counter++){
        switch(true){
            case counter < secondViewCopy.length:
                value = firstViewCopy[firstViewCopyLength - counter] + secondViewCopy[secondViewCopyLength - counter] + c[0];
                break;
            default:
                value = firstViewCopy[firstViewCopyLength - counter] + c[0];
        }
        c[0] = value / 10;
        switch(true){
            case counter >= firstViewCopy.length:
                firstViewCopy = pvutils__namespace.utilConcatView(new Uint8Array([
                    value % 10
                ]), firstViewCopy);
                break;
            default:
                firstViewCopy[firstViewCopyLength - counter] = value % 10;
        }
    }
    if (c[0] > 0) firstViewCopy = pvutils__namespace.utilConcatView(c, firstViewCopy);
    return firstViewCopy;
}
function power2(n) {
    if (n >= powers2.length) {
        for(let p = powers2.length; p <= n; p++){
            const c = new Uint8Array([
                0
            ]);
            let digits = powers2[p - 1].slice(0);
            for(let i = digits.length - 1; i >= 0; i--){
                const newValue = new Uint8Array([
                    (digits[i] << 1) + c[0]
                ]);
                c[0] = newValue[0] / 10;
                digits[i] = newValue[0] % 10;
            }
            if (c[0] > 0) digits = pvutils__namespace.utilConcatView(c, digits);
            powers2.push(digits);
        }
    }
    return powers2[n];
}
function viewSub(first, second) {
    let b = 0;
    const firstView = new Uint8Array(first);
    const secondView = new Uint8Array(second);
    const firstViewCopy = firstView.slice(0);
    const firstViewCopyLength = firstViewCopy.length - 1;
    const secondViewCopy = secondView.slice(0);
    const secondViewCopyLength = secondViewCopy.length - 1;
    let value;
    let counter = 0;
    for(let i = secondViewCopyLength; i >= 0; i--, counter++){
        value = firstViewCopy[firstViewCopyLength - counter] - secondViewCopy[secondViewCopyLength - counter] - b;
        switch(true){
            case value < 0:
                b = 1;
                firstViewCopy[firstViewCopyLength - counter] = value + 10;
                break;
            default:
                b = 0;
                firstViewCopy[firstViewCopyLength - counter] = value;
        }
    }
    if (b > 0) {
        for(let i = firstViewCopyLength - secondViewCopyLength + 1; i >= 0; i--, counter++){
            value = firstViewCopy[firstViewCopyLength - counter] - b;
            if (value < 0) {
                b = 1;
                firstViewCopy[firstViewCopyLength - counter] = value + 10;
            } else {
                b = 0;
                firstViewCopy[firstViewCopyLength - counter] = value;
                break;
            }
        }
    }
    return firstViewCopy.slice();
}
class LocalIntegerValueBlock extends HexBlock(ValueBlock) {
    constructor({ value , ...parameters } = {}){
        super(parameters);
        this._valueDec = 0;
        if (parameters.valueHex) {
            this.setValueHex();
        }
        if (value !== undefined) {
            this.valueDec = value;
        }
    }
    setValueHex() {
        if (this.valueHexView.length >= 4) {
            this.warnings.push("Too big Integer for decoding, hex only");
            this.isHexOnly = true;
            this._valueDec = 0;
        } else {
            this.isHexOnly = false;
            if (this.valueHexView.length > 0) {
                this._valueDec = pvutils__namespace.utilDecodeTC.call(this);
            }
        }
    }
    set valueDec(v) {
        this._valueDec = v;
        this.isHexOnly = false;
        this.valueHexView = new Uint8Array(pvutils__namespace.utilEncodeTC(v));
    }
    get valueDec() {
        return this._valueDec;
    }
    fromDER(inputBuffer, inputOffset, inputLength, expectedLength = 0) {
        const offset = this.fromBER(inputBuffer, inputOffset, inputLength);
        if (offset === -1) return offset;
        const view = this.valueHexView;
        if (view[0] === 0x00 && (view[1] & 0x80) !== 0) {
            this.valueHexView = view.subarray(1);
        } else {
            if (expectedLength !== 0) {
                if (view.length < expectedLength) {
                    if (expectedLength - view.length > 1) expectedLength = view.length + 1;
                    this.valueHexView = view.subarray(expectedLength - view.length);
                }
            }
        }
        return offset;
    }
    toDER(sizeOnly = false) {
        const view = this.valueHexView;
        switch(true){
            case (view[0] & 0x80) !== 0:
                {
                    const updatedView = new Uint8Array(this.valueHexView.length + 1);
                    updatedView[0] = 0x00;
                    updatedView.set(view, 1);
                    this.valueHexView = updatedView;
                }
                break;
            case view[0] === 0x00 && (view[1] & 0x80) === 0:
                {
                    this.valueHexView = this.valueHexView.subarray(1);
                }
                break;
        }
        return this.toBER(sizeOnly);
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        const resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);
        if (resultOffset === -1) {
            return resultOffset;
        }
        this.setValueHex();
        return resultOffset;
    }
    toBER(sizeOnly) {
        return sizeOnly ? new ArrayBuffer(this.valueHexView.length) : this.valueHexView.slice().buffer;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            valueDec: this.valueDec
        };
    }
    toString() {
        const firstBit = this.valueHexView.length * 8 - 1;
        let digits = new Uint8Array(this.valueHexView.length * 8 / 3);
        let bitNumber = 0;
        let currentByte;
        const asn1View = this.valueHexView;
        let result = "";
        let flag = false;
        for(let byteNumber = asn1View.byteLength - 1; byteNumber >= 0; byteNumber--){
            currentByte = asn1View[byteNumber];
            for(let i = 0; i < 8; i++){
                if ((currentByte & 1) === 1) {
                    switch(bitNumber){
                        case firstBit:
                            digits = viewSub(power2(bitNumber), digits);
                            result = "-";
                            break;
                        default:
                            digits = viewAdd(digits, power2(bitNumber));
                    }
                }
                bitNumber++;
                currentByte >>= 1;
            }
        }
        for(let i = 0; i < digits.length; i++){
            if (digits[i]) flag = true;
            if (flag) result += digitsString.charAt(digits[i]);
        }
        if (flag === false) result += digitsString.charAt(0);
        return result;
    }
}
_a$p = LocalIntegerValueBlock;
LocalIntegerValueBlock.NAME = "IntegerValueBlock";
(()=>{
    Object.defineProperty(_a$p.prototype, "valueHex", {
        set: function(v) {
            this.valueHexView = new Uint8Array(v);
            this.setValueHex();
        },
        get: function() {
            return this.valueHexView.slice().buffer;
        }
    });
})();
var _a$o;
class Integer extends BaseBlock {
    constructor(parameters = {}){
        super(parameters, LocalIntegerValueBlock);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 2;
    }
    toBigInt() {
        assertBigInt();
        return BigInt(this.valueBlock.toString());
    }
    static fromBigInt(value) {
        assertBigInt();
        const bigIntValue = BigInt(value);
        const writer = new ViewWriter();
        const hex = bigIntValue.toString(16).replace(/^-/, "");
        const view = new Uint8Array(pvtsutils__namespace.Convert.FromHex(hex));
        if (bigIntValue < 0) {
            const first = new Uint8Array(view.length + (view[0] & 0x80 ? 1 : 0));
            first[0] |= 0x80;
            const firstInt = BigInt(`0x${pvtsutils__namespace.Convert.ToHex(first)}`);
            const secondInt = firstInt + bigIntValue;
            const second = pvtsutils__namespace.BufferSourceConverter.toUint8Array(pvtsutils__namespace.Convert.FromHex(secondInt.toString(16)));
            second[0] |= 0x80;
            writer.write(second);
        } else {
            if (view[0] & 0x80) {
                writer.write(new Uint8Array([
                    0
                ]));
            }
            writer.write(view);
        }
        const res = new Integer({
            valueHex: writer.final()
        });
        return res;
    }
    convertToDER() {
        const integer = new Integer({
            valueHex: this.valueBlock.valueHexView
        });
        integer.valueBlock.toDER();
        return integer;
    }
    convertFromDER() {
        return new Integer({
            valueHex: this.valueBlock.valueHexView[0] === 0 ? this.valueBlock.valueHexView.subarray(1) : this.valueBlock.valueHexView
        });
    }
    onAsciiEncoding() {
        return `${this.constructor.NAME} : ${this.valueBlock.toString()}`;
    }
}
_a$o = Integer;
(()=>{
    typeStore.Integer = _a$o;
})();
Integer.NAME = "INTEGER";
var _a$n;
class Enumerated extends Integer {
    constructor(parameters = {}){
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 10;
    }
}
_a$n = Enumerated;
(()=>{
    typeStore.Enumerated = _a$n;
})();
Enumerated.NAME = "ENUMERATED";
class LocalSidValueBlock extends HexBlock(ValueBlock) {
    constructor({ valueDec =-1 , isFirstSid =false , ...parameters } = {}){
        super(parameters);
        this.valueDec = valueDec;
        this.isFirstSid = isFirstSid;
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        if (!inputLength) {
            return inputOffset;
        }
        const inputView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer);
        if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
            return -1;
        }
        const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
        this.valueHexView = new Uint8Array(inputLength);
        for(let i = 0; i < inputLength; i++){
            this.valueHexView[i] = intBuffer[i] & 0x7F;
            this.blockLength++;
            if ((intBuffer[i] & 0x80) === 0x00) break;
        }
        const tempView = new Uint8Array(this.blockLength);
        for(let i = 0; i < this.blockLength; i++){
            tempView[i] = this.valueHexView[i];
        }
        this.valueHexView = tempView;
        if ((intBuffer[this.blockLength - 1] & 0x80) !== 0x00) {
            this.error = "End of input reached before message was fully decoded";
            return -1;
        }
        if (this.valueHexView[0] === 0x00) this.warnings.push("Needlessly long format of SID encoding");
        if (this.blockLength <= 8) this.valueDec = pvutils__namespace.utilFromBase(this.valueHexView, 7);
        else {
            this.isHexOnly = true;
            this.warnings.push("Too big SID for decoding, hex only");
        }
        return inputOffset + this.blockLength;
    }
    set valueBigInt(value) {
        assertBigInt();
        let bits = BigInt(value).toString(2);
        while(bits.length % 7){
            bits = "0" + bits;
        }
        const bytes = new Uint8Array(bits.length / 7);
        for(let i = 0; i < bytes.length; i++){
            bytes[i] = parseInt(bits.slice(i * 7, i * 7 + 7), 2) + (i + 1 < bytes.length ? 0x80 : 0);
        }
        this.fromBER(bytes.buffer, 0, bytes.length);
    }
    toBER(sizeOnly) {
        if (this.isHexOnly) {
            if (sizeOnly) return new ArrayBuffer(this.valueHexView.byteLength);
            const curView = this.valueHexView;
            const retView = new Uint8Array(this.blockLength);
            for(let i = 0; i < this.blockLength - 1; i++)retView[i] = curView[i] | 0x80;
            retView[this.blockLength - 1] = curView[this.blockLength - 1];
            return retView.buffer;
        }
        const encodedBuf = pvutils__namespace.utilToBase(this.valueDec, 7);
        if (encodedBuf.byteLength === 0) {
            this.error = "Error during encoding SID value";
            return EMPTY_BUFFER;
        }
        const retView = new Uint8Array(encodedBuf.byteLength);
        if (!sizeOnly) {
            const encodedView = new Uint8Array(encodedBuf);
            const len = encodedBuf.byteLength - 1;
            for(let i = 0; i < len; i++)retView[i] = encodedView[i] | 0x80;
            retView[len] = encodedView[len];
        }
        return retView;
    }
    toString() {
        let result = "";
        if (this.isHexOnly) result = pvtsutils__namespace.Convert.ToHex(this.valueHexView);
        else {
            if (this.isFirstSid) {
                let sidValue = this.valueDec;
                if (this.valueDec <= 39) result = "0.";
                else {
                    if (this.valueDec <= 79) {
                        result = "1.";
                        sidValue -= 40;
                    } else {
                        result = "2.";
                        sidValue -= 80;
                    }
                }
                result += sidValue.toString();
            } else result = this.valueDec.toString();
        }
        return result;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            valueDec: this.valueDec,
            isFirstSid: this.isFirstSid
        };
    }
}
LocalSidValueBlock.NAME = "sidBlock";
class LocalObjectIdentifierValueBlock extends ValueBlock {
    constructor({ value =EMPTY_STRING , ...parameters } = {}){
        super(parameters);
        this.value = [];
        if (value) {
            this.fromString(value);
        }
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        let resultOffset = inputOffset;
        while(inputLength > 0){
            const sidBlock = new LocalSidValueBlock();
            resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);
            if (resultOffset === -1) {
                this.blockLength = 0;
                this.error = sidBlock.error;
                return resultOffset;
            }
            if (this.value.length === 0) sidBlock.isFirstSid = true;
            this.blockLength += sidBlock.blockLength;
            inputLength -= sidBlock.blockLength;
            this.value.push(sidBlock);
        }
        return resultOffset;
    }
    toBER(sizeOnly) {
        const retBuffers = [];
        for(let i = 0; i < this.value.length; i++){
            const valueBuf = this.value[i].toBER(sizeOnly);
            if (valueBuf.byteLength === 0) {
                this.error = this.value[i].error;
                return EMPTY_BUFFER;
            }
            retBuffers.push(valueBuf);
        }
        return concat(retBuffers);
    }
    fromString(string) {
        this.value = [];
        let pos1 = 0;
        let pos2 = 0;
        let sid = "";
        let flag = false;
        do {
            pos2 = string.indexOf(".", pos1);
            if (pos2 === -1) sid = string.substring(pos1);
            else sid = string.substring(pos1, pos2);
            pos1 = pos2 + 1;
            if (flag) {
                const sidBlock = this.value[0];
                let plus = 0;
                switch(sidBlock.valueDec){
                    case 0:
                        break;
                    case 1:
                        plus = 40;
                        break;
                    case 2:
                        plus = 80;
                        break;
                    default:
                        this.value = [];
                        return;
                }
                const parsedSID = parseInt(sid, 10);
                if (isNaN(parsedSID)) return;
                sidBlock.valueDec = parsedSID + plus;
                flag = false;
            } else {
                const sidBlock = new LocalSidValueBlock();
                if (sid > Number.MAX_SAFE_INTEGER) {
                    assertBigInt();
                    const sidValue = BigInt(sid);
                    sidBlock.valueBigInt = sidValue;
                } else {
                    sidBlock.valueDec = parseInt(sid, 10);
                    if (isNaN(sidBlock.valueDec)) return;
                }
                if (!this.value.length) {
                    sidBlock.isFirstSid = true;
                    flag = true;
                }
                this.value.push(sidBlock);
            }
        }while (pos2 !== -1);
    }
    toString() {
        let result = "";
        let isHexOnly = false;
        for(let i = 0; i < this.value.length; i++){
            isHexOnly = this.value[i].isHexOnly;
            let sidStr = this.value[i].toString();
            if (i !== 0) result = `${result}.`;
            if (isHexOnly) {
                sidStr = `{${sidStr}}`;
                if (this.value[i].isFirstSid) result = `2.{${sidStr} - 80}`;
                else result += sidStr;
            } else result += sidStr;
        }
        return result;
    }
    toJSON() {
        const object = {
            ...super.toJSON(),
            value: this.toString(),
            sidArray: []
        };
        for(let i = 0; i < this.value.length; i++){
            object.sidArray.push(this.value[i].toJSON());
        }
        return object;
    }
}
LocalObjectIdentifierValueBlock.NAME = "ObjectIdentifierValueBlock";
var _a$m;
class ObjectIdentifier extends BaseBlock {
    constructor(parameters = {}){
        super(parameters, LocalObjectIdentifierValueBlock);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 6;
    }
    getValue() {
        return this.valueBlock.toString();
    }
    setValue(value) {
        this.valueBlock.fromString(value);
    }
    onAsciiEncoding() {
        return `${this.constructor.NAME} : ${this.valueBlock.toString() || "empty"}`;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            value: this.getValue()
        };
    }
}
_a$m = ObjectIdentifier;
(()=>{
    typeStore.ObjectIdentifier = _a$m;
})();
ObjectIdentifier.NAME = "OBJECT IDENTIFIER";
class LocalRelativeSidValueBlock extends HexBlock(LocalBaseBlock) {
    constructor({ valueDec =0 , ...parameters } = {}){
        super(parameters);
        this.valueDec = valueDec;
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        if (inputLength === 0) return inputOffset;
        const inputView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer);
        if (!checkBufferParams(this, inputView, inputOffset, inputLength)) return -1;
        const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
        this.valueHexView = new Uint8Array(inputLength);
        for(let i = 0; i < inputLength; i++){
            this.valueHexView[i] = intBuffer[i] & 0x7F;
            this.blockLength++;
            if ((intBuffer[i] & 0x80) === 0x00) break;
        }
        const tempView = new Uint8Array(this.blockLength);
        for(let i = 0; i < this.blockLength; i++)tempView[i] = this.valueHexView[i];
        this.valueHexView = tempView;
        if ((intBuffer[this.blockLength - 1] & 0x80) !== 0x00) {
            this.error = "End of input reached before message was fully decoded";
            return -1;
        }
        if (this.valueHexView[0] === 0x00) this.warnings.push("Needlessly long format of SID encoding");
        if (this.blockLength <= 8) this.valueDec = pvutils__namespace.utilFromBase(this.valueHexView, 7);
        else {
            this.isHexOnly = true;
            this.warnings.push("Too big SID for decoding, hex only");
        }
        return inputOffset + this.blockLength;
    }
    toBER(sizeOnly) {
        if (this.isHexOnly) {
            if (sizeOnly) return new ArrayBuffer(this.valueHexView.byteLength);
            const curView = this.valueHexView;
            const retView = new Uint8Array(this.blockLength);
            for(let i = 0; i < this.blockLength - 1; i++)retView[i] = curView[i] | 0x80;
            retView[this.blockLength - 1] = curView[this.blockLength - 1];
            return retView.buffer;
        }
        const encodedBuf = pvutils__namespace.utilToBase(this.valueDec, 7);
        if (encodedBuf.byteLength === 0) {
            this.error = "Error during encoding SID value";
            return EMPTY_BUFFER;
        }
        const retView = new Uint8Array(encodedBuf.byteLength);
        if (!sizeOnly) {
            const encodedView = new Uint8Array(encodedBuf);
            const len = encodedBuf.byteLength - 1;
            for(let i = 0; i < len; i++)retView[i] = encodedView[i] | 0x80;
            retView[len] = encodedView[len];
        }
        return retView.buffer;
    }
    toString() {
        let result = "";
        if (this.isHexOnly) result = pvtsutils__namespace.Convert.ToHex(this.valueHexView);
        else {
            result = this.valueDec.toString();
        }
        return result;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            valueDec: this.valueDec
        };
    }
}
LocalRelativeSidValueBlock.NAME = "relativeSidBlock";
class LocalRelativeObjectIdentifierValueBlock extends ValueBlock {
    constructor({ value =EMPTY_STRING , ...parameters } = {}){
        super(parameters);
        this.value = [];
        if (value) {
            this.fromString(value);
        }
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        let resultOffset = inputOffset;
        while(inputLength > 0){
            const sidBlock = new LocalRelativeSidValueBlock();
            resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);
            if (resultOffset === -1) {
                this.blockLength = 0;
                this.error = sidBlock.error;
                return resultOffset;
            }
            this.blockLength += sidBlock.blockLength;
            inputLength -= sidBlock.blockLength;
            this.value.push(sidBlock);
        }
        return resultOffset;
    }
    toBER(sizeOnly, writer) {
        const retBuffers = [];
        for(let i = 0; i < this.value.length; i++){
            const valueBuf = this.value[i].toBER(sizeOnly);
            if (valueBuf.byteLength === 0) {
                this.error = this.value[i].error;
                return EMPTY_BUFFER;
            }
            retBuffers.push(valueBuf);
        }
        return concat(retBuffers);
    }
    fromString(string) {
        this.value = [];
        let pos1 = 0;
        let pos2 = 0;
        let sid = "";
        do {
            pos2 = string.indexOf(".", pos1);
            if (pos2 === -1) sid = string.substring(pos1);
            else sid = string.substring(pos1, pos2);
            pos1 = pos2 + 1;
            const sidBlock = new LocalRelativeSidValueBlock();
            sidBlock.valueDec = parseInt(sid, 10);
            if (isNaN(sidBlock.valueDec)) return true;
            this.value.push(sidBlock);
        }while (pos2 !== -1);
        return true;
    }
    toString() {
        let result = "";
        let isHexOnly = false;
        for(let i = 0; i < this.value.length; i++){
            isHexOnly = this.value[i].isHexOnly;
            let sidStr = this.value[i].toString();
            if (i !== 0) result = `${result}.`;
            if (isHexOnly) {
                sidStr = `{${sidStr}}`;
                result += sidStr;
            } else result += sidStr;
        }
        return result;
    }
    toJSON() {
        const object = {
            ...super.toJSON(),
            value: this.toString(),
            sidArray: []
        };
        for(let i = 0; i < this.value.length; i++)object.sidArray.push(this.value[i].toJSON());
        return object;
    }
}
LocalRelativeObjectIdentifierValueBlock.NAME = "RelativeObjectIdentifierValueBlock";
var _a$l;
class RelativeObjectIdentifier extends BaseBlock {
    constructor(parameters = {}){
        super(parameters, LocalRelativeObjectIdentifierValueBlock);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 13;
    }
    getValue() {
        return this.valueBlock.toString();
    }
    setValue(value) {
        this.valueBlock.fromString(value);
    }
    onAsciiEncoding() {
        return `${this.constructor.NAME} : ${this.valueBlock.toString() || "empty"}`;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            value: this.getValue()
        };
    }
}
_a$l = RelativeObjectIdentifier;
(()=>{
    typeStore.RelativeObjectIdentifier = _a$l;
})();
RelativeObjectIdentifier.NAME = "RelativeObjectIdentifier";
var _a$k;
class Sequence extends Constructed {
    constructor(parameters = {}){
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 16;
    }
}
_a$k = Sequence;
(()=>{
    typeStore.Sequence = _a$k;
})();
Sequence.NAME = "SEQUENCE";
var _a$j;
class Set extends Constructed {
    constructor(parameters = {}){
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 17;
    }
}
_a$j = Set;
(()=>{
    typeStore.Set = _a$j;
})();
Set.NAME = "SET";
class LocalStringValueBlock extends HexBlock(ValueBlock) {
    constructor({ ...parameters } = {}){
        super(parameters);
        this.isHexOnly = true;
        this.value = EMPTY_STRING;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            value: this.value
        };
    }
}
LocalStringValueBlock.NAME = "StringValueBlock";
class LocalSimpleStringValueBlock extends LocalStringValueBlock {
}
LocalSimpleStringValueBlock.NAME = "SimpleStringValueBlock";
class LocalSimpleStringBlock extends BaseStringBlock {
    constructor({ ...parameters } = {}){
        super(parameters, LocalSimpleStringValueBlock);
    }
    fromBuffer(inputBuffer) {
        this.valueBlock.value = String.fromCharCode.apply(null, pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer));
    }
    fromString(inputString) {
        const strLen = inputString.length;
        const view = this.valueBlock.valueHexView = new Uint8Array(strLen);
        for(let i = 0; i < strLen; i++)view[i] = inputString.charCodeAt(i);
        this.valueBlock.value = inputString;
    }
}
LocalSimpleStringBlock.NAME = "SIMPLE STRING";
class LocalUtf8StringValueBlock extends LocalSimpleStringBlock {
    fromBuffer(inputBuffer) {
        this.valueBlock.valueHexView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer);
        try {
            this.valueBlock.value = pvtsutils__namespace.Convert.ToUtf8String(inputBuffer);
        } catch (ex) {
            this.warnings.push(`Error during "decodeURIComponent": ${ex}, using raw string`);
            this.valueBlock.value = pvtsutils__namespace.Convert.ToBinary(inputBuffer);
        }
    }
    fromString(inputString) {
        this.valueBlock.valueHexView = new Uint8Array(pvtsutils__namespace.Convert.FromUtf8String(inputString));
        this.valueBlock.value = inputString;
    }
}
LocalUtf8StringValueBlock.NAME = "Utf8StringValueBlock";
var _a$i;
class Utf8String extends LocalUtf8StringValueBlock {
    constructor(parameters = {}){
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 12;
    }
}
_a$i = Utf8String;
(()=>{
    typeStore.Utf8String = _a$i;
})();
Utf8String.NAME = "UTF8String";
class LocalBmpStringValueBlock extends LocalSimpleStringBlock {
    fromBuffer(inputBuffer) {
        this.valueBlock.value = pvtsutils__namespace.Convert.ToUtf16String(inputBuffer);
        this.valueBlock.valueHexView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer);
    }
    fromString(inputString) {
        this.valueBlock.value = inputString;
        this.valueBlock.valueHexView = new Uint8Array(pvtsutils__namespace.Convert.FromUtf16String(inputString));
    }
}
LocalBmpStringValueBlock.NAME = "BmpStringValueBlock";
var _a$h;
class BmpString extends LocalBmpStringValueBlock {
    constructor({ ...parameters } = {}){
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 30;
    }
}
_a$h = BmpString;
(()=>{
    typeStore.BmpString = _a$h;
})();
BmpString.NAME = "BMPString";
class LocalUniversalStringValueBlock extends LocalSimpleStringBlock {
    fromBuffer(inputBuffer) {
        const copyBuffer = ArrayBuffer.isView(inputBuffer) ? inputBuffer.slice().buffer : inputBuffer.slice(0);
        const valueView = new Uint8Array(copyBuffer);
        for(let i = 0; i < valueView.length; i += 4){
            valueView[i] = valueView[i + 3];
            valueView[i + 1] = valueView[i + 2];
            valueView[i + 2] = 0x00;
            valueView[i + 3] = 0x00;
        }
        this.valueBlock.value = String.fromCharCode.apply(null, new Uint32Array(copyBuffer));
    }
    fromString(inputString) {
        const strLength = inputString.length;
        const valueHexView = this.valueBlock.valueHexView = new Uint8Array(strLength * 4);
        for(let i = 0; i < strLength; i++){
            const codeBuf = pvutils__namespace.utilToBase(inputString.charCodeAt(i), 8);
            const codeView = new Uint8Array(codeBuf);
            if (codeView.length > 4) continue;
            const dif = 4 - codeView.length;
            for(let j = codeView.length - 1; j >= 0; j--)valueHexView[i * 4 + j + dif] = codeView[j];
        }
        this.valueBlock.value = inputString;
    }
}
LocalUniversalStringValueBlock.NAME = "UniversalStringValueBlock";
var _a$g;
class UniversalString extends LocalUniversalStringValueBlock {
    constructor({ ...parameters } = {}){
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 28;
    }
}
_a$g = UniversalString;
(()=>{
    typeStore.UniversalString = _a$g;
})();
UniversalString.NAME = "UniversalString";
var _a$f;
class NumericString extends LocalSimpleStringBlock {
    constructor(parameters = {}){
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 18;
    }
}
_a$f = NumericString;
(()=>{
    typeStore.NumericString = _a$f;
})();
NumericString.NAME = "NumericString";
var _a$e;
class PrintableString extends LocalSimpleStringBlock {
    constructor(parameters = {}){
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 19;
    }
}
_a$e = PrintableString;
(()=>{
    typeStore.PrintableString = _a$e;
})();
PrintableString.NAME = "PrintableString";
var _a$d;
class TeletexString extends LocalSimpleStringBlock {
    constructor(parameters = {}){
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 20;
    }
}
_a$d = TeletexString;
(()=>{
    typeStore.TeletexString = _a$d;
})();
TeletexString.NAME = "TeletexString";
var _a$c;
class VideotexString extends LocalSimpleStringBlock {
    constructor(parameters = {}){
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 21;
    }
}
_a$c = VideotexString;
(()=>{
    typeStore.VideotexString = _a$c;
})();
VideotexString.NAME = "VideotexString";
var _a$b;
class IA5String extends LocalSimpleStringBlock {
    constructor(parameters = {}){
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 22;
    }
}
_a$b = IA5String;
(()=>{
    typeStore.IA5String = _a$b;
})();
IA5String.NAME = "IA5String";
var _a$a;
class GraphicString extends LocalSimpleStringBlock {
    constructor(parameters = {}){
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 25;
    }
}
_a$a = GraphicString;
(()=>{
    typeStore.GraphicString = _a$a;
})();
GraphicString.NAME = "GraphicString";
var _a$9;
class VisibleString extends LocalSimpleStringBlock {
    constructor(parameters = {}){
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 26;
    }
}
_a$9 = VisibleString;
(()=>{
    typeStore.VisibleString = _a$9;
})();
VisibleString.NAME = "VisibleString";
var _a$8;
class GeneralString extends LocalSimpleStringBlock {
    constructor(parameters = {}){
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 27;
    }
}
_a$8 = GeneralString;
(()=>{
    typeStore.GeneralString = _a$8;
})();
GeneralString.NAME = "GeneralString";
var _a$7;
class CharacterString extends LocalSimpleStringBlock {
    constructor(parameters = {}){
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 29;
    }
}
_a$7 = CharacterString;
(()=>{
    typeStore.CharacterString = _a$7;
})();
CharacterString.NAME = "CharacterString";
var _a$6;
class UTCTime extends VisibleString {
    constructor({ value , valueDate , ...parameters } = {}){
        super(parameters);
        this.year = 0;
        this.month = 0;
        this.day = 0;
        this.hour = 0;
        this.minute = 0;
        this.second = 0;
        if (value) {
            this.fromString(value);
            this.valueBlock.valueHexView = new Uint8Array(value.length);
            for(let i = 0; i < value.length; i++)this.valueBlock.valueHexView[i] = value.charCodeAt(i);
        }
        if (valueDate) {
            this.fromDate(valueDate);
            this.valueBlock.valueHexView = new Uint8Array(this.toBuffer());
        }
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 23;
    }
    fromBuffer(inputBuffer) {
        this.fromString(String.fromCharCode.apply(null, pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer)));
    }
    toBuffer() {
        const str = this.toString();
        const buffer = new ArrayBuffer(str.length);
        const view = new Uint8Array(buffer);
        for(let i = 0; i < str.length; i++)view[i] = str.charCodeAt(i);
        return buffer;
    }
    fromDate(inputDate) {
        this.year = inputDate.getUTCFullYear();
        this.month = inputDate.getUTCMonth() + 1;
        this.day = inputDate.getUTCDate();
        this.hour = inputDate.getUTCHours();
        this.minute = inputDate.getUTCMinutes();
        this.second = inputDate.getUTCSeconds();
    }
    toDate() {
        return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second));
    }
    fromString(inputString) {
        const parser = /(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/ig;
        const parserArray = parser.exec(inputString);
        if (parserArray === null) {
            this.error = "Wrong input string for conversion";
            return;
        }
        const year = parseInt(parserArray[1], 10);
        if (year >= 50) this.year = 1900 + year;
        else this.year = 2000 + year;
        this.month = parseInt(parserArray[2], 10);
        this.day = parseInt(parserArray[3], 10);
        this.hour = parseInt(parserArray[4], 10);
        this.minute = parseInt(parserArray[5], 10);
        this.second = parseInt(parserArray[6], 10);
    }
    toString(encoding = "iso") {
        if (encoding === "iso") {
            const outputArray = new Array(7);
            outputArray[0] = pvutils__namespace.padNumber(this.year < 2000 ? this.year - 1900 : this.year - 2000, 2);
            outputArray[1] = pvutils__namespace.padNumber(this.month, 2);
            outputArray[2] = pvutils__namespace.padNumber(this.day, 2);
            outputArray[3] = pvutils__namespace.padNumber(this.hour, 2);
            outputArray[4] = pvutils__namespace.padNumber(this.minute, 2);
            outputArray[5] = pvutils__namespace.padNumber(this.second, 2);
            outputArray[6] = "Z";
            return outputArray.join("");
        }
        return super.toString(encoding);
    }
    onAsciiEncoding() {
        return `${this.constructor.NAME} : ${this.toDate().toISOString()}`;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            year: this.year,
            month: this.month,
            day: this.day,
            hour: this.hour,
            minute: this.minute,
            second: this.second
        };
    }
}
_a$6 = UTCTime;
(()=>{
    typeStore.UTCTime = _a$6;
})();
UTCTime.NAME = "UTCTime";
var _a$5;
class GeneralizedTime extends UTCTime {
    constructor(parameters = {}){
        var _b;
        super(parameters);
        (_b = this.millisecond) !== null && _b !== void 0 ? _b : this.millisecond = 0;
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 24;
    }
    fromDate(inputDate) {
        super.fromDate(inputDate);
        this.millisecond = inputDate.getUTCMilliseconds();
    }
    toDate() {
        return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond));
    }
    fromString(inputString) {
        let isUTC = false;
        let timeString = "";
        let dateTimeString = "";
        let fractionPart = 0;
        let parser;
        let hourDifference = 0;
        let minuteDifference = 0;
        if (inputString[inputString.length - 1] === "Z") {
            timeString = inputString.substring(0, inputString.length - 1);
            isUTC = true;
        } else {
            const number = new Number(inputString[inputString.length - 1]);
            if (isNaN(number.valueOf())) throw new Error("Wrong input string for conversion");
            timeString = inputString;
        }
        if (isUTC) {
            if (timeString.indexOf("+") !== -1) throw new Error("Wrong input string for conversion");
            if (timeString.indexOf("-") !== -1) throw new Error("Wrong input string for conversion");
        } else {
            let multiplier = 1;
            let differencePosition = timeString.indexOf("+");
            let differenceString = "";
            if (differencePosition === -1) {
                differencePosition = timeString.indexOf("-");
                multiplier = -1;
            }
            if (differencePosition !== -1) {
                differenceString = timeString.substring(differencePosition + 1);
                timeString = timeString.substring(0, differencePosition);
                if (differenceString.length !== 2 && differenceString.length !== 4) throw new Error("Wrong input string for conversion");
                let number = parseInt(differenceString.substring(0, 2), 10);
                if (isNaN(number.valueOf())) throw new Error("Wrong input string for conversion");
                hourDifference = multiplier * number;
                if (differenceString.length === 4) {
                    number = parseInt(differenceString.substring(2, 4), 10);
                    if (isNaN(number.valueOf())) throw new Error("Wrong input string for conversion");
                    minuteDifference = multiplier * number;
                }
            }
        }
        let fractionPointPosition = timeString.indexOf(".");
        if (fractionPointPosition === -1) fractionPointPosition = timeString.indexOf(",");
        if (fractionPointPosition !== -1) {
            const fractionPartCheck = new Number(`0${timeString.substring(fractionPointPosition)}`);
            if (isNaN(fractionPartCheck.valueOf())) throw new Error("Wrong input string for conversion");
            fractionPart = fractionPartCheck.valueOf();
            dateTimeString = timeString.substring(0, fractionPointPosition);
        } else dateTimeString = timeString;
        switch(true){
            case dateTimeString.length === 8:
                parser = /(\d{4})(\d{2})(\d{2})/ig;
                if (fractionPointPosition !== -1) throw new Error("Wrong input string for conversion");
                break;
            case dateTimeString.length === 10:
                parser = /(\d{4})(\d{2})(\d{2})(\d{2})/ig;
                if (fractionPointPosition !== -1) {
                    let fractionResult = 60 * fractionPart;
                    this.minute = Math.floor(fractionResult);
                    fractionResult = 60 * (fractionResult - this.minute);
                    this.second = Math.floor(fractionResult);
                    fractionResult = 1000 * (fractionResult - this.second);
                    this.millisecond = Math.floor(fractionResult);
                }
                break;
            case dateTimeString.length === 12:
                parser = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/ig;
                if (fractionPointPosition !== -1) {
                    let fractionResult = 60 * fractionPart;
                    this.second = Math.floor(fractionResult);
                    fractionResult = 1000 * (fractionResult - this.second);
                    this.millisecond = Math.floor(fractionResult);
                }
                break;
            case dateTimeString.length === 14:
                parser = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/ig;
                if (fractionPointPosition !== -1) {
                    const fractionResult = 1000 * fractionPart;
                    this.millisecond = Math.floor(fractionResult);
                }
                break;
            default:
                throw new Error("Wrong input string for conversion");
        }
        const parserArray = parser.exec(dateTimeString);
        if (parserArray === null) throw new Error("Wrong input string for conversion");
        for(let j = 1; j < parserArray.length; j++){
            switch(j){
                case 1:
                    this.year = parseInt(parserArray[j], 10);
                    break;
                case 2:
                    this.month = parseInt(parserArray[j], 10);
                    break;
                case 3:
                    this.day = parseInt(parserArray[j], 10);
                    break;
                case 4:
                    this.hour = parseInt(parserArray[j], 10) + hourDifference;
                    break;
                case 5:
                    this.minute = parseInt(parserArray[j], 10) + minuteDifference;
                    break;
                case 6:
                    this.second = parseInt(parserArray[j], 10);
                    break;
                default:
                    throw new Error("Wrong input string for conversion");
            }
        }
        if (isUTC === false) {
            const tempDate = new Date(this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
            this.year = tempDate.getUTCFullYear();
            this.month = tempDate.getUTCMonth();
            this.day = tempDate.getUTCDay();
            this.hour = tempDate.getUTCHours();
            this.minute = tempDate.getUTCMinutes();
            this.second = tempDate.getUTCSeconds();
            this.millisecond = tempDate.getUTCMilliseconds();
        }
    }
    toString(encoding = "iso") {
        if (encoding === "iso") {
            const outputArray = [];
            outputArray.push(pvutils__namespace.padNumber(this.year, 4));
            outputArray.push(pvutils__namespace.padNumber(this.month, 2));
            outputArray.push(pvutils__namespace.padNumber(this.day, 2));
            outputArray.push(pvutils__namespace.padNumber(this.hour, 2));
            outputArray.push(pvutils__namespace.padNumber(this.minute, 2));
            outputArray.push(pvutils__namespace.padNumber(this.second, 2));
            if (this.millisecond !== 0) {
                outputArray.push(".");
                outputArray.push(pvutils__namespace.padNumber(this.millisecond, 3));
            }
            outputArray.push("Z");
            return outputArray.join("");
        }
        return super.toString(encoding);
    }
    toJSON() {
        return {
            ...super.toJSON(),
            millisecond: this.millisecond
        };
    }
}
_a$5 = GeneralizedTime;
(()=>{
    typeStore.GeneralizedTime = _a$5;
})();
GeneralizedTime.NAME = "GeneralizedTime";
var _a$4;
class DATE extends Utf8String {
    constructor(parameters = {}){
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 31;
    }
}
_a$4 = DATE;
(()=>{
    typeStore.DATE = _a$4;
})();
DATE.NAME = "DATE";
var _a$3;
class TimeOfDay extends Utf8String {
    constructor(parameters = {}){
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 32;
    }
}
_a$3 = TimeOfDay;
(()=>{
    typeStore.TimeOfDay = _a$3;
})();
TimeOfDay.NAME = "TimeOfDay";
var _a$2;
class DateTime extends Utf8String {
    constructor(parameters = {}){
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 33;
    }
}
_a$2 = DateTime;
(()=>{
    typeStore.DateTime = _a$2;
})();
DateTime.NAME = "DateTime";
var _a$1;
class Duration extends Utf8String {
    constructor(parameters = {}){
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 34;
    }
}
_a$1 = Duration;
(()=>{
    typeStore.Duration = _a$1;
})();
Duration.NAME = "Duration";
var _a;
class TIME extends Utf8String {
    constructor(parameters = {}){
        super(parameters);
        this.idBlock.tagClass = 1;
        this.idBlock.tagNumber = 14;
    }
}
_a = TIME;
(()=>{
    typeStore.TIME = _a;
})();
TIME.NAME = "TIME";
class Any {
    constructor({ name =EMPTY_STRING , optional =false  } = {}){
        this.name = name;
        this.optional = optional;
    }
}
class Choice extends Any {
    constructor({ value =[] , ...parameters } = {}){
        super(parameters);
        this.value = value;
    }
}
class Repeated extends Any {
    constructor({ value =new Any() , local =false , ...parameters } = {}){
        super(parameters);
        this.value = value;
        this.local = local;
    }
}
class RawData {
    constructor({ data =EMPTY_VIEW  } = {}){
        this.dataView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(data);
    }
    get data() {
        return this.dataView.slice().buffer;
    }
    set data(value) {
        this.dataView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(value);
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
        const endLength = inputOffset + inputLength;
        this.dataView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer).subarray(inputOffset, endLength);
        return endLength;
    }
    toBER(sizeOnly) {
        return this.dataView.slice().buffer;
    }
}
function compareSchema(root, inputData, inputSchema) {
    if (inputSchema instanceof Choice) {
        for(let j = 0; j < inputSchema.value.length; j++){
            const result = compareSchema(root, inputData, inputSchema.value[j]);
            if (result.verified) {
                return {
                    verified: true,
                    result: root
                };
            }
        }
        {
            const _result = {
                verified: false,
                result: {
                    error: "Wrong values for Choice type"
                }
            };
            if (inputSchema.hasOwnProperty(NAME)) _result.name = inputSchema.name;
            return _result;
        }
    }
    if (inputSchema instanceof Any) {
        if (inputSchema.hasOwnProperty(NAME)) root[inputSchema.name] = inputData;
        return {
            verified: true,
            result: root
        };
    }
    if (root instanceof Object === false) {
        return {
            verified: false,
            result: {
                error: "Wrong root object"
            }
        };
    }
    if (inputData instanceof Object === false) {
        return {
            verified: false,
            result: {
                error: "Wrong ASN.1 data"
            }
        };
    }
    if (inputSchema instanceof Object === false) {
        return {
            verified: false,
            result: {
                error: "Wrong ASN.1 schema"
            }
        };
    }
    if (ID_BLOCK in inputSchema === false) {
        return {
            verified: false,
            result: {
                error: "Wrong ASN.1 schema"
            }
        };
    }
    if (FROM_BER in inputSchema.idBlock === false) {
        return {
            verified: false,
            result: {
                error: "Wrong ASN.1 schema"
            }
        };
    }
    if (TO_BER in inputSchema.idBlock === false) {
        return {
            verified: false,
            result: {
                error: "Wrong ASN.1 schema"
            }
        };
    }
    const encodedId = inputSchema.idBlock.toBER(false);
    if (encodedId.byteLength === 0) {
        return {
            verified: false,
            result: {
                error: "Error encoding idBlock for ASN.1 schema"
            }
        };
    }
    const decodedOffset = inputSchema.idBlock.fromBER(encodedId, 0, encodedId.byteLength);
    if (decodedOffset === -1) {
        return {
            verified: false,
            result: {
                error: "Error decoding idBlock for ASN.1 schema"
            }
        };
    }
    if (inputSchema.idBlock.hasOwnProperty(TAG_CLASS) === false) {
        return {
            verified: false,
            result: {
                error: "Wrong ASN.1 schema"
            }
        };
    }
    if (inputSchema.idBlock.tagClass !== inputData.idBlock.tagClass) {
        return {
            verified: false,
            result: root
        };
    }
    if (inputSchema.idBlock.hasOwnProperty(TAG_NUMBER) === false) {
        return {
            verified: false,
            result: {
                error: "Wrong ASN.1 schema"
            }
        };
    }
    if (inputSchema.idBlock.tagNumber !== inputData.idBlock.tagNumber) {
        return {
            verified: false,
            result: root
        };
    }
    if (inputSchema.idBlock.hasOwnProperty(IS_CONSTRUCTED) === false) {
        return {
            verified: false,
            result: {
                error: "Wrong ASN.1 schema"
            }
        };
    }
    if (inputSchema.idBlock.isConstructed !== inputData.idBlock.isConstructed) {
        return {
            verified: false,
            result: root
        };
    }
    if (!(IS_HEX_ONLY in inputSchema.idBlock)) {
        return {
            verified: false,
            result: {
                error: "Wrong ASN.1 schema"
            }
        };
    }
    if (inputSchema.idBlock.isHexOnly !== inputData.idBlock.isHexOnly) {
        return {
            verified: false,
            result: root
        };
    }
    if (inputSchema.idBlock.isHexOnly) {
        if (VALUE_HEX_VIEW in inputSchema.idBlock === false) {
            return {
                verified: false,
                result: {
                    error: "Wrong ASN.1 schema"
                }
            };
        }
        const schemaView = inputSchema.idBlock.valueHexView;
        const asn1View = inputData.idBlock.valueHexView;
        if (schemaView.length !== asn1View.length) {
            return {
                verified: false,
                result: root
            };
        }
        for(let i = 0; i < schemaView.length; i++){
            if (schemaView[i] !== asn1View[1]) {
                return {
                    verified: false,
                    result: root
                };
            }
        }
    }
    if (inputSchema.name) {
        inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
        if (inputSchema.name) root[inputSchema.name] = inputData;
    }
    if (inputSchema instanceof typeStore.Constructed) {
        let admission = 0;
        let result = {
            verified: false,
            result: {
                error: "Unknown error"
            }
        };
        let maxLength = inputSchema.valueBlock.value.length;
        if (maxLength > 0) {
            if (inputSchema.valueBlock.value[0] instanceof Repeated) {
                maxLength = inputData.valueBlock.value.length;
            }
        }
        if (maxLength === 0) {
            return {
                verified: true,
                result: root
            };
        }
        if (inputData.valueBlock.value.length === 0 && inputSchema.valueBlock.value.length !== 0) {
            let _optional = true;
            for(let i = 0; i < inputSchema.valueBlock.value.length; i++)_optional = _optional && (inputSchema.valueBlock.value[i].optional || false);
            if (_optional) {
                return {
                    verified: true,
                    result: root
                };
            }
            if (inputSchema.name) {
                inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
                if (inputSchema.name) delete root[inputSchema.name];
            }
            root.error = "Inconsistent object length";
            return {
                verified: false,
                result: root
            };
        }
        for(let i = 0; i < maxLength; i++){
            if (i - admission >= inputData.valueBlock.value.length) {
                if (inputSchema.valueBlock.value[i].optional === false) {
                    const _result = {
                        verified: false,
                        result: root
                    };
                    root.error = "Inconsistent length between ASN.1 data and schema";
                    if (inputSchema.name) {
                        inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
                        if (inputSchema.name) {
                            delete root[inputSchema.name];
                            _result.name = inputSchema.name;
                        }
                    }
                    return _result;
                }
            } else {
                if (inputSchema.valueBlock.value[0] instanceof Repeated) {
                    result = compareSchema(root, inputData.valueBlock.value[i], inputSchema.valueBlock.value[0].value);
                    if (result.verified === false) {
                        if (inputSchema.valueBlock.value[0].optional) admission++;
                        else {
                            if (inputSchema.name) {
                                inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
                                if (inputSchema.name) delete root[inputSchema.name];
                            }
                            return result;
                        }
                    }
                    if (NAME in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].name.length > 0) {
                        let arrayRoot = {};
                        if (LOCAL in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].local) arrayRoot = inputData;
                        else arrayRoot = root;
                        if (typeof arrayRoot[inputSchema.valueBlock.value[0].name] === "undefined") arrayRoot[inputSchema.valueBlock.value[0].name] = [];
                        arrayRoot[inputSchema.valueBlock.value[0].name].push(inputData.valueBlock.value[i]);
                    }
                } else {
                    result = compareSchema(root, inputData.valueBlock.value[i - admission], inputSchema.valueBlock.value[i]);
                    if (result.verified === false) {
                        if (inputSchema.valueBlock.value[i].optional) admission++;
                        else {
                            if (inputSchema.name) {
                                inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
                                if (inputSchema.name) delete root[inputSchema.name];
                            }
                            return result;
                        }
                    }
                }
            }
        }
        if (result.verified === false) {
            const _result = {
                verified: false,
                result: root
            };
            if (inputSchema.name) {
                inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
                if (inputSchema.name) {
                    delete root[inputSchema.name];
                    _result.name = inputSchema.name;
                }
            }
            return _result;
        }
        return {
            verified: true,
            result: root
        };
    }
    if (inputSchema.primitiveSchema && VALUE_HEX_VIEW in inputData.valueBlock) {
        const asn1 = localFromBER(inputData.valueBlock.valueHexView);
        if (asn1.offset === -1) {
            const _result = {
                verified: false,
                result: asn1.result
            };
            if (inputSchema.name) {
                inputSchema.name = inputSchema.name.replace(/^\s+|\s+$/g, EMPTY_STRING);
                if (inputSchema.name) {
                    delete root[inputSchema.name];
                    _result.name = inputSchema.name;
                }
            }
            return _result;
        }
        return compareSchema(root, asn1.result, inputSchema.primitiveSchema);
    }
    return {
        verified: true,
        result: root
    };
}
function verifySchema(inputBuffer, inputSchema) {
    if (inputSchema instanceof Object === false) {
        return {
            verified: false,
            result: {
                error: "Wrong ASN.1 schema type"
            }
        };
    }
    const asn1 = localFromBER(pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer));
    if (asn1.offset === -1) {
        return {
            verified: false,
            result: asn1.result
        };
    }
    return compareSchema(asn1.result, asn1.result, inputSchema);
}
exports.Any = Any;
exports.BaseBlock = BaseBlock;
exports.BaseStringBlock = BaseStringBlock;
exports.BitString = BitString;
exports.BmpString = BmpString;
exports.Boolean = Boolean;
exports.CharacterString = CharacterString;
exports.Choice = Choice;
exports.Constructed = Constructed;
exports.DATE = DATE;
exports.DateTime = DateTime;
exports.Duration = Duration;
exports.EndOfContent = EndOfContent;
exports.Enumerated = Enumerated;
exports.GeneralString = GeneralString;
exports.GeneralizedTime = GeneralizedTime;
exports.GraphicString = GraphicString;
exports.HexBlock = HexBlock;
exports.IA5String = IA5String;
exports.Integer = Integer;
exports.Null = Null;
exports.NumericString = NumericString;
exports.ObjectIdentifier = ObjectIdentifier;
exports.OctetString = OctetString;
exports.Primitive = Primitive;
exports.PrintableString = PrintableString;
exports.RawData = RawData;
exports.RelativeObjectIdentifier = RelativeObjectIdentifier;
exports.Repeated = Repeated;
exports.Sequence = Sequence;
exports.Set = Set;
exports.TIME = TIME;
exports.TeletexString = TeletexString;
exports.TimeOfDay = TimeOfDay;
exports.UTCTime = UTCTime;
exports.UniversalString = UniversalString;
exports.Utf8String = Utf8String;
exports.ValueBlock = ValueBlock;
exports.VideotexString = VideotexString;
exports.ViewWriter = ViewWriter;
exports.VisibleString = VisibleString;
exports.compareSchema = compareSchema;
exports.fromBER = fromBER;
exports.verifySchema = verifySchema;


/***/ }),

/***/ 637:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const { parseContentType  } = __webpack_require__(5344);
function getInstance(cfg) {
    const headers = cfg.headers;
    const conType = parseContentType(headers["content-type"]);
    if (!conType) throw new Error("Malformed content type");
    for (const type of TYPES){
        const matched = type.detect(conType);
        if (!matched) continue;
        const instanceCfg = {
            limits: cfg.limits,
            headers,
            conType,
            highWaterMark: undefined,
            fileHwm: undefined,
            defCharset: undefined,
            defParamCharset: undefined,
            preservePath: false
        };
        if (cfg.highWaterMark) instanceCfg.highWaterMark = cfg.highWaterMark;
        if (cfg.fileHwm) instanceCfg.fileHwm = cfg.fileHwm;
        instanceCfg.defCharset = cfg.defCharset;
        instanceCfg.defParamCharset = cfg.defParamCharset;
        instanceCfg.preservePath = cfg.preservePath;
        return new type(instanceCfg);
    }
    throw new Error(`Unsupported content type: ${headers["content-type"]}`);
}
// Note: types are explicitly listed here for easier bundling
// See: https://github.com/mscdex/busboy/issues/121
const TYPES = [
    __webpack_require__(6707),
    __webpack_require__(2953)
].filter(function(typemod) {
    return typeof typemod.detect === "function";
});
module.exports = (cfg)=>{
    if (typeof cfg !== "object" || cfg === null) cfg = {};
    if (typeof cfg.headers !== "object" || cfg.headers === null || typeof cfg.headers["content-type"] !== "string") {
        throw new Error("Missing Content-Type");
    }
    return getInstance(cfg);
};


/***/ }),

/***/ 6707:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const { Readable , Writable  } = __webpack_require__(2781);
const StreamSearch = __webpack_require__(6298);
const { basename , convertToUTF8 , getDecoder , parseContentType , parseDisposition  } = __webpack_require__(5344);
const BUF_CRLF = Buffer.from("\r\n");
const BUF_CR = Buffer.from("\r");
const BUF_DASH = Buffer.from("-");
function noop() {}
const MAX_HEADER_PAIRS = 2000; // From node
const MAX_HEADER_SIZE = 16 * 1024; // From node (its default value)
const HPARSER_NAME = 0;
const HPARSER_PRE_OWS = 1;
const HPARSER_VALUE = 2;
class HeaderParser {
    constructor(cb){
        this.header = Object.create(null);
        this.pairCount = 0;
        this.byteCount = 0;
        this.state = HPARSER_NAME;
        this.name = "";
        this.value = "";
        this.crlf = 0;
        this.cb = cb;
    }
    reset() {
        this.header = Object.create(null);
        this.pairCount = 0;
        this.byteCount = 0;
        this.state = HPARSER_NAME;
        this.name = "";
        this.value = "";
        this.crlf = 0;
    }
    push(chunk, pos, end) {
        let start = pos;
        while(pos < end){
            switch(this.state){
                case HPARSER_NAME:
                    {
                        let done = false;
                        for(; pos < end; ++pos){
                            if (this.byteCount === MAX_HEADER_SIZE) return -1;
                            ++this.byteCount;
                            const code = chunk[pos];
                            if (TOKEN[code] !== 1) {
                                if (code !== 58 /* ':' */ ) return -1;
                                this.name += chunk.latin1Slice(start, pos);
                                if (this.name.length === 0) return -1;
                                ++pos;
                                done = true;
                                this.state = HPARSER_PRE_OWS;
                                break;
                            }
                        }
                        if (!done) {
                            this.name += chunk.latin1Slice(start, pos);
                            break;
                        }
                    // FALLTHROUGH
                    }
                case HPARSER_PRE_OWS:
                    {
                        // Skip optional whitespace
                        let done = false;
                        for(; pos < end; ++pos){
                            if (this.byteCount === MAX_HEADER_SIZE) return -1;
                            ++this.byteCount;
                            const code = chunk[pos];
                            if (code !== 32 /* ' ' */  && code !== 9 /* '\t' */ ) {
                                start = pos;
                                done = true;
                                this.state = HPARSER_VALUE;
                                break;
                            }
                        }
                        if (!done) break;
                    // FALLTHROUGH
                    }
                case HPARSER_VALUE:
                    switch(this.crlf){
                        case 0:
                            for(; pos < end; ++pos){
                                if (this.byteCount === MAX_HEADER_SIZE) return -1;
                                ++this.byteCount;
                                const code = chunk[pos];
                                if (FIELD_VCHAR[code] !== 1) {
                                    if (code !== 13 /* '\r' */ ) return -1;
                                    ++this.crlf;
                                    break;
                                }
                            }
                            this.value += chunk.latin1Slice(start, pos++);
                            break;
                        case 1:
                            if (this.byteCount === MAX_HEADER_SIZE) return -1;
                            ++this.byteCount;
                            if (chunk[pos++] !== 10 /* '\n' */ ) return -1;
                            ++this.crlf;
                            break;
                        case 2:
                            {
                                if (this.byteCount === MAX_HEADER_SIZE) return -1;
                                ++this.byteCount;
                                const code = chunk[pos];
                                if (code === 32 /* ' ' */  || code === 9 /* '\t' */ ) {
                                    // Folded value
                                    start = pos;
                                    this.crlf = 0;
                                } else {
                                    if (++this.pairCount < MAX_HEADER_PAIRS) {
                                        this.name = this.name.toLowerCase();
                                        if (this.header[this.name] === undefined) this.header[this.name] = [
                                            this.value
                                        ];
                                        else this.header[this.name].push(this.value);
                                    }
                                    if (code === 13 /* '\r' */ ) {
                                        ++this.crlf;
                                        ++pos;
                                    } else {
                                        // Assume start of next header field name
                                        start = pos;
                                        this.crlf = 0;
                                        this.state = HPARSER_NAME;
                                        this.name = "";
                                        this.value = "";
                                    }
                                }
                                break;
                            }
                        case 3:
                            {
                                if (this.byteCount === MAX_HEADER_SIZE) return -1;
                                ++this.byteCount;
                                if (chunk[pos++] !== 10 /* '\n' */ ) return -1;
                                // End of header
                                const header = this.header;
                                this.reset();
                                this.cb(header);
                                return pos;
                            }
                    }
                    break;
            }
        }
        return pos;
    }
}
class FileStream extends Readable {
    constructor(opts, owner){
        super(opts);
        this.truncated = false;
        this._readcb = null;
        this.once("end", ()=>{
            // We need to make sure that we call any outstanding _writecb() that is
            // associated with this file so that processing of the rest of the form
            // can continue. This may not happen if the file stream ends right after
            // backpressure kicks in, so we force it here.
            this._read();
            if (--owner._fileEndsLeft === 0 && owner._finalcb) {
                const cb = owner._finalcb;
                owner._finalcb = null;
                // Make sure other 'end' event handlers get a chance to be executed
                // before busboy's 'finish' event is emitted
                process.nextTick(cb);
            }
        });
    }
    _read(n) {
        const cb = this._readcb;
        if (cb) {
            this._readcb = null;
            cb();
        }
    }
}
const ignoreData = {
    push: (chunk, pos)=>{},
    destroy: ()=>{}
};
function callAndUnsetCb(self, err) {
    const cb = self._writecb;
    self._writecb = null;
    if (err) self.destroy(err);
    else if (cb) cb();
}
function nullDecoder(val, hint) {
    return val;
}
class Multipart extends Writable {
    constructor(cfg){
        const streamOpts = {
            autoDestroy: true,
            emitClose: true,
            highWaterMark: typeof cfg.highWaterMark === "number" ? cfg.highWaterMark : undefined
        };
        super(streamOpts);
        if (!cfg.conType.params || typeof cfg.conType.params.boundary !== "string") throw new Error("Multipart: Boundary not found");
        const boundary = cfg.conType.params.boundary;
        const paramDecoder = typeof cfg.defParamCharset === "string" && cfg.defParamCharset ? getDecoder(cfg.defParamCharset) : nullDecoder;
        const defCharset = cfg.defCharset || "utf8";
        const preservePath = cfg.preservePath;
        const fileOpts = {
            autoDestroy: true,
            emitClose: true,
            highWaterMark: typeof cfg.fileHwm === "number" ? cfg.fileHwm : undefined
        };
        const limits = cfg.limits;
        const fieldSizeLimit = limits && typeof limits.fieldSize === "number" ? limits.fieldSize : 1 * 1024 * 1024;
        const fileSizeLimit = limits && typeof limits.fileSize === "number" ? limits.fileSize : Infinity;
        const filesLimit = limits && typeof limits.files === "number" ? limits.files : Infinity;
        const fieldsLimit = limits && typeof limits.fields === "number" ? limits.fields : Infinity;
        const partsLimit = limits && typeof limits.parts === "number" ? limits.parts : Infinity;
        let parts = -1; // Account for initial boundary
        let fields = 0;
        let files = 0;
        let skipPart = false;
        this._fileEndsLeft = 0;
        this._fileStream = undefined;
        this._complete = false;
        let fileSize = 0;
        let field;
        let fieldSize = 0;
        let partCharset;
        let partEncoding;
        let partType;
        let partName;
        let partTruncated = false;
        let hitFilesLimit = false;
        let hitFieldsLimit = false;
        this._hparser = null;
        const hparser = new HeaderParser((header)=>{
            this._hparser = null;
            skipPart = false;
            partType = "text/plain";
            partCharset = defCharset;
            partEncoding = "7bit";
            partName = undefined;
            partTruncated = false;
            let filename;
            if (!header["content-disposition"]) {
                skipPart = true;
                return;
            }
            const disp = parseDisposition(header["content-disposition"][0], paramDecoder);
            if (!disp || disp.type !== "form-data") {
                skipPart = true;
                return;
            }
            if (disp.params) {
                if (disp.params.name) partName = disp.params.name;
                if (disp.params["filename*"]) filename = disp.params["filename*"];
                else if (disp.params.filename) filename = disp.params.filename;
                if (filename !== undefined && !preservePath) filename = basename(filename);
            }
            if (header["content-type"]) {
                const conType = parseContentType(header["content-type"][0]);
                if (conType) {
                    partType = `${conType.type}/${conType.subtype}`;
                    if (conType.params && typeof conType.params.charset === "string") partCharset = conType.params.charset.toLowerCase();
                }
            }
            if (header["content-transfer-encoding"]) partEncoding = header["content-transfer-encoding"][0].toLowerCase();
            if (partType === "application/octet-stream" || filename !== undefined) {
                // File
                if (files === filesLimit) {
                    if (!hitFilesLimit) {
                        hitFilesLimit = true;
                        this.emit("filesLimit");
                    }
                    skipPart = true;
                    return;
                }
                ++files;
                if (this.listenerCount("file") === 0) {
                    skipPart = true;
                    return;
                }
                fileSize = 0;
                this._fileStream = new FileStream(fileOpts, this);
                ++this._fileEndsLeft;
                this.emit("file", partName, this._fileStream, {
                    filename,
                    encoding: partEncoding,
                    mimeType: partType
                });
            } else {
                // Non-file
                if (fields === fieldsLimit) {
                    if (!hitFieldsLimit) {
                        hitFieldsLimit = true;
                        this.emit("fieldsLimit");
                    }
                    skipPart = true;
                    return;
                }
                ++fields;
                if (this.listenerCount("field") === 0) {
                    skipPart = true;
                    return;
                }
                field = [];
                fieldSize = 0;
            }
        });
        let matchPostBoundary = 0;
        const ssCb = (isMatch, data, start, end, isDataSafe)=>{
            retrydata: while(data){
                if (this._hparser !== null) {
                    const ret = this._hparser.push(data, start, end);
                    if (ret === -1) {
                        this._hparser = null;
                        hparser.reset();
                        this.emit("error", new Error("Malformed part header"));
                        break;
                    }
                    start = ret;
                }
                if (start === end) break;
                if (matchPostBoundary !== 0) {
                    if (matchPostBoundary === 1) {
                        switch(data[start]){
                            case 45:
                                // Try matching '--' after boundary
                                matchPostBoundary = 2;
                                ++start;
                                break;
                            case 13:
                                // Try matching CR LF before header
                                matchPostBoundary = 3;
                                ++start;
                                break;
                            default:
                                matchPostBoundary = 0;
                        }
                        if (start === end) return;
                    }
                    if (matchPostBoundary === 2) {
                        matchPostBoundary = 0;
                        if (data[start] === 45 /* '-' */ ) {
                            // End of multipart data
                            this._complete = true;
                            this._bparser = ignoreData;
                            return;
                        }
                        // We saw something other than '-', so put the dash we consumed
                        // "back"
                        const writecb = this._writecb;
                        this._writecb = noop;
                        ssCb(false, BUF_DASH, 0, 1, false);
                        this._writecb = writecb;
                    } else if (matchPostBoundary === 3) {
                        matchPostBoundary = 0;
                        if (data[start] === 10 /* '\n' */ ) {
                            ++start;
                            if (parts >= partsLimit) break;
                            // Prepare the header parser
                            this._hparser = hparser;
                            if (start === end) break;
                            continue retrydata;
                        } else {
                            // We saw something other than LF, so put the CR we consumed
                            // "back"
                            const writecb = this._writecb;
                            this._writecb = noop;
                            ssCb(false, BUF_CR, 0, 1, false);
                            this._writecb = writecb;
                        }
                    }
                }
                if (!skipPart) {
                    if (this._fileStream) {
                        let chunk;
                        const actualLen = Math.min(end - start, fileSizeLimit - fileSize);
                        if (!isDataSafe) {
                            chunk = Buffer.allocUnsafe(actualLen);
                            data.copy(chunk, 0, start, start + actualLen);
                        } else {
                            chunk = data.slice(start, start + actualLen);
                        }
                        fileSize += chunk.length;
                        if (fileSize === fileSizeLimit) {
                            if (chunk.length > 0) this._fileStream.push(chunk);
                            this._fileStream.emit("limit");
                            this._fileStream.truncated = true;
                            skipPart = true;
                        } else if (!this._fileStream.push(chunk)) {
                            if (this._writecb) this._fileStream._readcb = this._writecb;
                            this._writecb = null;
                        }
                    } else if (field !== undefined) {
                        let chunk;
                        const actualLen = Math.min(end - start, fieldSizeLimit - fieldSize);
                        if (!isDataSafe) {
                            chunk = Buffer.allocUnsafe(actualLen);
                            data.copy(chunk, 0, start, start + actualLen);
                        } else {
                            chunk = data.slice(start, start + actualLen);
                        }
                        fieldSize += actualLen;
                        field.push(chunk);
                        if (fieldSize === fieldSizeLimit) {
                            skipPart = true;
                            partTruncated = true;
                        }
                    }
                }
                break;
            }
            if (isMatch) {
                matchPostBoundary = 1;
                if (this._fileStream) {
                    // End the active file stream if the previous part was a file
                    this._fileStream.push(null);
                    this._fileStream = null;
                } else if (field !== undefined) {
                    let data;
                    switch(field.length){
                        case 0:
                            data = "";
                            break;
                        case 1:
                            data = convertToUTF8(field[0], partCharset, 0);
                            break;
                        default:
                            data = convertToUTF8(Buffer.concat(field, fieldSize), partCharset, 0);
                    }
                    field = undefined;
                    fieldSize = 0;
                    this.emit("field", partName, data, {
                        nameTruncated: false,
                        valueTruncated: partTruncated,
                        encoding: partEncoding,
                        mimeType: partType
                    });
                }
                if (++parts === partsLimit) this.emit("partsLimit");
            }
        };
        this._bparser = new StreamSearch(`\r\n--${boundary}`, ssCb);
        this._writecb = null;
        this._finalcb = null;
        // Just in case there is no preamble
        this.write(BUF_CRLF);
    }
    static detect(conType) {
        return conType.type === "multipart" && conType.subtype === "form-data";
    }
    _write(chunk, enc, cb) {
        this._writecb = cb;
        this._bparser.push(chunk, 0);
        if (this._writecb) callAndUnsetCb(this);
    }
    _destroy(err, cb) {
        this._hparser = null;
        this._bparser = ignoreData;
        if (!err) err = checkEndState(this);
        const fileStream = this._fileStream;
        if (fileStream) {
            this._fileStream = null;
            fileStream.destroy(err);
        }
        cb(err);
    }
    _final(cb) {
        this._bparser.destroy();
        if (!this._complete) return cb(new Error("Unexpected end of form"));
        if (this._fileEndsLeft) this._finalcb = finalcb.bind(null, this, cb);
        else finalcb(this, cb);
    }
}
function finalcb(self, cb, err) {
    if (err) return cb(err);
    err = checkEndState(self);
    cb(err);
}
function checkEndState(self) {
    if (self._hparser) return new Error("Malformed part header");
    const fileStream = self._fileStream;
    if (fileStream) {
        self._fileStream = null;
        fileStream.destroy(new Error("Unexpected end of file"));
    }
    if (!self._complete) return new Error("Unexpected end of form");
}
const TOKEN = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
];
const FIELD_VCHAR = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
];
module.exports = Multipart;


/***/ }),

/***/ 2953:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const { Writable  } = __webpack_require__(2781);
const { getDecoder  } = __webpack_require__(5344);
class URLEncoded extends Writable {
    constructor(cfg){
        const streamOpts = {
            autoDestroy: true,
            emitClose: true,
            highWaterMark: typeof cfg.highWaterMark === "number" ? cfg.highWaterMark : undefined
        };
        super(streamOpts);
        let charset = cfg.defCharset || "utf8";
        if (cfg.conType.params && typeof cfg.conType.params.charset === "string") charset = cfg.conType.params.charset;
        this.charset = charset;
        const limits = cfg.limits;
        this.fieldSizeLimit = limits && typeof limits.fieldSize === "number" ? limits.fieldSize : 1 * 1024 * 1024;
        this.fieldsLimit = limits && typeof limits.fields === "number" ? limits.fields : Infinity;
        this.fieldNameSizeLimit = limits && typeof limits.fieldNameSize === "number" ? limits.fieldNameSize : 100;
        this._inKey = true;
        this._keyTrunc = false;
        this._valTrunc = false;
        this._bytesKey = 0;
        this._bytesVal = 0;
        this._fields = 0;
        this._key = "";
        this._val = "";
        this._byte = -2;
        this._lastPos = 0;
        this._encode = 0;
        this._decoder = getDecoder(charset);
    }
    static detect(conType) {
        return conType.type === "application" && conType.subtype === "x-www-form-urlencoded";
    }
    _write(chunk, enc, cb) {
        if (this._fields >= this.fieldsLimit) return cb();
        let i = 0;
        const len = chunk.length;
        this._lastPos = 0;
        // Check if we last ended mid-percent-encoded byte
        if (this._byte !== -2) {
            i = readPctEnc(this, chunk, i, len);
            if (i === -1) return cb(new Error("Malformed urlencoded form"));
            if (i >= len) return cb();
            if (this._inKey) ++this._bytesKey;
            else ++this._bytesVal;
        }
        main: while(i < len){
            if (this._inKey) {
                // Parsing key
                i = skipKeyBytes(this, chunk, i, len);
                while(i < len){
                    switch(chunk[i]){
                        case 61:
                            if (this._lastPos < i) this._key += chunk.latin1Slice(this._lastPos, i);
                            this._lastPos = ++i;
                            this._key = this._decoder(this._key, this._encode);
                            this._encode = 0;
                            this._inKey = false;
                            continue main;
                        case 38:
                            if (this._lastPos < i) this._key += chunk.latin1Slice(this._lastPos, i);
                            this._lastPos = ++i;
                            this._key = this._decoder(this._key, this._encode);
                            this._encode = 0;
                            if (this._bytesKey > 0) {
                                this.emit("field", this._key, "", {
                                    nameTruncated: this._keyTrunc,
                                    valueTruncated: false,
                                    encoding: this.charset,
                                    mimeType: "text/plain"
                                });
                            }
                            this._key = "";
                            this._val = "";
                            this._keyTrunc = false;
                            this._valTrunc = false;
                            this._bytesKey = 0;
                            this._bytesVal = 0;
                            if (++this._fields >= this.fieldsLimit) {
                                this.emit("fieldsLimit");
                                return cb();
                            }
                            continue;
                        case 43:
                            if (this._lastPos < i) this._key += chunk.latin1Slice(this._lastPos, i);
                            this._key += " ";
                            this._lastPos = i + 1;
                            break;
                        case 37:
                            if (this._encode === 0) this._encode = 1;
                            if (this._lastPos < i) this._key += chunk.latin1Slice(this._lastPos, i);
                            this._lastPos = i + 1;
                            this._byte = -1;
                            i = readPctEnc(this, chunk, i + 1, len);
                            if (i === -1) return cb(new Error("Malformed urlencoded form"));
                            if (i >= len) return cb();
                            ++this._bytesKey;
                            i = skipKeyBytes(this, chunk, i, len);
                            continue;
                    }
                    ++i;
                    ++this._bytesKey;
                    i = skipKeyBytes(this, chunk, i, len);
                }
                if (this._lastPos < i) this._key += chunk.latin1Slice(this._lastPos, i);
            } else {
                // Parsing value
                i = skipValBytes(this, chunk, i, len);
                while(i < len){
                    switch(chunk[i]){
                        case 38:
                            if (this._lastPos < i) this._val += chunk.latin1Slice(this._lastPos, i);
                            this._lastPos = ++i;
                            this._inKey = true;
                            this._val = this._decoder(this._val, this._encode);
                            this._encode = 0;
                            if (this._bytesKey > 0 || this._bytesVal > 0) {
                                this.emit("field", this._key, this._val, {
                                    nameTruncated: this._keyTrunc,
                                    valueTruncated: this._valTrunc,
                                    encoding: this.charset,
                                    mimeType: "text/plain"
                                });
                            }
                            this._key = "";
                            this._val = "";
                            this._keyTrunc = false;
                            this._valTrunc = false;
                            this._bytesKey = 0;
                            this._bytesVal = 0;
                            if (++this._fields >= this.fieldsLimit) {
                                this.emit("fieldsLimit");
                                return cb();
                            }
                            continue main;
                        case 43:
                            if (this._lastPos < i) this._val += chunk.latin1Slice(this._lastPos, i);
                            this._val += " ";
                            this._lastPos = i + 1;
                            break;
                        case 37:
                            if (this._encode === 0) this._encode = 1;
                            if (this._lastPos < i) this._val += chunk.latin1Slice(this._lastPos, i);
                            this._lastPos = i + 1;
                            this._byte = -1;
                            i = readPctEnc(this, chunk, i + 1, len);
                            if (i === -1) return cb(new Error("Malformed urlencoded form"));
                            if (i >= len) return cb();
                            ++this._bytesVal;
                            i = skipValBytes(this, chunk, i, len);
                            continue;
                    }
                    ++i;
                    ++this._bytesVal;
                    i = skipValBytes(this, chunk, i, len);
                }
                if (this._lastPos < i) this._val += chunk.latin1Slice(this._lastPos, i);
            }
        }
        cb();
    }
    _final(cb) {
        if (this._byte !== -2) return cb(new Error("Malformed urlencoded form"));
        if (!this._inKey || this._bytesKey > 0 || this._bytesVal > 0) {
            if (this._inKey) this._key = this._decoder(this._key, this._encode);
            else this._val = this._decoder(this._val, this._encode);
            this.emit("field", this._key, this._val, {
                nameTruncated: this._keyTrunc,
                valueTruncated: this._valTrunc,
                encoding: this.charset,
                mimeType: "text/plain"
            });
        }
        cb();
    }
}
function readPctEnc(self, chunk, pos, len) {
    if (pos >= len) return len;
    if (self._byte === -1) {
        // We saw a '%' but no hex characters yet
        const hexUpper = HEX_VALUES[chunk[pos++]];
        if (hexUpper === -1) return -1;
        if (hexUpper >= 8) self._encode = 2; // Indicate high bits detected
        if (pos < len) {
            // Both hex characters are in this chunk
            const hexLower = HEX_VALUES[chunk[pos++]];
            if (hexLower === -1) return -1;
            if (self._inKey) self._key += String.fromCharCode((hexUpper << 4) + hexLower);
            else self._val += String.fromCharCode((hexUpper << 4) + hexLower);
            self._byte = -2;
            self._lastPos = pos;
        } else {
            // Only one hex character was available in this chunk
            self._byte = hexUpper;
        }
    } else {
        // We saw only one hex character so far
        const hexLower = HEX_VALUES[chunk[pos++]];
        if (hexLower === -1) return -1;
        if (self._inKey) self._key += String.fromCharCode((self._byte << 4) + hexLower);
        else self._val += String.fromCharCode((self._byte << 4) + hexLower);
        self._byte = -2;
        self._lastPos = pos;
    }
    return pos;
}
function skipKeyBytes(self, chunk, pos, len) {
    // Skip bytes if we've truncated
    if (self._bytesKey > self.fieldNameSizeLimit) {
        if (!self._keyTrunc) {
            if (self._lastPos < pos) self._key += chunk.latin1Slice(self._lastPos, pos - 1);
        }
        self._keyTrunc = true;
        for(; pos < len; ++pos){
            const code = chunk[pos];
            if (code === 61 /* '=' */  || code === 38 /* '&' */ ) break;
            ++self._bytesKey;
        }
        self._lastPos = pos;
    }
    return pos;
}
function skipValBytes(self, chunk, pos, len) {
    // Skip bytes if we've truncated
    if (self._bytesVal > self.fieldSizeLimit) {
        if (!self._valTrunc) {
            if (self._lastPos < pos) self._val += chunk.latin1Slice(self._lastPos, pos - 1);
        }
        self._valTrunc = true;
        for(; pos < len; ++pos){
            if (chunk[pos] === 38 /* '&' */ ) break;
            ++self._bytesVal;
        }
        self._lastPos = pos;
    }
    return pos;
}
/* eslint-disable no-multi-spaces */ const HEX_VALUES = [
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    12,
    13,
    14,
    15,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    12,
    13,
    14,
    15,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1
];
/* eslint-enable no-multi-spaces */ module.exports = URLEncoded;


/***/ }),

/***/ 5344:
/***/ ((module) => {

"use strict";

function parseContentType(str) {
    if (str.length === 0) return;
    const params = Object.create(null);
    let i = 0;
    // Parse type
    for(; i < str.length; ++i){
        const code = str.charCodeAt(i);
        if (TOKEN[code] !== 1) {
            if (code !== 47 /* '/' */  || i === 0) return;
            break;
        }
    }
    // Check for type without subtype
    if (i === str.length) return;
    const type = str.slice(0, i).toLowerCase();
    // Parse subtype
    const subtypeStart = ++i;
    for(; i < str.length; ++i){
        const code = str.charCodeAt(i);
        if (TOKEN[code] !== 1) {
            // Make sure we have a subtype
            if (i === subtypeStart) return;
            if (parseContentTypeParams(str, i, params) === undefined) return;
            break;
        }
    }
    // Make sure we have a subtype
    if (i === subtypeStart) return;
    const subtype = str.slice(subtypeStart, i).toLowerCase();
    return {
        type,
        subtype,
        params
    };
}
function parseContentTypeParams(str, i, params) {
    while(i < str.length){
        // Consume whitespace
        for(; i < str.length; ++i){
            const code = str.charCodeAt(i);
            if (code !== 32 /* ' ' */  && code !== 9 /* '\t' */ ) break;
        }
        // Ended on whitespace
        if (i === str.length) break;
        // Check for malformed parameter
        if (str.charCodeAt(i++) !== 59 /* ';' */ ) return;
        // Consume whitespace
        for(; i < str.length; ++i){
            const code = str.charCodeAt(i);
            if (code !== 32 /* ' ' */  && code !== 9 /* '\t' */ ) break;
        }
        // Ended on whitespace (malformed)
        if (i === str.length) return;
        let name;
        const nameStart = i;
        // Parse parameter name
        for(; i < str.length; ++i){
            const code = str.charCodeAt(i);
            if (TOKEN[code] !== 1) {
                if (code !== 61 /* '=' */ ) return;
                break;
            }
        }
        // No value (malformed)
        if (i === str.length) return;
        name = str.slice(nameStart, i);
        ++i; // Skip over '='
        // No value (malformed)
        if (i === str.length) return;
        let value = "";
        let valueStart;
        if (str.charCodeAt(i) === 34 /* '"' */ ) {
            valueStart = ++i;
            let escaping = false;
            // Parse quoted value
            for(; i < str.length; ++i){
                const code = str.charCodeAt(i);
                if (code === 92 /* '\\' */ ) {
                    if (escaping) {
                        valueStart = i;
                        escaping = false;
                    } else {
                        value += str.slice(valueStart, i);
                        escaping = true;
                    }
                    continue;
                }
                if (code === 34 /* '"' */ ) {
                    if (escaping) {
                        valueStart = i;
                        escaping = false;
                        continue;
                    }
                    value += str.slice(valueStart, i);
                    break;
                }
                if (escaping) {
                    valueStart = i - 1;
                    escaping = false;
                }
                // Invalid unescaped quoted character (malformed)
                if (QDTEXT[code] !== 1) return;
            }
            // No end quote (malformed)
            if (i === str.length) return;
            ++i; // Skip over double quote
        } else {
            valueStart = i;
            // Parse unquoted value
            for(; i < str.length; ++i){
                const code = str.charCodeAt(i);
                if (TOKEN[code] !== 1) {
                    // No value (malformed)
                    if (i === valueStart) return;
                    break;
                }
            }
            value = str.slice(valueStart, i);
        }
        name = name.toLowerCase();
        if (params[name] === undefined) params[name] = value;
    }
    return params;
}
function parseDisposition(str, defDecoder) {
    if (str.length === 0) return;
    const params = Object.create(null);
    let i = 0;
    for(; i < str.length; ++i){
        const code = str.charCodeAt(i);
        if (TOKEN[code] !== 1) {
            if (parseDispositionParams(str, i, params, defDecoder) === undefined) return;
            break;
        }
    }
    const type = str.slice(0, i).toLowerCase();
    return {
        type,
        params
    };
}
function parseDispositionParams(str, i, params, defDecoder) {
    while(i < str.length){
        // Consume whitespace
        for(; i < str.length; ++i){
            const code = str.charCodeAt(i);
            if (code !== 32 /* ' ' */  && code !== 9 /* '\t' */ ) break;
        }
        // Ended on whitespace
        if (i === str.length) break;
        // Check for malformed parameter
        if (str.charCodeAt(i++) !== 59 /* ';' */ ) return;
        // Consume whitespace
        for(; i < str.length; ++i){
            const code = str.charCodeAt(i);
            if (code !== 32 /* ' ' */  && code !== 9 /* '\t' */ ) break;
        }
        // Ended on whitespace (malformed)
        if (i === str.length) return;
        let name;
        const nameStart = i;
        // Parse parameter name
        for(; i < str.length; ++i){
            const code = str.charCodeAt(i);
            if (TOKEN[code] !== 1) {
                if (code === 61 /* '=' */ ) break;
                return;
            }
        }
        // No value (malformed)
        if (i === str.length) return;
        let value = "";
        let valueStart;
        let charset;
        //~ let lang;
        name = str.slice(nameStart, i);
        if (name.charCodeAt(name.length - 1) === 42 /* '*' */ ) {
            // Extended value
            const charsetStart = ++i;
            // Parse charset name
            for(; i < str.length; ++i){
                const code = str.charCodeAt(i);
                if (CHARSET[code] !== 1) {
                    if (code !== 39 /* '\'' */ ) return;
                    break;
                }
            }
            // Incomplete charset (malformed)
            if (i === str.length) return;
            charset = str.slice(charsetStart, i);
            ++i; // Skip over the '\''
            //~ const langStart = ++i;
            // Parse language name
            for(; i < str.length; ++i){
                const code = str.charCodeAt(i);
                if (code === 39 /* '\'' */ ) break;
            }
            // Incomplete language (malformed)
            if (i === str.length) return;
            //~ lang = str.slice(langStart, i);
            ++i; // Skip over the '\''
            // No value (malformed)
            if (i === str.length) return;
            valueStart = i;
            let encode = 0;
            // Parse value
            for(; i < str.length; ++i){
                const code = str.charCodeAt(i);
                if (EXTENDED_VALUE[code] !== 1) {
                    if (code === 37 /* '%' */ ) {
                        let hexUpper;
                        let hexLower;
                        if (i + 2 < str.length && (hexUpper = HEX_VALUES[str.charCodeAt(i + 1)]) !== -1 && (hexLower = HEX_VALUES[str.charCodeAt(i + 2)]) !== -1) {
                            const byteVal = (hexUpper << 4) + hexLower;
                            value += str.slice(valueStart, i);
                            value += String.fromCharCode(byteVal);
                            i += 2;
                            valueStart = i + 1;
                            if (byteVal >= 128) encode = 2;
                            else if (encode === 0) encode = 1;
                            continue;
                        }
                        // '%' disallowed in non-percent encoded contexts (malformed)
                        return;
                    }
                    break;
                }
            }
            value += str.slice(valueStart, i);
            value = convertToUTF8(value, charset, encode);
            if (value === undefined) return;
        } else {
            // Non-extended value
            ++i; // Skip over '='
            // No value (malformed)
            if (i === str.length) return;
            if (str.charCodeAt(i) === 34 /* '"' */ ) {
                valueStart = ++i;
                let escaping = false;
                // Parse quoted value
                for(; i < str.length; ++i){
                    const code = str.charCodeAt(i);
                    if (code === 92 /* '\\' */ ) {
                        if (escaping) {
                            valueStart = i;
                            escaping = false;
                        } else {
                            value += str.slice(valueStart, i);
                            escaping = true;
                        }
                        continue;
                    }
                    if (code === 34 /* '"' */ ) {
                        if (escaping) {
                            valueStart = i;
                            escaping = false;
                            continue;
                        }
                        value += str.slice(valueStart, i);
                        break;
                    }
                    if (escaping) {
                        valueStart = i - 1;
                        escaping = false;
                    }
                    // Invalid unescaped quoted character (malformed)
                    if (QDTEXT[code] !== 1) return;
                }
                // No end quote (malformed)
                if (i === str.length) return;
                ++i; // Skip over double quote
            } else {
                valueStart = i;
                // Parse unquoted value
                for(; i < str.length; ++i){
                    const code = str.charCodeAt(i);
                    if (TOKEN[code] !== 1) {
                        // No value (malformed)
                        if (i === valueStart) return;
                        break;
                    }
                }
                value = str.slice(valueStart, i);
            }
            value = defDecoder(value, 2);
            if (value === undefined) return;
        }
        name = name.toLowerCase();
        if (params[name] === undefined) params[name] = value;
    }
    return params;
}
function getDecoder(charset) {
    let lc;
    while(true){
        switch(charset){
            case "utf-8":
            case "utf8":
                return decoders.utf8;
            case "latin1":
            case "ascii":
            case "us-ascii":
            case "iso-8859-1":
            case "iso8859-1":
            case "iso88591":
            case "iso_8859-1":
            case "windows-1252":
            case "iso_8859-1:1987":
            case "cp1252":
            case "x-cp1252":
                return decoders.latin1;
            case "utf16le":
            case "utf-16le":
            case "ucs2":
            case "ucs-2":
                return decoders.utf16le;
            case "base64":
                return decoders.base64;
            default:
                if (lc === undefined) {
                    lc = true;
                    charset = charset.toLowerCase();
                    continue;
                }
                return decoders.other.bind(charset);
        }
    }
}
const decoders = {
    utf8: (data, hint)=>{
        if (data.length === 0) return "";
        if (typeof data === "string") {
            // If `data` never had any percent-encoded bytes or never had any that
            // were outside of the ASCII range, then we can safely just return the
            // input since UTF-8 is ASCII compatible
            if (hint < 2) return data;
            data = Buffer.from(data, "latin1");
        }
        return data.utf8Slice(0, data.length);
    },
    latin1: (data, hint)=>{
        if (data.length === 0) return "";
        if (typeof data === "string") return data;
        return data.latin1Slice(0, data.length);
    },
    utf16le: (data, hint)=>{
        if (data.length === 0) return "";
        if (typeof data === "string") data = Buffer.from(data, "latin1");
        return data.ucs2Slice(0, data.length);
    },
    base64: (data, hint)=>{
        if (data.length === 0) return "";
        if (typeof data === "string") data = Buffer.from(data, "latin1");
        return data.base64Slice(0, data.length);
    },
    other: (data, hint)=>{
        if (data.length === 0) return "";
        if (typeof data === "string") data = Buffer.from(data, "latin1");
        try {
            const decoder = new TextDecoder(void 0);
            return decoder.decode(data);
        } catch  {}
    }
};
function convertToUTF8(data, charset, hint) {
    const decode = getDecoder(charset);
    if (decode) return decode(data, hint);
}
function basename(path) {
    if (typeof path !== "string") return "";
    for(let i = path.length - 1; i >= 0; --i){
        switch(path.charCodeAt(i)){
            case 0x2F:
            case 0x5C:
                path = path.slice(i + 1);
                return path === ".." || path === "." ? "" : path;
        }
    }
    return path === ".." || path === "." ? "" : path;
}
const TOKEN = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
];
const QDTEXT = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
];
const CHARSET = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
];
const EXTENDED_VALUE = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    0,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
];
/* eslint-disable no-multi-spaces */ const HEX_VALUES = [
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    12,
    13,
    14,
    15,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    12,
    13,
    14,
    15,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1
];
/* eslint-enable no-multi-spaces */ module.exports = {
    basename,
    convertToUTF8,
    getDecoder,
    parseContentType,
    parseDisposition
};


/***/ }),

/***/ 5826:
/***/ ((module) => {

"use strict";

var UTF8_ACCEPT = 12;
var UTF8_REJECT = 0;
var UTF8_DATA = [
    // The first part of the table maps bytes to character to a transition.
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    4,
    4,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    6,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    8,
    7,
    7,
    10,
    9,
    9,
    9,
    11,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    // The second part of the table maps a state to a new state when adding a
    // transition.
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    12,
    0,
    0,
    0,
    0,
    24,
    36,
    48,
    60,
    72,
    84,
    96,
    0,
    12,
    12,
    12,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    24,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    48,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    // The third part maps the current transition to a mask that needs to apply
    // to the byte.
    0x7F,
    0x3F,
    0x3F,
    0x3F,
    0x00,
    0x1F,
    0x0F,
    0x0F,
    0x0F,
    0x07,
    0x07,
    0x07
];
function decodeURIComponent(uri) {
    var percentPosition = uri.indexOf("%");
    if (percentPosition === -1) return uri;
    var length = uri.length;
    var decoded = "";
    var last = 0;
    var codepoint = 0;
    var startOfOctets = percentPosition;
    var state = UTF8_ACCEPT;
    while(percentPosition > -1 && percentPosition < length){
        var high = hexCodeToInt(uri[percentPosition + 1], 4);
        var low = hexCodeToInt(uri[percentPosition + 2], 0);
        var byte = high | low;
        var type = UTF8_DATA[byte];
        state = UTF8_DATA[256 + state + type];
        codepoint = codepoint << 6 | byte & UTF8_DATA[364 + type];
        if (state === UTF8_ACCEPT) {
            decoded += uri.slice(last, startOfOctets);
            decoded += codepoint <= 0xFFFF ? String.fromCharCode(codepoint) : String.fromCharCode(0xD7C0 + (codepoint >> 10), 0xDC00 + (codepoint & 0x3FF));
            codepoint = 0;
            last = percentPosition + 3;
            percentPosition = startOfOctets = uri.indexOf("%", last);
        } else if (state === UTF8_REJECT) {
            return null;
        } else {
            percentPosition += 3;
            if (percentPosition < length && uri.charCodeAt(percentPosition) === 37) continue;
            return null;
        }
    }
    return decoded + uri.slice(last);
}
var HEX = {
    "0": 0,
    "1": 1,
    "2": 2,
    "3": 3,
    "4": 4,
    "5": 5,
    "6": 6,
    "7": 7,
    "8": 8,
    "9": 9,
    "a": 10,
    "A": 10,
    "b": 11,
    "B": 11,
    "c": 12,
    "C": 12,
    "d": 13,
    "D": 13,
    "e": 14,
    "E": 14,
    "f": 15,
    "F": 15
};
function hexCodeToInt(c, shift) {
    var i = HEX[c];
    return i === undefined ? 255 : i << shift;
}
module.exports = decodeURIComponent;


/***/ }),

/***/ 8054:
/***/ ((module) => {

"use strict";

module.exports = function(data, opts) {
    if (!opts) opts = {};
    if (typeof opts === "function") opts = {
        cmp: opts
    };
    var cycles = typeof opts.cycles === "boolean" ? opts.cycles : false;
    var cmp = opts.cmp && function(f) {
        return function(node) {
            return function(a, b) {
                var aobj = {
                    key: a,
                    value: node[a]
                };
                var bobj = {
                    key: b,
                    value: node[b]
                };
                return f(aobj, bobj);
            };
        };
    }(opts.cmp);
    var seen = [];
    return function stringify(node) {
        if (node && node.toJSON && typeof node.toJSON === "function") {
            node = node.toJSON();
        }
        if (node === undefined) return;
        if (typeof node == "number") return isFinite(node) ? "" + node : "null";
        if (typeof node !== "object") return JSON.stringify(node);
        var i, out;
        if (Array.isArray(node)) {
            out = "[";
            for(i = 0; i < node.length; i++){
                if (i) out += ",";
                out += stringify(node[i]) || "null";
            }
            return out + "]";
        }
        if (node === null) return "null";
        if (seen.indexOf(node) !== -1) {
            if (cycles) return JSON.stringify("__cycle__");
            throw new TypeError("Converting circular structure to JSON");
        }
        var seenIndex = seen.push(node) - 1;
        var keys = Object.keys(node).sort(cmp && cmp(node));
        out = "";
        for(i = 0; i < keys.length; i++){
            var key = keys[i];
            var value = stringify(node[key]);
            if (!value) continue;
            if (out) out += ",";
            out += JSON.stringify(key) + ":" + value;
        }
        seen.splice(seenIndex, 1);
        return "{" + out + "}";
    }(data);
};


/***/ }),

/***/ 1663:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const parse = __webpack_require__(7548);
const stringify = __webpack_require__(6941);
const fastQuerystring = {
    parse,
    stringify
};
/**
 * Enable TS and JS support
 *
 * - `const qs = require('fast-querystring')`
 * - `import qs from 'fast-querystring'`
 */ module.exports = fastQuerystring;
module.exports["default"] = fastQuerystring;
module.exports.parse = parse;
module.exports.stringify = stringify;


/***/ }),

/***/ 9136:
/***/ ((module) => {

"use strict";
// This file is taken from Node.js project.
// Full implementation can be found from https://github.com/nodejs/node/blob/main/lib/internal/querystring.js

const hexTable = Array.from({
    length: 256
}, (_, i)=>"%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
// These characters do not need escaping when generating query strings:
// ! - . _ ~
// ' ( ) *
// digits
// alpha (uppercase)
// alpha (lowercase)
// rome-ignore format: the array should not be formatted
const noEscape = new Int8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    0
]);
/**
 * @param {string} str
 * @returns {string}
 */ function encodeString(str) {
    const len = str.length;
    if (len === 0) return "";
    let out = "";
    let lastPos = 0;
    let i = 0;
    outer: for(; i < len; i++){
        let c = str.charCodeAt(i);
        // ASCII
        while(c < 0x80){
            if (noEscape[c] !== 1) {
                if (lastPos < i) out += str.slice(lastPos, i);
                lastPos = i + 1;
                out += hexTable[c];
            }
            if (++i === len) break outer;
            c = str.charCodeAt(i);
        }
        if (lastPos < i) out += str.slice(lastPos, i);
        // Multi-byte characters ...
        if (c < 0x800) {
            lastPos = i + 1;
            out += hexTable[0xc0 | c >> 6] + hexTable[0x80 | c & 0x3f];
            continue;
        }
        if (c < 0xd800 || c >= 0xe000) {
            lastPos = i + 1;
            out += hexTable[0xe0 | c >> 12] + hexTable[0x80 | c >> 6 & 0x3f] + hexTable[0x80 | c & 0x3f];
            continue;
        }
        // Surrogate pair
        ++i;
        // This branch should never happen because all URLSearchParams entries
        // should already be converted to USVString. But, included for
        // completion's sake anyway.
        if (i >= len) {
            throw new Error("URI malformed");
        }
        const c2 = str.charCodeAt(i) & 0x3ff;
        lastPos = i + 1;
        c = 0x10000 + ((c & 0x3ff) << 10 | c2);
        out += hexTable[0xf0 | c >> 18] + hexTable[0x80 | c >> 12 & 0x3f] + hexTable[0x80 | c >> 6 & 0x3f] + hexTable[0x80 | c & 0x3f];
    }
    if (lastPos === 0) return str;
    if (lastPos < len) return out + str.slice(lastPos);
    return out;
}
module.exports = {
    encodeString
};


/***/ }),

/***/ 7548:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const fastDecode = __webpack_require__(5826);
const plusRegex = /\+/g;
const Empty = function() {};
Empty.prototype = Object.create(null);
/**
 * @callback parse
 * @param {string} input
 */ function parse(input) {
    // Optimization: Use new Empty() instead of Object.create(null) for performance
    // v8 has a better optimization for initializing functions compared to Object
    const result = new Empty();
    if (typeof input !== "string") {
        return result;
    }
    let inputLength = input.length;
    let key = "";
    let value = "";
    let startingIndex = -1;
    let equalityIndex = -1;
    let shouldDecodeKey = false;
    let shouldDecodeValue = false;
    let keyHasPlus = false;
    let valueHasPlus = false;
    let hasBothKeyValuePair = false;
    let c = 0;
    // Have a boundary of input.length + 1 to access last pair inside the loop.
    for(let i = 0; i < inputLength + 1; i++){
        c = i !== inputLength ? input.charCodeAt(i) : 38;
        // Handle '&' and end of line to pass the current values to result
        if (c === 38) {
            hasBothKeyValuePair = equalityIndex > startingIndex;
            // Optimization: Reuse equality index to store the end of key
            if (!hasBothKeyValuePair) {
                equalityIndex = i;
            }
            key = input.slice(startingIndex + 1, equalityIndex);
            // Add key/value pair only if the range size is greater than 1; a.k.a. contains at least "="
            if (hasBothKeyValuePair || key.length > 0) {
                // Optimization: Replace '+' with space
                if (keyHasPlus) {
                    key = key.replace(plusRegex, " ");
                }
                // Optimization: Do not decode if it's not necessary.
                if (shouldDecodeKey) {
                    key = fastDecode(key) || key;
                }
                if (hasBothKeyValuePair) {
                    value = input.slice(equalityIndex + 1, i);
                    if (valueHasPlus) {
                        value = value.replace(plusRegex, " ");
                    }
                    if (shouldDecodeValue) {
                        value = fastDecode(value) || value;
                    }
                }
                const currentValue = result[key];
                if (currentValue === undefined) {
                    result[key] = value;
                } else {
                    // Optimization: value.pop is faster than Array.isArray(value)
                    if (currentValue.pop) {
                        currentValue.push(value);
                    } else {
                        result[key] = [
                            currentValue,
                            value
                        ];
                    }
                }
            }
            // Reset reading key value pairs
            value = "";
            startingIndex = i;
            equalityIndex = i;
            shouldDecodeKey = false;
            shouldDecodeValue = false;
            keyHasPlus = false;
            valueHasPlus = false;
        } else if (c === 61) {
            if (equalityIndex <= startingIndex) {
                equalityIndex = i;
            } else {
                shouldDecodeValue = true;
            }
        } else if (c === 43) {
            if (equalityIndex > startingIndex) {
                valueHasPlus = true;
            } else {
                keyHasPlus = true;
            }
        } else if (c === 37) {
            if (equalityIndex > startingIndex) {
                shouldDecodeValue = true;
            } else {
                shouldDecodeKey = true;
            }
        }
    }
    return result;
}
module.exports = parse;


/***/ }),

/***/ 6941:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const { encodeString  } = __webpack_require__(9136);
function getAsPrimitive(value) {
    const type = typeof value;
    if (type === "string") {
        // Length check is handled inside encodeString function
        return encodeString(value);
    } else if (type === "bigint") {
        return value.toString();
    } else if (type === "boolean") {
        return value ? "true" : "false";
    } else if (type === "number" && Number.isFinite(value)) {
        return value < 1e21 ? "" + value : encodeString("" + value);
    }
    return "";
}
/**
 * @param {Record<string, string | number | boolean
 * | ReadonlyArray<string | number | boolean> | null>} input
 * @returns {string}
 */ function stringify(input) {
    let result = "";
    if (input === null || typeof input !== "object") {
        return result;
    }
    const separator = "&";
    const keys = Object.keys(input);
    const keyLength = keys.length;
    let valueLength = 0;
    for(let i = 0; i < keyLength; i++){
        const key = keys[i];
        const value = input[key];
        const encodedKey = encodeString(key) + "=";
        if (i) {
            result += separator;
        }
        if (Array.isArray(value)) {
            valueLength = value.length;
            for(let j = 0; j < valueLength; j++){
                if (j) {
                    result += separator;
                }
                // Optimization: Dividing into multiple lines improves the performance.
                // Since v8 does not need to care about the '+' character if it was one-liner.
                result += encodedKey;
                result += getAsPrimitive(value[j]);
            }
        } else {
            result += encodedKey;
            result += getAsPrimitive(value);
        }
    }
    return result;
}
module.exports = stringify;


/***/ }),

/***/ 5544:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/*
Copyright (c) 2014 Petka Antonov

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/ function Url() {
    //For more efficient internal representation and laziness.
    //The non-underscore versions of these properties are accessor functions
    //defined on the prototype.
    this._protocol = null;
    this._href = "";
    this._port = -1;
    this._query = null;
    this.auth = null;
    this.slashes = null;
    this.host = null;
    this.hostname = null;
    this.hash = null;
    this.search = null;
    this.pathname = null;
    this._prependSlash = false;
}
var querystring = __webpack_require__(3477);
Url.queryString = querystring;
Url.prototype.parse = function Url$parse(str, parseQueryString, hostDenotesSlash, disableAutoEscapeChars) {
    if (typeof str !== "string") {
        throw new TypeError("Parameter 'url' must be a string, not " + typeof str);
    }
    var start = 0;
    var end = str.length - 1;
    //Trim leading and trailing ws
    while(str.charCodeAt(start) <= 0x20 /*' '*/ )start++;
    while(str.charCodeAt(end) <= 0x20 /*' '*/ )end--;
    start = this._parseProtocol(str, start, end);
    //Javascript doesn't have host
    if (this._protocol !== "javascript") {
        start = this._parseHost(str, start, end, hostDenotesSlash);
        var proto = this._protocol;
        if (!this.hostname && (this.slashes || proto && !slashProtocols[proto])) {
            this.hostname = this.host = "";
        }
    }
    if (start <= end) {
        var ch = str.charCodeAt(start);
        if (ch === 0x2F /*'/'*/  || ch === 0x5C /*'\'*/ ) {
            this._parsePath(str, start, end, disableAutoEscapeChars);
        } else if (ch === 0x3F /*'?'*/ ) {
            this._parseQuery(str, start, end, disableAutoEscapeChars);
        } else if (ch === 0x23 /*'#'*/ ) {
            this._parseHash(str, start, end, disableAutoEscapeChars);
        } else if (this._protocol !== "javascript") {
            this._parsePath(str, start, end, disableAutoEscapeChars);
        } else {
            this.pathname = str.slice(start, end + 1);
        }
    }
    if (!this.pathname && this.hostname && this._slashProtocols[this._protocol]) {
        this.pathname = "/";
    }
    if (parseQueryString) {
        var search = this.search;
        if (search == null) {
            search = this.search = "";
        }
        if (search.charCodeAt(0) === 0x3F /*'?'*/ ) {
            search = search.slice(1);
        }
        //This calls a setter function, there is no .query data property
        this.query = Url.queryString.parse(search);
    }
};
Url.prototype.resolve = function Url$resolve(relative) {
    return this.resolveObject(Url.parse(relative, false, true)).format();
};
Url.prototype.format = function Url$format() {
    var auth = this.auth || "";
    if (auth) {
        auth = encodeURIComponent(auth);
        auth = auth.replace(/%3A/i, ":");
        auth += "@";
    }
    var protocol = this.protocol || "";
    var pathname = this.pathname || "";
    var hash = this.hash || "";
    var search = this.search || "";
    var query = "";
    var hostname = this.hostname || "";
    var port = this.port || "";
    var host = false;
    var scheme = "";
    //Cache the result of the getter function
    var q = this.query;
    if (q && typeof q === "object") {
        query = Url.queryString.stringify(q);
    }
    if (!search) {
        search = query ? "?" + query : "";
    }
    if (protocol && protocol.charCodeAt(protocol.length - 1) !== 0x3A /*':'*/ ) protocol += ":";
    if (this.host) {
        host = auth + this.host;
    } else if (hostname) {
        var ip6 = hostname.indexOf(":") > -1;
        if (ip6) hostname = "[" + hostname + "]";
        host = auth + hostname + (port ? ":" + port : "");
    }
    var slashes = this.slashes || (!protocol || slashProtocols[protocol]) && host !== false;
    if (protocol) scheme = protocol + (slashes ? "//" : "");
    else if (slashes) scheme = "//";
    if (slashes && pathname && pathname.charCodeAt(0) !== 0x2F /*'/'*/ ) {
        pathname = "/" + pathname;
    }
    if (search && search.charCodeAt(0) !== 0x3F /*'?'*/ ) search = "?" + search;
    if (hash && hash.charCodeAt(0) !== 0x23 /*'#'*/ ) hash = "#" + hash;
    pathname = escapePathName(pathname);
    search = escapeSearch(search);
    return scheme + (host === false ? "" : host) + pathname + search + hash;
};
Url.prototype.resolveObject = function Url$resolveObject(relative) {
    if (typeof relative === "string") relative = Url.parse(relative, false, true);
    var result = this._clone();
    // hash is always overridden, no matter what.
    // even href="" will remove it.
    result.hash = relative.hash;
    // if the relative url is empty, then there"s nothing left to do here.
    if (!relative.href) {
        result._href = "";
        return result;
    }
    // hrefs like //foo/bar always cut to the protocol.
    if (relative.slashes && !relative._protocol) {
        relative._copyPropsTo(result, true);
        if (slashProtocols[result._protocol] && result.hostname && !result.pathname) {
            result.pathname = "/";
        }
        result._href = "";
        return result;
    }
    if (relative._protocol && relative._protocol !== result._protocol) {
        // if it"s a known url protocol, then changing
        // the protocol does weird things
        // first, if it"s not file:, then we MUST have a host,
        // and if there was a path
        // to begin with, then we MUST have a path.
        // if it is file:, then the host is dropped,
        // because that"s known to be hostless.
        // anything else is assumed to be absolute.
        if (!slashProtocols[relative._protocol]) {
            relative._copyPropsTo(result, false);
            result._href = "";
            return result;
        }
        result._protocol = relative._protocol;
        if (!relative.host && relative._protocol !== "javascript") {
            var relPath = (relative.pathname || "").split("/");
            while(relPath.length && !(relative.host = relPath.shift()));
            if (!relative.host) relative.host = "";
            if (!relative.hostname) relative.hostname = "";
            if (relPath[0] !== "") relPath.unshift("");
            if (relPath.length < 2) relPath.unshift("");
            result.pathname = relPath.join("/");
        } else {
            result.pathname = relative.pathname;
        }
        result.search = relative.search;
        result.host = relative.host || "";
        result.auth = relative.auth;
        result.hostname = relative.hostname || relative.host;
        result._port = relative._port;
        result.slashes = result.slashes || relative.slashes;
        result._href = "";
        return result;
    }
    var isSourceAbs = result.pathname && result.pathname.charCodeAt(0) === 0x2F /*'/'*/ ;
    var isRelAbs = relative.host || relative.pathname && relative.pathname.charCodeAt(0) === 0x2F /*'/'*/ ;
    var mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname;
    var removeAllDots = mustEndAbs;
    var srcPath = result.pathname && result.pathname.split("/") || [];
    var relPath = relative.pathname && relative.pathname.split("/") || [];
    var psychotic = result._protocol && !slashProtocols[result._protocol];
    // if the url is a non-slashed url, then relative
    // links like ../.. should be able
    // to crawl up to the hostname, as well.  This is strange.
    // result.protocol has already been set by now.
    // Later on, put the first path part into the host field.
    if (psychotic) {
        result.hostname = "";
        result._port = -1;
        if (result.host) {
            if (srcPath[0] === "") srcPath[0] = result.host;
            else srcPath.unshift(result.host);
        }
        result.host = "";
        if (relative._protocol) {
            relative.hostname = "";
            relative._port = -1;
            if (relative.host) {
                if (relPath[0] === "") relPath[0] = relative.host;
                else relPath.unshift(relative.host);
            }
            relative.host = "";
        }
        mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
    }
    if (isRelAbs) {
        // it"s absolute.
        result.host = relative.host ? relative.host : result.host;
        result.hostname = relative.hostname ? relative.hostname : result.hostname;
        result.search = relative.search;
        srcPath = relPath;
    // fall through to the dot-handling below.
    } else if (relPath.length) {
        // it"s relative
        // throw away the existing file, and take the new path instead.
        if (!srcPath) srcPath = [];
        srcPath.pop();
        srcPath = srcPath.concat(relPath);
        result.search = relative.search;
    } else if (relative.search) {
        // just pull out the search.
        // like href="?foo".
        // Put this after the other two cases because it simplifies the booleans
        if (psychotic) {
            result.hostname = result.host = srcPath.shift();
            //occationaly the auth can get stuck only in host
            //this especialy happens in cases like
            //url.resolveObject("mailto:local1@domain1", "local2@domain2")
            var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
            if (authInHost) {
                result.auth = authInHost.shift();
                result.host = result.hostname = authInHost.shift();
            }
        }
        result.search = relative.search;
        result._href = "";
        return result;
    }
    if (!srcPath.length) {
        // no path at all.  easy.
        // we"ve already handled the other stuff above.
        result.pathname = null;
        result._href = "";
        return result;
    }
    // if a url ENDs in . or .., then it must get a trailing slash.
    // however, if it ends in anything else non-slashy,
    // then it must NOT get a trailing slash.
    var last = srcPath.slice(-1)[0];
    var hasTrailingSlash = (result.host || relative.host) && (last === "." || last === "..") || last === "";
    // strip single dots, resolve double dots to parent dir
    // if the path tries to go above the root, `up` ends up > 0
    var up = 0;
    for(var i = srcPath.length; i >= 0; i--){
        last = srcPath[i];
        if (last === ".") {
            srcPath.splice(i, 1);
        } else if (last === "..") {
            srcPath.splice(i, 1);
            up++;
        } else if (up) {
            srcPath.splice(i, 1);
            up--;
        }
    }
    // if the path is allowed to go above the root, restore leading ..s
    if (!mustEndAbs && !removeAllDots) {
        for(; up--; up){
            srcPath.unshift("..");
        }
    }
    if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charCodeAt(0) !== 0x2F /*'/'*/ )) {
        srcPath.unshift("");
    }
    if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
        srcPath.push("");
    }
    var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charCodeAt(0) === 0x2F /*'/'*/ ;
    // put the host back
    if (psychotic) {
        result.hostname = result.host = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
        //occationaly the auth can get stuck only in host
        //this especialy happens in cases like
        //url.resolveObject("mailto:local1@domain1", "local2@domain2")
        var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
        if (authInHost) {
            result.auth = authInHost.shift();
            result.host = result.hostname = authInHost.shift();
        }
    }
    mustEndAbs = mustEndAbs || result.host && srcPath.length;
    if (mustEndAbs && !isAbsolute) {
        srcPath.unshift("");
    }
    result.pathname = srcPath.length === 0 ? null : srcPath.join("/");
    result.auth = relative.auth || result.auth;
    result.slashes = result.slashes || relative.slashes;
    result._href = "";
    return result;
};
var punycode = __webpack_require__(5477);
Url.prototype._hostIdna = function Url$_hostIdna(hostname) {
    // IDNA Support: Returns a punycoded representation of "domain".
    // It only converts parts of the domain name that
    // have non-ASCII characters, i.e. it doesn't matter if
    // you call it with a domain that already is ASCII-only.
    return punycode.toASCII(hostname);
};
var escapePathName = Url.prototype._escapePathName = function Url$_escapePathName(pathname) {
    if (!containsCharacter2(pathname, 0x23 /*'#'*/ , 0x3F /*'?'*/ )) {
        return pathname;
    }
    //Avoid closure creation to keep this inlinable
    return _escapePath(pathname);
};
var escapeSearch = Url.prototype._escapeSearch = function Url$_escapeSearch(search) {
    if (!containsCharacter2(search, 0x23 /*'#'*/ , -1)) return search;
    //Avoid closure creation to keep this inlinable
    return _escapeSearch(search);
};
Url.prototype._parseProtocol = function Url$_parseProtocol(str, start, end) {
    var doLowerCase = false;
    var protocolCharacters = this._protocolCharacters;
    for(var i = start; i <= end; ++i){
        var ch = str.charCodeAt(i);
        if (ch === 0x3A /*':'*/ ) {
            var protocol = str.slice(start, i);
            if (doLowerCase) protocol = protocol.toLowerCase();
            this._protocol = protocol;
            return i + 1;
        } else if (protocolCharacters[ch] === 1) {
            if (ch < 0x61 /*'a'*/ ) doLowerCase = true;
        } else {
            return start;
        }
    }
    return start;
};
Url.prototype._parseAuth = function Url$_parseAuth(str, start, end, decode) {
    var auth = str.slice(start, end + 1);
    if (decode) {
        auth = decodeURIComponent(auth);
    }
    this.auth = auth;
};
Url.prototype._parsePort = function Url$_parsePort(str, start, end) {
    //Internal format is integer for more efficient parsing
    //and for efficient trimming of leading zeros
    var port = 0;
    //Distinguish between :0 and : (no port number at all)
    var hadChars = false;
    var validPort = true;
    for(var i = start; i <= end; ++i){
        var ch = str.charCodeAt(i);
        if (0x30 /*'0'*/  <= ch && ch <= 0x39 /*'9'*/ ) {
            port = 10 * port + (ch - 0x30 /*'0'*/ );
            hadChars = true;
        } else {
            validPort = false;
            if (ch === 0x5C /*'\'*/  || ch === 0x2F /*'/'*/ ) {
                validPort = true;
            }
            break;
        }
    }
    if (port === 0 && !hadChars || !validPort) {
        if (!validPort) {
            this._port = -2;
        }
        return 0;
    }
    this._port = port;
    return i - start;
};
Url.prototype._parseHost = function Url$_parseHost(str, start, end, slashesDenoteHost) {
    var hostEndingCharacters = this._hostEndingCharacters;
    var first = str.charCodeAt(start);
    var second = str.charCodeAt(start + 1);
    if ((first === 0x2F /*'/'*/  || first === 0x5C /*'\'*/ ) && (second === 0x2F /*'/'*/  || second === 0x5C /*'\'*/ )) {
        this.slashes = true;
        //The string starts with //
        if (start === 0) {
            //The string is just "//"
            if (end < 2) return start;
            //If slashes do not denote host and there is no auth,
            //there is no host when the string starts with //
            var hasAuth = containsCharacter(str, 0x40 /*'@'*/ , 2, hostEndingCharacters);
            if (!hasAuth && !slashesDenoteHost) {
                this.slashes = null;
                return start;
            }
        }
        //There is a host that starts after the //
        start += 2;
    } else if (!this._protocol || //2. there was a protocol that requires slashes
    //e.g. in 'http:asd' 'asd' is not a hostname
    slashProtocols[this._protocol]) {
        return start;
    }
    var doLowerCase = false;
    var idna = false;
    var hostNameStart = start;
    var hostNameEnd = end;
    var lastCh = -1;
    var portLength = 0;
    var charsAfterDot = 0;
    var authNeedsDecoding = false;
    var j = -1;
    //Find the last occurrence of an @-sign until hostending character is met
    //also mark if decoding is needed for the auth portion
    for(var i = start; i <= end; ++i){
        var ch = str.charCodeAt(i);
        if (ch === 0x40 /*'@'*/ ) {
            j = i;
        } else if (ch === 0x25 /*'%'*/ ) {
            authNeedsDecoding = true;
        } else if (hostEndingCharacters[ch] === 1) {
            break;
        }
    }
    //@-sign was found at index j, everything to the left from it
    //is auth part
    if (j > -1) {
        this._parseAuth(str, start, j - 1, authNeedsDecoding);
        //hostname starts after the last @-sign
        start = hostNameStart = j + 1;
    }
    //Host name is starting with a [
    if (str.charCodeAt(start) === 0x5B /*'['*/ ) {
        for(var i = start + 1; i <= end; ++i){
            var ch = str.charCodeAt(i);
            //Assume valid IP6 is between the brackets
            if (ch === 0x5D /*']'*/ ) {
                if (str.charCodeAt(i + 1) === 0x3A /*':'*/ ) {
                    portLength = this._parsePort(str, i + 2, end) + 1;
                }
                var hostname = str.slice(start + 1, i).toLowerCase();
                this.hostname = hostname;
                this.host = this._port > 0 ? "[" + hostname + "]:" + this._port : "[" + hostname + "]";
                this.pathname = "/";
                return i + portLength + 1;
            }
        }
        //Empty hostname, [ starts a path
        return start;
    }
    for(var i = start; i <= end; ++i){
        if (charsAfterDot > 62) {
            this.hostname = this.host = str.slice(start, i);
            return i;
        }
        var ch = str.charCodeAt(i);
        if (ch === 0x3A /*':'*/ ) {
            portLength = this._parsePort(str, i + 1, end) + 1;
            hostNameEnd = i - 1;
            break;
        } else if (ch < 0x61 /*'a'*/ ) {
            if (ch === 0x2E /*'.'*/ ) {
                //Node.js ignores this error
                /*
                if (lastCh === DOT || lastCh === -1) {
                    this.hostname = this.host = "";
                    return start;
                }
                */ charsAfterDot = -1;
            } else if (0x41 /*'A'*/  <= ch && ch <= 0x5A /*'Z'*/ ) {
                doLowerCase = true;
            } else if (!(ch === 0x2D /*'-'*/  || ch === 0x5F /*'_'*/  || ch === 0x2B /*'+'*/  || 0x30 /*'0'*/  <= ch && ch <= 0x39 /*'9'*/ )) {
                if (hostEndingCharacters[ch] === 0 && this._noPrependSlashHostEnders[ch] === 0) {
                    this._prependSlash = true;
                }
                hostNameEnd = i - 1;
                break;
            }
        } else if (ch >= 0x7B /*'{'*/ ) {
            if (ch <= 0x7E /*'~'*/ ) {
                if (this._noPrependSlashHostEnders[ch] === 0) {
                    this._prependSlash = true;
                }
                hostNameEnd = i - 1;
                break;
            }
            idna = true;
        }
        lastCh = ch;
        charsAfterDot++;
    }
    //Node.js ignores this error
    /*
    if (lastCh === DOT) {
        hostNameEnd--;
    }
    */ if (hostNameEnd + 1 !== start && hostNameEnd - hostNameStart <= 256) {
        var hostname = str.slice(hostNameStart, hostNameEnd + 1);
        if (doLowerCase) hostname = hostname.toLowerCase();
        if (idna) hostname = this._hostIdna(hostname);
        this.hostname = hostname;
        this.host = this._port > 0 ? hostname + ":" + this._port : hostname;
    }
    return hostNameEnd + 1 + portLength;
};
Url.prototype._copyPropsTo = function Url$_copyPropsTo(input, noProtocol) {
    if (!noProtocol) {
        input._protocol = this._protocol;
    }
    input._href = this._href;
    input._port = this._port;
    input._prependSlash = this._prependSlash;
    input.auth = this.auth;
    input.slashes = this.slashes;
    input.host = this.host;
    input.hostname = this.hostname;
    input.hash = this.hash;
    input.search = this.search;
    input.pathname = this.pathname;
};
Url.prototype._clone = function Url$_clone() {
    var ret = new Url();
    ret._protocol = this._protocol;
    ret._href = this._href;
    ret._port = this._port;
    ret._prependSlash = this._prependSlash;
    ret.auth = this.auth;
    ret.slashes = this.slashes;
    ret.host = this.host;
    ret.hostname = this.hostname;
    ret.hash = this.hash;
    ret.search = this.search;
    ret.pathname = this.pathname;
    return ret;
};
Url.prototype._getComponentEscaped = function Url$_getComponentEscaped(str, start, end, isAfterQuery) {
    var cur = start;
    var i = start;
    var ret = "";
    var autoEscapeMap = isAfterQuery ? this._afterQueryAutoEscapeMap : this._autoEscapeMap;
    for(; i <= end; ++i){
        var ch = str.charCodeAt(i);
        var escaped = autoEscapeMap[ch];
        if (escaped !== "" && escaped !== undefined) {
            if (cur < i) ret += str.slice(cur, i);
            ret += escaped;
            cur = i + 1;
        }
    }
    if (cur < i + 1) ret += str.slice(cur, i);
    return ret;
};
Url.prototype._parsePath = function Url$_parsePath(str, start, end, disableAutoEscapeChars) {
    var pathStart = start;
    var pathEnd = end;
    var escape1 = false;
    var autoEscapeCharacters = this._autoEscapeCharacters;
    var prePath = this._port === -2 ? "/:" : "";
    for(var i = start; i <= end; ++i){
        var ch = str.charCodeAt(i);
        if (ch === 0x23 /*'#'*/ ) {
            this._parseHash(str, i, end, disableAutoEscapeChars);
            pathEnd = i - 1;
            break;
        } else if (ch === 0x3F /*'?'*/ ) {
            this._parseQuery(str, i, end, disableAutoEscapeChars);
            pathEnd = i - 1;
            break;
        } else if (!disableAutoEscapeChars && !escape1 && autoEscapeCharacters[ch] === 1) {
            escape1 = true;
        }
    }
    if (pathStart > pathEnd) {
        this.pathname = prePath === "" ? "/" : prePath;
        return;
    }
    var path;
    if (escape1) {
        path = this._getComponentEscaped(str, pathStart, pathEnd, false);
    } else {
        path = str.slice(pathStart, pathEnd + 1);
    }
    this.pathname = prePath === "" ? this._prependSlash ? "/" + path : path : prePath + path;
};
Url.prototype._parseQuery = function Url$_parseQuery(str, start, end, disableAutoEscapeChars) {
    var queryStart = start;
    var queryEnd = end;
    var escape1 = false;
    var autoEscapeCharacters = this._autoEscapeCharacters;
    for(var i = start; i <= end; ++i){
        var ch = str.charCodeAt(i);
        if (ch === 0x23 /*'#'*/ ) {
            this._parseHash(str, i, end, disableAutoEscapeChars);
            queryEnd = i - 1;
            break;
        } else if (!disableAutoEscapeChars && !escape1 && autoEscapeCharacters[ch] === 1) {
            escape1 = true;
        }
    }
    if (queryStart > queryEnd) {
        this.search = "";
        return;
    }
    var query;
    if (escape1) {
        query = this._getComponentEscaped(str, queryStart, queryEnd, true);
    } else {
        query = str.slice(queryStart, queryEnd + 1);
    }
    this.search = query;
};
Url.prototype._parseHash = function Url$_parseHash(str, start, end, disableAutoEscapeChars) {
    if (start > end) {
        this.hash = "";
        return;
    }
    this.hash = disableAutoEscapeChars ? str.slice(start, end + 1) : this._getComponentEscaped(str, start, end, true);
};
Object.defineProperty(Url.prototype, "port", {
    get: function() {
        if (this._port >= 0) {
            return "" + this._port;
        }
        return null;
    },
    set: function(v) {
        if (v == null) {
            this._port = -1;
        } else {
            this._port = parseInt(v, 10);
        }
    }
});
Object.defineProperty(Url.prototype, "query", {
    get: function() {
        var query = this._query;
        if (query != null) {
            return query;
        }
        var search = this.search;
        if (search) {
            if (search.charCodeAt(0) === 0x3F /*'?'*/ ) {
                search = search.slice(1);
            }
            if (search !== "") {
                this._query = search;
                return search;
            }
        }
        return search;
    },
    set: function(v) {
        this._query = v;
    }
});
Object.defineProperty(Url.prototype, "path", {
    get: function() {
        var p = this.pathname || "";
        var s = this.search || "";
        if (p || s) {
            return p + s;
        }
        return p == null && s ? "/" + s : null;
    },
    set: function() {}
});
Object.defineProperty(Url.prototype, "protocol", {
    get: function() {
        var proto = this._protocol;
        return proto ? proto + ":" : proto;
    },
    set: function(v) {
        if (typeof v === "string") {
            var end = v.length - 1;
            if (v.charCodeAt(end) === 0x3A /*':'*/ ) {
                this._protocol = v.slice(0, end);
            } else {
                this._protocol = v;
            }
        } else if (v == null) {
            this._protocol = null;
        }
    }
});
Object.defineProperty(Url.prototype, "href", {
    get: function() {
        var href = this._href;
        if (!href) {
            href = this._href = this.format();
        }
        return href;
    },
    set: function(v) {
        this._href = v;
    }
});
Url.parse = function Url$Parse(str, parseQueryString, hostDenotesSlash, disableAutoEscapeChars) {
    if (str instanceof Url) return str;
    var ret = new Url();
    ret.parse(str, !!parseQueryString, !!hostDenotesSlash, !!disableAutoEscapeChars);
    return ret;
};
Url.format = function Url$Format(obj) {
    if (typeof obj === "string") {
        obj = Url.parse(obj);
    }
    if (!(obj instanceof Url)) {
        return Url.prototype.format.call(obj);
    }
    return obj.format();
};
Url.resolve = function Url$Resolve(source, relative) {
    return Url.parse(source, false, true).resolve(relative);
};
Url.resolveObject = function Url$ResolveObject(source, relative) {
    if (!source) return relative;
    return Url.parse(source, false, true).resolveObject(relative);
};
function _escapePath(pathname) {
    return pathname.replace(/[?#]/g, function(match) {
        return encodeURIComponent(match);
    });
}
function _escapeSearch(search) {
    return search.replace(/#/g, function(match) {
        return encodeURIComponent(match);
    });
}
//Search `char1` (integer code for a character) in `string`
//starting from `fromIndex` and ending at `string.length - 1`
//or when a stop character is found
function containsCharacter(string, char1, fromIndex, stopCharacterTable) {
    var len = string.length;
    for(var i = fromIndex; i < len; ++i){
        var ch = string.charCodeAt(i);
        if (ch === char1) {
            return true;
        } else if (stopCharacterTable[ch] === 1) {
            return false;
        }
    }
    return false;
}
//See if `char1` or `char2` (integer codes for characters)
//is contained in `string`
function containsCharacter2(string, char1, char2) {
    for(var i = 0, len = string.length; i < len; ++i){
        var ch = string.charCodeAt(i);
        if (ch === char1 || ch === char2) return true;
    }
    return false;
}
//Makes an array of 128 uint8's which represent boolean values.
//Spec is an array of ascii code points or ascii code point ranges
//ranges are expressed as [start, end]
//Create a table with the characters 0x30-0x39 (decimals '0' - '9') and
//0x7A (lowercaseletter 'z') as `true`:
//
//var a = makeAsciiTable([[0x30, 0x39], 0x7A]);
//a[0x30]; //1
//a[0x15]; //0
//a[0x35]; //1
function makeAsciiTable(spec) {
    var ret = new Uint8Array(128);
    spec.forEach(function(item) {
        if (typeof item === "number") {
            ret[item] = 1;
        } else {
            var start = item[0];
            var end = item[1];
            for(var j = start; j <= end; ++j){
                ret[j] = 1;
            }
        }
    });
    return ret;
}
var autoEscape = [
    "<",
    ">",
    '"',
    "`",
    " ",
    "\r",
    "\n",
    "	",
    "{",
    "}",
    "|",
    "\\",
    "^",
    "`",
    "'"
];
var autoEscapeMap = new Array(128);
for(var i = 0, len = autoEscapeMap.length; i < len; ++i){
    autoEscapeMap[i] = "";
}
for(var i = 0, len = autoEscape.length; i < len; ++i){
    var c = autoEscape[i];
    var esc = encodeURIComponent(c);
    if (esc === c) {
        esc = escape(c);
    }
    autoEscapeMap[c.charCodeAt(0)] = esc;
}
var afterQueryAutoEscapeMap = autoEscapeMap.slice();
autoEscapeMap[0x5C /*'\'*/ ] = "/";
var slashProtocols = Url.prototype._slashProtocols = {
    http: true,
    https: true,
    gopher: true,
    file: true,
    ftp: true,
    "http:": true,
    "https:": true,
    "gopher:": true,
    "file:": true,
    "ftp:": true
};
//Optimize back from normalized object caused by non-identifier keys
function f() {}
f.prototype = slashProtocols;
Url.prototype._protocolCharacters = makeAsciiTable([
    [
        0x61 /*'a'*/ ,
        0x7A /*'z'*/ 
    ],
    [
        0x41 /*'A'*/ ,
        0x5A /*'Z'*/ 
    ],
    0x2E /*'.'*/ ,
    0x2B /*'+'*/ ,
    0x2D /*'-'*/ 
]);
Url.prototype._hostEndingCharacters = makeAsciiTable([
    0x23 /*'#'*/ ,
    0x3F /*'?'*/ ,
    0x2F /*'/'*/ ,
    0x5C /*'\'*/ 
]);
Url.prototype._autoEscapeCharacters = makeAsciiTable(autoEscape.map(function(v) {
    return v.charCodeAt(0);
}));
//If these characters end a host name, the path will not be prepended a /
Url.prototype._noPrependSlashHostEnders = makeAsciiTable([
    "<",
    ">",
    "'",
    "`",
    " ",
    "\r",
    "\n",
    "	",
    "{",
    "}",
    "|",
    "^",
    "`",
    '"',
    "%",
    ";"
].map(function(v) {
    return v.charCodeAt(0);
}));
Url.prototype._autoEscapeMap = autoEscapeMap;
Url.prototype._afterQueryAutoEscapeMap = afterQueryAutoEscapeMap;
module.exports = Url;
Url.replace = function Url$Replace() {
    __webpack_require__.c.url = {
        exports: Url
    };
};


/***/ }),

/***/ 2169:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.GraphQLError = void 0;
exports.formatError = formatError;
exports.printError = printError;
var _isObjectLike = __webpack_require__(5564);
var _location = __webpack_require__(8140);
var _printLocation = __webpack_require__(941);
function toNormalizedOptions(args) {
    const firstArg = args[0];
    if (firstArg == null || "kind" in firstArg || "length" in firstArg) {
        return {
            nodes: firstArg,
            source: args[1],
            positions: args[2],
            path: args[3],
            originalError: args[4],
            extensions: args[5]
        };
    }
    return firstArg;
}
/**
 * A GraphQLError describes an Error found during the parse, validate, or
 * execute phases of performing a GraphQL operation. In addition to a message
 * and stack trace, it also includes information about the locations in a
 * GraphQL document and/or execution result that correspond to the Error.
 */ class GraphQLError extends Error {
    /**
   * An array of `{ line, column }` locations within the source GraphQL document
   * which correspond to this error.
   *
   * Errors during validation often contain multiple locations, for example to
   * point out two things with the same name. Errors during execution include a
   * single location, the field which produced the error.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */ /**
   * An array describing the JSON-path into the execution response which
   * corresponds to this error. Only included for errors during execution.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */ /**
   * An array of GraphQL AST Nodes corresponding to this error.
   */ /**
   * The source GraphQL document for the first location of this error.
   *
   * Note that if this Error represents more than one node, the source may not
   * represent nodes after the first node.
   */ /**
   * An array of character offsets within the source GraphQL document
   * which correspond to this error.
   */ /**
   * The original error thrown from a field resolver during execution.
   */ /**
   * Extension fields to add to the formatted error.
   */ /**
   * @deprecated Please use the `GraphQLErrorOptions` constructor overload instead.
   */ constructor(message, ...rawArgs){
        var _this$nodes, _nodeLocations$, _ref;
        const { nodes , source , positions , path , originalError , extensions  } = toNormalizedOptions(rawArgs);
        super(message);
        this.name = "GraphQLError";
        this.path = path !== null && path !== void 0 ? path : undefined;
        this.originalError = originalError !== null && originalError !== void 0 ? originalError : undefined; // Compute list of blame nodes.
        this.nodes = undefinedIfEmpty(Array.isArray(nodes) ? nodes : nodes ? [
            nodes
        ] : undefined);
        const nodeLocations = undefinedIfEmpty((_this$nodes = this.nodes) === null || _this$nodes === void 0 ? void 0 : _this$nodes.map((node)=>node.loc).filter((loc)=>loc != null)); // Compute locations in the source for the given nodes/positions.
        this.source = source !== null && source !== void 0 ? source : nodeLocations === null || nodeLocations === void 0 ? void 0 : (_nodeLocations$ = nodeLocations[0]) === null || _nodeLocations$ === void 0 ? void 0 : _nodeLocations$.source;
        this.positions = positions !== null && positions !== void 0 ? positions : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc)=>loc.start);
        this.locations = positions && source ? positions.map((pos)=>(0, _location.getLocation)(source, pos)) : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc)=>(0, _location.getLocation)(loc.source, loc.start));
        const originalExtensions = (0, _isObjectLike.isObjectLike)(originalError === null || originalError === void 0 ? void 0 : originalError.extensions) ? originalError === null || originalError === void 0 ? void 0 : originalError.extensions : undefined;
        this.extensions = (_ref = extensions !== null && extensions !== void 0 ? extensions : originalExtensions) !== null && _ref !== void 0 ? _ref : Object.create(null); // Only properties prescribed by the spec should be enumerable.
        // Keep the rest as non-enumerable.
        Object.defineProperties(this, {
            message: {
                writable: true,
                enumerable: true
            },
            name: {
                enumerable: false
            },
            nodes: {
                enumerable: false
            },
            source: {
                enumerable: false
            },
            positions: {
                enumerable: false
            },
            originalError: {
                enumerable: false
            }
        }); // Include (non-enumerable) stack trace.
        /* c8 ignore start */ // FIXME: https://github.com/graphql/graphql-js/issues/2317
        if (originalError !== null && originalError !== void 0 && originalError.stack) {
            Object.defineProperty(this, "stack", {
                value: originalError.stack,
                writable: true,
                configurable: true
            });
        } else if (Error.captureStackTrace) {
            Error.captureStackTrace(this, GraphQLError);
        } else {
            Object.defineProperty(this, "stack", {
                value: Error().stack,
                writable: true,
                configurable: true
            });
        }
    /* c8 ignore stop */ }
    get [Symbol.toStringTag]() {
        return "GraphQLError";
    }
    toString() {
        let output = this.message;
        if (this.nodes) {
            for (const node of this.nodes){
                if (node.loc) {
                    output += "\n\n" + (0, _printLocation.printLocation)(node.loc);
                }
            }
        } else if (this.source && this.locations) {
            for (const location of this.locations){
                output += "\n\n" + (0, _printLocation.printSourceLocation)(this.source, location);
            }
        }
        return output;
    }
    toJSON() {
        const formattedError = {
            message: this.message
        };
        if (this.locations != null) {
            formattedError.locations = this.locations;
        }
        if (this.path != null) {
            formattedError.path = this.path;
        }
        if (this.extensions != null && Object.keys(this.extensions).length > 0) {
            formattedError.extensions = this.extensions;
        }
        return formattedError;
    }
}
exports.GraphQLError = GraphQLError;
function undefinedIfEmpty(array) {
    return array === undefined || array.length === 0 ? undefined : array;
}
/**
 * See: https://spec.graphql.org/draft/#sec-Errors
 */ /**
 * Prints a GraphQLError to a string, representing useful location information
 * about the error's position in the source.
 *
 * @deprecated Please use `error.toString` instead. Will be removed in v17
 */ function printError(error) {
    return error.toString();
}
/**
 * Given a GraphQLError, format it according to the rules described by the
 * Response Format, Errors section of the GraphQL Specification.
 *
 * @deprecated Please use `error.toJSON` instead. Will be removed in v17
 */ function formatError(error) {
    return error.toJSON();
}


/***/ }),

/***/ 3498:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "GraphQLError", ({
    enumerable: true,
    get: function() {
        return _GraphQLError.GraphQLError;
    }
}));
Object.defineProperty(exports, "formatError", ({
    enumerable: true,
    get: function() {
        return _GraphQLError.formatError;
    }
}));
Object.defineProperty(exports, "locatedError", ({
    enumerable: true,
    get: function() {
        return _locatedError.locatedError;
    }
}));
Object.defineProperty(exports, "printError", ({
    enumerable: true,
    get: function() {
        return _GraphQLError.printError;
    }
}));
Object.defineProperty(exports, "syntaxError", ({
    enumerable: true,
    get: function() {
        return _syntaxError.syntaxError;
    }
}));
var _GraphQLError = __webpack_require__(2169);
var _syntaxError = __webpack_require__(4466);
var _locatedError = __webpack_require__(3758);


/***/ }),

/***/ 3758:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.locatedError = locatedError;
var _toError = __webpack_require__(8202);
var _GraphQLError = __webpack_require__(2169);
/**
 * Given an arbitrary value, presumably thrown while attempting to execute a
 * GraphQL operation, produce a new GraphQLError aware of the location in the
 * document responsible for the original Error.
 */ function locatedError(rawOriginalError, nodes, path) {
    var _nodes;
    const originalError = (0, _toError.toError)(rawOriginalError); // Note: this uses a brand-check to support GraphQL errors originating from other contexts.
    if (isLocatedGraphQLError(originalError)) {
        return originalError;
    }
    return new _GraphQLError.GraphQLError(originalError.message, {
        nodes: (_nodes = originalError.nodes) !== null && _nodes !== void 0 ? _nodes : nodes,
        source: originalError.source,
        positions: originalError.positions,
        path,
        originalError
    });
}
function isLocatedGraphQLError(error) {
    return Array.isArray(error.path);
}


/***/ }),

/***/ 4466:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.syntaxError = syntaxError;
var _GraphQLError = __webpack_require__(2169);
/**
 * Produces a GraphQLError representing a syntax error, containing useful
 * descriptive information about the syntax error's position in the source.
 */ function syntaxError(source, position, description) {
    return new _GraphQLError.GraphQLError(`Syntax Error: ${description}`, {
        source,
        positions: [
            position
        ]
    });
}


/***/ }),

/***/ 6271:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.collectFields = collectFields;
exports.collectSubfields = collectSubfields;
var _kinds = __webpack_require__(5923);
var _definition = __webpack_require__(7982);
var _directives = __webpack_require__(3554);
var _typeFromAST = __webpack_require__(6013);
var _values = __webpack_require__(8732);
/**
 * Given a selectionSet, collects all of the fields and returns them.
 *
 * CollectFields requires the "runtime type" of an object. For a field that
 * returns an Interface or Union type, the "runtime type" will be the actual
 * object type returned by that field.
 *
 * @internal
 */ function collectFields(schema, fragments, variableValues, runtimeType, selectionSet) {
    const fields = new Map();
    collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, new Set());
    return fields;
}
/**
 * Given an array of field nodes, collects all of the subfields of the passed
 * in fields, and returns them at the end.
 *
 * CollectSubFields requires the "return type" of an object. For a field that
 * returns an Interface or Union type, the "return type" will be the actual
 * object type returned by that field.
 *
 * @internal
 */ function collectSubfields(schema, fragments, variableValues, returnType, fieldNodes) {
    const subFieldNodes = new Map();
    const visitedFragmentNames = new Set();
    for (const node of fieldNodes){
        if (node.selectionSet) {
            collectFieldsImpl(schema, fragments, variableValues, returnType, node.selectionSet, subFieldNodes, visitedFragmentNames);
        }
    }
    return subFieldNodes;
}
function collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, visitedFragmentNames) {
    for (const selection of selectionSet.selections){
        switch(selection.kind){
            case _kinds.Kind.FIELD:
                {
                    if (!shouldIncludeNode(variableValues, selection)) {
                        continue;
                    }
                    const name = getFieldEntryKey(selection);
                    const fieldList = fields.get(name);
                    if (fieldList !== undefined) {
                        fieldList.push(selection);
                    } else {
                        fields.set(name, [
                            selection
                        ]);
                    }
                    break;
                }
            case _kinds.Kind.INLINE_FRAGMENT:
                {
                    if (!shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema, selection, runtimeType)) {
                        continue;
                    }
                    collectFieldsImpl(schema, fragments, variableValues, runtimeType, selection.selectionSet, fields, visitedFragmentNames);
                    break;
                }
            case _kinds.Kind.FRAGMENT_SPREAD:
                {
                    const fragName = selection.name.value;
                    if (visitedFragmentNames.has(fragName) || !shouldIncludeNode(variableValues, selection)) {
                        continue;
                    }
                    visitedFragmentNames.add(fragName);
                    const fragment = fragments[fragName];
                    if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) {
                        continue;
                    }
                    collectFieldsImpl(schema, fragments, variableValues, runtimeType, fragment.selectionSet, fields, visitedFragmentNames);
                    break;
                }
        }
    }
}
/**
 * Determines if a field should be included based on the `@include` and `@skip`
 * directives, where `@skip` has higher precedence than `@include`.
 */ function shouldIncludeNode(variableValues, node) {
    const skip = (0, _values.getDirectiveValues)(_directives.GraphQLSkipDirective, node, variableValues);
    if ((skip === null || skip === void 0 ? void 0 : skip.if) === true) {
        return false;
    }
    const include = (0, _values.getDirectiveValues)(_directives.GraphQLIncludeDirective, node, variableValues);
    if ((include === null || include === void 0 ? void 0 : include.if) === false) {
        return false;
    }
    return true;
}
/**
 * Determines if a fragment is applicable to the given type.
 */ function doesFragmentConditionMatch(schema, fragment, type) {
    const typeConditionNode = fragment.typeCondition;
    if (!typeConditionNode) {
        return true;
    }
    const conditionalType = (0, _typeFromAST.typeFromAST)(schema, typeConditionNode);
    if (conditionalType === type) {
        return true;
    }
    if ((0, _definition.isAbstractType)(conditionalType)) {
        return schema.isSubType(conditionalType, type);
    }
    return false;
}
/**
 * Implements the logic to compute the key of a given field's entry
 */ function getFieldEntryKey(node) {
    return node.alias ? node.alias.value : node.name.value;
}


/***/ }),

/***/ 6678:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.assertValidExecutionArguments = assertValidExecutionArguments;
exports.buildExecutionContext = buildExecutionContext;
exports.buildResolveInfo = buildResolveInfo;
exports.defaultTypeResolver = exports.defaultFieldResolver = void 0;
exports.execute = execute;
exports.executeSync = executeSync;
exports.getFieldDef = getFieldDef;
var _devAssert = __webpack_require__(90);
var _inspect = __webpack_require__(8089);
var _invariant = __webpack_require__(5210);
var _isIterableObject = __webpack_require__(1167);
var _isObjectLike = __webpack_require__(5564);
var _isPromise = __webpack_require__(6578);
var _memoize = __webpack_require__(6173);
var _Path = __webpack_require__(6032);
var _promiseForObject = __webpack_require__(1977);
var _promiseReduce = __webpack_require__(4002);
var _GraphQLError = __webpack_require__(2169);
var _locatedError = __webpack_require__(3758);
var _ast = __webpack_require__(9344);
var _kinds = __webpack_require__(5923);
var _definition = __webpack_require__(7982);
var _introspection = __webpack_require__(1472);
var _validate = __webpack_require__(4968);
var _collectFields = __webpack_require__(6271);
var _values = __webpack_require__(8732);
/**
 * A memoized collection of relevant subfields with regard to the return
 * type. Memoizing ensures the subfields are not repeatedly calculated, which
 * saves overhead when resolving lists of values.
 */ const collectSubfields = (0, _memoize.memoize3)((exeContext, returnType, fieldNodes)=>(0, _collectFields.collectSubfields)(exeContext.schema, exeContext.fragments, exeContext.variableValues, returnType, fieldNodes));
/**
 * Terminology
 *
 * "Definitions" are the generic name for top-level statements in the document.
 * Examples of this include:
 * 1) Operations (such as a query)
 * 2) Fragments
 *
 * "Operations" are a generic name for requests in the document.
 * Examples of this include:
 * 1) query,
 * 2) mutation
 *
 * "Selections" are the definitions that can appear legally and at
 * single level of the query. These include:
 * 1) field references e.g `a`
 * 2) fragment "spreads" e.g. `...c`
 * 3) inline fragment "spreads" e.g. `...on Type { a }`
 */ /**
 * Data that must be available at all points during query execution.
 *
 * Namely, schema of the type system that is currently executing,
 * and the fragments defined in the query document
 */ /**
 * Implements the "Executing requests" section of the GraphQL specification.
 *
 * Returns either a synchronous ExecutionResult (if all encountered resolvers
 * are synchronous), or a Promise of an ExecutionResult that will eventually be
 * resolved and never rejected.
 *
 * If the arguments to this function do not result in a legal execution context,
 * a GraphQLError will be thrown immediately explaining the invalid input.
 */ function execute(args) {
    // Temporary for v15 to v16 migration. Remove in v17
    arguments.length < 2 || (0, _devAssert.devAssert)(false, "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead.");
    const { schema , document , variableValues , rootValue  } = args; // If arguments are missing or incorrect, throw an error.
    assertValidExecutionArguments(schema, document, variableValues); // If a valid execution context cannot be created due to incorrect arguments,
    // a "Response" with only errors is returned.
    const exeContext = buildExecutionContext(args); // Return early errors if execution context failed.
    if (!("schema" in exeContext)) {
        return {
            errors: exeContext
        };
    } // Return a Promise that will eventually resolve to the data described by
    // The "Response" section of the GraphQL specification.
    //
    // If errors are encountered while executing a GraphQL field, only that
    // field and its descendants will be omitted, and sibling fields will still
    // be executed. An execution which encounters errors will still result in a
    // resolved Promise.
    //
    // Errors from sub-fields of a NonNull type may propagate to the top level,
    // at which point we still log the error and null the parent field, which
    // in this case is the entire response.
    try {
        const { operation  } = exeContext;
        const result = executeOperation(exeContext, operation, rootValue);
        if ((0, _isPromise.isPromise)(result)) {
            return result.then((data)=>buildResponse(data, exeContext.errors), (error)=>{
                exeContext.errors.push(error);
                return buildResponse(null, exeContext.errors);
            });
        }
        return buildResponse(result, exeContext.errors);
    } catch (error) {
        exeContext.errors.push(error);
        return buildResponse(null, exeContext.errors);
    }
}
/**
 * Also implements the "Executing requests" section of the GraphQL specification.
 * However, it guarantees to complete synchronously (or throw an error) assuming
 * that all field resolvers are also synchronous.
 */ function executeSync(args) {
    const result = execute(args); // Assert that the execution was synchronous.
    if ((0, _isPromise.isPromise)(result)) {
        throw new Error("GraphQL execution failed to complete synchronously.");
    }
    return result;
}
/**
 * Given a completed execution context and data, build the `{ errors, data }`
 * response defined by the "Response" section of the GraphQL specification.
 */ function buildResponse(data, errors) {
    return errors.length === 0 ? {
        data
    } : {
        errors,
        data
    };
}
/**
 * Essential assertions before executing to provide developer feedback for
 * improper use of the GraphQL library.
 *
 * @internal
 */ function assertValidExecutionArguments(schema, document, rawVariableValues) {
    document || (0, _devAssert.devAssert)(false, "Must provide document."); // If the schema used for execution is invalid, throw an error.
    (0, _validate.assertValidSchema)(schema); // Variables, if provided, must be an object.
    rawVariableValues == null || (0, _isObjectLike.isObjectLike)(rawVariableValues) || (0, _devAssert.devAssert)(false, "Variables must be provided as an Object where each property is a variable value. Perhaps look to see if an unparsed JSON string was provided.");
}
/**
 * Constructs a ExecutionContext object from the arguments passed to
 * execute, which we will pass throughout the other execution methods.
 *
 * Throws a GraphQLError if a valid execution context cannot be created.
 *
 * @internal
 */ function buildExecutionContext(args) {
    var _definition$name, _operation$variableDe;
    const { schema , document , rootValue , contextValue , variableValues: rawVariableValues , operationName , fieldResolver , typeResolver , subscribeFieldResolver  } = args;
    let operation;
    const fragments = Object.create(null);
    for (const definition of document.definitions){
        switch(definition.kind){
            case _kinds.Kind.OPERATION_DEFINITION:
                if (operationName == null) {
                    if (operation !== undefined) {
                        return [
                            new _GraphQLError.GraphQLError("Must provide operation name if query contains multiple operations.")
                        ];
                    }
                    operation = definition;
                } else if (((_definition$name = definition.name) === null || _definition$name === void 0 ? void 0 : _definition$name.value) === operationName) {
                    operation = definition;
                }
                break;
            case _kinds.Kind.FRAGMENT_DEFINITION:
                fragments[definition.name.value] = definition;
                break;
            default:
        }
    }
    if (!operation) {
        if (operationName != null) {
            return [
                new _GraphQLError.GraphQLError(`Unknown operation named "${operationName}".`)
            ];
        }
        return [
            new _GraphQLError.GraphQLError("Must provide an operation.")
        ];
    } // FIXME: https://github.com/graphql/graphql-js/issues/2203
    /* c8 ignore next */ const variableDefinitions = (_operation$variableDe = operation.variableDefinitions) !== null && _operation$variableDe !== void 0 ? _operation$variableDe : [];
    const coercedVariableValues = (0, _values.getVariableValues)(schema, variableDefinitions, rawVariableValues !== null && rawVariableValues !== void 0 ? rawVariableValues : {}, {
        maxErrors: 50
    });
    if (coercedVariableValues.errors) {
        return coercedVariableValues.errors;
    }
    return {
        schema,
        fragments,
        rootValue,
        contextValue,
        operation,
        variableValues: coercedVariableValues.coerced,
        fieldResolver: fieldResolver !== null && fieldResolver !== void 0 ? fieldResolver : defaultFieldResolver,
        typeResolver: typeResolver !== null && typeResolver !== void 0 ? typeResolver : defaultTypeResolver,
        subscribeFieldResolver: subscribeFieldResolver !== null && subscribeFieldResolver !== void 0 ? subscribeFieldResolver : defaultFieldResolver,
        errors: []
    };
}
/**
 * Implements the "Executing operations" section of the spec.
 */ function executeOperation(exeContext, operation, rootValue) {
    const rootType = exeContext.schema.getRootType(operation.operation);
    if (rootType == null) {
        throw new _GraphQLError.GraphQLError(`Schema is not configured to execute ${operation.operation} operation.`, {
            nodes: operation
        });
    }
    const rootFields = (0, _collectFields.collectFields)(exeContext.schema, exeContext.fragments, exeContext.variableValues, rootType, operation.selectionSet);
    const path = undefined;
    switch(operation.operation){
        case _ast.OperationTypeNode.QUERY:
            return executeFields(exeContext, rootType, rootValue, path, rootFields);
        case _ast.OperationTypeNode.MUTATION:
            return executeFieldsSerially(exeContext, rootType, rootValue, path, rootFields);
        case _ast.OperationTypeNode.SUBSCRIPTION:
            // TODO: deprecate `subscribe` and move all logic here
            // Temporary solution until we finish merging execute and subscribe together
            return executeFields(exeContext, rootType, rootValue, path, rootFields);
    }
}
/**
 * Implements the "Executing selection sets" section of the spec
 * for fields that must be executed serially.
 */ function executeFieldsSerially(exeContext, parentType, sourceValue, path, fields) {
    return (0, _promiseReduce.promiseReduce)(fields.entries(), (results, [responseName, fieldNodes])=>{
        const fieldPath = (0, _Path.addPath)(path, responseName, parentType.name);
        const result = executeField(exeContext, parentType, sourceValue, fieldNodes, fieldPath);
        if (result === undefined) {
            return results;
        }
        if ((0, _isPromise.isPromise)(result)) {
            return result.then((resolvedResult)=>{
                results[responseName] = resolvedResult;
                return results;
            });
        }
        results[responseName] = result;
        return results;
    }, Object.create(null));
}
/**
 * Implements the "Executing selection sets" section of the spec
 * for fields that may be executed in parallel.
 */ function executeFields(exeContext, parentType, sourceValue, path, fields) {
    const results = Object.create(null);
    let containsPromise = false;
    for (const [responseName, fieldNodes] of fields.entries()){
        const fieldPath = (0, _Path.addPath)(path, responseName, parentType.name);
        const result = executeField(exeContext, parentType, sourceValue, fieldNodes, fieldPath);
        if (result !== undefined) {
            results[responseName] = result;
            if ((0, _isPromise.isPromise)(result)) {
                containsPromise = true;
            }
        }
    } // If there are no promises, we can just return the object
    if (!containsPromise) {
        return results;
    } // Otherwise, results is a map from field name to the result of resolving that
    // field, which is possibly a promise. Return a promise that will return this
    // same map, but with any promises replaced with the values they resolved to.
    return (0, _promiseForObject.promiseForObject)(results);
}
/**
 * Implements the "Executing fields" section of the spec
 * In particular, this function figures out the value that the field returns by
 * calling its resolve function, then calls completeValue to complete promises,
 * serialize scalars, or execute the sub-selection-set for objects.
 */ function executeField(exeContext, parentType, source, fieldNodes, path) {
    var _fieldDef$resolve;
    const fieldDef = getFieldDef(exeContext.schema, parentType, fieldNodes[0]);
    if (!fieldDef) {
        return;
    }
    const returnType = fieldDef.type;
    const resolveFn = (_fieldDef$resolve = fieldDef.resolve) !== null && _fieldDef$resolve !== void 0 ? _fieldDef$resolve : exeContext.fieldResolver;
    const info = buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path); // Get the resolve function, regardless of if its result is normal or abrupt (error).
    try {
        // Build a JS object of arguments from the field.arguments AST, using the
        // variables scope to fulfill any variable references.
        // TODO: find a way to memoize, in case this field is within a List type.
        const args = (0, _values.getArgumentValues)(fieldDef, fieldNodes[0], exeContext.variableValues); // The resolve function's optional third argument is a context value that
        // is provided to every resolve function within an execution. It is commonly
        // used to represent an authenticated user, or request-specific caches.
        const contextValue = exeContext.contextValue;
        const result = resolveFn(source, args, contextValue, info);
        let completed;
        if ((0, _isPromise.isPromise)(result)) {
            completed = result.then((resolved)=>completeValue(exeContext, returnType, fieldNodes, info, path, resolved));
        } else {
            completed = completeValue(exeContext, returnType, fieldNodes, info, path, result);
        }
        if ((0, _isPromise.isPromise)(completed)) {
            // Note: we don't rely on a `catch` method, but we do expect "thenable"
            // to take a second callback for the error case.
            return completed.then(undefined, (rawError)=>{
                const error = (0, _locatedError.locatedError)(rawError, fieldNodes, (0, _Path.pathToArray)(path));
                return handleFieldError(error, returnType, exeContext);
            });
        }
        return completed;
    } catch (rawError) {
        const error = (0, _locatedError.locatedError)(rawError, fieldNodes, (0, _Path.pathToArray)(path));
        return handleFieldError(error, returnType, exeContext);
    }
}
/**
 * @internal
 */ function buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path) {
    // The resolve function's optional fourth argument is a collection of
    // information about the current execution state.
    return {
        fieldName: fieldDef.name,
        fieldNodes,
        returnType: fieldDef.type,
        parentType,
        path,
        schema: exeContext.schema,
        fragments: exeContext.fragments,
        rootValue: exeContext.rootValue,
        operation: exeContext.operation,
        variableValues: exeContext.variableValues
    };
}
function handleFieldError(error, returnType, exeContext) {
    // If the field type is non-nullable, then it is resolved without any
    // protection from errors, however it still properly locates the error.
    if ((0, _definition.isNonNullType)(returnType)) {
        throw error;
    } // Otherwise, error protection is applied, logging the error and resolving
    // a null value for this field if one is encountered.
    exeContext.errors.push(error);
    return null;
}
/**
 * Implements the instructions for completeValue as defined in the
 * "Value Completion" section of the spec.
 *
 * If the field type is Non-Null, then this recursively completes the value
 * for the inner type. It throws a field error if that completion returns null,
 * as per the "Nullability" section of the spec.
 *
 * If the field type is a List, then this recursively completes the value
 * for the inner type on each item in the list.
 *
 * If the field type is a Scalar or Enum, ensures the completed value is a legal
 * value of the type by calling the `serialize` method of GraphQL type
 * definition.
 *
 * If the field is an abstract type, determine the runtime type of the value
 * and then complete based on that type
 *
 * Otherwise, the field type expects a sub-selection set, and will complete the
 * value by executing all sub-selections.
 */ function completeValue(exeContext, returnType, fieldNodes, info, path, result) {
    // If result is an Error, throw a located error.
    if (result instanceof Error) {
        throw result;
    } // If field type is NonNull, complete for inner type, and throw field error
    // if result is null.
    if ((0, _definition.isNonNullType)(returnType)) {
        const completed = completeValue(exeContext, returnType.ofType, fieldNodes, info, path, result);
        if (completed === null) {
            throw new Error(`Cannot return null for non-nullable field ${info.parentType.name}.${info.fieldName}.`);
        }
        return completed;
    } // If result value is null or undefined then return null.
    if (result == null) {
        return null;
    } // If field type is List, complete each item in the list with the inner type
    if ((0, _definition.isListType)(returnType)) {
        return completeListValue(exeContext, returnType, fieldNodes, info, path, result);
    } // If field type is a leaf type, Scalar or Enum, serialize to a valid value,
    // returning null if serialization is not possible.
    if ((0, _definition.isLeafType)(returnType)) {
        return completeLeafValue(returnType, result);
    } // If field type is an abstract type, Interface or Union, determine the
    // runtime Object type and complete for that type.
    if ((0, _definition.isAbstractType)(returnType)) {
        return completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result);
    } // If field type is Object, execute and complete all sub-selections.
    if ((0, _definition.isObjectType)(returnType)) {
        return completeObjectValue(exeContext, returnType, fieldNodes, info, path, result);
    }
    /* c8 ignore next 6 */ // Not reachable, all possible output types have been considered.
     false || (0, _invariant.invariant)(false, "Cannot complete value of unexpected output type: " + (0, _inspect.inspect)(returnType));
}
/**
 * Complete a list value by completing each item in the list with the
 * inner type
 */ function completeListValue(exeContext, returnType, fieldNodes, info, path, result) {
    if (!(0, _isIterableObject.isIterableObject)(result)) {
        throw new _GraphQLError.GraphQLError(`Expected Iterable, but did not find one for field "${info.parentType.name}.${info.fieldName}".`);
    } // This is specified as a simple map, however we're optimizing the path
    // where the list contains no Promises by avoiding creating another Promise.
    const itemType = returnType.ofType;
    let containsPromise = false;
    const completedResults = Array.from(result, (item, index)=>{
        // No need to modify the info object containing the path,
        // since from here on it is not ever accessed by resolver functions.
        const itemPath = (0, _Path.addPath)(path, index, undefined);
        try {
            let completedItem;
            if ((0, _isPromise.isPromise)(item)) {
                completedItem = item.then((resolved)=>completeValue(exeContext, itemType, fieldNodes, info, itemPath, resolved));
            } else {
                completedItem = completeValue(exeContext, itemType, fieldNodes, info, itemPath, item);
            }
            if ((0, _isPromise.isPromise)(completedItem)) {
                containsPromise = true; // Note: we don't rely on a `catch` method, but we do expect "thenable"
                // to take a second callback for the error case.
                return completedItem.then(undefined, (rawError)=>{
                    const error = (0, _locatedError.locatedError)(rawError, fieldNodes, (0, _Path.pathToArray)(itemPath));
                    return handleFieldError(error, itemType, exeContext);
                });
            }
            return completedItem;
        } catch (rawError) {
            const error = (0, _locatedError.locatedError)(rawError, fieldNodes, (0, _Path.pathToArray)(itemPath));
            return handleFieldError(error, itemType, exeContext);
        }
    });
    return containsPromise ? Promise.all(completedResults) : completedResults;
}
/**
 * Complete a Scalar or Enum by serializing to a valid value, returning
 * null if serialization is not possible.
 */ function completeLeafValue(returnType, result) {
    const serializedResult = returnType.serialize(result);
    if (serializedResult == null) {
        throw new Error(`Expected \`${(0, _inspect.inspect)(returnType)}.serialize(${(0, _inspect.inspect)(result)})\` to ` + `return non-nullable value, returned: ${(0, _inspect.inspect)(serializedResult)}`);
    }
    return serializedResult;
}
/**
 * Complete a value of an abstract type by determining the runtime object type
 * of that value, then complete the value for that type.
 */ function completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result) {
    var _returnType$resolveTy;
    const resolveTypeFn = (_returnType$resolveTy = returnType.resolveType) !== null && _returnType$resolveTy !== void 0 ? _returnType$resolveTy : exeContext.typeResolver;
    const contextValue = exeContext.contextValue;
    const runtimeType = resolveTypeFn(result, contextValue, info, returnType);
    if ((0, _isPromise.isPromise)(runtimeType)) {
        return runtimeType.then((resolvedRuntimeType)=>completeObjectValue(exeContext, ensureValidRuntimeType(resolvedRuntimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result));
    }
    return completeObjectValue(exeContext, ensureValidRuntimeType(runtimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result);
}
function ensureValidRuntimeType(runtimeTypeName, exeContext, returnType, fieldNodes, info, result) {
    if (runtimeTypeName == null) {
        throw new _GraphQLError.GraphQLError(`Abstract type "${returnType.name}" must resolve to an Object type at runtime for field "${info.parentType.name}.${info.fieldName}". Either the "${returnType.name}" type should provide a "resolveType" function or each possible type should provide an "isTypeOf" function.`, fieldNodes);
    } // releases before 16.0.0 supported returning `GraphQLObjectType` from `resolveType`
    // TODO: remove in 17.0.0 release
    if ((0, _definition.isObjectType)(runtimeTypeName)) {
        throw new _GraphQLError.GraphQLError("Support for returning GraphQLObjectType from resolveType was removed in graphql-js@16.0.0 please return type name instead.");
    }
    if (typeof runtimeTypeName !== "string") {
        throw new _GraphQLError.GraphQLError(`Abstract type "${returnType.name}" must resolve to an Object type at runtime for field "${info.parentType.name}.${info.fieldName}" with ` + `value ${(0, _inspect.inspect)(result)}, received "${(0, _inspect.inspect)(runtimeTypeName)}".`);
    }
    const runtimeType = exeContext.schema.getType(runtimeTypeName);
    if (runtimeType == null) {
        throw new _GraphQLError.GraphQLError(`Abstract type "${returnType.name}" was resolved to a type "${runtimeTypeName}" that does not exist inside the schema.`, {
            nodes: fieldNodes
        });
    }
    if (!(0, _definition.isObjectType)(runtimeType)) {
        throw new _GraphQLError.GraphQLError(`Abstract type "${returnType.name}" was resolved to a non-object type "${runtimeTypeName}".`, {
            nodes: fieldNodes
        });
    }
    if (!exeContext.schema.isSubType(returnType, runtimeType)) {
        throw new _GraphQLError.GraphQLError(`Runtime Object type "${runtimeType.name}" is not a possible type for "${returnType.name}".`, {
            nodes: fieldNodes
        });
    }
    return runtimeType;
}
/**
 * Complete an Object value by executing all sub-selections.
 */ function completeObjectValue(exeContext, returnType, fieldNodes, info, path, result) {
    // Collect sub-fields to execute to complete this value.
    const subFieldNodes = collectSubfields(exeContext, returnType, fieldNodes); // If there is an isTypeOf predicate function, call it with the
    // current result. If isTypeOf returns false, then raise an error rather
    // than continuing execution.
    if (returnType.isTypeOf) {
        const isTypeOf = returnType.isTypeOf(result, exeContext.contextValue, info);
        if ((0, _isPromise.isPromise)(isTypeOf)) {
            return isTypeOf.then((resolvedIsTypeOf)=>{
                if (!resolvedIsTypeOf) {
                    throw invalidReturnTypeError(returnType, result, fieldNodes);
                }
                return executeFields(exeContext, returnType, result, path, subFieldNodes);
            });
        }
        if (!isTypeOf) {
            throw invalidReturnTypeError(returnType, result, fieldNodes);
        }
    }
    return executeFields(exeContext, returnType, result, path, subFieldNodes);
}
function invalidReturnTypeError(returnType, result, fieldNodes) {
    return new _GraphQLError.GraphQLError(`Expected value of type "${returnType.name}" but got: ${(0, _inspect.inspect)(result)}.`, {
        nodes: fieldNodes
    });
}
/**
 * If a resolveType function is not given, then a default resolve behavior is
 * used which attempts two strategies:
 *
 * First, See if the provided value has a `__typename` field defined, if so, use
 * that value as name of the resolved type.
 *
 * Otherwise, test each possible type for the abstract type by calling
 * isTypeOf for the object being coerced, returning the first type that matches.
 */ const defaultTypeResolver = function(value, contextValue, info, abstractType) {
    // First, look for `__typename`.
    if ((0, _isObjectLike.isObjectLike)(value) && typeof value.__typename === "string") {
        return value.__typename;
    } // Otherwise, test each possible type.
    const possibleTypes = info.schema.getPossibleTypes(abstractType);
    const promisedIsTypeOfResults = [];
    for(let i = 0; i < possibleTypes.length; i++){
        const type = possibleTypes[i];
        if (type.isTypeOf) {
            const isTypeOfResult = type.isTypeOf(value, contextValue, info);
            if ((0, _isPromise.isPromise)(isTypeOfResult)) {
                promisedIsTypeOfResults[i] = isTypeOfResult;
            } else if (isTypeOfResult) {
                return type.name;
            }
        }
    }
    if (promisedIsTypeOfResults.length) {
        return Promise.all(promisedIsTypeOfResults).then((isTypeOfResults)=>{
            for(let i = 0; i < isTypeOfResults.length; i++){
                if (isTypeOfResults[i]) {
                    return possibleTypes[i].name;
                }
            }
        });
    }
};
/**
 * If a resolve function is not given, then a default resolve behavior is used
 * which takes the property of the source object of the same name as the field
 * and returns it as the result, or if it's a function, returns the result
 * of calling that function while passing along args and context value.
 */ exports.defaultTypeResolver = defaultTypeResolver;
const defaultFieldResolver = function(source, args, contextValue, info) {
    // ensure source is a value for which property access is acceptable.
    if ((0, _isObjectLike.isObjectLike)(source) || typeof source === "function") {
        const property = source[info.fieldName];
        if (typeof property === "function") {
            return source[info.fieldName](args, contextValue, info);
        }
        return property;
    }
};
/**
 * This method looks up the field on the given type definition.
 * It has special casing for the three introspection fields,
 * __schema, __type and __typename. __typename is special because
 * it can always be queried as a field, even in situations where no
 * other fields are allowed, like on a Union. __schema and __type
 * could get automatically added to the query type, but that would
 * require mutating type definitions, which would cause issues.
 *
 * @internal
 */ exports.defaultFieldResolver = defaultFieldResolver;
function getFieldDef(schema, parentType, fieldNode) {
    const fieldName = fieldNode.name.value;
    if (fieldName === _introspection.SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {
        return _introspection.SchemaMetaFieldDef;
    } else if (fieldName === _introspection.TypeMetaFieldDef.name && schema.getQueryType() === parentType) {
        return _introspection.TypeMetaFieldDef;
    } else if (fieldName === _introspection.TypeNameMetaFieldDef.name) {
        return _introspection.TypeNameMetaFieldDef;
    }
    return parentType.getFields()[fieldName];
}


/***/ }),

/***/ 1319:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "createSourceEventStream", ({
    enumerable: true,
    get: function() {
        return _subscribe.createSourceEventStream;
    }
}));
Object.defineProperty(exports, "defaultFieldResolver", ({
    enumerable: true,
    get: function() {
        return _execute.defaultFieldResolver;
    }
}));
Object.defineProperty(exports, "defaultTypeResolver", ({
    enumerable: true,
    get: function() {
        return _execute.defaultTypeResolver;
    }
}));
Object.defineProperty(exports, "execute", ({
    enumerable: true,
    get: function() {
        return _execute.execute;
    }
}));
Object.defineProperty(exports, "executeSync", ({
    enumerable: true,
    get: function() {
        return _execute.executeSync;
    }
}));
Object.defineProperty(exports, "getArgumentValues", ({
    enumerable: true,
    get: function() {
        return _values.getArgumentValues;
    }
}));
Object.defineProperty(exports, "getDirectiveValues", ({
    enumerable: true,
    get: function() {
        return _values.getDirectiveValues;
    }
}));
Object.defineProperty(exports, "getVariableValues", ({
    enumerable: true,
    get: function() {
        return _values.getVariableValues;
    }
}));
Object.defineProperty(exports, "responsePathAsArray", ({
    enumerable: true,
    get: function() {
        return _Path.pathToArray;
    }
}));
Object.defineProperty(exports, "subscribe", ({
    enumerable: true,
    get: function() {
        return _subscribe.subscribe;
    }
}));
var _Path = __webpack_require__(6032);
var _execute = __webpack_require__(6678);
var _subscribe = __webpack_require__(6354);
var _values = __webpack_require__(8732);


/***/ }),

/***/ 2487:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.mapAsyncIterator = mapAsyncIterator;
/**
 * Given an AsyncIterable and a callback function, return an AsyncIterator
 * which produces values mapped via calling the callback function.
 */ function mapAsyncIterator(iterable, callback) {
    const iterator = iterable[Symbol.asyncIterator]();
    async function mapResult(result) {
        if (result.done) {
            return result;
        }
        try {
            return {
                value: await callback(result.value),
                done: false
            };
        } catch (error) {
            /* c8 ignore start */ // FIXME: add test case
            if (typeof iterator.return === "function") {
                try {
                    await iterator.return();
                } catch (_e) {
                /* ignore error */ }
            }
            throw error;
        /* c8 ignore stop */ }
    }
    return {
        async next () {
            return mapResult(await iterator.next());
        },
        async return () {
            // If iterator.return() does not exist, then type R must be undefined.
            return typeof iterator.return === "function" ? mapResult(await iterator.return()) : {
                value: undefined,
                done: true
            };
        },
        async throw (error) {
            if (typeof iterator.throw === "function") {
                return mapResult(await iterator.throw(error));
            }
            throw error;
        },
        [Symbol.asyncIterator] () {
            return this;
        }
    };
}


/***/ }),

/***/ 6354:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.createSourceEventStream = createSourceEventStream;
exports.subscribe = subscribe;
var _devAssert = __webpack_require__(90);
var _inspect = __webpack_require__(8089);
var _isAsyncIterable = __webpack_require__(4262);
var _Path = __webpack_require__(6032);
var _GraphQLError = __webpack_require__(2169);
var _locatedError = __webpack_require__(3758);
var _collectFields = __webpack_require__(6271);
var _execute = __webpack_require__(6678);
var _mapAsyncIterator = __webpack_require__(2487);
var _values = __webpack_require__(8732);
/**
 * Implements the "Subscribe" algorithm described in the GraphQL specification.
 *
 * Returns a Promise which resolves to either an AsyncIterator (if successful)
 * or an ExecutionResult (error). The promise will be rejected if the schema or
 * other arguments to this function are invalid, or if the resolved event stream
 * is not an async iterable.
 *
 * If the client-provided arguments to this function do not result in a
 * compliant subscription, a GraphQL Response (ExecutionResult) with
 * descriptive errors and no data will be returned.
 *
 * If the source stream could not be created due to faulty subscription
 * resolver logic or underlying systems, the promise will resolve to a single
 * ExecutionResult containing `errors` and no `data`.
 *
 * If the operation succeeded, the promise resolves to an AsyncIterator, which
 * yields a stream of ExecutionResults representing the response stream.
 *
 * Accepts either an object with named arguments, or individual arguments.
 */ async function subscribe(args) {
    // Temporary for v15 to v16 migration. Remove in v17
    arguments.length < 2 || (0, _devAssert.devAssert)(false, "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead.");
    const resultOrStream = await createSourceEventStream(args);
    if (!(0, _isAsyncIterable.isAsyncIterable)(resultOrStream)) {
        return resultOrStream;
    } // For each payload yielded from a subscription, map it over the normal
    // GraphQL `execute` function, with `payload` as the rootValue.
    // This implements the "MapSourceToResponseEvent" algorithm described in
    // the GraphQL specification. The `execute` function provides the
    // "ExecuteSubscriptionEvent" algorithm, as it is nearly identical to the
    // "ExecuteQuery" algorithm, for which `execute` is also used.
    const mapSourceToResponse = (payload)=>(0, _execute.execute)({
            ...args,
            rootValue: payload
        }); // Map every source value to a ExecutionResult value as described above.
    return (0, _mapAsyncIterator.mapAsyncIterator)(resultOrStream, mapSourceToResponse);
}
function toNormalizedArgs(args) {
    const firstArg = args[0];
    if (firstArg && "document" in firstArg) {
        return firstArg;
    }
    return {
        schema: firstArg,
        // FIXME: when underlying TS bug fixed, see https://github.com/microsoft/TypeScript/issues/31613
        document: args[1],
        rootValue: args[2],
        contextValue: args[3],
        variableValues: args[4],
        operationName: args[5],
        subscribeFieldResolver: args[6]
    };
}
/**
 * Implements the "CreateSourceEventStream" algorithm described in the
 * GraphQL specification, resolving the subscription source event stream.
 *
 * Returns a Promise which resolves to either an AsyncIterable (if successful)
 * or an ExecutionResult (error). The promise will be rejected if the schema or
 * other arguments to this function are invalid, or if the resolved event stream
 * is not an async iterable.
 *
 * If the client-provided arguments to this function do not result in a
 * compliant subscription, a GraphQL Response (ExecutionResult) with
 * descriptive errors and no data will be returned.
 *
 * If the the source stream could not be created due to faulty subscription
 * resolver logic or underlying systems, the promise will resolve to a single
 * ExecutionResult containing `errors` and no `data`.
 *
 * If the operation succeeded, the promise resolves to the AsyncIterable for the
 * event stream returned by the resolver.
 *
 * A Source Event Stream represents a sequence of events, each of which triggers
 * a GraphQL execution for that event.
 *
 * This may be useful when hosting the stateful subscription service in a
 * different process or machine than the stateless GraphQL execution engine,
 * or otherwise separating these two steps. For more on this, see the
 * "Supporting Subscriptions at Scale" information in the GraphQL specification.
 */ async function createSourceEventStream(...rawArgs) {
    const args = toNormalizedArgs(rawArgs);
    const { schema , document , variableValues  } = args; // If arguments are missing or incorrectly typed, this is an internal
    // developer mistake which should throw an early error.
    (0, _execute.assertValidExecutionArguments)(schema, document, variableValues); // If a valid execution context cannot be created due to incorrect arguments,
    // a "Response" with only errors is returned.
    const exeContext = (0, _execute.buildExecutionContext)(args); // Return early errors if execution context failed.
    if (!("schema" in exeContext)) {
        return {
            errors: exeContext
        };
    }
    try {
        const eventStream = await executeSubscription(exeContext); // Assert field returned an event stream, otherwise yield an error.
        if (!(0, _isAsyncIterable.isAsyncIterable)(eventStream)) {
            throw new Error("Subscription field must return Async Iterable. " + `Received: ${(0, _inspect.inspect)(eventStream)}.`);
        }
        return eventStream;
    } catch (error) {
        // If it GraphQLError, report it as an ExecutionResult, containing only errors and no data.
        // Otherwise treat the error as a system-class error and re-throw it.
        if (error instanceof _GraphQLError.GraphQLError) {
            return {
                errors: [
                    error
                ]
            };
        }
        throw error;
    }
}
async function executeSubscription(exeContext) {
    const { schema , fragments , operation , variableValues , rootValue  } = exeContext;
    const rootType = schema.getSubscriptionType();
    if (rootType == null) {
        throw new _GraphQLError.GraphQLError("Schema is not configured to execute subscription operation.", {
            nodes: operation
        });
    }
    const rootFields = (0, _collectFields.collectFields)(schema, fragments, variableValues, rootType, operation.selectionSet);
    const [responseName, fieldNodes] = [
        ...rootFields.entries()
    ][0];
    const fieldDef = (0, _execute.getFieldDef)(schema, rootType, fieldNodes[0]);
    if (!fieldDef) {
        const fieldName = fieldNodes[0].name.value;
        throw new _GraphQLError.GraphQLError(`The subscription field "${fieldName}" is not defined.`, {
            nodes: fieldNodes
        });
    }
    const path = (0, _Path.addPath)(undefined, responseName, rootType.name);
    const info = (0, _execute.buildResolveInfo)(exeContext, fieldDef, fieldNodes, rootType, path);
    try {
        var _fieldDef$subscribe;
        // Implements the "ResolveFieldEventStream" algorithm from GraphQL specification.
        // It differs from "ResolveFieldValue" due to providing a different `resolveFn`.
        // Build a JS object of arguments from the field.arguments AST, using the
        // variables scope to fulfill any variable references.
        const args = (0, _values.getArgumentValues)(fieldDef, fieldNodes[0], variableValues); // The resolve function's optional third argument is a context value that
        // is provided to every resolve function within an execution. It is commonly
        // used to represent an authenticated user, or request-specific caches.
        const contextValue = exeContext.contextValue; // Call the `subscribe()` resolver or the default resolver to produce an
        // AsyncIterable yielding raw payloads.
        const resolveFn = (_fieldDef$subscribe = fieldDef.subscribe) !== null && _fieldDef$subscribe !== void 0 ? _fieldDef$subscribe : exeContext.subscribeFieldResolver;
        const eventStream = await resolveFn(rootValue, args, contextValue, info);
        if (eventStream instanceof Error) {
            throw eventStream;
        }
        return eventStream;
    } catch (error) {
        throw (0, _locatedError.locatedError)(error, fieldNodes, (0, _Path.pathToArray)(path));
    }
}


/***/ }),

/***/ 8732:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getArgumentValues = getArgumentValues;
exports.getDirectiveValues = getDirectiveValues;
exports.getVariableValues = getVariableValues;
var _inspect = __webpack_require__(8089);
var _keyMap = __webpack_require__(2512);
var _printPathArray = __webpack_require__(7884);
var _GraphQLError = __webpack_require__(2169);
var _kinds = __webpack_require__(5923);
var _printer = __webpack_require__(800);
var _definition = __webpack_require__(7982);
var _coerceInputValue = __webpack_require__(1401);
var _typeFromAST = __webpack_require__(6013);
var _valueFromAST = __webpack_require__(7735);
/**
 * Prepares an object map of variableValues of the correct type based on the
 * provided variable definitions and arbitrary input. If the input cannot be
 * parsed to match the variable definitions, a GraphQLError will be thrown.
 *
 * Note: The returned value is a plain Object with a prototype, since it is
 * exposed to user code. Care should be taken to not pull values from the
 * Object prototype.
 */ function getVariableValues(schema, varDefNodes, inputs, options) {
    const errors = [];
    const maxErrors = options === null || options === void 0 ? void 0 : options.maxErrors;
    try {
        const coerced = coerceVariableValues(schema, varDefNodes, inputs, (error)=>{
            if (maxErrors != null && errors.length >= maxErrors) {
                throw new _GraphQLError.GraphQLError("Too many errors processing variables, error limit reached. Execution aborted.");
            }
            errors.push(error);
        });
        if (errors.length === 0) {
            return {
                coerced
            };
        }
    } catch (error) {
        errors.push(error);
    }
    return {
        errors
    };
}
function coerceVariableValues(schema, varDefNodes, inputs, onError) {
    const coercedValues = {};
    for (const varDefNode of varDefNodes){
        const varName = varDefNode.variable.name.value;
        const varType = (0, _typeFromAST.typeFromAST)(schema, varDefNode.type);
        if (!(0, _definition.isInputType)(varType)) {
            // Must use input types for variables. This should be caught during
            // validation, however is checked again here for safety.
            const varTypeStr = (0, _printer.print)(varDefNode.type);
            onError(new _GraphQLError.GraphQLError(`Variable "$${varName}" expected value of type "${varTypeStr}" which cannot be used as an input type.`, {
                nodes: varDefNode.type
            }));
            continue;
        }
        if (!hasOwnProperty(inputs, varName)) {
            if (varDefNode.defaultValue) {
                coercedValues[varName] = (0, _valueFromAST.valueFromAST)(varDefNode.defaultValue, varType);
            } else if ((0, _definition.isNonNullType)(varType)) {
                const varTypeStr = (0, _inspect.inspect)(varType);
                onError(new _GraphQLError.GraphQLError(`Variable "$${varName}" of required type "${varTypeStr}" was not provided.`, {
                    nodes: varDefNode
                }));
            }
            continue;
        }
        const value = inputs[varName];
        if (value === null && (0, _definition.isNonNullType)(varType)) {
            const varTypeStr = (0, _inspect.inspect)(varType);
            onError(new _GraphQLError.GraphQLError(`Variable "$${varName}" of non-null type "${varTypeStr}" must not be null.`, {
                nodes: varDefNode
            }));
            continue;
        }
        coercedValues[varName] = (0, _coerceInputValue.coerceInputValue)(value, varType, (path, invalidValue, error)=>{
            let prefix = `Variable "$${varName}" got invalid value ` + (0, _inspect.inspect)(invalidValue);
            if (path.length > 0) {
                prefix += ` at "${varName}${(0, _printPathArray.printPathArray)(path)}"`;
            }
            onError(new _GraphQLError.GraphQLError(prefix + "; " + error.message, {
                nodes: varDefNode,
                originalError: error.originalError
            }));
        });
    }
    return coercedValues;
}
/**
 * Prepares an object map of argument values given a list of argument
 * definitions and list of argument AST nodes.
 *
 * Note: The returned value is a plain Object with a prototype, since it is
 * exposed to user code. Care should be taken to not pull values from the
 * Object prototype.
 */ function getArgumentValues(def, node, variableValues) {
    var _node$arguments;
    const coercedValues = {}; // FIXME: https://github.com/graphql/graphql-js/issues/2203
    /* c8 ignore next */ const argumentNodes = (_node$arguments = node.arguments) !== null && _node$arguments !== void 0 ? _node$arguments : [];
    const argNodeMap = (0, _keyMap.keyMap)(argumentNodes, (arg)=>arg.name.value);
    for (const argDef of def.args){
        const name = argDef.name;
        const argType = argDef.type;
        const argumentNode = argNodeMap[name];
        if (!argumentNode) {
            if (argDef.defaultValue !== undefined) {
                coercedValues[name] = argDef.defaultValue;
            } else if ((0, _definition.isNonNullType)(argType)) {
                throw new _GraphQLError.GraphQLError(`Argument "${name}" of required type "${(0, _inspect.inspect)(argType)}" ` + "was not provided.", {
                    nodes: node
                });
            }
            continue;
        }
        const valueNode = argumentNode.value;
        let isNull = valueNode.kind === _kinds.Kind.NULL;
        if (valueNode.kind === _kinds.Kind.VARIABLE) {
            const variableName = valueNode.name.value;
            if (variableValues == null || !hasOwnProperty(variableValues, variableName)) {
                if (argDef.defaultValue !== undefined) {
                    coercedValues[name] = argDef.defaultValue;
                } else if ((0, _definition.isNonNullType)(argType)) {
                    throw new _GraphQLError.GraphQLError(`Argument "${name}" of required type "${(0, _inspect.inspect)(argType)}" ` + `was provided the variable "$${variableName}" which was not provided a runtime value.`, {
                        nodes: valueNode
                    });
                }
                continue;
            }
            isNull = variableValues[variableName] == null;
        }
        if (isNull && (0, _definition.isNonNullType)(argType)) {
            throw new _GraphQLError.GraphQLError(`Argument "${name}" of non-null type "${(0, _inspect.inspect)(argType)}" ` + "must not be null.", {
                nodes: valueNode
            });
        }
        const coercedValue = (0, _valueFromAST.valueFromAST)(valueNode, argType, variableValues);
        if (coercedValue === undefined) {
            // Note: ValuesOfCorrectTypeRule validation should catch this before
            // execution. This is a runtime check to ensure execution does not
            // continue with an invalid argument value.
            throw new _GraphQLError.GraphQLError(`Argument "${name}" has invalid value ${(0, _printer.print)(valueNode)}.`, {
                nodes: valueNode
            });
        }
        coercedValues[name] = coercedValue;
    }
    return coercedValues;
}
/**
 * Prepares an object map of argument values given a directive definition
 * and a AST node which may contain directives. Optionally also accepts a map
 * of variable values.
 *
 * If the directive does not exist on the node, returns undefined.
 *
 * Note: The returned value is a plain Object with a prototype, since it is
 * exposed to user code. Care should be taken to not pull values from the
 * Object prototype.
 */ function getDirectiveValues(directiveDef, node, variableValues) {
    var _node$directives;
    const directiveNode = (_node$directives = node.directives) === null || _node$directives === void 0 ? void 0 : _node$directives.find((directive)=>directive.name.value === directiveDef.name);
    if (directiveNode) {
        return getArgumentValues(directiveDef, directiveNode, variableValues);
    }
}
function hasOwnProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
}


/***/ }),

/***/ 6035:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.graphql = graphql;
exports.graphqlSync = graphqlSync;
var _devAssert = __webpack_require__(90);
var _isPromise = __webpack_require__(6578);
var _parser = __webpack_require__(8208);
var _validate = __webpack_require__(4968);
var _validate2 = __webpack_require__(9571);
var _execute = __webpack_require__(6678);
function graphql(args) {
    // Always return a Promise for a consistent API.
    return new Promise((resolve)=>resolve(graphqlImpl(args)));
}
/**
 * The graphqlSync function also fulfills GraphQL operations by parsing,
 * validating, and executing a GraphQL document along side a GraphQL schema.
 * However, it guarantees to complete synchronously (or throw an error) assuming
 * that all field resolvers are also synchronous.
 */ function graphqlSync(args) {
    const result = graphqlImpl(args); // Assert that the execution was synchronous.
    if ((0, _isPromise.isPromise)(result)) {
        throw new Error("GraphQL execution failed to complete synchronously.");
    }
    return result;
}
function graphqlImpl(args) {
    // Temporary for v15 to v16 migration. Remove in v17
    arguments.length < 2 || (0, _devAssert.devAssert)(false, "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead.");
    const { schema , source , rootValue , contextValue , variableValues , operationName , fieldResolver , typeResolver  } = args; // Validate Schema
    const schemaValidationErrors = (0, _validate.validateSchema)(schema);
    if (schemaValidationErrors.length > 0) {
        return {
            errors: schemaValidationErrors
        };
    } // Parse
    let document;
    try {
        document = (0, _parser.parse)(source);
    } catch (syntaxError) {
        return {
            errors: [
                syntaxError
            ]
        };
    } // Validate
    const validationErrors = (0, _validate2.validate)(schema, document);
    if (validationErrors.length > 0) {
        return {
            errors: validationErrors
        };
    } // Execute
    return (0, _execute.execute)({
        schema,
        document,
        rootValue,
        contextValue,
        variableValues,
        operationName,
        fieldResolver,
        typeResolver
    });
}


/***/ }),

/***/ 5736:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "BREAK", ({
    enumerable: true,
    get: function() {
        return _index2.BREAK;
    }
}));
Object.defineProperty(exports, "BreakingChangeType", ({
    enumerable: true,
    get: function() {
        return _index6.BreakingChangeType;
    }
}));
Object.defineProperty(exports, "DEFAULT_DEPRECATION_REASON", ({
    enumerable: true,
    get: function() {
        return _index.DEFAULT_DEPRECATION_REASON;
    }
}));
Object.defineProperty(exports, "DangerousChangeType", ({
    enumerable: true,
    get: function() {
        return _index6.DangerousChangeType;
    }
}));
Object.defineProperty(exports, "DirectiveLocation", ({
    enumerable: true,
    get: function() {
        return _index2.DirectiveLocation;
    }
}));
Object.defineProperty(exports, "ExecutableDefinitionsRule", ({
    enumerable: true,
    get: function() {
        return _index4.ExecutableDefinitionsRule;
    }
}));
Object.defineProperty(exports, "FieldsOnCorrectTypeRule", ({
    enumerable: true,
    get: function() {
        return _index4.FieldsOnCorrectTypeRule;
    }
}));
Object.defineProperty(exports, "FragmentsOnCompositeTypesRule", ({
    enumerable: true,
    get: function() {
        return _index4.FragmentsOnCompositeTypesRule;
    }
}));
Object.defineProperty(exports, "GRAPHQL_MAX_INT", ({
    enumerable: true,
    get: function() {
        return _index.GRAPHQL_MAX_INT;
    }
}));
Object.defineProperty(exports, "GRAPHQL_MIN_INT", ({
    enumerable: true,
    get: function() {
        return _index.GRAPHQL_MIN_INT;
    }
}));
Object.defineProperty(exports, "GraphQLBoolean", ({
    enumerable: true,
    get: function() {
        return _index.GraphQLBoolean;
    }
}));
Object.defineProperty(exports, "GraphQLDeprecatedDirective", ({
    enumerable: true,
    get: function() {
        return _index.GraphQLDeprecatedDirective;
    }
}));
Object.defineProperty(exports, "GraphQLDirective", ({
    enumerable: true,
    get: function() {
        return _index.GraphQLDirective;
    }
}));
Object.defineProperty(exports, "GraphQLEnumType", ({
    enumerable: true,
    get: function() {
        return _index.GraphQLEnumType;
    }
}));
Object.defineProperty(exports, "GraphQLError", ({
    enumerable: true,
    get: function() {
        return _index5.GraphQLError;
    }
}));
Object.defineProperty(exports, "GraphQLFloat", ({
    enumerable: true,
    get: function() {
        return _index.GraphQLFloat;
    }
}));
Object.defineProperty(exports, "GraphQLID", ({
    enumerable: true,
    get: function() {
        return _index.GraphQLID;
    }
}));
Object.defineProperty(exports, "GraphQLIncludeDirective", ({
    enumerable: true,
    get: function() {
        return _index.GraphQLIncludeDirective;
    }
}));
Object.defineProperty(exports, "GraphQLInputObjectType", ({
    enumerable: true,
    get: function() {
        return _index.GraphQLInputObjectType;
    }
}));
Object.defineProperty(exports, "GraphQLInt", ({
    enumerable: true,
    get: function() {
        return _index.GraphQLInt;
    }
}));
Object.defineProperty(exports, "GraphQLInterfaceType", ({
    enumerable: true,
    get: function() {
        return _index.GraphQLInterfaceType;
    }
}));
Object.defineProperty(exports, "GraphQLList", ({
    enumerable: true,
    get: function() {
        return _index.GraphQLList;
    }
}));
Object.defineProperty(exports, "GraphQLNonNull", ({
    enumerable: true,
    get: function() {
        return _index.GraphQLNonNull;
    }
}));
Object.defineProperty(exports, "GraphQLObjectType", ({
    enumerable: true,
    get: function() {
        return _index.GraphQLObjectType;
    }
}));
Object.defineProperty(exports, "GraphQLScalarType", ({
    enumerable: true,
    get: function() {
        return _index.GraphQLScalarType;
    }
}));
Object.defineProperty(exports, "GraphQLSchema", ({
    enumerable: true,
    get: function() {
        return _index.GraphQLSchema;
    }
}));
Object.defineProperty(exports, "GraphQLSkipDirective", ({
    enumerable: true,
    get: function() {
        return _index.GraphQLSkipDirective;
    }
}));
Object.defineProperty(exports, "GraphQLSpecifiedByDirective", ({
    enumerable: true,
    get: function() {
        return _index.GraphQLSpecifiedByDirective;
    }
}));
Object.defineProperty(exports, "GraphQLString", ({
    enumerable: true,
    get: function() {
        return _index.GraphQLString;
    }
}));
Object.defineProperty(exports, "GraphQLUnionType", ({
    enumerable: true,
    get: function() {
        return _index.GraphQLUnionType;
    }
}));
Object.defineProperty(exports, "Kind", ({
    enumerable: true,
    get: function() {
        return _index2.Kind;
    }
}));
Object.defineProperty(exports, "KnownArgumentNamesRule", ({
    enumerable: true,
    get: function() {
        return _index4.KnownArgumentNamesRule;
    }
}));
Object.defineProperty(exports, "KnownDirectivesRule", ({
    enumerable: true,
    get: function() {
        return _index4.KnownDirectivesRule;
    }
}));
Object.defineProperty(exports, "KnownFragmentNamesRule", ({
    enumerable: true,
    get: function() {
        return _index4.KnownFragmentNamesRule;
    }
}));
Object.defineProperty(exports, "KnownTypeNamesRule", ({
    enumerable: true,
    get: function() {
        return _index4.KnownTypeNamesRule;
    }
}));
Object.defineProperty(exports, "Lexer", ({
    enumerable: true,
    get: function() {
        return _index2.Lexer;
    }
}));
Object.defineProperty(exports, "Location", ({
    enumerable: true,
    get: function() {
        return _index2.Location;
    }
}));
Object.defineProperty(exports, "LoneAnonymousOperationRule", ({
    enumerable: true,
    get: function() {
        return _index4.LoneAnonymousOperationRule;
    }
}));
Object.defineProperty(exports, "LoneSchemaDefinitionRule", ({
    enumerable: true,
    get: function() {
        return _index4.LoneSchemaDefinitionRule;
    }
}));
Object.defineProperty(exports, "NoDeprecatedCustomRule", ({
    enumerable: true,
    get: function() {
        return _index4.NoDeprecatedCustomRule;
    }
}));
Object.defineProperty(exports, "NoFragmentCyclesRule", ({
    enumerable: true,
    get: function() {
        return _index4.NoFragmentCyclesRule;
    }
}));
Object.defineProperty(exports, "NoSchemaIntrospectionCustomRule", ({
    enumerable: true,
    get: function() {
        return _index4.NoSchemaIntrospectionCustomRule;
    }
}));
Object.defineProperty(exports, "NoUndefinedVariablesRule", ({
    enumerable: true,
    get: function() {
        return _index4.NoUndefinedVariablesRule;
    }
}));
Object.defineProperty(exports, "NoUnusedFragmentsRule", ({
    enumerable: true,
    get: function() {
        return _index4.NoUnusedFragmentsRule;
    }
}));
Object.defineProperty(exports, "NoUnusedVariablesRule", ({
    enumerable: true,
    get: function() {
        return _index4.NoUnusedVariablesRule;
    }
}));
Object.defineProperty(exports, "OperationTypeNode", ({
    enumerable: true,
    get: function() {
        return _index2.OperationTypeNode;
    }
}));
Object.defineProperty(exports, "OverlappingFieldsCanBeMergedRule", ({
    enumerable: true,
    get: function() {
        return _index4.OverlappingFieldsCanBeMergedRule;
    }
}));
Object.defineProperty(exports, "PossibleFragmentSpreadsRule", ({
    enumerable: true,
    get: function() {
        return _index4.PossibleFragmentSpreadsRule;
    }
}));
Object.defineProperty(exports, "PossibleTypeExtensionsRule", ({
    enumerable: true,
    get: function() {
        return _index4.PossibleTypeExtensionsRule;
    }
}));
Object.defineProperty(exports, "ProvidedRequiredArgumentsRule", ({
    enumerable: true,
    get: function() {
        return _index4.ProvidedRequiredArgumentsRule;
    }
}));
Object.defineProperty(exports, "ScalarLeafsRule", ({
    enumerable: true,
    get: function() {
        return _index4.ScalarLeafsRule;
    }
}));
Object.defineProperty(exports, "SchemaMetaFieldDef", ({
    enumerable: true,
    get: function() {
        return _index.SchemaMetaFieldDef;
    }
}));
Object.defineProperty(exports, "SingleFieldSubscriptionsRule", ({
    enumerable: true,
    get: function() {
        return _index4.SingleFieldSubscriptionsRule;
    }
}));
Object.defineProperty(exports, "Source", ({
    enumerable: true,
    get: function() {
        return _index2.Source;
    }
}));
Object.defineProperty(exports, "Token", ({
    enumerable: true,
    get: function() {
        return _index2.Token;
    }
}));
Object.defineProperty(exports, "TokenKind", ({
    enumerable: true,
    get: function() {
        return _index2.TokenKind;
    }
}));
Object.defineProperty(exports, "TypeInfo", ({
    enumerable: true,
    get: function() {
        return _index6.TypeInfo;
    }
}));
Object.defineProperty(exports, "TypeKind", ({
    enumerable: true,
    get: function() {
        return _index.TypeKind;
    }
}));
Object.defineProperty(exports, "TypeMetaFieldDef", ({
    enumerable: true,
    get: function() {
        return _index.TypeMetaFieldDef;
    }
}));
Object.defineProperty(exports, "TypeNameMetaFieldDef", ({
    enumerable: true,
    get: function() {
        return _index.TypeNameMetaFieldDef;
    }
}));
Object.defineProperty(exports, "UniqueArgumentDefinitionNamesRule", ({
    enumerable: true,
    get: function() {
        return _index4.UniqueArgumentDefinitionNamesRule;
    }
}));
Object.defineProperty(exports, "UniqueArgumentNamesRule", ({
    enumerable: true,
    get: function() {
        return _index4.UniqueArgumentNamesRule;
    }
}));
Object.defineProperty(exports, "UniqueDirectiveNamesRule", ({
    enumerable: true,
    get: function() {
        return _index4.UniqueDirectiveNamesRule;
    }
}));
Object.defineProperty(exports, "UniqueDirectivesPerLocationRule", ({
    enumerable: true,
    get: function() {
        return _index4.UniqueDirectivesPerLocationRule;
    }
}));
Object.defineProperty(exports, "UniqueEnumValueNamesRule", ({
    enumerable: true,
    get: function() {
        return _index4.UniqueEnumValueNamesRule;
    }
}));
Object.defineProperty(exports, "UniqueFieldDefinitionNamesRule", ({
    enumerable: true,
    get: function() {
        return _index4.UniqueFieldDefinitionNamesRule;
    }
}));
Object.defineProperty(exports, "UniqueFragmentNamesRule", ({
    enumerable: true,
    get: function() {
        return _index4.UniqueFragmentNamesRule;
    }
}));
Object.defineProperty(exports, "UniqueInputFieldNamesRule", ({
    enumerable: true,
    get: function() {
        return _index4.UniqueInputFieldNamesRule;
    }
}));
Object.defineProperty(exports, "UniqueOperationNamesRule", ({
    enumerable: true,
    get: function() {
        return _index4.UniqueOperationNamesRule;
    }
}));
Object.defineProperty(exports, "UniqueOperationTypesRule", ({
    enumerable: true,
    get: function() {
        return _index4.UniqueOperationTypesRule;
    }
}));
Object.defineProperty(exports, "UniqueTypeNamesRule", ({
    enumerable: true,
    get: function() {
        return _index4.UniqueTypeNamesRule;
    }
}));
Object.defineProperty(exports, "UniqueVariableNamesRule", ({
    enumerable: true,
    get: function() {
        return _index4.UniqueVariableNamesRule;
    }
}));
Object.defineProperty(exports, "ValidationContext", ({
    enumerable: true,
    get: function() {
        return _index4.ValidationContext;
    }
}));
Object.defineProperty(exports, "ValuesOfCorrectTypeRule", ({
    enumerable: true,
    get: function() {
        return _index4.ValuesOfCorrectTypeRule;
    }
}));
Object.defineProperty(exports, "VariablesAreInputTypesRule", ({
    enumerable: true,
    get: function() {
        return _index4.VariablesAreInputTypesRule;
    }
}));
Object.defineProperty(exports, "VariablesInAllowedPositionRule", ({
    enumerable: true,
    get: function() {
        return _index4.VariablesInAllowedPositionRule;
    }
}));
Object.defineProperty(exports, "__Directive", ({
    enumerable: true,
    get: function() {
        return _index.__Directive;
    }
}));
Object.defineProperty(exports, "__DirectiveLocation", ({
    enumerable: true,
    get: function() {
        return _index.__DirectiveLocation;
    }
}));
Object.defineProperty(exports, "__EnumValue", ({
    enumerable: true,
    get: function() {
        return _index.__EnumValue;
    }
}));
Object.defineProperty(exports, "__Field", ({
    enumerable: true,
    get: function() {
        return _index.__Field;
    }
}));
Object.defineProperty(exports, "__InputValue", ({
    enumerable: true,
    get: function() {
        return _index.__InputValue;
    }
}));
Object.defineProperty(exports, "__Schema", ({
    enumerable: true,
    get: function() {
        return _index.__Schema;
    }
}));
Object.defineProperty(exports, "__Type", ({
    enumerable: true,
    get: function() {
        return _index.__Type;
    }
}));
Object.defineProperty(exports, "__TypeKind", ({
    enumerable: true,
    get: function() {
        return _index.__TypeKind;
    }
}));
Object.defineProperty(exports, "assertAbstractType", ({
    enumerable: true,
    get: function() {
        return _index.assertAbstractType;
    }
}));
Object.defineProperty(exports, "assertCompositeType", ({
    enumerable: true,
    get: function() {
        return _index.assertCompositeType;
    }
}));
Object.defineProperty(exports, "assertDirective", ({
    enumerable: true,
    get: function() {
        return _index.assertDirective;
    }
}));
Object.defineProperty(exports, "assertEnumType", ({
    enumerable: true,
    get: function() {
        return _index.assertEnumType;
    }
}));
Object.defineProperty(exports, "assertEnumValueName", ({
    enumerable: true,
    get: function() {
        return _index.assertEnumValueName;
    }
}));
Object.defineProperty(exports, "assertInputObjectType", ({
    enumerable: true,
    get: function() {
        return _index.assertInputObjectType;
    }
}));
Object.defineProperty(exports, "assertInputType", ({
    enumerable: true,
    get: function() {
        return _index.assertInputType;
    }
}));
Object.defineProperty(exports, "assertInterfaceType", ({
    enumerable: true,
    get: function() {
        return _index.assertInterfaceType;
    }
}));
Object.defineProperty(exports, "assertLeafType", ({
    enumerable: true,
    get: function() {
        return _index.assertLeafType;
    }
}));
Object.defineProperty(exports, "assertListType", ({
    enumerable: true,
    get: function() {
        return _index.assertListType;
    }
}));
Object.defineProperty(exports, "assertName", ({
    enumerable: true,
    get: function() {
        return _index.assertName;
    }
}));
Object.defineProperty(exports, "assertNamedType", ({
    enumerable: true,
    get: function() {
        return _index.assertNamedType;
    }
}));
Object.defineProperty(exports, "assertNonNullType", ({
    enumerable: true,
    get: function() {
        return _index.assertNonNullType;
    }
}));
Object.defineProperty(exports, "assertNullableType", ({
    enumerable: true,
    get: function() {
        return _index.assertNullableType;
    }
}));
Object.defineProperty(exports, "assertObjectType", ({
    enumerable: true,
    get: function() {
        return _index.assertObjectType;
    }
}));
Object.defineProperty(exports, "assertOutputType", ({
    enumerable: true,
    get: function() {
        return _index.assertOutputType;
    }
}));
Object.defineProperty(exports, "assertScalarType", ({
    enumerable: true,
    get: function() {
        return _index.assertScalarType;
    }
}));
Object.defineProperty(exports, "assertSchema", ({
    enumerable: true,
    get: function() {
        return _index.assertSchema;
    }
}));
Object.defineProperty(exports, "assertType", ({
    enumerable: true,
    get: function() {
        return _index.assertType;
    }
}));
Object.defineProperty(exports, "assertUnionType", ({
    enumerable: true,
    get: function() {
        return _index.assertUnionType;
    }
}));
Object.defineProperty(exports, "assertValidName", ({
    enumerable: true,
    get: function() {
        return _index6.assertValidName;
    }
}));
Object.defineProperty(exports, "assertValidSchema", ({
    enumerable: true,
    get: function() {
        return _index.assertValidSchema;
    }
}));
Object.defineProperty(exports, "assertWrappingType", ({
    enumerable: true,
    get: function() {
        return _index.assertWrappingType;
    }
}));
Object.defineProperty(exports, "astFromValue", ({
    enumerable: true,
    get: function() {
        return _index6.astFromValue;
    }
}));
Object.defineProperty(exports, "buildASTSchema", ({
    enumerable: true,
    get: function() {
        return _index6.buildASTSchema;
    }
}));
Object.defineProperty(exports, "buildClientSchema", ({
    enumerable: true,
    get: function() {
        return _index6.buildClientSchema;
    }
}));
Object.defineProperty(exports, "buildSchema", ({
    enumerable: true,
    get: function() {
        return _index6.buildSchema;
    }
}));
Object.defineProperty(exports, "coerceInputValue", ({
    enumerable: true,
    get: function() {
        return _index6.coerceInputValue;
    }
}));
Object.defineProperty(exports, "concatAST", ({
    enumerable: true,
    get: function() {
        return _index6.concatAST;
    }
}));
Object.defineProperty(exports, "createSourceEventStream", ({
    enumerable: true,
    get: function() {
        return _index3.createSourceEventStream;
    }
}));
Object.defineProperty(exports, "defaultFieldResolver", ({
    enumerable: true,
    get: function() {
        return _index3.defaultFieldResolver;
    }
}));
Object.defineProperty(exports, "defaultTypeResolver", ({
    enumerable: true,
    get: function() {
        return _index3.defaultTypeResolver;
    }
}));
Object.defineProperty(exports, "doTypesOverlap", ({
    enumerable: true,
    get: function() {
        return _index6.doTypesOverlap;
    }
}));
Object.defineProperty(exports, "execute", ({
    enumerable: true,
    get: function() {
        return _index3.execute;
    }
}));
Object.defineProperty(exports, "executeSync", ({
    enumerable: true,
    get: function() {
        return _index3.executeSync;
    }
}));
Object.defineProperty(exports, "extendSchema", ({
    enumerable: true,
    get: function() {
        return _index6.extendSchema;
    }
}));
Object.defineProperty(exports, "findBreakingChanges", ({
    enumerable: true,
    get: function() {
        return _index6.findBreakingChanges;
    }
}));
Object.defineProperty(exports, "findDangerousChanges", ({
    enumerable: true,
    get: function() {
        return _index6.findDangerousChanges;
    }
}));
Object.defineProperty(exports, "formatError", ({
    enumerable: true,
    get: function() {
        return _index5.formatError;
    }
}));
Object.defineProperty(exports, "getArgumentValues", ({
    enumerable: true,
    get: function() {
        return _index3.getArgumentValues;
    }
}));
Object.defineProperty(exports, "getDirectiveValues", ({
    enumerable: true,
    get: function() {
        return _index3.getDirectiveValues;
    }
}));
Object.defineProperty(exports, "getEnterLeaveForKind", ({
    enumerable: true,
    get: function() {
        return _index2.getEnterLeaveForKind;
    }
}));
Object.defineProperty(exports, "getIntrospectionQuery", ({
    enumerable: true,
    get: function() {
        return _index6.getIntrospectionQuery;
    }
}));
Object.defineProperty(exports, "getLocation", ({
    enumerable: true,
    get: function() {
        return _index2.getLocation;
    }
}));
Object.defineProperty(exports, "getNamedType", ({
    enumerable: true,
    get: function() {
        return _index.getNamedType;
    }
}));
Object.defineProperty(exports, "getNullableType", ({
    enumerable: true,
    get: function() {
        return _index.getNullableType;
    }
}));
Object.defineProperty(exports, "getOperationAST", ({
    enumerable: true,
    get: function() {
        return _index6.getOperationAST;
    }
}));
Object.defineProperty(exports, "getOperationRootType", ({
    enumerable: true,
    get: function() {
        return _index6.getOperationRootType;
    }
}));
Object.defineProperty(exports, "getVariableValues", ({
    enumerable: true,
    get: function() {
        return _index3.getVariableValues;
    }
}));
Object.defineProperty(exports, "getVisitFn", ({
    enumerable: true,
    get: function() {
        return _index2.getVisitFn;
    }
}));
Object.defineProperty(exports, "graphql", ({
    enumerable: true,
    get: function() {
        return _graphql.graphql;
    }
}));
Object.defineProperty(exports, "graphqlSync", ({
    enumerable: true,
    get: function() {
        return _graphql.graphqlSync;
    }
}));
Object.defineProperty(exports, "introspectionFromSchema", ({
    enumerable: true,
    get: function() {
        return _index6.introspectionFromSchema;
    }
}));
Object.defineProperty(exports, "introspectionTypes", ({
    enumerable: true,
    get: function() {
        return _index.introspectionTypes;
    }
}));
Object.defineProperty(exports, "isAbstractType", ({
    enumerable: true,
    get: function() {
        return _index.isAbstractType;
    }
}));
Object.defineProperty(exports, "isCompositeType", ({
    enumerable: true,
    get: function() {
        return _index.isCompositeType;
    }
}));
Object.defineProperty(exports, "isConstValueNode", ({
    enumerable: true,
    get: function() {
        return _index2.isConstValueNode;
    }
}));
Object.defineProperty(exports, "isDefinitionNode", ({
    enumerable: true,
    get: function() {
        return _index2.isDefinitionNode;
    }
}));
Object.defineProperty(exports, "isDirective", ({
    enumerable: true,
    get: function() {
        return _index.isDirective;
    }
}));
Object.defineProperty(exports, "isEnumType", ({
    enumerable: true,
    get: function() {
        return _index.isEnumType;
    }
}));
Object.defineProperty(exports, "isEqualType", ({
    enumerable: true,
    get: function() {
        return _index6.isEqualType;
    }
}));
Object.defineProperty(exports, "isExecutableDefinitionNode", ({
    enumerable: true,
    get: function() {
        return _index2.isExecutableDefinitionNode;
    }
}));
Object.defineProperty(exports, "isInputObjectType", ({
    enumerable: true,
    get: function() {
        return _index.isInputObjectType;
    }
}));
Object.defineProperty(exports, "isInputType", ({
    enumerable: true,
    get: function() {
        return _index.isInputType;
    }
}));
Object.defineProperty(exports, "isInterfaceType", ({
    enumerable: true,
    get: function() {
        return _index.isInterfaceType;
    }
}));
Object.defineProperty(exports, "isIntrospectionType", ({
    enumerable: true,
    get: function() {
        return _index.isIntrospectionType;
    }
}));
Object.defineProperty(exports, "isLeafType", ({
    enumerable: true,
    get: function() {
        return _index.isLeafType;
    }
}));
Object.defineProperty(exports, "isListType", ({
    enumerable: true,
    get: function() {
        return _index.isListType;
    }
}));
Object.defineProperty(exports, "isNamedType", ({
    enumerable: true,
    get: function() {
        return _index.isNamedType;
    }
}));
Object.defineProperty(exports, "isNonNullType", ({
    enumerable: true,
    get: function() {
        return _index.isNonNullType;
    }
}));
Object.defineProperty(exports, "isNullableType", ({
    enumerable: true,
    get: function() {
        return _index.isNullableType;
    }
}));
Object.defineProperty(exports, "isObjectType", ({
    enumerable: true,
    get: function() {
        return _index.isObjectType;
    }
}));
Object.defineProperty(exports, "isOutputType", ({
    enumerable: true,
    get: function() {
        return _index.isOutputType;
    }
}));
Object.defineProperty(exports, "isRequiredArgument", ({
    enumerable: true,
    get: function() {
        return _index.isRequiredArgument;
    }
}));
Object.defineProperty(exports, "isRequiredInputField", ({
    enumerable: true,
    get: function() {
        return _index.isRequiredInputField;
    }
}));
Object.defineProperty(exports, "isScalarType", ({
    enumerable: true,
    get: function() {
        return _index.isScalarType;
    }
}));
Object.defineProperty(exports, "isSchema", ({
    enumerable: true,
    get: function() {
        return _index.isSchema;
    }
}));
Object.defineProperty(exports, "isSelectionNode", ({
    enumerable: true,
    get: function() {
        return _index2.isSelectionNode;
    }
}));
Object.defineProperty(exports, "isSpecifiedDirective", ({
    enumerable: true,
    get: function() {
        return _index.isSpecifiedDirective;
    }
}));
Object.defineProperty(exports, "isSpecifiedScalarType", ({
    enumerable: true,
    get: function() {
        return _index.isSpecifiedScalarType;
    }
}));
Object.defineProperty(exports, "isType", ({
    enumerable: true,
    get: function() {
        return _index.isType;
    }
}));
Object.defineProperty(exports, "isTypeDefinitionNode", ({
    enumerable: true,
    get: function() {
        return _index2.isTypeDefinitionNode;
    }
}));
Object.defineProperty(exports, "isTypeExtensionNode", ({
    enumerable: true,
    get: function() {
        return _index2.isTypeExtensionNode;
    }
}));
Object.defineProperty(exports, "isTypeNode", ({
    enumerable: true,
    get: function() {
        return _index2.isTypeNode;
    }
}));
Object.defineProperty(exports, "isTypeSubTypeOf", ({
    enumerable: true,
    get: function() {
        return _index6.isTypeSubTypeOf;
    }
}));
Object.defineProperty(exports, "isTypeSystemDefinitionNode", ({
    enumerable: true,
    get: function() {
        return _index2.isTypeSystemDefinitionNode;
    }
}));
Object.defineProperty(exports, "isTypeSystemExtensionNode", ({
    enumerable: true,
    get: function() {
        return _index2.isTypeSystemExtensionNode;
    }
}));
Object.defineProperty(exports, "isUnionType", ({
    enumerable: true,
    get: function() {
        return _index.isUnionType;
    }
}));
Object.defineProperty(exports, "isValidNameError", ({
    enumerable: true,
    get: function() {
        return _index6.isValidNameError;
    }
}));
Object.defineProperty(exports, "isValueNode", ({
    enumerable: true,
    get: function() {
        return _index2.isValueNode;
    }
}));
Object.defineProperty(exports, "isWrappingType", ({
    enumerable: true,
    get: function() {
        return _index.isWrappingType;
    }
}));
Object.defineProperty(exports, "lexicographicSortSchema", ({
    enumerable: true,
    get: function() {
        return _index6.lexicographicSortSchema;
    }
}));
Object.defineProperty(exports, "locatedError", ({
    enumerable: true,
    get: function() {
        return _index5.locatedError;
    }
}));
Object.defineProperty(exports, "parse", ({
    enumerable: true,
    get: function() {
        return _index2.parse;
    }
}));
Object.defineProperty(exports, "parseConstValue", ({
    enumerable: true,
    get: function() {
        return _index2.parseConstValue;
    }
}));
Object.defineProperty(exports, "parseType", ({
    enumerable: true,
    get: function() {
        return _index2.parseType;
    }
}));
Object.defineProperty(exports, "parseValue", ({
    enumerable: true,
    get: function() {
        return _index2.parseValue;
    }
}));
Object.defineProperty(exports, "print", ({
    enumerable: true,
    get: function() {
        return _index2.print;
    }
}));
Object.defineProperty(exports, "printError", ({
    enumerable: true,
    get: function() {
        return _index5.printError;
    }
}));
Object.defineProperty(exports, "printIntrospectionSchema", ({
    enumerable: true,
    get: function() {
        return _index6.printIntrospectionSchema;
    }
}));
Object.defineProperty(exports, "printLocation", ({
    enumerable: true,
    get: function() {
        return _index2.printLocation;
    }
}));
Object.defineProperty(exports, "printSchema", ({
    enumerable: true,
    get: function() {
        return _index6.printSchema;
    }
}));
Object.defineProperty(exports, "printSourceLocation", ({
    enumerable: true,
    get: function() {
        return _index2.printSourceLocation;
    }
}));
Object.defineProperty(exports, "printType", ({
    enumerable: true,
    get: function() {
        return _index6.printType;
    }
}));
Object.defineProperty(exports, "resolveObjMapThunk", ({
    enumerable: true,
    get: function() {
        return _index.resolveObjMapThunk;
    }
}));
Object.defineProperty(exports, "resolveReadonlyArrayThunk", ({
    enumerable: true,
    get: function() {
        return _index.resolveReadonlyArrayThunk;
    }
}));
Object.defineProperty(exports, "responsePathAsArray", ({
    enumerable: true,
    get: function() {
        return _index3.responsePathAsArray;
    }
}));
Object.defineProperty(exports, "separateOperations", ({
    enumerable: true,
    get: function() {
        return _index6.separateOperations;
    }
}));
Object.defineProperty(exports, "specifiedDirectives", ({
    enumerable: true,
    get: function() {
        return _index.specifiedDirectives;
    }
}));
Object.defineProperty(exports, "specifiedRules", ({
    enumerable: true,
    get: function() {
        return _index4.specifiedRules;
    }
}));
Object.defineProperty(exports, "specifiedScalarTypes", ({
    enumerable: true,
    get: function() {
        return _index.specifiedScalarTypes;
    }
}));
Object.defineProperty(exports, "stripIgnoredCharacters", ({
    enumerable: true,
    get: function() {
        return _index6.stripIgnoredCharacters;
    }
}));
Object.defineProperty(exports, "subscribe", ({
    enumerable: true,
    get: function() {
        return _index3.subscribe;
    }
}));
Object.defineProperty(exports, "syntaxError", ({
    enumerable: true,
    get: function() {
        return _index5.syntaxError;
    }
}));
Object.defineProperty(exports, "typeFromAST", ({
    enumerable: true,
    get: function() {
        return _index6.typeFromAST;
    }
}));
Object.defineProperty(exports, "validate", ({
    enumerable: true,
    get: function() {
        return _index4.validate;
    }
}));
Object.defineProperty(exports, "validateSchema", ({
    enumerable: true,
    get: function() {
        return _index.validateSchema;
    }
}));
Object.defineProperty(exports, "valueFromAST", ({
    enumerable: true,
    get: function() {
        return _index6.valueFromAST;
    }
}));
Object.defineProperty(exports, "valueFromASTUntyped", ({
    enumerable: true,
    get: function() {
        return _index6.valueFromASTUntyped;
    }
}));
Object.defineProperty(exports, "version", ({
    enumerable: true,
    get: function() {
        return _version.version;
    }
}));
Object.defineProperty(exports, "versionInfo", ({
    enumerable: true,
    get: function() {
        return _version.versionInfo;
    }
}));
Object.defineProperty(exports, "visit", ({
    enumerable: true,
    get: function() {
        return _index2.visit;
    }
}));
Object.defineProperty(exports, "visitInParallel", ({
    enumerable: true,
    get: function() {
        return _index2.visitInParallel;
    }
}));
Object.defineProperty(exports, "visitWithTypeInfo", ({
    enumerable: true,
    get: function() {
        return _index6.visitWithTypeInfo;
    }
}));
var _version = __webpack_require__(4259);
var _graphql = __webpack_require__(6035);
var _index = __webpack_require__(6351);
var _index2 = __webpack_require__(1371);
var _index3 = __webpack_require__(1319);
var _index4 = __webpack_require__(1340);
var _index5 = __webpack_require__(3498);
var _index6 = __webpack_require__(853);


/***/ }),

/***/ 6032:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.addPath = addPath;
exports.pathToArray = pathToArray;
/**
 * Given a Path and a key, return a new Path containing the new key.
 */ function addPath(prev, key, typename) {
    return {
        prev,
        key,
        typename
    };
}
/**
 * Given a Path, return an Array of the path keys.
 */ function pathToArray(path) {
    const flattened = [];
    let curr = path;
    while(curr){
        flattened.push(curr.key);
        curr = curr.prev;
    }
    return flattened.reverse();
}


/***/ }),

/***/ 90:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.devAssert = devAssert;
function devAssert(condition, message) {
    const booleanCondition = Boolean(condition);
    if (!booleanCondition) {
        throw new Error(message);
    }
}


/***/ }),

/***/ 2228:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.didYouMean = didYouMean;
const MAX_SUGGESTIONS = 5;
/**
 * Given [ A, B, C ] return ' Did you mean A, B, or C?'.
 */ function didYouMean(firstArg, secondArg) {
    const [subMessage, suggestionsArg] = secondArg ? [
        firstArg,
        secondArg
    ] : [
        undefined,
        firstArg
    ];
    let message = " Did you mean ";
    if (subMessage) {
        message += subMessage + " ";
    }
    const suggestions = suggestionsArg.map((x)=>`"${x}"`);
    switch(suggestions.length){
        case 0:
            return "";
        case 1:
            return message + suggestions[0] + "?";
        case 2:
            return message + suggestions[0] + " or " + suggestions[1] + "?";
    }
    const selected = suggestions.slice(0, MAX_SUGGESTIONS);
    const lastItem = selected.pop();
    return message + selected.join(", ") + ", or " + lastItem + "?";
}


/***/ }),

/***/ 6344:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.groupBy = groupBy;
/**
 * Groups array items into a Map, given a function to produce grouping key.
 */ function groupBy(list, keyFn) {
    const result = new Map();
    for (const item of list){
        const key = keyFn(item);
        const group = result.get(key);
        if (group === undefined) {
            result.set(key, [
                item
            ]);
        } else {
            group.push(item);
        }
    }
    return result;
}


/***/ }),

/***/ 6812:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.identityFunc = identityFunc;
/**
 * Returns the first argument it receives.
 */ function identityFunc(x) {
    return x;
}


/***/ }),

/***/ 8089:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.inspect = inspect;
const MAX_ARRAY_LENGTH = 10;
const MAX_RECURSIVE_DEPTH = 2;
/**
 * Used to print values in error messages.
 */ function inspect(value) {
    return formatValue(value, []);
}
function formatValue(value, seenValues) {
    switch(typeof value){
        case "string":
            return JSON.stringify(value);
        case "function":
            return value.name ? `[function ${value.name}]` : "[function]";
        case "object":
            return formatObjectValue(value, seenValues);
        default:
            return String(value);
    }
}
function formatObjectValue(value, previouslySeenValues) {
    if (value === null) {
        return "null";
    }
    if (previouslySeenValues.includes(value)) {
        return "[Circular]";
    }
    const seenValues = [
        ...previouslySeenValues,
        value
    ];
    if (isJSONable(value)) {
        const jsonValue = value.toJSON(); // check for infinite recursion
        if (jsonValue !== value) {
            return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
        }
    } else if (Array.isArray(value)) {
        return formatArray(value, seenValues);
    }
    return formatObject(value, seenValues);
}
function isJSONable(value) {
    return typeof value.toJSON === "function";
}
function formatObject(object, seenValues) {
    const entries = Object.entries(object);
    if (entries.length === 0) {
        return "{}";
    }
    if (seenValues.length > MAX_RECURSIVE_DEPTH) {
        return "[" + getObjectTag(object) + "]";
    }
    const properties = entries.map(([key, value])=>key + ": " + formatValue(value, seenValues));
    return "{ " + properties.join(", ") + " }";
}
function formatArray(array, seenValues) {
    if (array.length === 0) {
        return "[]";
    }
    if (seenValues.length > MAX_RECURSIVE_DEPTH) {
        return "[Array]";
    }
    const len = Math.min(MAX_ARRAY_LENGTH, array.length);
    const remaining = array.length - len;
    const items = [];
    for(let i = 0; i < len; ++i){
        items.push(formatValue(array[i], seenValues));
    }
    if (remaining === 1) {
        items.push("... 1 more item");
    } else if (remaining > 1) {
        items.push(`... ${remaining} more items`);
    }
    return "[" + items.join(", ") + "]";
}
function getObjectTag(object) {
    const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
    if (tag === "Object" && typeof object.constructor === "function") {
        const name = object.constructor.name;
        if (typeof name === "string" && name !== "") {
            return name;
        }
    }
    return tag;
}


/***/ }),

/***/ 9738:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.instanceOf = void 0;
var _inspect = __webpack_require__(8089);
/**
 * A replacement for instanceof which includes an error warning when multi-realm
 * constructors are detected.
 * See: https://expressjs.com/en/advanced/best-practice-performance.html#set-node_env-to-production
 * See: https://webpack.js.org/guides/production/
 */ const instanceOf = /* c8 ignore next 6 */ // FIXME: https://github.com/graphql/graphql-js/issues/2317
// eslint-disable-next-line no-undef
 true ? function instanceOf(value, constructor) {
    return value instanceof constructor;
} : 0;
exports.instanceOf = instanceOf;


/***/ }),

/***/ 5210:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.invariant = invariant;
function invariant(condition, message) {
    const booleanCondition = Boolean(condition);
    if (!booleanCondition) {
        throw new Error(message != null ? message : "Unexpected invariant triggered.");
    }
}


/***/ }),

/***/ 4262:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.isAsyncIterable = isAsyncIterable;
/**
 * Returns true if the provided object implements the AsyncIterator protocol via
 * implementing a `Symbol.asyncIterator` method.
 */ function isAsyncIterable(maybeAsyncIterable) {
    return typeof (maybeAsyncIterable === null || maybeAsyncIterable === void 0 ? void 0 : maybeAsyncIterable[Symbol.asyncIterator]) === "function";
}


/***/ }),

/***/ 1167:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.isIterableObject = isIterableObject;
/**
 * Returns true if the provided object is an Object (i.e. not a string literal)
 * and implements the Iterator protocol.
 *
 * This may be used in place of [Array.isArray()][isArray] to determine if
 * an object should be iterated-over e.g. Array, Map, Set, Int8Array,
 * TypedArray, etc. but excludes string literals.
 *
 * @example
 * ```ts
 * isIterableObject([ 1, 2, 3 ]) // true
 * isIterableObject(new Map()) // true
 * isIterableObject('ABC') // false
 * isIterableObject({ key: 'value' }) // false
 * isIterableObject({ length: 1, 0: 'Alpha' }) // false
 * ```
 */ function isIterableObject(maybeIterable) {
    return typeof maybeIterable === "object" && typeof (maybeIterable === null || maybeIterable === void 0 ? void 0 : maybeIterable[Symbol.iterator]) === "function";
}


/***/ }),

/***/ 5564:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.isObjectLike = isObjectLike;
/**
 * Return true if `value` is object-like. A value is object-like if it's not
 * `null` and has a `typeof` result of "object".
 */ function isObjectLike(value) {
    return typeof value == "object" && value !== null;
}


/***/ }),

/***/ 6578:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.isPromise = isPromise;
/**
 * Returns true if the value acts like a Promise, i.e. has a "then" function,
 * otherwise returns false.
 */ function isPromise(value) {
    return typeof (value === null || value === void 0 ? void 0 : value.then) === "function";
}


/***/ }),

/***/ 2512:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.keyMap = keyMap;
/**
 * Creates a keyed JS object from an array, given a function to produce the keys
 * for each value in the array.
 *
 * This provides a convenient lookup for the array items if the key function
 * produces unique results.
 * ```ts
 * const phoneBook = [
 *   { name: 'Jon', num: '555-1234' },
 *   { name: 'Jenny', num: '867-5309' }
 * ]
 *
 * const entriesByName = keyMap(
 *   phoneBook,
 *   entry => entry.name
 * )
 *
 * // {
 * //   Jon: { name: 'Jon', num: '555-1234' },
 * //   Jenny: { name: 'Jenny', num: '867-5309' }
 * // }
 *
 * const jennyEntry = entriesByName['Jenny']
 *
 * // { name: 'Jenny', num: '857-6309' }
 * ```
 */ function keyMap(list, keyFn) {
    const result = Object.create(null);
    for (const item of list){
        result[keyFn(item)] = item;
    }
    return result;
}


/***/ }),

/***/ 370:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.keyValMap = keyValMap;
/**
 * Creates a keyed JS object from an array, given a function to produce the keys
 * and a function to produce the values from each item in the array.
 * ```ts
 * const phoneBook = [
 *   { name: 'Jon', num: '555-1234' },
 *   { name: 'Jenny', num: '867-5309' }
 * ]
 *
 * // { Jon: '555-1234', Jenny: '867-5309' }
 * const phonesByName = keyValMap(
 *   phoneBook,
 *   entry => entry.name,
 *   entry => entry.num
 * )
 * ```
 */ function keyValMap(list, keyFn, valFn) {
    const result = Object.create(null);
    for (const item of list){
        result[keyFn(item)] = valFn(item);
    }
    return result;
}


/***/ }),

/***/ 1030:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.mapValue = mapValue;
/**
 * Creates an object map with the same keys as `map` and values generated by
 * running each value of `map` thru `fn`.
 */ function mapValue(map, fn) {
    const result = Object.create(null);
    for (const key of Object.keys(map)){
        result[key] = fn(map[key], key);
    }
    return result;
}


/***/ }),

/***/ 6173:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.memoize3 = memoize3;
/**
 * Memoizes the provided three-argument function.
 */ function memoize3(fn) {
    let cache0;
    return function memoized(a1, a2, a3) {
        if (cache0 === undefined) {
            cache0 = new WeakMap();
        }
        let cache1 = cache0.get(a1);
        if (cache1 === undefined) {
            cache1 = new WeakMap();
            cache0.set(a1, cache1);
        }
        let cache2 = cache1.get(a2);
        if (cache2 === undefined) {
            cache2 = new WeakMap();
            cache1.set(a2, cache2);
        }
        let fnResult = cache2.get(a3);
        if (fnResult === undefined) {
            fnResult = fn(a1, a2, a3);
            cache2.set(a3, fnResult);
        }
        return fnResult;
    };
}


/***/ }),

/***/ 135:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.naturalCompare = naturalCompare;
/**
 * Returns a number indicating whether a reference string comes before, or after,
 * or is the same as the given string in natural sort order.
 *
 * See: https://en.wikipedia.org/wiki/Natural_sort_order
 *
 */ function naturalCompare(aStr, bStr) {
    let aIndex = 0;
    let bIndex = 0;
    while(aIndex < aStr.length && bIndex < bStr.length){
        let aChar = aStr.charCodeAt(aIndex);
        let bChar = bStr.charCodeAt(bIndex);
        if (isDigit(aChar) && isDigit(bChar)) {
            let aNum = 0;
            do {
                ++aIndex;
                aNum = aNum * 10 + aChar - DIGIT_0;
                aChar = aStr.charCodeAt(aIndex);
            }while (isDigit(aChar) && aNum > 0);
            let bNum = 0;
            do {
                ++bIndex;
                bNum = bNum * 10 + bChar - DIGIT_0;
                bChar = bStr.charCodeAt(bIndex);
            }while (isDigit(bChar) && bNum > 0);
            if (aNum < bNum) {
                return -1;
            }
            if (aNum > bNum) {
                return 1;
            }
        } else {
            if (aChar < bChar) {
                return -1;
            }
            if (aChar > bChar) {
                return 1;
            }
            ++aIndex;
            ++bIndex;
        }
    }
    return aStr.length - bStr.length;
}
const DIGIT_0 = 48;
const DIGIT_9 = 57;
function isDigit(code) {
    return !isNaN(code) && DIGIT_0 <= code && code <= DIGIT_9;
}


/***/ }),

/***/ 7884:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.printPathArray = printPathArray;
/**
 * Build a string describing the path.
 */ function printPathArray(path) {
    return path.map((key)=>typeof key === "number" ? "[" + key.toString() + "]" : "." + key).join("");
}


/***/ }),

/***/ 1977:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.promiseForObject = promiseForObject;
/**
 * This function transforms a JS object `ObjMap<Promise<T>>` into
 * a `Promise<ObjMap<T>>`
 *
 * This is akin to bluebird's `Promise.props`, but implemented only using
 * `Promise.all` so it will work with any implementation of ES6 promises.
 */ function promiseForObject(object) {
    return Promise.all(Object.values(object)).then((resolvedValues)=>{
        const resolvedObject = Object.create(null);
        for (const [i, key] of Object.keys(object).entries()){
            resolvedObject[key] = resolvedValues[i];
        }
        return resolvedObject;
    });
}


/***/ }),

/***/ 4002:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.promiseReduce = promiseReduce;
var _isPromise = __webpack_require__(6578);
/**
 * Similar to Array.prototype.reduce(), however the reducing callback may return
 * a Promise, in which case reduction will continue after each promise resolves.
 *
 * If the callback does not return a Promise, then this function will also not
 * return a Promise.
 */ function promiseReduce(values, callbackFn, initialValue) {
    let accumulator = initialValue;
    for (const value of values){
        accumulator = (0, _isPromise.isPromise)(accumulator) ? accumulator.then((resolved)=>callbackFn(resolved, value)) : callbackFn(accumulator, value);
    }
    return accumulator;
}


/***/ }),

/***/ 6347:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.suggestionList = suggestionList;
var _naturalCompare = __webpack_require__(135);
/**
 * Given an invalid input string and a list of valid options, returns a filtered
 * list of valid options sorted based on their similarity with the input.
 */ function suggestionList(input, options) {
    const optionsByDistance = Object.create(null);
    const lexicalDistance = new LexicalDistance(input);
    const threshold = Math.floor(input.length * 0.4) + 1;
    for (const option of options){
        const distance = lexicalDistance.measure(option, threshold);
        if (distance !== undefined) {
            optionsByDistance[option] = distance;
        }
    }
    return Object.keys(optionsByDistance).sort((a, b)=>{
        const distanceDiff = optionsByDistance[a] - optionsByDistance[b];
        return distanceDiff !== 0 ? distanceDiff : (0, _naturalCompare.naturalCompare)(a, b);
    });
}
/**
 * Computes the lexical distance between strings A and B.
 *
 * The "distance" between two strings is given by counting the minimum number
 * of edits needed to transform string A into string B. An edit can be an
 * insertion, deletion, or substitution of a single character, or a swap of two
 * adjacent characters.
 *
 * Includes a custom alteration from Damerau-Levenshtein to treat case changes
 * as a single edit which helps identify mis-cased values with an edit distance
 * of 1.
 *
 * This distance can be useful for detecting typos in input or sorting
 */ class LexicalDistance {
    constructor(input){
        this._input = input;
        this._inputLowerCase = input.toLowerCase();
        this._inputArray = stringToArray(this._inputLowerCase);
        this._rows = [
            new Array(input.length + 1).fill(0),
            new Array(input.length + 1).fill(0),
            new Array(input.length + 1).fill(0)
        ];
    }
    measure(option, threshold) {
        if (this._input === option) {
            return 0;
        }
        const optionLowerCase = option.toLowerCase(); // Any case change counts as a single edit
        if (this._inputLowerCase === optionLowerCase) {
            return 1;
        }
        let a = stringToArray(optionLowerCase);
        let b = this._inputArray;
        if (a.length < b.length) {
            const tmp = a;
            a = b;
            b = tmp;
        }
        const aLength = a.length;
        const bLength = b.length;
        if (aLength - bLength > threshold) {
            return undefined;
        }
        const rows = this._rows;
        for(let j = 0; j <= bLength; j++){
            rows[0][j] = j;
        }
        for(let i = 1; i <= aLength; i++){
            const upRow = rows[(i - 1) % 3];
            const currentRow = rows[i % 3];
            let smallestCell = currentRow[0] = i;
            for(let j = 1; j <= bLength; j++){
                const cost = a[i - 1] === b[j - 1] ? 0 : 1;
                let currentCell = Math.min(upRow[j] + 1, currentRow[j - 1] + 1, upRow[j - 1] + cost);
                if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
                    // transposition
                    const doubleDiagonalCell = rows[(i - 2) % 3][j - 2];
                    currentCell = Math.min(currentCell, doubleDiagonalCell + 1);
                }
                if (currentCell < smallestCell) {
                    smallestCell = currentCell;
                }
                currentRow[j] = currentCell;
            } // Early exit, since distance can't go smaller than smallest element of the previous row.
            if (smallestCell > threshold) {
                return undefined;
            }
        }
        const distance = rows[aLength % 3][bLength];
        return distance <= threshold ? distance : undefined;
    }
}
function stringToArray(str) {
    const strLength = str.length;
    const array = new Array(strLength);
    for(let i = 0; i < strLength; ++i){
        array[i] = str.charCodeAt(i);
    }
    return array;
}


/***/ }),

/***/ 8202:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.toError = toError;
var _inspect = __webpack_require__(8089);
/**
 * Sometimes a non-error is thrown, wrap it as an Error instance to ensure a consistent Error interface.
 */ function toError(thrownValue) {
    return thrownValue instanceof Error ? thrownValue : new NonErrorThrown(thrownValue);
}
class NonErrorThrown extends Error {
    constructor(thrownValue){
        super("Unexpected error value: " + (0, _inspect.inspect)(thrownValue));
        this.name = "NonErrorThrown";
        this.thrownValue = thrownValue;
    }
}


/***/ }),

/***/ 5891:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.toObjMap = toObjMap;
function toObjMap(obj) {
    if (obj == null) {
        return Object.create(null);
    }
    if (Object.getPrototypeOf(obj) === null) {
        return obj;
    }
    const map = Object.create(null);
    for (const [key, value] of Object.entries(obj)){
        map[key] = value;
    }
    return map;
}


/***/ }),

/***/ 9344:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.Token = exports.QueryDocumentKeys = exports.OperationTypeNode = exports.Location = void 0;
exports.isNode = isNode;
/**
 * Contains a range of UTF-8 character offsets and token references that
 * identify the region of the source from which the AST derived.
 */ class Location {
    /**
   * The character offset at which this Node begins.
   */ /**
   * The character offset at which this Node ends.
   */ /**
   * The Token at which this Node begins.
   */ /**
   * The Token at which this Node ends.
   */ /**
   * The Source document the AST represents.
   */ constructor(startToken, endToken, source){
        this.start = startToken.start;
        this.end = endToken.end;
        this.startToken = startToken;
        this.endToken = endToken;
        this.source = source;
    }
    get [Symbol.toStringTag]() {
        return "Location";
    }
    toJSON() {
        return {
            start: this.start,
            end: this.end
        };
    }
}
/**
 * Represents a range of characters represented by a lexical token
 * within a Source.
 */ exports.Location = Location;
class Token {
    /**
   * The kind of Token.
   */ /**
   * The character offset at which this Node begins.
   */ /**
   * The character offset at which this Node ends.
   */ /**
   * The 1-indexed line number on which this Token appears.
   */ /**
   * The 1-indexed column number at which this Token begins.
   */ /**
   * For non-punctuation tokens, represents the interpreted value of the token.
   *
   * Note: is undefined for punctuation tokens, but typed as string for
   * convenience in the parser.
   */ /**
   * Tokens exist as nodes in a double-linked-list amongst all tokens
   * including ignored tokens. <SOF> is always the first node and <EOF>
   * the last.
   */ constructor(kind, start, end, line, column, value){
        this.kind = kind;
        this.start = start;
        this.end = end;
        this.line = line;
        this.column = column; // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        this.value = value;
        this.prev = null;
        this.next = null;
    }
    get [Symbol.toStringTag]() {
        return "Token";
    }
    toJSON() {
        return {
            kind: this.kind,
            value: this.value,
            line: this.line,
            column: this.column
        };
    }
}
/**
 * The list of all possible AST node types.
 */ exports.Token = Token;
/**
 * @internal
 */ const QueryDocumentKeys = {
    Name: [],
    Document: [
        "definitions"
    ],
    OperationDefinition: [
        "name",
        "variableDefinitions",
        "directives",
        "selectionSet"
    ],
    VariableDefinition: [
        "variable",
        "type",
        "defaultValue",
        "directives"
    ],
    Variable: [
        "name"
    ],
    SelectionSet: [
        "selections"
    ],
    Field: [
        "alias",
        "name",
        "arguments",
        "directives",
        "selectionSet"
    ],
    Argument: [
        "name",
        "value"
    ],
    FragmentSpread: [
        "name",
        "directives"
    ],
    InlineFragment: [
        "typeCondition",
        "directives",
        "selectionSet"
    ],
    FragmentDefinition: [
        "name",
        "variableDefinitions",
        "typeCondition",
        "directives",
        "selectionSet"
    ],
    IntValue: [],
    FloatValue: [],
    StringValue: [],
    BooleanValue: [],
    NullValue: [],
    EnumValue: [],
    ListValue: [
        "values"
    ],
    ObjectValue: [
        "fields"
    ],
    ObjectField: [
        "name",
        "value"
    ],
    Directive: [
        "name",
        "arguments"
    ],
    NamedType: [
        "name"
    ],
    ListType: [
        "type"
    ],
    NonNullType: [
        "type"
    ],
    SchemaDefinition: [
        "description",
        "directives",
        "operationTypes"
    ],
    OperationTypeDefinition: [
        "type"
    ],
    ScalarTypeDefinition: [
        "description",
        "name",
        "directives"
    ],
    ObjectTypeDefinition: [
        "description",
        "name",
        "interfaces",
        "directives",
        "fields"
    ],
    FieldDefinition: [
        "description",
        "name",
        "arguments",
        "type",
        "directives"
    ],
    InputValueDefinition: [
        "description",
        "name",
        "type",
        "defaultValue",
        "directives"
    ],
    InterfaceTypeDefinition: [
        "description",
        "name",
        "interfaces",
        "directives",
        "fields"
    ],
    UnionTypeDefinition: [
        "description",
        "name",
        "directives",
        "types"
    ],
    EnumTypeDefinition: [
        "description",
        "name",
        "directives",
        "values"
    ],
    EnumValueDefinition: [
        "description",
        "name",
        "directives"
    ],
    InputObjectTypeDefinition: [
        "description",
        "name",
        "directives",
        "fields"
    ],
    DirectiveDefinition: [
        "description",
        "name",
        "arguments",
        "locations"
    ],
    SchemaExtension: [
        "directives",
        "operationTypes"
    ],
    ScalarTypeExtension: [
        "name",
        "directives"
    ],
    ObjectTypeExtension: [
        "name",
        "interfaces",
        "directives",
        "fields"
    ],
    InterfaceTypeExtension: [
        "name",
        "interfaces",
        "directives",
        "fields"
    ],
    UnionTypeExtension: [
        "name",
        "directives",
        "types"
    ],
    EnumTypeExtension: [
        "name",
        "directives",
        "values"
    ],
    InputObjectTypeExtension: [
        "name",
        "directives",
        "fields"
    ]
};
exports.QueryDocumentKeys = QueryDocumentKeys;
const kindValues = new Set(Object.keys(QueryDocumentKeys));
/**
 * @internal
 */ function isNode(maybeNode) {
    const maybeKind = maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.kind;
    return typeof maybeKind === "string" && kindValues.has(maybeKind);
}
/** Name */ var OperationTypeNode;
exports.OperationTypeNode = OperationTypeNode;
(function(OperationTypeNode) {
    OperationTypeNode["QUERY"] = "query";
    OperationTypeNode["MUTATION"] = "mutation";
    OperationTypeNode["SUBSCRIPTION"] = "subscription";
})(OperationTypeNode || (exports.OperationTypeNode = OperationTypeNode = {}));


/***/ }),

/***/ 9121:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.dedentBlockStringLines = dedentBlockStringLines;
exports.isPrintableAsBlockString = isPrintableAsBlockString;
exports.printBlockString = printBlockString;
var _characterClasses = __webpack_require__(1097);
/**
 * Produces the value of a block string from its parsed raw value, similar to
 * CoffeeScript's block string, Python's docstring trim or Ruby's strip_heredoc.
 *
 * This implements the GraphQL spec's BlockStringValue() static algorithm.
 *
 * @internal
 */ function dedentBlockStringLines(lines) {
    var _firstNonEmptyLine2;
    let commonIndent = Number.MAX_SAFE_INTEGER;
    let firstNonEmptyLine = null;
    let lastNonEmptyLine = -1;
    for(let i = 0; i < lines.length; ++i){
        var _firstNonEmptyLine;
        const line = lines[i];
        const indent = leadingWhitespace(line);
        if (indent === line.length) {
            continue; // skip empty lines
        }
        firstNonEmptyLine = (_firstNonEmptyLine = firstNonEmptyLine) !== null && _firstNonEmptyLine !== void 0 ? _firstNonEmptyLine : i;
        lastNonEmptyLine = i;
        if (i !== 0 && indent < commonIndent) {
            commonIndent = indent;
        }
    }
    return lines // Remove common indentation from all lines but first.
    .map((line, i)=>i === 0 ? line : line.slice(commonIndent)) // Remove leading and trailing blank lines.
    .slice((_firstNonEmptyLine2 = firstNonEmptyLine) !== null && _firstNonEmptyLine2 !== void 0 ? _firstNonEmptyLine2 : 0, lastNonEmptyLine + 1);
}
function leadingWhitespace(str) {
    let i = 0;
    while(i < str.length && (0, _characterClasses.isWhiteSpace)(str.charCodeAt(i))){
        ++i;
    }
    return i;
}
/**
 * @internal
 */ function isPrintableAsBlockString(value) {
    if (value === "") {
        return true; // empty string is printable
    }
    let isEmptyLine = true;
    let hasIndent = false;
    let hasCommonIndent = true;
    let seenNonEmptyLine = false;
    for(let i = 0; i < value.length; ++i){
        switch(value.codePointAt(i)){
            case 0x0000:
            case 0x0001:
            case 0x0002:
            case 0x0003:
            case 0x0004:
            case 0x0005:
            case 0x0006:
            case 0x0007:
            case 0x0008:
            case 0x000b:
            case 0x000c:
            case 0x000e:
            case 0x000f:
                return false;
            // Has non-printable characters
            case 0x000d:
                //  \r
                return false;
            // Has \r or \r\n which will be replaced as \n
            case 10:
                //  \n
                if (isEmptyLine && !seenNonEmptyLine) {
                    return false; // Has leading new line
                }
                seenNonEmptyLine = true;
                isEmptyLine = true;
                hasIndent = false;
                break;
            case 9:
            case 32:
                //  <space>
                hasIndent || (hasIndent = isEmptyLine);
                break;
            default:
                hasCommonIndent && (hasCommonIndent = hasIndent);
                isEmptyLine = false;
        }
    }
    if (isEmptyLine) {
        return false; // Has trailing empty lines
    }
    if (hasCommonIndent && seenNonEmptyLine) {
        return false; // Has internal indent
    }
    return true;
}
/**
 * Print a block string in the indented block form by adding a leading and
 * trailing blank line. However, if a block string starts with whitespace and is
 * a single-line, adding a leading blank line would strip that whitespace.
 *
 * @internal
 */ function printBlockString(value, options) {
    const escapedValue = value.replace(/"""/g, '\\"""'); // Expand a block string's raw value into independent lines.
    const lines = escapedValue.split(/\r\n|[\n\r]/g);
    const isSingleLine = lines.length === 1; // If common indentation is found we can fix some of those cases by adding leading new line
    const forceLeadingNewLine = lines.length > 1 && lines.slice(1).every((line)=>line.length === 0 || (0, _characterClasses.isWhiteSpace)(line.charCodeAt(0))); // Trailing triple quotes just looks confusing but doesn't force trailing new line
    const hasTrailingTripleQuotes = escapedValue.endsWith('\\"""'); // Trailing quote (single or double) or slash forces trailing new line
    const hasTrailingQuote = value.endsWith('"') && !hasTrailingTripleQuotes;
    const hasTrailingSlash = value.endsWith("\\");
    const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;
    const printAsMultipleLines = !(options !== null && options !== void 0 && options.minimize) && // add leading and trailing new lines only if it improves readability
    (!isSingleLine || value.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes);
    let result = ""; // Format a multi-line block quote to account for leading space.
    const skipLeadingNewLine = isSingleLine && (0, _characterClasses.isWhiteSpace)(value.charCodeAt(0));
    if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {
        result += "\n";
    }
    result += escapedValue;
    if (printAsMultipleLines || forceTrailingNewline) {
        result += "\n";
    }
    return '"""' + result + '"""';
}


/***/ }),

/***/ 1097:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.isDigit = isDigit;
exports.isLetter = isLetter;
exports.isNameContinue = isNameContinue;
exports.isNameStart = isNameStart;
exports.isWhiteSpace = isWhiteSpace;
/**
 * ```
 * WhiteSpace ::
 *   - "Horizontal Tab (U+0009)"
 *   - "Space (U+0020)"
 * ```
 * @internal
 */ function isWhiteSpace(code) {
    return code === 0x0009 || code === 0x0020;
}
/**
 * ```
 * Digit :: one of
 *   - `0` `1` `2` `3` `4` `5` `6` `7` `8` `9`
 * ```
 * @internal
 */ function isDigit(code) {
    return code >= 0x0030 && code <= 0x0039;
}
/**
 * ```
 * Letter :: one of
 *   - `A` `B` `C` `D` `E` `F` `G` `H` `I` `J` `K` `L` `M`
 *   - `N` `O` `P` `Q` `R` `S` `T` `U` `V` `W` `X` `Y` `Z`
 *   - `a` `b` `c` `d` `e` `f` `g` `h` `i` `j` `k` `l` `m`
 *   - `n` `o` `p` `q` `r` `s` `t` `u` `v` `w` `x` `y` `z`
 * ```
 * @internal
 */ function isLetter(code) {
    return code >= 0x0061 && code <= 0x007a || // A-Z
    code >= 0x0041 && code <= 0x005a // a-z
    ;
}
/**
 * ```
 * NameStart ::
 *   - Letter
 *   - `_`
 * ```
 * @internal
 */ function isNameStart(code) {
    return isLetter(code) || code === 0x005f;
}
/**
 * ```
 * NameContinue ::
 *   - Letter
 *   - Digit
 *   - `_`
 * ```
 * @internal
 */ function isNameContinue(code) {
    return isLetter(code) || isDigit(code) || code === 0x005f;
}


/***/ }),

/***/ 7936:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.DirectiveLocation = void 0;
/**
 * The set of allowed directive location values.
 */ var DirectiveLocation;
exports.DirectiveLocation = DirectiveLocation;
(function(DirectiveLocation) {
    DirectiveLocation["QUERY"] = "QUERY";
    DirectiveLocation["MUTATION"] = "MUTATION";
    DirectiveLocation["SUBSCRIPTION"] = "SUBSCRIPTION";
    DirectiveLocation["FIELD"] = "FIELD";
    DirectiveLocation["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
    DirectiveLocation["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
    DirectiveLocation["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
    DirectiveLocation["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
    DirectiveLocation["SCHEMA"] = "SCHEMA";
    DirectiveLocation["SCALAR"] = "SCALAR";
    DirectiveLocation["OBJECT"] = "OBJECT";
    DirectiveLocation["FIELD_DEFINITION"] = "FIELD_DEFINITION";
    DirectiveLocation["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
    DirectiveLocation["INTERFACE"] = "INTERFACE";
    DirectiveLocation["UNION"] = "UNION";
    DirectiveLocation["ENUM"] = "ENUM";
    DirectiveLocation["ENUM_VALUE"] = "ENUM_VALUE";
    DirectiveLocation["INPUT_OBJECT"] = "INPUT_OBJECT";
    DirectiveLocation["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
})(DirectiveLocation || (exports.DirectiveLocation = DirectiveLocation = {})); /**
 * The enum type representing the directive location values.
 *
 * @deprecated Please use `DirectiveLocation`. Will be remove in v17.
 */ 


/***/ }),

/***/ 1371:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "BREAK", ({
    enumerable: true,
    get: function() {
        return _visitor.BREAK;
    }
}));
Object.defineProperty(exports, "DirectiveLocation", ({
    enumerable: true,
    get: function() {
        return _directiveLocation.DirectiveLocation;
    }
}));
Object.defineProperty(exports, "Kind", ({
    enumerable: true,
    get: function() {
        return _kinds.Kind;
    }
}));
Object.defineProperty(exports, "Lexer", ({
    enumerable: true,
    get: function() {
        return _lexer.Lexer;
    }
}));
Object.defineProperty(exports, "Location", ({
    enumerable: true,
    get: function() {
        return _ast.Location;
    }
}));
Object.defineProperty(exports, "OperationTypeNode", ({
    enumerable: true,
    get: function() {
        return _ast.OperationTypeNode;
    }
}));
Object.defineProperty(exports, "Source", ({
    enumerable: true,
    get: function() {
        return _source.Source;
    }
}));
Object.defineProperty(exports, "Token", ({
    enumerable: true,
    get: function() {
        return _ast.Token;
    }
}));
Object.defineProperty(exports, "TokenKind", ({
    enumerable: true,
    get: function() {
        return _tokenKind.TokenKind;
    }
}));
Object.defineProperty(exports, "getEnterLeaveForKind", ({
    enumerable: true,
    get: function() {
        return _visitor.getEnterLeaveForKind;
    }
}));
Object.defineProperty(exports, "getLocation", ({
    enumerable: true,
    get: function() {
        return _location.getLocation;
    }
}));
Object.defineProperty(exports, "getVisitFn", ({
    enumerable: true,
    get: function() {
        return _visitor.getVisitFn;
    }
}));
Object.defineProperty(exports, "isConstValueNode", ({
    enumerable: true,
    get: function() {
        return _predicates.isConstValueNode;
    }
}));
Object.defineProperty(exports, "isDefinitionNode", ({
    enumerable: true,
    get: function() {
        return _predicates.isDefinitionNode;
    }
}));
Object.defineProperty(exports, "isExecutableDefinitionNode", ({
    enumerable: true,
    get: function() {
        return _predicates.isExecutableDefinitionNode;
    }
}));
Object.defineProperty(exports, "isSelectionNode", ({
    enumerable: true,
    get: function() {
        return _predicates.isSelectionNode;
    }
}));
Object.defineProperty(exports, "isTypeDefinitionNode", ({
    enumerable: true,
    get: function() {
        return _predicates.isTypeDefinitionNode;
    }
}));
Object.defineProperty(exports, "isTypeExtensionNode", ({
    enumerable: true,
    get: function() {
        return _predicates.isTypeExtensionNode;
    }
}));
Object.defineProperty(exports, "isTypeNode", ({
    enumerable: true,
    get: function() {
        return _predicates.isTypeNode;
    }
}));
Object.defineProperty(exports, "isTypeSystemDefinitionNode", ({
    enumerable: true,
    get: function() {
        return _predicates.isTypeSystemDefinitionNode;
    }
}));
Object.defineProperty(exports, "isTypeSystemExtensionNode", ({
    enumerable: true,
    get: function() {
        return _predicates.isTypeSystemExtensionNode;
    }
}));
Object.defineProperty(exports, "isValueNode", ({
    enumerable: true,
    get: function() {
        return _predicates.isValueNode;
    }
}));
Object.defineProperty(exports, "parse", ({
    enumerable: true,
    get: function() {
        return _parser.parse;
    }
}));
Object.defineProperty(exports, "parseConstValue", ({
    enumerable: true,
    get: function() {
        return _parser.parseConstValue;
    }
}));
Object.defineProperty(exports, "parseType", ({
    enumerable: true,
    get: function() {
        return _parser.parseType;
    }
}));
Object.defineProperty(exports, "parseValue", ({
    enumerable: true,
    get: function() {
        return _parser.parseValue;
    }
}));
Object.defineProperty(exports, "print", ({
    enumerable: true,
    get: function() {
        return _printer.print;
    }
}));
Object.defineProperty(exports, "printLocation", ({
    enumerable: true,
    get: function() {
        return _printLocation.printLocation;
    }
}));
Object.defineProperty(exports, "printSourceLocation", ({
    enumerable: true,
    get: function() {
        return _printLocation.printSourceLocation;
    }
}));
Object.defineProperty(exports, "visit", ({
    enumerable: true,
    get: function() {
        return _visitor.visit;
    }
}));
Object.defineProperty(exports, "visitInParallel", ({
    enumerable: true,
    get: function() {
        return _visitor.visitInParallel;
    }
}));
var _source = __webpack_require__(8509);
var _location = __webpack_require__(8140);
var _printLocation = __webpack_require__(941);
var _kinds = __webpack_require__(5923);
var _tokenKind = __webpack_require__(8845);
var _lexer = __webpack_require__(8225);
var _parser = __webpack_require__(8208);
var _printer = __webpack_require__(800);
var _visitor = __webpack_require__(4256);
var _ast = __webpack_require__(9344);
var _predicates = __webpack_require__(3288);
var _directiveLocation = __webpack_require__(7936);


/***/ }),

/***/ 5923:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.Kind = void 0;
/**
 * The set of allowed kind values for AST nodes.
 */ var Kind;
exports.Kind = Kind;
(function(Kind) {
    Kind["NAME"] = "Name";
    Kind["DOCUMENT"] = "Document";
    Kind["OPERATION_DEFINITION"] = "OperationDefinition";
    Kind["VARIABLE_DEFINITION"] = "VariableDefinition";
    Kind["SELECTION_SET"] = "SelectionSet";
    Kind["FIELD"] = "Field";
    Kind["ARGUMENT"] = "Argument";
    Kind["FRAGMENT_SPREAD"] = "FragmentSpread";
    Kind["INLINE_FRAGMENT"] = "InlineFragment";
    Kind["FRAGMENT_DEFINITION"] = "FragmentDefinition";
    Kind["VARIABLE"] = "Variable";
    Kind["INT"] = "IntValue";
    Kind["FLOAT"] = "FloatValue";
    Kind["STRING"] = "StringValue";
    Kind["BOOLEAN"] = "BooleanValue";
    Kind["NULL"] = "NullValue";
    Kind["ENUM"] = "EnumValue";
    Kind["LIST"] = "ListValue";
    Kind["OBJECT"] = "ObjectValue";
    Kind["OBJECT_FIELD"] = "ObjectField";
    Kind["DIRECTIVE"] = "Directive";
    Kind["NAMED_TYPE"] = "NamedType";
    Kind["LIST_TYPE"] = "ListType";
    Kind["NON_NULL_TYPE"] = "NonNullType";
    Kind["SCHEMA_DEFINITION"] = "SchemaDefinition";
    Kind["OPERATION_TYPE_DEFINITION"] = "OperationTypeDefinition";
    Kind["SCALAR_TYPE_DEFINITION"] = "ScalarTypeDefinition";
    Kind["OBJECT_TYPE_DEFINITION"] = "ObjectTypeDefinition";
    Kind["FIELD_DEFINITION"] = "FieldDefinition";
    Kind["INPUT_VALUE_DEFINITION"] = "InputValueDefinition";
    Kind["INTERFACE_TYPE_DEFINITION"] = "InterfaceTypeDefinition";
    Kind["UNION_TYPE_DEFINITION"] = "UnionTypeDefinition";
    Kind["ENUM_TYPE_DEFINITION"] = "EnumTypeDefinition";
    Kind["ENUM_VALUE_DEFINITION"] = "EnumValueDefinition";
    Kind["INPUT_OBJECT_TYPE_DEFINITION"] = "InputObjectTypeDefinition";
    Kind["DIRECTIVE_DEFINITION"] = "DirectiveDefinition";
    Kind["SCHEMA_EXTENSION"] = "SchemaExtension";
    Kind["SCALAR_TYPE_EXTENSION"] = "ScalarTypeExtension";
    Kind["OBJECT_TYPE_EXTENSION"] = "ObjectTypeExtension";
    Kind["INTERFACE_TYPE_EXTENSION"] = "InterfaceTypeExtension";
    Kind["UNION_TYPE_EXTENSION"] = "UnionTypeExtension";
    Kind["ENUM_TYPE_EXTENSION"] = "EnumTypeExtension";
    Kind["INPUT_OBJECT_TYPE_EXTENSION"] = "InputObjectTypeExtension";
})(Kind || (exports.Kind = Kind = {})); /**
 * The enum type representing the possible kind values of AST nodes.
 *
 * @deprecated Please use `Kind`. Will be remove in v17.
 */ 


/***/ }),

/***/ 8225:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.Lexer = void 0;
exports.isPunctuatorTokenKind = isPunctuatorTokenKind;
var _syntaxError = __webpack_require__(4466);
var _ast = __webpack_require__(9344);
var _blockString = __webpack_require__(9121);
var _characterClasses = __webpack_require__(1097);
var _tokenKind = __webpack_require__(8845);
/**
 * Given a Source object, creates a Lexer for that source.
 * A Lexer is a stateful stream generator in that every time
 * it is advanced, it returns the next token in the Source. Assuming the
 * source lexes, the final Token emitted by the lexer will be of kind
 * EOF, after which the lexer will repeatedly return the same EOF token
 * whenever called.
 */ class Lexer {
    /**
   * The previously focused non-ignored token.
   */ /**
   * The currently focused non-ignored token.
   */ /**
   * The (1-indexed) line containing the current token.
   */ /**
   * The character offset at which the current line begins.
   */ constructor(source){
        const startOfFileToken = new _ast.Token(_tokenKind.TokenKind.SOF, 0, 0, 0, 0);
        this.source = source;
        this.lastToken = startOfFileToken;
        this.token = startOfFileToken;
        this.line = 1;
        this.lineStart = 0;
    }
    get [Symbol.toStringTag]() {
        return "Lexer";
    }
    /**
   * Advances the token stream to the next non-ignored token.
   */ advance() {
        this.lastToken = this.token;
        const token = this.token = this.lookahead();
        return token;
    }
    /**
   * Looks ahead and returns the next non-ignored token, but does not change
   * the state of Lexer.
   */ lookahead() {
        let token = this.token;
        if (token.kind !== _tokenKind.TokenKind.EOF) {
            do {
                if (token.next) {
                    token = token.next;
                } else {
                    // Read the next token and form a link in the token linked-list.
                    const nextToken = readNextToken(this, token.end); // @ts-expect-error next is only mutable during parsing.
                    token.next = nextToken; // @ts-expect-error prev is only mutable during parsing.
                    nextToken.prev = token;
                    token = nextToken;
                }
            }while (token.kind === _tokenKind.TokenKind.COMMENT);
        }
        return token;
    }
}
/**
 * @internal
 */ exports.Lexer = Lexer;
function isPunctuatorTokenKind(kind) {
    return kind === _tokenKind.TokenKind.BANG || kind === _tokenKind.TokenKind.DOLLAR || kind === _tokenKind.TokenKind.AMP || kind === _tokenKind.TokenKind.PAREN_L || kind === _tokenKind.TokenKind.PAREN_R || kind === _tokenKind.TokenKind.SPREAD || kind === _tokenKind.TokenKind.COLON || kind === _tokenKind.TokenKind.EQUALS || kind === _tokenKind.TokenKind.AT || kind === _tokenKind.TokenKind.BRACKET_L || kind === _tokenKind.TokenKind.BRACKET_R || kind === _tokenKind.TokenKind.BRACE_L || kind === _tokenKind.TokenKind.PIPE || kind === _tokenKind.TokenKind.BRACE_R;
}
/**
 * A Unicode scalar value is any Unicode code point except surrogate code
 * points. In other words, the inclusive ranges of values 0x0000 to 0xD7FF and
 * 0xE000 to 0x10FFFF.
 *
 * SourceCharacter ::
 *   - "Any Unicode scalar value"
 */ function isUnicodeScalarValue(code) {
    return code >= 0x0000 && code <= 0xd7ff || code >= 0xe000 && code <= 0x10ffff;
}
/**
 * The GraphQL specification defines source text as a sequence of unicode scalar
 * values (which Unicode defines to exclude surrogate code points). However
 * JavaScript defines strings as a sequence of UTF-16 code units which may
 * include surrogates. A surrogate pair is a valid source character as it
 * encodes a supplementary code point (above U+FFFF), but unpaired surrogate
 * code points are not valid source characters.
 */ function isSupplementaryCodePoint(body, location) {
    return isLeadingSurrogate(body.charCodeAt(location)) && isTrailingSurrogate(body.charCodeAt(location + 1));
}
function isLeadingSurrogate(code) {
    return code >= 0xd800 && code <= 0xdbff;
}
function isTrailingSurrogate(code) {
    return code >= 0xdc00 && code <= 0xdfff;
}
/**
 * Prints the code point (or end of file reference) at a given location in a
 * source for use in error messages.
 *
 * Printable ASCII is printed quoted, while other points are printed in Unicode
 * code point form (ie. U+1234).
 */ function printCodePointAt(lexer, location) {
    const code = lexer.source.body.codePointAt(location);
    if (code === undefined) {
        return _tokenKind.TokenKind.EOF;
    } else if (code >= 0x0020 && code <= 0x007e) {
        // Printable ASCII
        const char = String.fromCodePoint(code);
        return char === '"' ? "'\"'" : `"${char}"`;
    } // Unicode code point
    return "U+" + code.toString(16).toUpperCase().padStart(4, "0");
}
/**
 * Create a token with line and column location information.
 */ function createToken(lexer, kind, start, end, value) {
    const line = lexer.line;
    const col = 1 + start - lexer.lineStart;
    return new _ast.Token(kind, start, end, line, col, value);
}
/**
 * Gets the next token from the source starting at the given position.
 *
 * This skips over whitespace until it finds the next lexable token, then lexes
 * punctuators immediately or calls the appropriate helper function for more
 * complicated tokens.
 */ function readNextToken(lexer, start) {
    const body = lexer.source.body;
    const bodyLength = body.length;
    let position = start;
    while(position < bodyLength){
        const code = body.charCodeAt(position); // SourceCharacter
        switch(code){
            // Ignored ::
            //   - UnicodeBOM
            //   - WhiteSpace
            //   - LineTerminator
            //   - Comment
            //   - Comma
            //
            // UnicodeBOM :: "Byte Order Mark (U+FEFF)"
            //
            // WhiteSpace ::
            //   - "Horizontal Tab (U+0009)"
            //   - "Space (U+0020)"
            //
            // Comma :: ,
            case 0xfeff:
            case 0x0009:
            case 0x0020:
            case 0x002c:
                // ,
                ++position;
                continue;
            // LineTerminator ::
            //   - "New Line (U+000A)"
            //   - "Carriage Return (U+000D)" [lookahead != "New Line (U+000A)"]
            //   - "Carriage Return (U+000D)" "New Line (U+000A)"
            case 0x000a:
                // \n
                ++position;
                ++lexer.line;
                lexer.lineStart = position;
                continue;
            case 0x000d:
                // \r
                if (body.charCodeAt(position + 1) === 0x000a) {
                    position += 2;
                } else {
                    ++position;
                }
                ++lexer.line;
                lexer.lineStart = position;
                continue;
            // Comment
            case 0x0023:
                // #
                return readComment(lexer, position);
            // Token ::
            //   - Punctuator
            //   - Name
            //   - IntValue
            //   - FloatValue
            //   - StringValue
            //
            // Punctuator :: one of ! $ & ( ) ... : = @ [ ] { | }
            case 0x0021:
                // !
                return createToken(lexer, _tokenKind.TokenKind.BANG, position, position + 1);
            case 0x0024:
                // $
                return createToken(lexer, _tokenKind.TokenKind.DOLLAR, position, position + 1);
            case 0x0026:
                // &
                return createToken(lexer, _tokenKind.TokenKind.AMP, position, position + 1);
            case 0x0028:
                // (
                return createToken(lexer, _tokenKind.TokenKind.PAREN_L, position, position + 1);
            case 0x0029:
                // )
                return createToken(lexer, _tokenKind.TokenKind.PAREN_R, position, position + 1);
            case 0x002e:
                // .
                if (body.charCodeAt(position + 1) === 0x002e && body.charCodeAt(position + 2) === 0x002e) {
                    return createToken(lexer, _tokenKind.TokenKind.SPREAD, position, position + 3);
                }
                break;
            case 0x003a:
                // :
                return createToken(lexer, _tokenKind.TokenKind.COLON, position, position + 1);
            case 0x003d:
                // =
                return createToken(lexer, _tokenKind.TokenKind.EQUALS, position, position + 1);
            case 0x0040:
                // @
                return createToken(lexer, _tokenKind.TokenKind.AT, position, position + 1);
            case 0x005b:
                // [
                return createToken(lexer, _tokenKind.TokenKind.BRACKET_L, position, position + 1);
            case 0x005d:
                // ]
                return createToken(lexer, _tokenKind.TokenKind.BRACKET_R, position, position + 1);
            case 0x007b:
                // {
                return createToken(lexer, _tokenKind.TokenKind.BRACE_L, position, position + 1);
            case 0x007c:
                // |
                return createToken(lexer, _tokenKind.TokenKind.PIPE, position, position + 1);
            case 0x007d:
                // }
                return createToken(lexer, _tokenKind.TokenKind.BRACE_R, position, position + 1);
            // StringValue
            case 0x0022:
                // "
                if (body.charCodeAt(position + 1) === 0x0022 && body.charCodeAt(position + 2) === 0x0022) {
                    return readBlockString(lexer, position);
                }
                return readString(lexer, position);
        } // IntValue | FloatValue (Digit | -)
        if ((0, _characterClasses.isDigit)(code) || code === 0x002d) {
            return readNumber(lexer, position, code);
        } // Name
        if ((0, _characterClasses.isNameStart)(code)) {
            return readName(lexer, position);
        }
        throw (0, _syntaxError.syntaxError)(lexer.source, position, code === 0x0027 ? "Unexpected single quote character ('), did you mean to use a double quote (\")?" : isUnicodeScalarValue(code) || isSupplementaryCodePoint(body, position) ? `Unexpected character: ${printCodePointAt(lexer, position)}.` : `Invalid character: ${printCodePointAt(lexer, position)}.`);
    }
    return createToken(lexer, _tokenKind.TokenKind.EOF, bodyLength, bodyLength);
}
/**
 * Reads a comment token from the source file.
 *
 * ```
 * Comment :: # CommentChar* [lookahead != CommentChar]
 *
 * CommentChar :: SourceCharacter but not LineTerminator
 * ```
 */ function readComment(lexer, start) {
    const body = lexer.source.body;
    const bodyLength = body.length;
    let position = start + 1;
    while(position < bodyLength){
        const code = body.charCodeAt(position); // LineTerminator (\n | \r)
        if (code === 0x000a || code === 0x000d) {
            break;
        } // SourceCharacter
        if (isUnicodeScalarValue(code)) {
            ++position;
        } else if (isSupplementaryCodePoint(body, position)) {
            position += 2;
        } else {
            break;
        }
    }
    return createToken(lexer, _tokenKind.TokenKind.COMMENT, start, position, body.slice(start + 1, position));
}
/**
 * Reads a number token from the source file, either a FloatValue or an IntValue
 * depending on whether a FractionalPart or ExponentPart is encountered.
 *
 * ```
 * IntValue :: IntegerPart [lookahead != {Digit, `.`, NameStart}]
 *
 * IntegerPart ::
 *   - NegativeSign? 0
 *   - NegativeSign? NonZeroDigit Digit*
 *
 * NegativeSign :: -
 *
 * NonZeroDigit :: Digit but not `0`
 *
 * FloatValue ::
 *   - IntegerPart FractionalPart ExponentPart [lookahead != {Digit, `.`, NameStart}]
 *   - IntegerPart FractionalPart [lookahead != {Digit, `.`, NameStart}]
 *   - IntegerPart ExponentPart [lookahead != {Digit, `.`, NameStart}]
 *
 * FractionalPart :: . Digit+
 *
 * ExponentPart :: ExponentIndicator Sign? Digit+
 *
 * ExponentIndicator :: one of `e` `E`
 *
 * Sign :: one of + -
 * ```
 */ function readNumber(lexer, start, firstCode) {
    const body = lexer.source.body;
    let position = start;
    let code = firstCode;
    let isFloat = false; // NegativeSign (-)
    if (code === 0x002d) {
        code = body.charCodeAt(++position);
    } // Zero (0)
    if (code === 0x0030) {
        code = body.charCodeAt(++position);
        if ((0, _characterClasses.isDigit)(code)) {
            throw (0, _syntaxError.syntaxError)(lexer.source, position, `Invalid number, unexpected digit after 0: ${printCodePointAt(lexer, position)}.`);
        }
    } else {
        position = readDigits(lexer, position, code);
        code = body.charCodeAt(position);
    } // Full stop (.)
    if (code === 0x002e) {
        isFloat = true;
        code = body.charCodeAt(++position);
        position = readDigits(lexer, position, code);
        code = body.charCodeAt(position);
    } // E e
    if (code === 0x0045 || code === 0x0065) {
        isFloat = true;
        code = body.charCodeAt(++position); // + -
        if (code === 0x002b || code === 0x002d) {
            code = body.charCodeAt(++position);
        }
        position = readDigits(lexer, position, code);
        code = body.charCodeAt(position);
    } // Numbers cannot be followed by . or NameStart
    if (code === 0x002e || (0, _characterClasses.isNameStart)(code)) {
        throw (0, _syntaxError.syntaxError)(lexer.source, position, `Invalid number, expected digit but got: ${printCodePointAt(lexer, position)}.`);
    }
    return createToken(lexer, isFloat ? _tokenKind.TokenKind.FLOAT : _tokenKind.TokenKind.INT, start, position, body.slice(start, position));
}
/**
 * Returns the new position in the source after reading one or more digits.
 */ function readDigits(lexer, start, firstCode) {
    if (!(0, _characterClasses.isDigit)(firstCode)) {
        throw (0, _syntaxError.syntaxError)(lexer.source, start, `Invalid number, expected digit but got: ${printCodePointAt(lexer, start)}.`);
    }
    const body = lexer.source.body;
    let position = start + 1; // +1 to skip first firstCode
    while((0, _characterClasses.isDigit)(body.charCodeAt(position))){
        ++position;
    }
    return position;
}
/**
 * Reads a single-quote string token from the source file.
 *
 * ```
 * StringValue ::
 *   - `""` [lookahead != `"`]
 *   - `"` StringCharacter+ `"`
 *
 * StringCharacter ::
 *   - SourceCharacter but not `"` or `\` or LineTerminator
 *   - `\u` EscapedUnicode
 *   - `\` EscapedCharacter
 *
 * EscapedUnicode ::
 *   - `{` HexDigit+ `}`
 *   - HexDigit HexDigit HexDigit HexDigit
 *
 * EscapedCharacter :: one of `"` `\` `/` `b` `f` `n` `r` `t`
 * ```
 */ function readString(lexer, start) {
    const body = lexer.source.body;
    const bodyLength = body.length;
    let position = start + 1;
    let chunkStart = position;
    let value = "";
    while(position < bodyLength){
        const code = body.charCodeAt(position); // Closing Quote (")
        if (code === 0x0022) {
            value += body.slice(chunkStart, position);
            return createToken(lexer, _tokenKind.TokenKind.STRING, start, position + 1, value);
        } // Escape Sequence (\)
        if (code === 0x005c) {
            value += body.slice(chunkStart, position);
            const escape = body.charCodeAt(position + 1) === 0x0075 // u
             ? body.charCodeAt(position + 2) === 0x007b // {
             ? readEscapedUnicodeVariableWidth(lexer, position) : readEscapedUnicodeFixedWidth(lexer, position) : readEscapedCharacter(lexer, position);
            value += escape.value;
            position += escape.size;
            chunkStart = position;
            continue;
        } // LineTerminator (\n | \r)
        if (code === 0x000a || code === 0x000d) {
            break;
        } // SourceCharacter
        if (isUnicodeScalarValue(code)) {
            ++position;
        } else if (isSupplementaryCodePoint(body, position)) {
            position += 2;
        } else {
            throw (0, _syntaxError.syntaxError)(lexer.source, position, `Invalid character within String: ${printCodePointAt(lexer, position)}.`);
        }
    }
    throw (0, _syntaxError.syntaxError)(lexer.source, position, "Unterminated string.");
} // The string value and lexed size of an escape sequence.
function readEscapedUnicodeVariableWidth(lexer, position) {
    const body = lexer.source.body;
    let point = 0;
    let size = 3; // Cannot be larger than 12 chars (\u{00000000}).
    while(size < 12){
        const code = body.charCodeAt(position + size++); // Closing Brace (})
        if (code === 0x007d) {
            // Must be at least 5 chars (\u{0}) and encode a Unicode scalar value.
            if (size < 5 || !isUnicodeScalarValue(point)) {
                break;
            }
            return {
                value: String.fromCodePoint(point),
                size
            };
        } // Append this hex digit to the code point.
        point = point << 4 | readHexDigit(code);
        if (point < 0) {
            break;
        }
    }
    throw (0, _syntaxError.syntaxError)(lexer.source, position, `Invalid Unicode escape sequence: "${body.slice(position, position + size)}".`);
}
function readEscapedUnicodeFixedWidth(lexer, position) {
    const body = lexer.source.body;
    const code = read16BitHexCode(body, position + 2);
    if (isUnicodeScalarValue(code)) {
        return {
            value: String.fromCodePoint(code),
            size: 6
        };
    } // GraphQL allows JSON-style surrogate pair escape sequences, but only when
    // a valid pair is formed.
    if (isLeadingSurrogate(code)) {
        // \u
        if (body.charCodeAt(position + 6) === 0x005c && body.charCodeAt(position + 7) === 0x0075) {
            const trailingCode = read16BitHexCode(body, position + 8);
            if (isTrailingSurrogate(trailingCode)) {
                // JavaScript defines strings as a sequence of UTF-16 code units and
                // encodes Unicode code points above U+FFFF using a surrogate pair of
                // code units. Since this is a surrogate pair escape sequence, just
                // include both codes into the JavaScript string value. Had JavaScript
                // not been internally based on UTF-16, then this surrogate pair would
                // be decoded to retrieve the supplementary code point.
                return {
                    value: String.fromCodePoint(code, trailingCode),
                    size: 12
                };
            }
        }
    }
    throw (0, _syntaxError.syntaxError)(lexer.source, position, `Invalid Unicode escape sequence: "${body.slice(position, position + 6)}".`);
}
/**
 * Reads four hexadecimal characters and returns the positive integer that 16bit
 * hexadecimal string represents. For example, "000f" will return 15, and "dead"
 * will return 57005.
 *
 * Returns a negative number if any char was not a valid hexadecimal digit.
 */ function read16BitHexCode(body, position) {
    // readHexDigit() returns -1 on error. ORing a negative value with any other
    // value always produces a negative value.
    return readHexDigit(body.charCodeAt(position)) << 12 | readHexDigit(body.charCodeAt(position + 1)) << 8 | readHexDigit(body.charCodeAt(position + 2)) << 4 | readHexDigit(body.charCodeAt(position + 3));
}
/**
 * Reads a hexadecimal character and returns its positive integer value (0-15).
 *
 * '0' becomes 0, '9' becomes 9
 * 'A' becomes 10, 'F' becomes 15
 * 'a' becomes 10, 'f' becomes 15
 *
 * Returns -1 if the provided character code was not a valid hexadecimal digit.
 *
 * HexDigit :: one of
 *   - `0` `1` `2` `3` `4` `5` `6` `7` `8` `9`
 *   - `A` `B` `C` `D` `E` `F`
 *   - `a` `b` `c` `d` `e` `f`
 */ function readHexDigit(code) {
    return code >= 0x0030 && code <= 0x0039 // 0-9
     ? code - 0x0030 : code >= 0x0041 && code <= 0x0046 // A-F
     ? code - 0x0037 : code >= 0x0061 && code <= 0x0066 // a-f
     ? code - 0x0057 : -1;
}
/**
 * | Escaped Character | Code Point | Character Name               |
 * | ----------------- | ---------- | ---------------------------- |
 * | `"`               | U+0022     | double quote                 |
 * | `\`               | U+005C     | reverse solidus (back slash) |
 * | `/`               | U+002F     | solidus (forward slash)      |
 * | `b`               | U+0008     | backspace                    |
 * | `f`               | U+000C     | form feed                    |
 * | `n`               | U+000A     | line feed (new line)         |
 * | `r`               | U+000D     | carriage return              |
 * | `t`               | U+0009     | horizontal tab               |
 */ function readEscapedCharacter(lexer, position) {
    const body = lexer.source.body;
    const code = body.charCodeAt(position + 1);
    switch(code){
        case 0x0022:
            // "
            return {
                value: '"',
                size: 2
            };
        case 0x005c:
            // \
            return {
                value: "\\",
                size: 2
            };
        case 0x002f:
            // /
            return {
                value: "/",
                size: 2
            };
        case 0x0062:
            // b
            return {
                value: "\b",
                size: 2
            };
        case 0x0066:
            // f
            return {
                value: "\f",
                size: 2
            };
        case 0x006e:
            // n
            return {
                value: "\n",
                size: 2
            };
        case 0x0072:
            // r
            return {
                value: "\r",
                size: 2
            };
        case 0x0074:
            // t
            return {
                value: "	",
                size: 2
            };
    }
    throw (0, _syntaxError.syntaxError)(lexer.source, position, `Invalid character escape sequence: "${body.slice(position, position + 2)}".`);
}
/**
 * Reads a block string token from the source file.
 *
 * ```
 * StringValue ::
 *   - `"""` BlockStringCharacter* `"""`
 *
 * BlockStringCharacter ::
 *   - SourceCharacter but not `"""` or `\"""`
 *   - `\"""`
 * ```
 */ function readBlockString(lexer, start) {
    const body = lexer.source.body;
    const bodyLength = body.length;
    let lineStart = lexer.lineStart;
    let position = start + 3;
    let chunkStart = position;
    let currentLine = "";
    const blockLines = [];
    while(position < bodyLength){
        const code = body.charCodeAt(position); // Closing Triple-Quote (""")
        if (code === 0x0022 && body.charCodeAt(position + 1) === 0x0022 && body.charCodeAt(position + 2) === 0x0022) {
            currentLine += body.slice(chunkStart, position);
            blockLines.push(currentLine);
            const token = createToken(lexer, _tokenKind.TokenKind.BLOCK_STRING, start, position + 3, (0, _blockString.dedentBlockStringLines)(blockLines).join("\n"));
            lexer.line += blockLines.length - 1;
            lexer.lineStart = lineStart;
            return token;
        } // Escaped Triple-Quote (\""")
        if (code === 0x005c && body.charCodeAt(position + 1) === 0x0022 && body.charCodeAt(position + 2) === 0x0022 && body.charCodeAt(position + 3) === 0x0022) {
            currentLine += body.slice(chunkStart, position);
            chunkStart = position + 1; // skip only slash
            position += 4;
            continue;
        } // LineTerminator
        if (code === 0x000a || code === 0x000d) {
            currentLine += body.slice(chunkStart, position);
            blockLines.push(currentLine);
            if (code === 0x000d && body.charCodeAt(position + 1) === 0x000a) {
                position += 2;
            } else {
                ++position;
            }
            currentLine = "";
            chunkStart = position;
            lineStart = position;
            continue;
        } // SourceCharacter
        if (isUnicodeScalarValue(code)) {
            ++position;
        } else if (isSupplementaryCodePoint(body, position)) {
            position += 2;
        } else {
            throw (0, _syntaxError.syntaxError)(lexer.source, position, `Invalid character within String: ${printCodePointAt(lexer, position)}.`);
        }
    }
    throw (0, _syntaxError.syntaxError)(lexer.source, position, "Unterminated string.");
}
/**
 * Reads an alphanumeric + underscore name from the source.
 *
 * ```
 * Name ::
 *   - NameStart NameContinue* [lookahead != NameContinue]
 * ```
 */ function readName(lexer, start) {
    const body = lexer.source.body;
    const bodyLength = body.length;
    let position = start + 1;
    while(position < bodyLength){
        const code = body.charCodeAt(position);
        if ((0, _characterClasses.isNameContinue)(code)) {
            ++position;
        } else {
            break;
        }
    }
    return createToken(lexer, _tokenKind.TokenKind.NAME, start, position, body.slice(start, position));
}


/***/ }),

/***/ 8140:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getLocation = getLocation;
var _invariant = __webpack_require__(5210);
const LineRegExp = /\r\n|[\n\r]/g;
/**
 * Represents a location in a Source.
 */ /**
 * Takes a Source and a UTF-8 character offset, and returns the corresponding
 * line and column as a SourceLocation.
 */ function getLocation(source, position) {
    let lastLineStart = 0;
    let line = 1;
    for (const match of source.body.matchAll(LineRegExp)){
        typeof match.index === "number" || (0, _invariant.invariant)(false);
        if (match.index >= position) {
            break;
        }
        lastLineStart = match.index + match[0].length;
        line += 1;
    }
    return {
        line,
        column: position + 1 - lastLineStart
    };
}


/***/ }),

/***/ 8208:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.Parser = void 0;
exports.parse = parse;
exports.parseConstValue = parseConstValue;
exports.parseType = parseType;
exports.parseValue = parseValue;
var _syntaxError = __webpack_require__(4466);
var _ast = __webpack_require__(9344);
var _directiveLocation = __webpack_require__(7936);
var _kinds = __webpack_require__(5923);
var _lexer = __webpack_require__(8225);
var _source = __webpack_require__(8509);
var _tokenKind = __webpack_require__(8845);
/**
 * Given a GraphQL source, parses it into a Document.
 * Throws GraphQLError if a syntax error is encountered.
 */ function parse(source, options) {
    const parser = new Parser(source, options);
    return parser.parseDocument();
}
/**
 * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for
 * that value.
 * Throws GraphQLError if a syntax error is encountered.
 *
 * This is useful within tools that operate upon GraphQL Values directly and
 * in isolation of complete GraphQL documents.
 *
 * Consider providing the results to the utility function: valueFromAST().
 */ function parseValue(source, options) {
    const parser = new Parser(source, options);
    parser.expectToken(_tokenKind.TokenKind.SOF);
    const value = parser.parseValueLiteral(false);
    parser.expectToken(_tokenKind.TokenKind.EOF);
    return value;
}
/**
 * Similar to parseValue(), but raises a parse error if it encounters a
 * variable. The return type will be a constant value.
 */ function parseConstValue(source, options) {
    const parser = new Parser(source, options);
    parser.expectToken(_tokenKind.TokenKind.SOF);
    const value = parser.parseConstValueLiteral();
    parser.expectToken(_tokenKind.TokenKind.EOF);
    return value;
}
/**
 * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for
 * that type.
 * Throws GraphQLError if a syntax error is encountered.
 *
 * This is useful within tools that operate upon GraphQL Types directly and
 * in isolation of complete GraphQL documents.
 *
 * Consider providing the results to the utility function: typeFromAST().
 */ function parseType(source, options) {
    const parser = new Parser(source, options);
    parser.expectToken(_tokenKind.TokenKind.SOF);
    const type = parser.parseTypeReference();
    parser.expectToken(_tokenKind.TokenKind.EOF);
    return type;
}
/**
 * This class is exported only to assist people in implementing their own parsers
 * without duplicating too much code and should be used only as last resort for cases
 * such as experimental syntax or if certain features could not be contributed upstream.
 *
 * It is still part of the internal API and is versioned, so any changes to it are never
 * considered breaking changes. If you still need to support multiple versions of the
 * library, please use the `versionInfo` variable for version detection.
 *
 * @internal
 */ class Parser {
    constructor(source, options = {}){
        const sourceObj = (0, _source.isSource)(source) ? source : new _source.Source(source);
        this._lexer = new _lexer.Lexer(sourceObj);
        this._options = options;
        this._tokenCounter = 0;
    }
    /**
   * Converts a name lex token into a name parse node.
   */ parseName() {
        const token = this.expectToken(_tokenKind.TokenKind.NAME);
        return this.node(token, {
            kind: _kinds.Kind.NAME,
            value: token.value
        });
    }
    /**
   * Document : Definition+
   */ parseDocument() {
        return this.node(this._lexer.token, {
            kind: _kinds.Kind.DOCUMENT,
            definitions: this.many(_tokenKind.TokenKind.SOF, this.parseDefinition, _tokenKind.TokenKind.EOF)
        });
    }
    /**
   * Definition :
   *   - ExecutableDefinition
   *   - TypeSystemDefinition
   *   - TypeSystemExtension
   *
   * ExecutableDefinition :
   *   - OperationDefinition
   *   - FragmentDefinition
   *
   * TypeSystemDefinition :
   *   - SchemaDefinition
   *   - TypeDefinition
   *   - DirectiveDefinition
   *
   * TypeDefinition :
   *   - ScalarTypeDefinition
   *   - ObjectTypeDefinition
   *   - InterfaceTypeDefinition
   *   - UnionTypeDefinition
   *   - EnumTypeDefinition
   *   - InputObjectTypeDefinition
   */ parseDefinition() {
        if (this.peek(_tokenKind.TokenKind.BRACE_L)) {
            return this.parseOperationDefinition();
        } // Many definitions begin with a description and require a lookahead.
        const hasDescription = this.peekDescription();
        const keywordToken = hasDescription ? this._lexer.lookahead() : this._lexer.token;
        if (keywordToken.kind === _tokenKind.TokenKind.NAME) {
            switch(keywordToken.value){
                case "schema":
                    return this.parseSchemaDefinition();
                case "scalar":
                    return this.parseScalarTypeDefinition();
                case "type":
                    return this.parseObjectTypeDefinition();
                case "interface":
                    return this.parseInterfaceTypeDefinition();
                case "union":
                    return this.parseUnionTypeDefinition();
                case "enum":
                    return this.parseEnumTypeDefinition();
                case "input":
                    return this.parseInputObjectTypeDefinition();
                case "directive":
                    return this.parseDirectiveDefinition();
            }
            if (hasDescription) {
                throw (0, _syntaxError.syntaxError)(this._lexer.source, this._lexer.token.start, "Unexpected description, descriptions are supported only on type definitions.");
            }
            switch(keywordToken.value){
                case "query":
                case "mutation":
                case "subscription":
                    return this.parseOperationDefinition();
                case "fragment":
                    return this.parseFragmentDefinition();
                case "extend":
                    return this.parseTypeSystemExtension();
            }
        }
        throw this.unexpected(keywordToken);
    }
    /**
   * OperationDefinition :
   *  - SelectionSet
   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet
   */ parseOperationDefinition() {
        const start = this._lexer.token;
        if (this.peek(_tokenKind.TokenKind.BRACE_L)) {
            return this.node(start, {
                kind: _kinds.Kind.OPERATION_DEFINITION,
                operation: _ast.OperationTypeNode.QUERY,
                name: undefined,
                variableDefinitions: [],
                directives: [],
                selectionSet: this.parseSelectionSet()
            });
        }
        const operation = this.parseOperationType();
        let name;
        if (this.peek(_tokenKind.TokenKind.NAME)) {
            name = this.parseName();
        }
        return this.node(start, {
            kind: _kinds.Kind.OPERATION_DEFINITION,
            operation,
            name,
            variableDefinitions: this.parseVariableDefinitions(),
            directives: this.parseDirectives(false),
            selectionSet: this.parseSelectionSet()
        });
    }
    /**
   * OperationType : one of query mutation subscription
   */ parseOperationType() {
        const operationToken = this.expectToken(_tokenKind.TokenKind.NAME);
        switch(operationToken.value){
            case "query":
                return _ast.OperationTypeNode.QUERY;
            case "mutation":
                return _ast.OperationTypeNode.MUTATION;
            case "subscription":
                return _ast.OperationTypeNode.SUBSCRIPTION;
        }
        throw this.unexpected(operationToken);
    }
    /**
   * VariableDefinitions : ( VariableDefinition+ )
   */ parseVariableDefinitions() {
        return this.optionalMany(_tokenKind.TokenKind.PAREN_L, this.parseVariableDefinition, _tokenKind.TokenKind.PAREN_R);
    }
    /**
   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?
   */ parseVariableDefinition() {
        return this.node(this._lexer.token, {
            kind: _kinds.Kind.VARIABLE_DEFINITION,
            variable: this.parseVariable(),
            type: (this.expectToken(_tokenKind.TokenKind.COLON), this.parseTypeReference()),
            defaultValue: this.expectOptionalToken(_tokenKind.TokenKind.EQUALS) ? this.parseConstValueLiteral() : undefined,
            directives: this.parseConstDirectives()
        });
    }
    /**
   * Variable : $ Name
   */ parseVariable() {
        const start = this._lexer.token;
        this.expectToken(_tokenKind.TokenKind.DOLLAR);
        return this.node(start, {
            kind: _kinds.Kind.VARIABLE,
            name: this.parseName()
        });
    }
    /**
   * ```
   * SelectionSet : { Selection+ }
   * ```
   */ parseSelectionSet() {
        return this.node(this._lexer.token, {
            kind: _kinds.Kind.SELECTION_SET,
            selections: this.many(_tokenKind.TokenKind.BRACE_L, this.parseSelection, _tokenKind.TokenKind.BRACE_R)
        });
    }
    /**
   * Selection :
   *   - Field
   *   - FragmentSpread
   *   - InlineFragment
   */ parseSelection() {
        return this.peek(_tokenKind.TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
    }
    /**
   * Field : Alias? Name Arguments? Directives? SelectionSet?
   *
   * Alias : Name :
   */ parseField() {
        const start = this._lexer.token;
        const nameOrAlias = this.parseName();
        let alias;
        let name;
        if (this.expectOptionalToken(_tokenKind.TokenKind.COLON)) {
            alias = nameOrAlias;
            name = this.parseName();
        } else {
            name = nameOrAlias;
        }
        return this.node(start, {
            kind: _kinds.Kind.FIELD,
            alias,
            name,
            arguments: this.parseArguments(false),
            directives: this.parseDirectives(false),
            selectionSet: this.peek(_tokenKind.TokenKind.BRACE_L) ? this.parseSelectionSet() : undefined
        });
    }
    /**
   * Arguments[Const] : ( Argument[?Const]+ )
   */ parseArguments(isConst) {
        const item = isConst ? this.parseConstArgument : this.parseArgument;
        return this.optionalMany(_tokenKind.TokenKind.PAREN_L, item, _tokenKind.TokenKind.PAREN_R);
    }
    /**
   * Argument[Const] : Name : Value[?Const]
   */ parseArgument(isConst = false) {
        const start = this._lexer.token;
        const name = this.parseName();
        this.expectToken(_tokenKind.TokenKind.COLON);
        return this.node(start, {
            kind: _kinds.Kind.ARGUMENT,
            name,
            value: this.parseValueLiteral(isConst)
        });
    }
    parseConstArgument() {
        return this.parseArgument(true);
    }
    /**
   * Corresponds to both FragmentSpread and InlineFragment in the spec.
   *
   * FragmentSpread : ... FragmentName Directives?
   *
   * InlineFragment : ... TypeCondition? Directives? SelectionSet
   */ parseFragment() {
        const start = this._lexer.token;
        this.expectToken(_tokenKind.TokenKind.SPREAD);
        const hasTypeCondition = this.expectOptionalKeyword("on");
        if (!hasTypeCondition && this.peek(_tokenKind.TokenKind.NAME)) {
            return this.node(start, {
                kind: _kinds.Kind.FRAGMENT_SPREAD,
                name: this.parseFragmentName(),
                directives: this.parseDirectives(false)
            });
        }
        return this.node(start, {
            kind: _kinds.Kind.INLINE_FRAGMENT,
            typeCondition: hasTypeCondition ? this.parseNamedType() : undefined,
            directives: this.parseDirectives(false),
            selectionSet: this.parseSelectionSet()
        });
    }
    /**
   * FragmentDefinition :
   *   - fragment FragmentName on TypeCondition Directives? SelectionSet
   *
   * TypeCondition : NamedType
   */ parseFragmentDefinition() {
        const start = this._lexer.token;
        this.expectKeyword("fragment"); // Legacy support for defining variables within fragments changes
        // the grammar of FragmentDefinition:
        //   - fragment FragmentName VariableDefinitions? on TypeCondition Directives? SelectionSet
        if (this._options.allowLegacyFragmentVariables === true) {
            return this.node(start, {
                kind: _kinds.Kind.FRAGMENT_DEFINITION,
                name: this.parseFragmentName(),
                variableDefinitions: this.parseVariableDefinitions(),
                typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
                directives: this.parseDirectives(false),
                selectionSet: this.parseSelectionSet()
            });
        }
        return this.node(start, {
            kind: _kinds.Kind.FRAGMENT_DEFINITION,
            name: this.parseFragmentName(),
            typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
            directives: this.parseDirectives(false),
            selectionSet: this.parseSelectionSet()
        });
    }
    /**
   * FragmentName : Name but not `on`
   */ parseFragmentName() {
        if (this._lexer.token.value === "on") {
            throw this.unexpected();
        }
        return this.parseName();
    }
    /**
   * Value[Const] :
   *   - [~Const] Variable
   *   - IntValue
   *   - FloatValue
   *   - StringValue
   *   - BooleanValue
   *   - NullValue
   *   - EnumValue
   *   - ListValue[?Const]
   *   - ObjectValue[?Const]
   *
   * BooleanValue : one of `true` `false`
   *
   * NullValue : `null`
   *
   * EnumValue : Name but not `true`, `false` or `null`
   */ parseValueLiteral(isConst) {
        const token = this._lexer.token;
        switch(token.kind){
            case _tokenKind.TokenKind.BRACKET_L:
                return this.parseList(isConst);
            case _tokenKind.TokenKind.BRACE_L:
                return this.parseObject(isConst);
            case _tokenKind.TokenKind.INT:
                this.advanceLexer();
                return this.node(token, {
                    kind: _kinds.Kind.INT,
                    value: token.value
                });
            case _tokenKind.TokenKind.FLOAT:
                this.advanceLexer();
                return this.node(token, {
                    kind: _kinds.Kind.FLOAT,
                    value: token.value
                });
            case _tokenKind.TokenKind.STRING:
            case _tokenKind.TokenKind.BLOCK_STRING:
                return this.parseStringLiteral();
            case _tokenKind.TokenKind.NAME:
                this.advanceLexer();
                switch(token.value){
                    case "true":
                        return this.node(token, {
                            kind: _kinds.Kind.BOOLEAN,
                            value: true
                        });
                    case "false":
                        return this.node(token, {
                            kind: _kinds.Kind.BOOLEAN,
                            value: false
                        });
                    case "null":
                        return this.node(token, {
                            kind: _kinds.Kind.NULL
                        });
                    default:
                        return this.node(token, {
                            kind: _kinds.Kind.ENUM,
                            value: token.value
                        });
                }
            case _tokenKind.TokenKind.DOLLAR:
                if (isConst) {
                    this.expectToken(_tokenKind.TokenKind.DOLLAR);
                    if (this._lexer.token.kind === _tokenKind.TokenKind.NAME) {
                        const varName = this._lexer.token.value;
                        throw (0, _syntaxError.syntaxError)(this._lexer.source, token.start, `Unexpected variable "$${varName}" in constant value.`);
                    } else {
                        throw this.unexpected(token);
                    }
                }
                return this.parseVariable();
            default:
                throw this.unexpected();
        }
    }
    parseConstValueLiteral() {
        return this.parseValueLiteral(true);
    }
    parseStringLiteral() {
        const token = this._lexer.token;
        this.advanceLexer();
        return this.node(token, {
            kind: _kinds.Kind.STRING,
            value: token.value,
            block: token.kind === _tokenKind.TokenKind.BLOCK_STRING
        });
    }
    /**
   * ListValue[Const] :
   *   - [ ]
   *   - [ Value[?Const]+ ]
   */ parseList(isConst) {
        const item = ()=>this.parseValueLiteral(isConst);
        return this.node(this._lexer.token, {
            kind: _kinds.Kind.LIST,
            values: this.any(_tokenKind.TokenKind.BRACKET_L, item, _tokenKind.TokenKind.BRACKET_R)
        });
    }
    /**
   * ```
   * ObjectValue[Const] :
   *   - { }
   *   - { ObjectField[?Const]+ }
   * ```
   */ parseObject(isConst) {
        const item = ()=>this.parseObjectField(isConst);
        return this.node(this._lexer.token, {
            kind: _kinds.Kind.OBJECT,
            fields: this.any(_tokenKind.TokenKind.BRACE_L, item, _tokenKind.TokenKind.BRACE_R)
        });
    }
    /**
   * ObjectField[Const] : Name : Value[?Const]
   */ parseObjectField(isConst) {
        const start = this._lexer.token;
        const name = this.parseName();
        this.expectToken(_tokenKind.TokenKind.COLON);
        return this.node(start, {
            kind: _kinds.Kind.OBJECT_FIELD,
            name,
            value: this.parseValueLiteral(isConst)
        });
    }
    /**
   * Directives[Const] : Directive[?Const]+
   */ parseDirectives(isConst) {
        const directives = [];
        while(this.peek(_tokenKind.TokenKind.AT)){
            directives.push(this.parseDirective(isConst));
        }
        return directives;
    }
    parseConstDirectives() {
        return this.parseDirectives(true);
    }
    /**
   * ```
   * Directive[Const] : @ Name Arguments[?Const]?
   * ```
   */ parseDirective(isConst) {
        const start = this._lexer.token;
        this.expectToken(_tokenKind.TokenKind.AT);
        return this.node(start, {
            kind: _kinds.Kind.DIRECTIVE,
            name: this.parseName(),
            arguments: this.parseArguments(isConst)
        });
    }
    /**
   * Type :
   *   - NamedType
   *   - ListType
   *   - NonNullType
   */ parseTypeReference() {
        const start = this._lexer.token;
        let type;
        if (this.expectOptionalToken(_tokenKind.TokenKind.BRACKET_L)) {
            const innerType = this.parseTypeReference();
            this.expectToken(_tokenKind.TokenKind.BRACKET_R);
            type = this.node(start, {
                kind: _kinds.Kind.LIST_TYPE,
                type: innerType
            });
        } else {
            type = this.parseNamedType();
        }
        if (this.expectOptionalToken(_tokenKind.TokenKind.BANG)) {
            return this.node(start, {
                kind: _kinds.Kind.NON_NULL_TYPE,
                type
            });
        }
        return type;
    }
    /**
   * NamedType : Name
   */ parseNamedType() {
        return this.node(this._lexer.token, {
            kind: _kinds.Kind.NAMED_TYPE,
            name: this.parseName()
        });
    }
    peekDescription() {
        return this.peek(_tokenKind.TokenKind.STRING) || this.peek(_tokenKind.TokenKind.BLOCK_STRING);
    }
    /**
   * Description : StringValue
   */ parseDescription() {
        if (this.peekDescription()) {
            return this.parseStringLiteral();
        }
    }
    /**
   * ```
   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }
   * ```
   */ parseSchemaDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("schema");
        const directives = this.parseConstDirectives();
        const operationTypes = this.many(_tokenKind.TokenKind.BRACE_L, this.parseOperationTypeDefinition, _tokenKind.TokenKind.BRACE_R);
        return this.node(start, {
            kind: _kinds.Kind.SCHEMA_DEFINITION,
            description,
            directives,
            operationTypes
        });
    }
    /**
   * OperationTypeDefinition : OperationType : NamedType
   */ parseOperationTypeDefinition() {
        const start = this._lexer.token;
        const operation = this.parseOperationType();
        this.expectToken(_tokenKind.TokenKind.COLON);
        const type = this.parseNamedType();
        return this.node(start, {
            kind: _kinds.Kind.OPERATION_TYPE_DEFINITION,
            operation,
            type
        });
    }
    /**
   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?
   */ parseScalarTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("scalar");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        return this.node(start, {
            kind: _kinds.Kind.SCALAR_TYPE_DEFINITION,
            description,
            name,
            directives
        });
    }
    /**
   * ObjectTypeDefinition :
   *   Description?
   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?
   */ parseObjectTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("type");
        const name = this.parseName();
        const interfaces = this.parseImplementsInterfaces();
        const directives = this.parseConstDirectives();
        const fields = this.parseFieldsDefinition();
        return this.node(start, {
            kind: _kinds.Kind.OBJECT_TYPE_DEFINITION,
            description,
            name,
            interfaces,
            directives,
            fields
        });
    }
    /**
   * ImplementsInterfaces :
   *   - implements `&`? NamedType
   *   - ImplementsInterfaces & NamedType
   */ parseImplementsInterfaces() {
        return this.expectOptionalKeyword("implements") ? this.delimitedMany(_tokenKind.TokenKind.AMP, this.parseNamedType) : [];
    }
    /**
   * ```
   * FieldsDefinition : { FieldDefinition+ }
   * ```
   */ parseFieldsDefinition() {
        return this.optionalMany(_tokenKind.TokenKind.BRACE_L, this.parseFieldDefinition, _tokenKind.TokenKind.BRACE_R);
    }
    /**
   * FieldDefinition :
   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?
   */ parseFieldDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        const name = this.parseName();
        const args = this.parseArgumentDefs();
        this.expectToken(_tokenKind.TokenKind.COLON);
        const type = this.parseTypeReference();
        const directives = this.parseConstDirectives();
        return this.node(start, {
            kind: _kinds.Kind.FIELD_DEFINITION,
            description,
            name,
            arguments: args,
            type,
            directives
        });
    }
    /**
   * ArgumentsDefinition : ( InputValueDefinition+ )
   */ parseArgumentDefs() {
        return this.optionalMany(_tokenKind.TokenKind.PAREN_L, this.parseInputValueDef, _tokenKind.TokenKind.PAREN_R);
    }
    /**
   * InputValueDefinition :
   *   - Description? Name : Type DefaultValue? Directives[Const]?
   */ parseInputValueDef() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        const name = this.parseName();
        this.expectToken(_tokenKind.TokenKind.COLON);
        const type = this.parseTypeReference();
        let defaultValue;
        if (this.expectOptionalToken(_tokenKind.TokenKind.EQUALS)) {
            defaultValue = this.parseConstValueLiteral();
        }
        const directives = this.parseConstDirectives();
        return this.node(start, {
            kind: _kinds.Kind.INPUT_VALUE_DEFINITION,
            description,
            name,
            type,
            defaultValue,
            directives
        });
    }
    /**
   * InterfaceTypeDefinition :
   *   - Description? interface Name Directives[Const]? FieldsDefinition?
   */ parseInterfaceTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("interface");
        const name = this.parseName();
        const interfaces = this.parseImplementsInterfaces();
        const directives = this.parseConstDirectives();
        const fields = this.parseFieldsDefinition();
        return this.node(start, {
            kind: _kinds.Kind.INTERFACE_TYPE_DEFINITION,
            description,
            name,
            interfaces,
            directives,
            fields
        });
    }
    /**
   * UnionTypeDefinition :
   *   - Description? union Name Directives[Const]? UnionMemberTypes?
   */ parseUnionTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("union");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const types = this.parseUnionMemberTypes();
        return this.node(start, {
            kind: _kinds.Kind.UNION_TYPE_DEFINITION,
            description,
            name,
            directives,
            types
        });
    }
    /**
   * UnionMemberTypes :
   *   - = `|`? NamedType
   *   - UnionMemberTypes | NamedType
   */ parseUnionMemberTypes() {
        return this.expectOptionalToken(_tokenKind.TokenKind.EQUALS) ? this.delimitedMany(_tokenKind.TokenKind.PIPE, this.parseNamedType) : [];
    }
    /**
   * EnumTypeDefinition :
   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?
   */ parseEnumTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("enum");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const values = this.parseEnumValuesDefinition();
        return this.node(start, {
            kind: _kinds.Kind.ENUM_TYPE_DEFINITION,
            description,
            name,
            directives,
            values
        });
    }
    /**
   * ```
   * EnumValuesDefinition : { EnumValueDefinition+ }
   * ```
   */ parseEnumValuesDefinition() {
        return this.optionalMany(_tokenKind.TokenKind.BRACE_L, this.parseEnumValueDefinition, _tokenKind.TokenKind.BRACE_R);
    }
    /**
   * EnumValueDefinition : Description? EnumValue Directives[Const]?
   */ parseEnumValueDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        const name = this.parseEnumValueName();
        const directives = this.parseConstDirectives();
        return this.node(start, {
            kind: _kinds.Kind.ENUM_VALUE_DEFINITION,
            description,
            name,
            directives
        });
    }
    /**
   * EnumValue : Name but not `true`, `false` or `null`
   */ parseEnumValueName() {
        if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null") {
            throw (0, _syntaxError.syntaxError)(this._lexer.source, this._lexer.token.start, `${getTokenDesc(this._lexer.token)} is reserved and cannot be used for an enum value.`);
        }
        return this.parseName();
    }
    /**
   * InputObjectTypeDefinition :
   *   - Description? input Name Directives[Const]? InputFieldsDefinition?
   */ parseInputObjectTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("input");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const fields = this.parseInputFieldsDefinition();
        return this.node(start, {
            kind: _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION,
            description,
            name,
            directives,
            fields
        });
    }
    /**
   * ```
   * InputFieldsDefinition : { InputValueDefinition+ }
   * ```
   */ parseInputFieldsDefinition() {
        return this.optionalMany(_tokenKind.TokenKind.BRACE_L, this.parseInputValueDef, _tokenKind.TokenKind.BRACE_R);
    }
    /**
   * TypeSystemExtension :
   *   - SchemaExtension
   *   - TypeExtension
   *
   * TypeExtension :
   *   - ScalarTypeExtension
   *   - ObjectTypeExtension
   *   - InterfaceTypeExtension
   *   - UnionTypeExtension
   *   - EnumTypeExtension
   *   - InputObjectTypeDefinition
   */ parseTypeSystemExtension() {
        const keywordToken = this._lexer.lookahead();
        if (keywordToken.kind === _tokenKind.TokenKind.NAME) {
            switch(keywordToken.value){
                case "schema":
                    return this.parseSchemaExtension();
                case "scalar":
                    return this.parseScalarTypeExtension();
                case "type":
                    return this.parseObjectTypeExtension();
                case "interface":
                    return this.parseInterfaceTypeExtension();
                case "union":
                    return this.parseUnionTypeExtension();
                case "enum":
                    return this.parseEnumTypeExtension();
                case "input":
                    return this.parseInputObjectTypeExtension();
            }
        }
        throw this.unexpected(keywordToken);
    }
    /**
   * ```
   * SchemaExtension :
   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }
   *  - extend schema Directives[Const]
   * ```
   */ parseSchemaExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("schema");
        const directives = this.parseConstDirectives();
        const operationTypes = this.optionalMany(_tokenKind.TokenKind.BRACE_L, this.parseOperationTypeDefinition, _tokenKind.TokenKind.BRACE_R);
        if (directives.length === 0 && operationTypes.length === 0) {
            throw this.unexpected();
        }
        return this.node(start, {
            kind: _kinds.Kind.SCHEMA_EXTENSION,
            directives,
            operationTypes
        });
    }
    /**
   * ScalarTypeExtension :
   *   - extend scalar Name Directives[Const]
   */ parseScalarTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("scalar");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        if (directives.length === 0) {
            throw this.unexpected();
        }
        return this.node(start, {
            kind: _kinds.Kind.SCALAR_TYPE_EXTENSION,
            name,
            directives
        });
    }
    /**
   * ObjectTypeExtension :
   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
   *  - extend type Name ImplementsInterfaces? Directives[Const]
   *  - extend type Name ImplementsInterfaces
   */ parseObjectTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("type");
        const name = this.parseName();
        const interfaces = this.parseImplementsInterfaces();
        const directives = this.parseConstDirectives();
        const fields = this.parseFieldsDefinition();
        if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
            throw this.unexpected();
        }
        return this.node(start, {
            kind: _kinds.Kind.OBJECT_TYPE_EXTENSION,
            name,
            interfaces,
            directives,
            fields
        });
    }
    /**
   * InterfaceTypeExtension :
   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
   *  - extend interface Name ImplementsInterfaces? Directives[Const]
   *  - extend interface Name ImplementsInterfaces
   */ parseInterfaceTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("interface");
        const name = this.parseName();
        const interfaces = this.parseImplementsInterfaces();
        const directives = this.parseConstDirectives();
        const fields = this.parseFieldsDefinition();
        if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
            throw this.unexpected();
        }
        return this.node(start, {
            kind: _kinds.Kind.INTERFACE_TYPE_EXTENSION,
            name,
            interfaces,
            directives,
            fields
        });
    }
    /**
   * UnionTypeExtension :
   *   - extend union Name Directives[Const]? UnionMemberTypes
   *   - extend union Name Directives[Const]
   */ parseUnionTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("union");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const types = this.parseUnionMemberTypes();
        if (directives.length === 0 && types.length === 0) {
            throw this.unexpected();
        }
        return this.node(start, {
            kind: _kinds.Kind.UNION_TYPE_EXTENSION,
            name,
            directives,
            types
        });
    }
    /**
   * EnumTypeExtension :
   *   - extend enum Name Directives[Const]? EnumValuesDefinition
   *   - extend enum Name Directives[Const]
   */ parseEnumTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("enum");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const values = this.parseEnumValuesDefinition();
        if (directives.length === 0 && values.length === 0) {
            throw this.unexpected();
        }
        return this.node(start, {
            kind: _kinds.Kind.ENUM_TYPE_EXTENSION,
            name,
            directives,
            values
        });
    }
    /**
   * InputObjectTypeExtension :
   *   - extend input Name Directives[Const]? InputFieldsDefinition
   *   - extend input Name Directives[Const]
   */ parseInputObjectTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("input");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const fields = this.parseInputFieldsDefinition();
        if (directives.length === 0 && fields.length === 0) {
            throw this.unexpected();
        }
        return this.node(start, {
            kind: _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION,
            name,
            directives,
            fields
        });
    }
    /**
   * ```
   * DirectiveDefinition :
   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations
   * ```
   */ parseDirectiveDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("directive");
        this.expectToken(_tokenKind.TokenKind.AT);
        const name = this.parseName();
        const args = this.parseArgumentDefs();
        const repeatable = this.expectOptionalKeyword("repeatable");
        this.expectKeyword("on");
        const locations = this.parseDirectiveLocations();
        return this.node(start, {
            kind: _kinds.Kind.DIRECTIVE_DEFINITION,
            description,
            name,
            arguments: args,
            repeatable,
            locations
        });
    }
    /**
   * DirectiveLocations :
   *   - `|`? DirectiveLocation
   *   - DirectiveLocations | DirectiveLocation
   */ parseDirectiveLocations() {
        return this.delimitedMany(_tokenKind.TokenKind.PIPE, this.parseDirectiveLocation);
    }
    /*
   * DirectiveLocation :
   *   - ExecutableDirectiveLocation
   *   - TypeSystemDirectiveLocation
   *
   * ExecutableDirectiveLocation : one of
   *   `QUERY`
   *   `MUTATION`
   *   `SUBSCRIPTION`
   *   `FIELD`
   *   `FRAGMENT_DEFINITION`
   *   `FRAGMENT_SPREAD`
   *   `INLINE_FRAGMENT`
   *
   * TypeSystemDirectiveLocation : one of
   *   `SCHEMA`
   *   `SCALAR`
   *   `OBJECT`
   *   `FIELD_DEFINITION`
   *   `ARGUMENT_DEFINITION`
   *   `INTERFACE`
   *   `UNION`
   *   `ENUM`
   *   `ENUM_VALUE`
   *   `INPUT_OBJECT`
   *   `INPUT_FIELD_DEFINITION`
   */ parseDirectiveLocation() {
        const start = this._lexer.token;
        const name = this.parseName();
        if (Object.prototype.hasOwnProperty.call(_directiveLocation.DirectiveLocation, name.value)) {
            return name;
        }
        throw this.unexpected(start);
    }
    /**
   * Returns a node that, if configured to do so, sets a "loc" field as a
   * location object, used to identify the place in the source that created a
   * given parsed object.
   */ node(startToken, node) {
        if (this._options.noLocation !== true) {
            node.loc = new _ast.Location(startToken, this._lexer.lastToken, this._lexer.source);
        }
        return node;
    }
    /**
   * Determines if the next token is of a given kind
   */ peek(kind) {
        return this._lexer.token.kind === kind;
    }
    /**
   * If the next token is of the given kind, return that token after advancing the lexer.
   * Otherwise, do not change the parser state and throw an error.
   */ expectToken(kind) {
        const token = this._lexer.token;
        if (token.kind === kind) {
            this.advanceLexer();
            return token;
        }
        throw (0, _syntaxError.syntaxError)(this._lexer.source, token.start, `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token)}.`);
    }
    /**
   * If the next token is of the given kind, return "true" after advancing the lexer.
   * Otherwise, do not change the parser state and return "false".
   */ expectOptionalToken(kind) {
        const token = this._lexer.token;
        if (token.kind === kind) {
            this.advanceLexer();
            return true;
        }
        return false;
    }
    /**
   * If the next token is a given keyword, advance the lexer.
   * Otherwise, do not change the parser state and throw an error.
   */ expectKeyword(value) {
        const token = this._lexer.token;
        if (token.kind === _tokenKind.TokenKind.NAME && token.value === value) {
            this.advanceLexer();
        } else {
            throw (0, _syntaxError.syntaxError)(this._lexer.source, token.start, `Expected "${value}", found ${getTokenDesc(token)}.`);
        }
    }
    /**
   * If the next token is a given keyword, return "true" after advancing the lexer.
   * Otherwise, do not change the parser state and return "false".
   */ expectOptionalKeyword(value) {
        const token = this._lexer.token;
        if (token.kind === _tokenKind.TokenKind.NAME && token.value === value) {
            this.advanceLexer();
            return true;
        }
        return false;
    }
    /**
   * Helper function for creating an error when an unexpected lexed token is encountered.
   */ unexpected(atToken) {
        const token = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;
        return (0, _syntaxError.syntaxError)(this._lexer.source, token.start, `Unexpected ${getTokenDesc(token)}.`);
    }
    /**
   * Returns a possibly empty list of parse nodes, determined by the parseFn.
   * This list begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */ any(openKind, parseFn, closeKind) {
        this.expectToken(openKind);
        const nodes = [];
        while(!this.expectOptionalToken(closeKind)){
            nodes.push(parseFn.call(this));
        }
        return nodes;
    }
    /**
   * Returns a list of parse nodes, determined by the parseFn.
   * It can be empty only if open token is missing otherwise it will always return non-empty list
   * that begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */ optionalMany(openKind, parseFn, closeKind) {
        if (this.expectOptionalToken(openKind)) {
            const nodes = [];
            do {
                nodes.push(parseFn.call(this));
            }while (!this.expectOptionalToken(closeKind));
            return nodes;
        }
        return [];
    }
    /**
   * Returns a non-empty list of parse nodes, determined by the parseFn.
   * This list begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */ many(openKind, parseFn, closeKind) {
        this.expectToken(openKind);
        const nodes = [];
        do {
            nodes.push(parseFn.call(this));
        }while (!this.expectOptionalToken(closeKind));
        return nodes;
    }
    /**
   * Returns a non-empty list of parse nodes, determined by the parseFn.
   * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.
   * Advances the parser to the next lex token after last item in the list.
   */ delimitedMany(delimiterKind, parseFn) {
        this.expectOptionalToken(delimiterKind);
        const nodes = [];
        do {
            nodes.push(parseFn.call(this));
        }while (this.expectOptionalToken(delimiterKind));
        return nodes;
    }
    advanceLexer() {
        const { maxTokens  } = this._options;
        const token = this._lexer.advance();
        if (maxTokens !== undefined && token.kind !== _tokenKind.TokenKind.EOF) {
            ++this._tokenCounter;
            if (this._tokenCounter > maxTokens) {
                throw (0, _syntaxError.syntaxError)(this._lexer.source, token.start, `Document contains more that ${maxTokens} tokens. Parsing aborted.`);
            }
        }
    }
}
/**
 * A helper function to describe a token as a string for debugging.
 */ exports.Parser = Parser;
function getTokenDesc(token) {
    const value = token.value;
    return getTokenKindDesc(token.kind) + (value != null ? ` "${value}"` : "");
}
/**
 * A helper function to describe a token kind as a string for debugging.
 */ function getTokenKindDesc(kind) {
    return (0, _lexer.isPunctuatorTokenKind)(kind) ? `"${kind}"` : kind;
}


/***/ }),

/***/ 3288:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.isConstValueNode = isConstValueNode;
exports.isDefinitionNode = isDefinitionNode;
exports.isExecutableDefinitionNode = isExecutableDefinitionNode;
exports.isSelectionNode = isSelectionNode;
exports.isTypeDefinitionNode = isTypeDefinitionNode;
exports.isTypeExtensionNode = isTypeExtensionNode;
exports.isTypeNode = isTypeNode;
exports.isTypeSystemDefinitionNode = isTypeSystemDefinitionNode;
exports.isTypeSystemExtensionNode = isTypeSystemExtensionNode;
exports.isValueNode = isValueNode;
var _kinds = __webpack_require__(5923);
function isDefinitionNode(node) {
    return isExecutableDefinitionNode(node) || isTypeSystemDefinitionNode(node) || isTypeSystemExtensionNode(node);
}
function isExecutableDefinitionNode(node) {
    return node.kind === _kinds.Kind.OPERATION_DEFINITION || node.kind === _kinds.Kind.FRAGMENT_DEFINITION;
}
function isSelectionNode(node) {
    return node.kind === _kinds.Kind.FIELD || node.kind === _kinds.Kind.FRAGMENT_SPREAD || node.kind === _kinds.Kind.INLINE_FRAGMENT;
}
function isValueNode(node) {
    return node.kind === _kinds.Kind.VARIABLE || node.kind === _kinds.Kind.INT || node.kind === _kinds.Kind.FLOAT || node.kind === _kinds.Kind.STRING || node.kind === _kinds.Kind.BOOLEAN || node.kind === _kinds.Kind.NULL || node.kind === _kinds.Kind.ENUM || node.kind === _kinds.Kind.LIST || node.kind === _kinds.Kind.OBJECT;
}
function isConstValueNode(node) {
    return isValueNode(node) && (node.kind === _kinds.Kind.LIST ? node.values.some(isConstValueNode) : node.kind === _kinds.Kind.OBJECT ? node.fields.some((field)=>isConstValueNode(field.value)) : node.kind !== _kinds.Kind.VARIABLE);
}
function isTypeNode(node) {
    return node.kind === _kinds.Kind.NAMED_TYPE || node.kind === _kinds.Kind.LIST_TYPE || node.kind === _kinds.Kind.NON_NULL_TYPE;
}
function isTypeSystemDefinitionNode(node) {
    return node.kind === _kinds.Kind.SCHEMA_DEFINITION || isTypeDefinitionNode(node) || node.kind === _kinds.Kind.DIRECTIVE_DEFINITION;
}
function isTypeDefinitionNode(node) {
    return node.kind === _kinds.Kind.SCALAR_TYPE_DEFINITION || node.kind === _kinds.Kind.OBJECT_TYPE_DEFINITION || node.kind === _kinds.Kind.INTERFACE_TYPE_DEFINITION || node.kind === _kinds.Kind.UNION_TYPE_DEFINITION || node.kind === _kinds.Kind.ENUM_TYPE_DEFINITION || node.kind === _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION;
}
function isTypeSystemExtensionNode(node) {
    return node.kind === _kinds.Kind.SCHEMA_EXTENSION || isTypeExtensionNode(node);
}
function isTypeExtensionNode(node) {
    return node.kind === _kinds.Kind.SCALAR_TYPE_EXTENSION || node.kind === _kinds.Kind.OBJECT_TYPE_EXTENSION || node.kind === _kinds.Kind.INTERFACE_TYPE_EXTENSION || node.kind === _kinds.Kind.UNION_TYPE_EXTENSION || node.kind === _kinds.Kind.ENUM_TYPE_EXTENSION || node.kind === _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION;
}


/***/ }),

/***/ 941:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.printLocation = printLocation;
exports.printSourceLocation = printSourceLocation;
var _location = __webpack_require__(8140);
/**
 * Render a helpful description of the location in the GraphQL Source document.
 */ function printLocation(location) {
    return printSourceLocation(location.source, (0, _location.getLocation)(location.source, location.start));
}
/**
 * Render a helpful description of the location in the GraphQL Source document.
 */ function printSourceLocation(source, sourceLocation) {
    const firstLineColumnOffset = source.locationOffset.column - 1;
    const body = "".padStart(firstLineColumnOffset) + source.body;
    const lineIndex = sourceLocation.line - 1;
    const lineOffset = source.locationOffset.line - 1;
    const lineNum = sourceLocation.line + lineOffset;
    const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
    const columnNum = sourceLocation.column + columnOffset;
    const locationStr = `${source.name}:${lineNum}:${columnNum}\n`;
    const lines = body.split(/\r\n|[\n\r]/g);
    const locationLine = lines[lineIndex]; // Special case for minified documents
    if (locationLine.length > 120) {
        const subLineIndex = Math.floor(columnNum / 80);
        const subLineColumnNum = columnNum % 80;
        const subLines = [];
        for(let i = 0; i < locationLine.length; i += 80){
            subLines.push(locationLine.slice(i, i + 80));
        }
        return locationStr + printPrefixedLines([
            [
                `${lineNum} |`,
                subLines[0]
            ],
            ...subLines.slice(1, subLineIndex + 1).map((subLine)=>[
                    "|",
                    subLine
                ]),
            [
                "|",
                "^".padStart(subLineColumnNum)
            ],
            [
                "|",
                subLines[subLineIndex + 1]
            ]
        ]);
    }
    return locationStr + printPrefixedLines([
        // Lines specified like this: ["prefix", "string"],
        [
            `${lineNum - 1} |`,
            lines[lineIndex - 1]
        ],
        [
            `${lineNum} |`,
            locationLine
        ],
        [
            "|",
            "^".padStart(columnNum)
        ],
        [
            `${lineNum + 1} |`,
            lines[lineIndex + 1]
        ]
    ]);
}
function printPrefixedLines(lines) {
    const existingLines = lines.filter(([_, line])=>line !== undefined);
    const padLen = Math.max(...existingLines.map(([prefix])=>prefix.length));
    return existingLines.map(([prefix, line])=>prefix.padStart(padLen) + (line ? " " + line : "")).join("\n");
}


/***/ }),

/***/ 7320:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.printString = printString;
/**
 * Prints a string as a GraphQL StringValue literal. Replaces control characters
 * and excluded characters (" U+0022 and \\ U+005C) with escape sequences.
 */ function printString(str) {
    return `"${str.replace(escapedRegExp, escapedReplacer)}"`;
} // eslint-disable-next-line no-control-regex
const escapedRegExp = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
function escapedReplacer(str) {
    return escapeSequences[str.charCodeAt(0)];
} // prettier-ignore
const escapeSequences = [
    "\\u0000",
    "\\u0001",
    "\\u0002",
    "\\u0003",
    "\\u0004",
    "\\u0005",
    "\\u0006",
    "\\u0007",
    "\\b",
    "\\t",
    "\\n",
    "\\u000B",
    "\\f",
    "\\r",
    "\\u000E",
    "\\u000F",
    "\\u0010",
    "\\u0011",
    "\\u0012",
    "\\u0013",
    "\\u0014",
    "\\u0015",
    "\\u0016",
    "\\u0017",
    "\\u0018",
    "\\u0019",
    "\\u001A",
    "\\u001B",
    "\\u001C",
    "\\u001D",
    "\\u001E",
    "\\u001F",
    "",
    "",
    '\\"',
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "\\\\",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "\\u007F",
    "\\u0080",
    "\\u0081",
    "\\u0082",
    "\\u0083",
    "\\u0084",
    "\\u0085",
    "\\u0086",
    "\\u0087",
    "\\u0088",
    "\\u0089",
    "\\u008A",
    "\\u008B",
    "\\u008C",
    "\\u008D",
    "\\u008E",
    "\\u008F",
    "\\u0090",
    "\\u0091",
    "\\u0092",
    "\\u0093",
    "\\u0094",
    "\\u0095",
    "\\u0096",
    "\\u0097",
    "\\u0098",
    "\\u0099",
    "\\u009A",
    "\\u009B",
    "\\u009C",
    "\\u009D",
    "\\u009E",
    "\\u009F"
];


/***/ }),

/***/ 800:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.print = print;
var _blockString = __webpack_require__(9121);
var _printString = __webpack_require__(7320);
var _visitor = __webpack_require__(4256);
/**
 * Converts an AST into a string, using one set of reasonable
 * formatting rules.
 */ function print(ast) {
    return (0, _visitor.visit)(ast, printDocASTReducer);
}
const MAX_LINE_LENGTH = 80;
const printDocASTReducer = {
    Name: {
        leave: (node)=>node.value
    },
    Variable: {
        leave: (node)=>"$" + node.name
    },
    // Document
    Document: {
        leave: (node)=>join(node.definitions, "\n\n")
    },
    OperationDefinition: {
        leave (node) {
            const varDefs = wrap("(", join(node.variableDefinitions, ", "), ")");
            const prefix = join([
                node.operation,
                join([
                    node.name,
                    varDefs
                ]),
                join(node.directives, " ")
            ], " "); // Anonymous queries with no directives or variable definitions can use
            // the query short form.
            return (prefix === "query" ? "" : prefix + " ") + node.selectionSet;
        }
    },
    VariableDefinition: {
        leave: ({ variable , type , defaultValue , directives  })=>variable + ": " + type + wrap(" = ", defaultValue) + wrap(" ", join(directives, " "))
    },
    SelectionSet: {
        leave: ({ selections  })=>block(selections)
    },
    Field: {
        leave ({ alias , name , arguments: args , directives , selectionSet  }) {
            const prefix = wrap("", alias, ": ") + name;
            let argsLine = prefix + wrap("(", join(args, ", "), ")");
            if (argsLine.length > MAX_LINE_LENGTH) {
                argsLine = prefix + wrap("(\n", indent(join(args, "\n")), "\n)");
            }
            return join([
                argsLine,
                join(directives, " "),
                selectionSet
            ], " ");
        }
    },
    Argument: {
        leave: ({ name , value  })=>name + ": " + value
    },
    // Fragments
    FragmentSpread: {
        leave: ({ name , directives  })=>"..." + name + wrap(" ", join(directives, " "))
    },
    InlineFragment: {
        leave: ({ typeCondition , directives , selectionSet  })=>join([
                "...",
                wrap("on ", typeCondition),
                join(directives, " "),
                selectionSet
            ], " ")
    },
    FragmentDefinition: {
        leave: ({ name , typeCondition , variableDefinitions , directives , selectionSet  })=>// or removed in the future.
            `fragment ${name}${wrap("(", join(variableDefinitions, ", "), ")")} ` + `on ${typeCondition} ${wrap("", join(directives, " "), " ")}` + selectionSet
    },
    // Value
    IntValue: {
        leave: ({ value  })=>value
    },
    FloatValue: {
        leave: ({ value  })=>value
    },
    StringValue: {
        leave: ({ value , block: isBlockString  })=>isBlockString ? (0, _blockString.printBlockString)(value) : (0, _printString.printString)(value)
    },
    BooleanValue: {
        leave: ({ value  })=>value ? "true" : "false"
    },
    NullValue: {
        leave: ()=>"null"
    },
    EnumValue: {
        leave: ({ value  })=>value
    },
    ListValue: {
        leave: ({ values  })=>"[" + join(values, ", ") + "]"
    },
    ObjectValue: {
        leave: ({ fields  })=>"{" + join(fields, ", ") + "}"
    },
    ObjectField: {
        leave: ({ name , value  })=>name + ": " + value
    },
    // Directive
    Directive: {
        leave: ({ name , arguments: args  })=>"@" + name + wrap("(", join(args, ", "), ")")
    },
    // Type
    NamedType: {
        leave: ({ name  })=>name
    },
    ListType: {
        leave: ({ type  })=>"[" + type + "]"
    },
    NonNullType: {
        leave: ({ type  })=>type + "!"
    },
    // Type System Definitions
    SchemaDefinition: {
        leave: ({ description , directives , operationTypes  })=>wrap("", description, "\n") + join([
                "schema",
                join(directives, " "),
                block(operationTypes)
            ], " ")
    },
    OperationTypeDefinition: {
        leave: ({ operation , type  })=>operation + ": " + type
    },
    ScalarTypeDefinition: {
        leave: ({ description , name , directives  })=>wrap("", description, "\n") + join([
                "scalar",
                name,
                join(directives, " ")
            ], " ")
    },
    ObjectTypeDefinition: {
        leave: ({ description , name , interfaces , directives , fields  })=>wrap("", description, "\n") + join([
                "type",
                name,
                wrap("implements ", join(interfaces, " & ")),
                join(directives, " "),
                block(fields)
            ], " ")
    },
    FieldDefinition: {
        leave: ({ description , name , arguments: args , type , directives  })=>wrap("", description, "\n") + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + ": " + type + wrap(" ", join(directives, " "))
    },
    InputValueDefinition: {
        leave: ({ description , name , type , defaultValue , directives  })=>wrap("", description, "\n") + join([
                name + ": " + type,
                wrap("= ", defaultValue),
                join(directives, " ")
            ], " ")
    },
    InterfaceTypeDefinition: {
        leave: ({ description , name , interfaces , directives , fields  })=>wrap("", description, "\n") + join([
                "interface",
                name,
                wrap("implements ", join(interfaces, " & ")),
                join(directives, " "),
                block(fields)
            ], " ")
    },
    UnionTypeDefinition: {
        leave: ({ description , name , directives , types  })=>wrap("", description, "\n") + join([
                "union",
                name,
                join(directives, " "),
                wrap("= ", join(types, " | "))
            ], " ")
    },
    EnumTypeDefinition: {
        leave: ({ description , name , directives , values  })=>wrap("", description, "\n") + join([
                "enum",
                name,
                join(directives, " "),
                block(values)
            ], " ")
    },
    EnumValueDefinition: {
        leave: ({ description , name , directives  })=>wrap("", description, "\n") + join([
                name,
                join(directives, " ")
            ], " ")
    },
    InputObjectTypeDefinition: {
        leave: ({ description , name , directives , fields  })=>wrap("", description, "\n") + join([
                "input",
                name,
                join(directives, " "),
                block(fields)
            ], " ")
    },
    DirectiveDefinition: {
        leave: ({ description , name , arguments: args , repeatable , locations  })=>wrap("", description, "\n") + "directive @" + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join(locations, " | ")
    },
    SchemaExtension: {
        leave: ({ directives , operationTypes  })=>join([
                "extend schema",
                join(directives, " "),
                block(operationTypes)
            ], " ")
    },
    ScalarTypeExtension: {
        leave: ({ name , directives  })=>join([
                "extend scalar",
                name,
                join(directives, " ")
            ], " ")
    },
    ObjectTypeExtension: {
        leave: ({ name , interfaces , directives , fields  })=>join([
                "extend type",
                name,
                wrap("implements ", join(interfaces, " & ")),
                join(directives, " "),
                block(fields)
            ], " ")
    },
    InterfaceTypeExtension: {
        leave: ({ name , interfaces , directives , fields  })=>join([
                "extend interface",
                name,
                wrap("implements ", join(interfaces, " & ")),
                join(directives, " "),
                block(fields)
            ], " ")
    },
    UnionTypeExtension: {
        leave: ({ name , directives , types  })=>join([
                "extend union",
                name,
                join(directives, " "),
                wrap("= ", join(types, " | "))
            ], " ")
    },
    EnumTypeExtension: {
        leave: ({ name , directives , values  })=>join([
                "extend enum",
                name,
                join(directives, " "),
                block(values)
            ], " ")
    },
    InputObjectTypeExtension: {
        leave: ({ name , directives , fields  })=>join([
                "extend input",
                name,
                join(directives, " "),
                block(fields)
            ], " ")
    }
};
/**
 * Given maybeArray, print an empty string if it is null or empty, otherwise
 * print all items together separated by separator if provided
 */ function join(maybeArray, separator = "") {
    var _maybeArray$filter$jo;
    return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter((x)=>x).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : "";
}
/**
 * Given array, print each item on its own line, wrapped in an indented `{ }` block.
 */ function block(array) {
    return wrap("{\n", indent(join(array, "\n")), "\n}");
}
/**
 * If maybeString is not null or empty, then wrap with start and end, otherwise print an empty string.
 */ function wrap(start, maybeString, end = "") {
    return maybeString != null && maybeString !== "" ? start + maybeString + end : "";
}
function indent(str) {
    return wrap("  ", str.replace(/\n/g, "\n  "));
}
function hasMultilineItems(maybeArray) {
    var _maybeArray$some;
    // FIXME: https://github.com/graphql/graphql-js/issues/2203
    /* c8 ignore next */ return (_maybeArray$some = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str)=>str.includes("\n"))) !== null && _maybeArray$some !== void 0 ? _maybeArray$some : false;
}


/***/ }),

/***/ 8509:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.Source = void 0;
exports.isSource = isSource;
var _devAssert = __webpack_require__(90);
var _inspect = __webpack_require__(8089);
var _instanceOf = __webpack_require__(9738);
/**
 * A representation of source input to GraphQL. The `name` and `locationOffset` parameters are
 * optional, but they are useful for clients who store GraphQL documents in source files.
 * For example, if the GraphQL input starts at line 40 in a file named `Foo.graphql`, it might
 * be useful for `name` to be `"Foo.graphql"` and location to be `{ line: 40, column: 1 }`.
 * The `line` and `column` properties in `locationOffset` are 1-indexed.
 */ class Source {
    constructor(body, name = "GraphQL request", locationOffset = {
        line: 1,
        column: 1
    }){
        typeof body === "string" || (0, _devAssert.devAssert)(false, `Body must be a string. Received: ${(0, _inspect.inspect)(body)}.`);
        this.body = body;
        this.name = name;
        this.locationOffset = locationOffset;
        this.locationOffset.line > 0 || (0, _devAssert.devAssert)(false, "line in locationOffset is 1-indexed and must be positive.");
        this.locationOffset.column > 0 || (0, _devAssert.devAssert)(false, "column in locationOffset is 1-indexed and must be positive.");
    }
    get [Symbol.toStringTag]() {
        return "Source";
    }
}
/**
 * Test if the given value is a Source object.
 *
 * @internal
 */ exports.Source = Source;
function isSource(source) {
    return (0, _instanceOf.instanceOf)(source, Source);
}


/***/ }),

/***/ 8845:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.TokenKind = void 0;
/**
 * An exported enum describing the different kinds of tokens that the
 * lexer emits.
 */ var TokenKind;
exports.TokenKind = TokenKind;
(function(TokenKind) {
    TokenKind["SOF"] = "<SOF>";
    TokenKind["EOF"] = "<EOF>";
    TokenKind["BANG"] = "!";
    TokenKind["DOLLAR"] = "$";
    TokenKind["AMP"] = "&";
    TokenKind["PAREN_L"] = "(";
    TokenKind["PAREN_R"] = ")";
    TokenKind["SPREAD"] = "...";
    TokenKind["COLON"] = ":";
    TokenKind["EQUALS"] = "=";
    TokenKind["AT"] = "@";
    TokenKind["BRACKET_L"] = "[";
    TokenKind["BRACKET_R"] = "]";
    TokenKind["BRACE_L"] = "{";
    TokenKind["PIPE"] = "|";
    TokenKind["BRACE_R"] = "}";
    TokenKind["NAME"] = "Name";
    TokenKind["INT"] = "Int";
    TokenKind["FLOAT"] = "Float";
    TokenKind["STRING"] = "String";
    TokenKind["BLOCK_STRING"] = "BlockString";
    TokenKind["COMMENT"] = "Comment";
})(TokenKind || (exports.TokenKind = TokenKind = {})); /**
 * The enum type representing the token kinds values.
 *
 * @deprecated Please use `TokenKind`. Will be remove in v17.
 */ 


/***/ }),

/***/ 4256:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.BREAK = void 0;
exports.getEnterLeaveForKind = getEnterLeaveForKind;
exports.getVisitFn = getVisitFn;
exports.visit = visit;
exports.visitInParallel = visitInParallel;
var _devAssert = __webpack_require__(90);
var _inspect = __webpack_require__(8089);
var _ast = __webpack_require__(9344);
var _kinds = __webpack_require__(5923);
const BREAK = Object.freeze({});
/**
 * visit() will walk through an AST using a depth-first traversal, calling
 * the visitor's enter function at each node in the traversal, and calling the
 * leave function after visiting that node and all of its child nodes.
 *
 * By returning different values from the enter and leave functions, the
 * behavior of the visitor can be altered, including skipping over a sub-tree of
 * the AST (by returning false), editing the AST by returning a value or null
 * to remove the value, or to stop the whole traversal by returning BREAK.
 *
 * When using visit() to edit an AST, the original AST will not be modified, and
 * a new version of the AST with the changes applied will be returned from the
 * visit function.
 *
 * ```ts
 * const editedAST = visit(ast, {
 *   enter(node, key, parent, path, ancestors) {
 *     // @return
 *     //   undefined: no action
 *     //   false: skip visiting this node
 *     //   visitor.BREAK: stop visiting altogether
 *     //   null: delete this node
 *     //   any value: replace this node with the returned value
 *   },
 *   leave(node, key, parent, path, ancestors) {
 *     // @return
 *     //   undefined: no action
 *     //   false: no action
 *     //   visitor.BREAK: stop visiting altogether
 *     //   null: delete this node
 *     //   any value: replace this node with the returned value
 *   }
 * });
 * ```
 *
 * Alternatively to providing enter() and leave() functions, a visitor can
 * instead provide functions named the same as the kinds of AST nodes, or
 * enter/leave visitors at a named key, leading to three permutations of the
 * visitor API:
 *
 * 1) Named visitors triggered when entering a node of a specific kind.
 *
 * ```ts
 * visit(ast, {
 *   Kind(node) {
 *     // enter the "Kind" node
 *   }
 * })
 * ```
 *
 * 2) Named visitors that trigger upon entering and leaving a node of a specific kind.
 *
 * ```ts
 * visit(ast, {
 *   Kind: {
 *     enter(node) {
 *       // enter the "Kind" node
 *     }
 *     leave(node) {
 *       // leave the "Kind" node
 *     }
 *   }
 * })
 * ```
 *
 * 3) Generic visitors that trigger upon entering and leaving any node.
 *
 * ```ts
 * visit(ast, {
 *   enter(node) {
 *     // enter any node
 *   },
 *   leave(node) {
 *     // leave any node
 *   }
 * })
 * ```
 */ exports.BREAK = BREAK;
function visit(root, visitor, visitorKeys = _ast.QueryDocumentKeys) {
    const enterLeaveMap = new Map();
    for (const kind of Object.values(_kinds.Kind)){
        enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind));
    }
    /* eslint-disable no-undef-init */ let stack = undefined;
    let inArray = Array.isArray(root);
    let keys = [
        root
    ];
    let index = -1;
    let edits = [];
    let node = root;
    let key = undefined;
    let parent = undefined;
    const path = [];
    const ancestors = [];
    /* eslint-enable no-undef-init */ do {
        index++;
        const isLeaving = index === keys.length;
        const isEdited = isLeaving && edits.length !== 0;
        if (isLeaving) {
            key = ancestors.length === 0 ? undefined : path[path.length - 1];
            node = parent;
            parent = ancestors.pop();
            if (isEdited) {
                if (inArray) {
                    node = node.slice();
                    let editOffset = 0;
                    for (const [editKey, editValue] of edits){
                        const arrayKey = editKey - editOffset;
                        if (editValue === null) {
                            node.splice(arrayKey, 1);
                            editOffset++;
                        } else {
                            node[arrayKey] = editValue;
                        }
                    }
                } else {
                    node = Object.defineProperties({}, Object.getOwnPropertyDescriptors(node));
                    for (const [editKey, editValue] of edits){
                        node[editKey] = editValue;
                    }
                }
            }
            index = stack.index;
            keys = stack.keys;
            edits = stack.edits;
            inArray = stack.inArray;
            stack = stack.prev;
        } else if (parent) {
            key = inArray ? index : keys[index];
            node = parent[key];
            if (node === null || node === undefined) {
                continue;
            }
            path.push(key);
        }
        let result;
        if (!Array.isArray(node)) {
            var _enterLeaveMap$get, _enterLeaveMap$get2;
            (0, _ast.isNode)(node) || (0, _devAssert.devAssert)(false, `Invalid AST Node: ${(0, _inspect.inspect)(node)}.`);
            const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get === void 0 ? void 0 : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get2 === void 0 ? void 0 : _enterLeaveMap$get2.enter;
            result = visitFn === null || visitFn === void 0 ? void 0 : visitFn.call(visitor, node, key, parent, path, ancestors);
            if (result === BREAK) {
                break;
            }
            if (result === false) {
                if (!isLeaving) {
                    path.pop();
                    continue;
                }
            } else if (result !== undefined) {
                edits.push([
                    key,
                    result
                ]);
                if (!isLeaving) {
                    if ((0, _ast.isNode)(result)) {
                        node = result;
                    } else {
                        path.pop();
                        continue;
                    }
                }
            }
        }
        if (result === undefined && isEdited) {
            edits.push([
                key,
                node
            ]);
        }
        if (isLeaving) {
            path.pop();
        } else {
            var _node$kind;
            stack = {
                inArray,
                index,
                keys,
                edits,
                prev: stack
            };
            inArray = Array.isArray(node);
            keys = inArray ? node : (_node$kind = visitorKeys[node.kind]) !== null && _node$kind !== void 0 ? _node$kind : [];
            index = -1;
            edits = [];
            if (parent) {
                ancestors.push(parent);
            }
            parent = node;
        }
    }while (stack !== undefined);
    if (edits.length !== 0) {
        // New root
        return edits[edits.length - 1][1];
    }
    return root;
}
/**
 * Creates a new visitor instance which delegates to many visitors to run in
 * parallel. Each visitor will be visited for each node before moving on.
 *
 * If a prior visitor edits a node, no following visitors will see that node.
 */ function visitInParallel(visitors) {
    const skipping = new Array(visitors.length).fill(null);
    const mergedVisitor = Object.create(null);
    for (const kind of Object.values(_kinds.Kind)){
        let hasVisitor = false;
        const enterList = new Array(visitors.length).fill(undefined);
        const leaveList = new Array(visitors.length).fill(undefined);
        for(let i = 0; i < visitors.length; ++i){
            const { enter , leave  } = getEnterLeaveForKind(visitors[i], kind);
            hasVisitor || (hasVisitor = enter != null || leave != null);
            enterList[i] = enter;
            leaveList[i] = leave;
        }
        if (!hasVisitor) {
            continue;
        }
        const mergedEnterLeave = {
            enter (...args) {
                const node = args[0];
                for(let i = 0; i < visitors.length; i++){
                    if (skipping[i] === null) {
                        var _enterList$i;
                        const result = (_enterList$i = enterList[i]) === null || _enterList$i === void 0 ? void 0 : _enterList$i.apply(visitors[i], args);
                        if (result === false) {
                            skipping[i] = node;
                        } else if (result === BREAK) {
                            skipping[i] = BREAK;
                        } else if (result !== undefined) {
                            return result;
                        }
                    }
                }
            },
            leave (...args) {
                const node = args[0];
                for(let i = 0; i < visitors.length; i++){
                    if (skipping[i] === null) {
                        var _leaveList$i;
                        const result = (_leaveList$i = leaveList[i]) === null || _leaveList$i === void 0 ? void 0 : _leaveList$i.apply(visitors[i], args);
                        if (result === BREAK) {
                            skipping[i] = BREAK;
                        } else if (result !== undefined && result !== false) {
                            return result;
                        }
                    } else if (skipping[i] === node) {
                        skipping[i] = null;
                    }
                }
            }
        };
        mergedVisitor[kind] = mergedEnterLeave;
    }
    return mergedVisitor;
}
/**
 * Given a visitor instance and a node kind, return EnterLeaveVisitor for that kind.
 */ function getEnterLeaveForKind(visitor, kind) {
    const kindVisitor = visitor[kind];
    if (typeof kindVisitor === "object") {
        // { Kind: { enter() {}, leave() {} } }
        return kindVisitor;
    } else if (typeof kindVisitor === "function") {
        // { Kind() {} }
        return {
            enter: kindVisitor,
            leave: undefined
        };
    } // { enter() {}, leave() {} }
    return {
        enter: visitor.enter,
        leave: visitor.leave
    };
}
/**
 * Given a visitor instance, if it is leaving or not, and a node kind, return
 * the function the visitor runtime should call.
 *
 * @deprecated Please use `getEnterLeaveForKind` instead. Will be removed in v17
 */ /* c8 ignore next 8 */ function getVisitFn(visitor, kind, isLeaving) {
    const { enter , leave  } = getEnterLeaveForKind(visitor, kind);
    return isLeaving ? leave : enter;
}


/***/ }),

/***/ 2039:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.assertEnumValueName = assertEnumValueName;
exports.assertName = assertName;
var _devAssert = __webpack_require__(90);
var _GraphQLError = __webpack_require__(2169);
var _characterClasses = __webpack_require__(1097);
/**
 * Upholds the spec rules about naming.
 */ function assertName(name) {
    name != null || (0, _devAssert.devAssert)(false, "Must provide name.");
    typeof name === "string" || (0, _devAssert.devAssert)(false, "Expected name to be a string.");
    if (name.length === 0) {
        throw new _GraphQLError.GraphQLError("Expected name to be a non-empty string.");
    }
    for(let i = 1; i < name.length; ++i){
        if (!(0, _characterClasses.isNameContinue)(name.charCodeAt(i))) {
            throw new _GraphQLError.GraphQLError(`Names must only contain [_a-zA-Z0-9] but "${name}" does not.`);
        }
    }
    if (!(0, _characterClasses.isNameStart)(name.charCodeAt(0))) {
        throw new _GraphQLError.GraphQLError(`Names must start with [_a-zA-Z] but "${name}" does not.`);
    }
    return name;
}
/**
 * Upholds the spec rules about naming enum values.
 *
 * @internal
 */ function assertEnumValueName(name) {
    if (name === "true" || name === "false" || name === "null") {
        throw new _GraphQLError.GraphQLError(`Enum values cannot be named: ${name}`);
    }
    return assertName(name);
}


/***/ }),

/***/ 7982:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.GraphQLUnionType = exports.GraphQLScalarType = exports.GraphQLObjectType = exports.GraphQLNonNull = exports.GraphQLList = exports.GraphQLInterfaceType = exports.GraphQLInputObjectType = exports.GraphQLEnumType = void 0;
exports.argsToArgsConfig = argsToArgsConfig;
exports.assertAbstractType = assertAbstractType;
exports.assertCompositeType = assertCompositeType;
exports.assertEnumType = assertEnumType;
exports.assertInputObjectType = assertInputObjectType;
exports.assertInputType = assertInputType;
exports.assertInterfaceType = assertInterfaceType;
exports.assertLeafType = assertLeafType;
exports.assertListType = assertListType;
exports.assertNamedType = assertNamedType;
exports.assertNonNullType = assertNonNullType;
exports.assertNullableType = assertNullableType;
exports.assertObjectType = assertObjectType;
exports.assertOutputType = assertOutputType;
exports.assertScalarType = assertScalarType;
exports.assertType = assertType;
exports.assertUnionType = assertUnionType;
exports.assertWrappingType = assertWrappingType;
exports.defineArguments = defineArguments;
exports.getNamedType = getNamedType;
exports.getNullableType = getNullableType;
exports.isAbstractType = isAbstractType;
exports.isCompositeType = isCompositeType;
exports.isEnumType = isEnumType;
exports.isInputObjectType = isInputObjectType;
exports.isInputType = isInputType;
exports.isInterfaceType = isInterfaceType;
exports.isLeafType = isLeafType;
exports.isListType = isListType;
exports.isNamedType = isNamedType;
exports.isNonNullType = isNonNullType;
exports.isNullableType = isNullableType;
exports.isObjectType = isObjectType;
exports.isOutputType = isOutputType;
exports.isRequiredArgument = isRequiredArgument;
exports.isRequiredInputField = isRequiredInputField;
exports.isScalarType = isScalarType;
exports.isType = isType;
exports.isUnionType = isUnionType;
exports.isWrappingType = isWrappingType;
exports.resolveObjMapThunk = resolveObjMapThunk;
exports.resolveReadonlyArrayThunk = resolveReadonlyArrayThunk;
var _devAssert = __webpack_require__(90);
var _didYouMean = __webpack_require__(2228);
var _identityFunc = __webpack_require__(6812);
var _inspect = __webpack_require__(8089);
var _instanceOf = __webpack_require__(9738);
var _isObjectLike = __webpack_require__(5564);
var _keyMap = __webpack_require__(2512);
var _keyValMap = __webpack_require__(370);
var _mapValue = __webpack_require__(1030);
var _suggestionList = __webpack_require__(6347);
var _toObjMap = __webpack_require__(5891);
var _GraphQLError = __webpack_require__(2169);
var _kinds = __webpack_require__(5923);
var _printer = __webpack_require__(800);
var _valueFromASTUntyped = __webpack_require__(9267);
var _assertName = __webpack_require__(2039);
function isType(type) {
    return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type) || isListType(type) || isNonNullType(type);
}
function assertType(type) {
    if (!isType(type)) {
        throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL type.`);
    }
    return type;
}
/**
 * There are predicates for each kind of GraphQL type.
 */ function isScalarType(type) {
    return (0, _instanceOf.instanceOf)(type, GraphQLScalarType);
}
function assertScalarType(type) {
    if (!isScalarType(type)) {
        throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Scalar type.`);
    }
    return type;
}
function isObjectType(type) {
    return (0, _instanceOf.instanceOf)(type, GraphQLObjectType);
}
function assertObjectType(type) {
    if (!isObjectType(type)) {
        throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Object type.`);
    }
    return type;
}
function isInterfaceType(type) {
    return (0, _instanceOf.instanceOf)(type, GraphQLInterfaceType);
}
function assertInterfaceType(type) {
    if (!isInterfaceType(type)) {
        throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Interface type.`);
    }
    return type;
}
function isUnionType(type) {
    return (0, _instanceOf.instanceOf)(type, GraphQLUnionType);
}
function assertUnionType(type) {
    if (!isUnionType(type)) {
        throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Union type.`);
    }
    return type;
}
function isEnumType(type) {
    return (0, _instanceOf.instanceOf)(type, GraphQLEnumType);
}
function assertEnumType(type) {
    if (!isEnumType(type)) {
        throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Enum type.`);
    }
    return type;
}
function isInputObjectType(type) {
    return (0, _instanceOf.instanceOf)(type, GraphQLInputObjectType);
}
function assertInputObjectType(type) {
    if (!isInputObjectType(type)) {
        throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Input Object type.`);
    }
    return type;
}
function isListType(type) {
    return (0, _instanceOf.instanceOf)(type, GraphQLList);
}
function assertListType(type) {
    if (!isListType(type)) {
        throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL List type.`);
    }
    return type;
}
function isNonNullType(type) {
    return (0, _instanceOf.instanceOf)(type, GraphQLNonNull);
}
function assertNonNullType(type) {
    if (!isNonNullType(type)) {
        throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Non-Null type.`);
    }
    return type;
}
/**
 * These types may be used as input types for arguments and directives.
 */ function isInputType(type) {
    return isScalarType(type) || isEnumType(type) || isInputObjectType(type) || isWrappingType(type) && isInputType(type.ofType);
}
function assertInputType(type) {
    if (!isInputType(type)) {
        throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL input type.`);
    }
    return type;
}
/**
 * These types may be used as output types as the result of fields.
 */ function isOutputType(type) {
    return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isWrappingType(type) && isOutputType(type.ofType);
}
function assertOutputType(type) {
    if (!isOutputType(type)) {
        throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL output type.`);
    }
    return type;
}
/**
 * These types may describe types which may be leaf values.
 */ function isLeafType(type) {
    return isScalarType(type) || isEnumType(type);
}
function assertLeafType(type) {
    if (!isLeafType(type)) {
        throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL leaf type.`);
    }
    return type;
}
/**
 * These types may describe the parent context of a selection set.
 */ function isCompositeType(type) {
    return isObjectType(type) || isInterfaceType(type) || isUnionType(type);
}
function assertCompositeType(type) {
    if (!isCompositeType(type)) {
        throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL composite type.`);
    }
    return type;
}
/**
 * These types may describe the parent context of a selection set.
 */ function isAbstractType(type) {
    return isInterfaceType(type) || isUnionType(type);
}
function assertAbstractType(type) {
    if (!isAbstractType(type)) {
        throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL abstract type.`);
    }
    return type;
}
/**
 * List Type Wrapper
 *
 * A list is a wrapping type which points to another type.
 * Lists are often created within the context of defining the fields of
 * an object type.
 *
 * Example:
 *
 * ```ts
 * const PersonType = new GraphQLObjectType({
 *   name: 'Person',
 *   fields: () => ({
 *     parents: { type: new GraphQLList(PersonType) },
 *     children: { type: new GraphQLList(PersonType) },
 *   })
 * })
 * ```
 */ class GraphQLList {
    constructor(ofType){
        isType(ofType) || (0, _devAssert.devAssert)(false, `Expected ${(0, _inspect.inspect)(ofType)} to be a GraphQL type.`);
        this.ofType = ofType;
    }
    get [Symbol.toStringTag]() {
        return "GraphQLList";
    }
    toString() {
        return "[" + String(this.ofType) + "]";
    }
    toJSON() {
        return this.toString();
    }
}
/**
 * Non-Null Type Wrapper
 *
 * A non-null is a wrapping type which points to another type.
 * Non-null types enforce that their values are never null and can ensure
 * an error is raised if this ever occurs during a request. It is useful for
 * fields which you can make a strong guarantee on non-nullability, for example
 * usually the id field of a database row will never be null.
 *
 * Example:
 *
 * ```ts
 * const RowType = new GraphQLObjectType({
 *   name: 'Row',
 *   fields: () => ({
 *     id: { type: new GraphQLNonNull(GraphQLString) },
 *   })
 * })
 * ```
 * Note: the enforcement of non-nullability occurs within the executor.
 */ exports.GraphQLList = GraphQLList;
class GraphQLNonNull {
    constructor(ofType){
        isNullableType(ofType) || (0, _devAssert.devAssert)(false, `Expected ${(0, _inspect.inspect)(ofType)} to be a GraphQL nullable type.`);
        this.ofType = ofType;
    }
    get [Symbol.toStringTag]() {
        return "GraphQLNonNull";
    }
    toString() {
        return String(this.ofType) + "!";
    }
    toJSON() {
        return this.toString();
    }
}
/**
 * These types wrap and modify other types
 */ exports.GraphQLNonNull = GraphQLNonNull;
function isWrappingType(type) {
    return isListType(type) || isNonNullType(type);
}
function assertWrappingType(type) {
    if (!isWrappingType(type)) {
        throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL wrapping type.`);
    }
    return type;
}
/**
 * These types can all accept null as a value.
 */ function isNullableType(type) {
    return isType(type) && !isNonNullType(type);
}
function assertNullableType(type) {
    if (!isNullableType(type)) {
        throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL nullable type.`);
    }
    return type;
}
function getNullableType(type) {
    if (type) {
        return isNonNullType(type) ? type.ofType : type;
    }
}
/**
 * These named types do not include modifiers like List or NonNull.
 */ function isNamedType(type) {
    return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type);
}
function assertNamedType(type) {
    if (!isNamedType(type)) {
        throw new Error(`Expected ${(0, _inspect.inspect)(type)} to be a GraphQL named type.`);
    }
    return type;
}
function getNamedType(type) {
    if (type) {
        let unwrappedType = type;
        while(isWrappingType(unwrappedType)){
            unwrappedType = unwrappedType.ofType;
        }
        return unwrappedType;
    }
}
/**
 * Used while defining GraphQL types to allow for circular references in
 * otherwise immutable type definitions.
 */ function resolveReadonlyArrayThunk(thunk) {
    return typeof thunk === "function" ? thunk() : thunk;
}
function resolveObjMapThunk(thunk) {
    return typeof thunk === "function" ? thunk() : thunk;
}
/**
 * Custom extensions
 *
 * @remarks
 * Use a unique identifier name for your extension, for example the name of
 * your library or project. Do not use a shortened identifier as this increases
 * the risk of conflicts. We recommend you add at most one extension field,
 * an object which can contain all the values you need.
 */ /**
 * Scalar Type Definition
 *
 * The leaf values of any request and input values to arguments are
 * Scalars (or Enums) and are defined with a name and a series of functions
 * used to parse input from ast or variables and to ensure validity.
 *
 * If a type's serialize function returns `null` or does not return a value
 * (i.e. it returns `undefined`) then an error will be raised and a `null`
 * value will be returned in the response. It is always better to validate
 *
 * Example:
 *
 * ```ts
 * const OddType = new GraphQLScalarType({
 *   name: 'Odd',
 *   serialize(value) {
 *     if (!Number.isFinite(value)) {
 *       throw new Error(
 *         `Scalar "Odd" cannot represent "${value}" since it is not a finite number.`,
 *       );
 *     }
 *
 *     if (value % 2 === 0) {
 *       throw new Error(`Scalar "Odd" cannot represent "${value}" since it is even.`);
 *     }
 *     return value;
 *   }
 * });
 * ```
 */ class GraphQLScalarType {
    constructor(config){
        var _config$parseValue, _config$serialize, _config$parseLiteral, _config$extensionASTN;
        const parseValue = (_config$parseValue = config.parseValue) !== null && _config$parseValue !== void 0 ? _config$parseValue : _identityFunc.identityFunc;
        this.name = (0, _assertName.assertName)(config.name);
        this.description = config.description;
        this.specifiedByURL = config.specifiedByURL;
        this.serialize = (_config$serialize = config.serialize) !== null && _config$serialize !== void 0 ? _config$serialize : _identityFunc.identityFunc;
        this.parseValue = parseValue;
        this.parseLiteral = (_config$parseLiteral = config.parseLiteral) !== null && _config$parseLiteral !== void 0 ? _config$parseLiteral : (node, variables)=>parseValue((0, _valueFromASTUntyped.valueFromASTUntyped)(node, variables));
        this.extensions = (0, _toObjMap.toObjMap)(config.extensions);
        this.astNode = config.astNode;
        this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];
        config.specifiedByURL == null || typeof config.specifiedByURL === "string" || (0, _devAssert.devAssert)(false, `${this.name} must provide "specifiedByURL" as a string, ` + `but got: ${(0, _inspect.inspect)(config.specifiedByURL)}.`);
        config.serialize == null || typeof config.serialize === "function" || (0, _devAssert.devAssert)(false, `${this.name} must provide "serialize" function. If this custom Scalar is also used as an input type, ensure "parseValue" and "parseLiteral" functions are also provided.`);
        if (config.parseLiteral) {
            typeof config.parseValue === "function" && typeof config.parseLiteral === "function" || (0, _devAssert.devAssert)(false, `${this.name} must provide both "parseValue" and "parseLiteral" functions.`);
        }
    }
    get [Symbol.toStringTag]() {
        return "GraphQLScalarType";
    }
    toConfig() {
        return {
            name: this.name,
            description: this.description,
            specifiedByURL: this.specifiedByURL,
            serialize: this.serialize,
            parseValue: this.parseValue,
            parseLiteral: this.parseLiteral,
            extensions: this.extensions,
            astNode: this.astNode,
            extensionASTNodes: this.extensionASTNodes
        };
    }
    toString() {
        return this.name;
    }
    toJSON() {
        return this.toString();
    }
}
exports.GraphQLScalarType = GraphQLScalarType;
/**
 * Object Type Definition
 *
 * Almost all of the GraphQL types you define will be object types. Object types
 * have a name, but most importantly describe their fields.
 *
 * Example:
 *
 * ```ts
 * const AddressType = new GraphQLObjectType({
 *   name: 'Address',
 *   fields: {
 *     street: { type: GraphQLString },
 *     number: { type: GraphQLInt },
 *     formatted: {
 *       type: GraphQLString,
 *       resolve(obj) {
 *         return obj.number + ' ' + obj.street
 *       }
 *     }
 *   }
 * });
 * ```
 *
 * When two types need to refer to each other, or a type needs to refer to
 * itself in a field, you can use a function expression (aka a closure or a
 * thunk) to supply the fields lazily.
 *
 * Example:
 *
 * ```ts
 * const PersonType = new GraphQLObjectType({
 *   name: 'Person',
 *   fields: () => ({
 *     name: { type: GraphQLString },
 *     bestFriend: { type: PersonType },
 *   })
 * });
 * ```
 */ class GraphQLObjectType {
    constructor(config){
        var _config$extensionASTN2;
        this.name = (0, _assertName.assertName)(config.name);
        this.description = config.description;
        this.isTypeOf = config.isTypeOf;
        this.extensions = (0, _toObjMap.toObjMap)(config.extensions);
        this.astNode = config.astNode;
        this.extensionASTNodes = (_config$extensionASTN2 = config.extensionASTNodes) !== null && _config$extensionASTN2 !== void 0 ? _config$extensionASTN2 : [];
        this._fields = ()=>defineFieldMap(config);
        this._interfaces = ()=>defineInterfaces(config);
        config.isTypeOf == null || typeof config.isTypeOf === "function" || (0, _devAssert.devAssert)(false, `${this.name} must provide "isTypeOf" as a function, ` + `but got: ${(0, _inspect.inspect)(config.isTypeOf)}.`);
    }
    get [Symbol.toStringTag]() {
        return "GraphQLObjectType";
    }
    getFields() {
        if (typeof this._fields === "function") {
            this._fields = this._fields();
        }
        return this._fields;
    }
    getInterfaces() {
        if (typeof this._interfaces === "function") {
            this._interfaces = this._interfaces();
        }
        return this._interfaces;
    }
    toConfig() {
        return {
            name: this.name,
            description: this.description,
            interfaces: this.getInterfaces(),
            fields: fieldsToFieldsConfig(this.getFields()),
            isTypeOf: this.isTypeOf,
            extensions: this.extensions,
            astNode: this.astNode,
            extensionASTNodes: this.extensionASTNodes
        };
    }
    toString() {
        return this.name;
    }
    toJSON() {
        return this.toString();
    }
}
exports.GraphQLObjectType = GraphQLObjectType;
function defineInterfaces(config) {
    var _config$interfaces;
    const interfaces = resolveReadonlyArrayThunk((_config$interfaces = config.interfaces) !== null && _config$interfaces !== void 0 ? _config$interfaces : []);
    Array.isArray(interfaces) || (0, _devAssert.devAssert)(false, `${config.name} interfaces must be an Array or a function which returns an Array.`);
    return interfaces;
}
function defineFieldMap(config) {
    const fieldMap = resolveObjMapThunk(config.fields);
    isPlainObj(fieldMap) || (0, _devAssert.devAssert)(false, `${config.name} fields must be an object with field names as keys or a function which returns such an object.`);
    return (0, _mapValue.mapValue)(fieldMap, (fieldConfig, fieldName)=>{
        var _fieldConfig$args;
        isPlainObj(fieldConfig) || (0, _devAssert.devAssert)(false, `${config.name}.${fieldName} field config must be an object.`);
        fieldConfig.resolve == null || typeof fieldConfig.resolve === "function" || (0, _devAssert.devAssert)(false, `${config.name}.${fieldName} field resolver must be a function if ` + `provided, but got: ${(0, _inspect.inspect)(fieldConfig.resolve)}.`);
        const argsConfig = (_fieldConfig$args = fieldConfig.args) !== null && _fieldConfig$args !== void 0 ? _fieldConfig$args : {};
        isPlainObj(argsConfig) || (0, _devAssert.devAssert)(false, `${config.name}.${fieldName} args must be an object with argument names as keys.`);
        return {
            name: (0, _assertName.assertName)(fieldName),
            description: fieldConfig.description,
            type: fieldConfig.type,
            args: defineArguments(argsConfig),
            resolve: fieldConfig.resolve,
            subscribe: fieldConfig.subscribe,
            deprecationReason: fieldConfig.deprecationReason,
            extensions: (0, _toObjMap.toObjMap)(fieldConfig.extensions),
            astNode: fieldConfig.astNode
        };
    });
}
function defineArguments(config) {
    return Object.entries(config).map(([argName, argConfig])=>({
            name: (0, _assertName.assertName)(argName),
            description: argConfig.description,
            type: argConfig.type,
            defaultValue: argConfig.defaultValue,
            deprecationReason: argConfig.deprecationReason,
            extensions: (0, _toObjMap.toObjMap)(argConfig.extensions),
            astNode: argConfig.astNode
        }));
}
function isPlainObj(obj) {
    return (0, _isObjectLike.isObjectLike)(obj) && !Array.isArray(obj);
}
function fieldsToFieldsConfig(fields) {
    return (0, _mapValue.mapValue)(fields, (field)=>({
            description: field.description,
            type: field.type,
            args: argsToArgsConfig(field.args),
            resolve: field.resolve,
            subscribe: field.subscribe,
            deprecationReason: field.deprecationReason,
            extensions: field.extensions,
            astNode: field.astNode
        }));
}
/**
 * @internal
 */ function argsToArgsConfig(args) {
    return (0, _keyValMap.keyValMap)(args, (arg)=>arg.name, (arg)=>({
            description: arg.description,
            type: arg.type,
            defaultValue: arg.defaultValue,
            deprecationReason: arg.deprecationReason,
            extensions: arg.extensions,
            astNode: arg.astNode
        }));
}
function isRequiredArgument(arg) {
    return isNonNullType(arg.type) && arg.defaultValue === undefined;
}
/**
 * Interface Type Definition
 *
 * When a field can return one of a heterogeneous set of types, a Interface type
 * is used to describe what types are possible, what fields are in common across
 * all types, as well as a function to determine which type is actually used
 * when the field is resolved.
 *
 * Example:
 *
 * ```ts
 * const EntityType = new GraphQLInterfaceType({
 *   name: 'Entity',
 *   fields: {
 *     name: { type: GraphQLString }
 *   }
 * });
 * ```
 */ class GraphQLInterfaceType {
    constructor(config){
        var _config$extensionASTN3;
        this.name = (0, _assertName.assertName)(config.name);
        this.description = config.description;
        this.resolveType = config.resolveType;
        this.extensions = (0, _toObjMap.toObjMap)(config.extensions);
        this.astNode = config.astNode;
        this.extensionASTNodes = (_config$extensionASTN3 = config.extensionASTNodes) !== null && _config$extensionASTN3 !== void 0 ? _config$extensionASTN3 : [];
        this._fields = defineFieldMap.bind(undefined, config);
        this._interfaces = defineInterfaces.bind(undefined, config);
        config.resolveType == null || typeof config.resolveType === "function" || (0, _devAssert.devAssert)(false, `${this.name} must provide "resolveType" as a function, ` + `but got: ${(0, _inspect.inspect)(config.resolveType)}.`);
    }
    get [Symbol.toStringTag]() {
        return "GraphQLInterfaceType";
    }
    getFields() {
        if (typeof this._fields === "function") {
            this._fields = this._fields();
        }
        return this._fields;
    }
    getInterfaces() {
        if (typeof this._interfaces === "function") {
            this._interfaces = this._interfaces();
        }
        return this._interfaces;
    }
    toConfig() {
        return {
            name: this.name,
            description: this.description,
            interfaces: this.getInterfaces(),
            fields: fieldsToFieldsConfig(this.getFields()),
            resolveType: this.resolveType,
            extensions: this.extensions,
            astNode: this.astNode,
            extensionASTNodes: this.extensionASTNodes
        };
    }
    toString() {
        return this.name;
    }
    toJSON() {
        return this.toString();
    }
}
exports.GraphQLInterfaceType = GraphQLInterfaceType;
/**
 * Union Type Definition
 *
 * When a field can return one of a heterogeneous set of types, a Union type
 * is used to describe what types are possible as well as providing a function
 * to determine which type is actually used when the field is resolved.
 *
 * Example:
 *
 * ```ts
 * const PetType = new GraphQLUnionType({
 *   name: 'Pet',
 *   types: [ DogType, CatType ],
 *   resolveType(value) {
 *     if (value instanceof Dog) {
 *       return DogType;
 *     }
 *     if (value instanceof Cat) {
 *       return CatType;
 *     }
 *   }
 * });
 * ```
 */ class GraphQLUnionType {
    constructor(config){
        var _config$extensionASTN4;
        this.name = (0, _assertName.assertName)(config.name);
        this.description = config.description;
        this.resolveType = config.resolveType;
        this.extensions = (0, _toObjMap.toObjMap)(config.extensions);
        this.astNode = config.astNode;
        this.extensionASTNodes = (_config$extensionASTN4 = config.extensionASTNodes) !== null && _config$extensionASTN4 !== void 0 ? _config$extensionASTN4 : [];
        this._types = defineTypes.bind(undefined, config);
        config.resolveType == null || typeof config.resolveType === "function" || (0, _devAssert.devAssert)(false, `${this.name} must provide "resolveType" as a function, ` + `but got: ${(0, _inspect.inspect)(config.resolveType)}.`);
    }
    get [Symbol.toStringTag]() {
        return "GraphQLUnionType";
    }
    getTypes() {
        if (typeof this._types === "function") {
            this._types = this._types();
        }
        return this._types;
    }
    toConfig() {
        return {
            name: this.name,
            description: this.description,
            types: this.getTypes(),
            resolveType: this.resolveType,
            extensions: this.extensions,
            astNode: this.astNode,
            extensionASTNodes: this.extensionASTNodes
        };
    }
    toString() {
        return this.name;
    }
    toJSON() {
        return this.toString();
    }
}
exports.GraphQLUnionType = GraphQLUnionType;
function defineTypes(config) {
    const types = resolveReadonlyArrayThunk(config.types);
    Array.isArray(types) || (0, _devAssert.devAssert)(false, `Must provide Array of types or a function which returns such an array for Union ${config.name}.`);
    return types;
}
/**
 * Enum Type Definition
 *
 * Some leaf values of requests and input values are Enums. GraphQL serializes
 * Enum values as strings, however internally Enums can be represented by any
 * kind of type, often integers.
 *
 * Example:
 *
 * ```ts
 * const RGBType = new GraphQLEnumType({
 *   name: 'RGB',
 *   values: {
 *     RED: { value: 0 },
 *     GREEN: { value: 1 },
 *     BLUE: { value: 2 }
 *   }
 * });
 * ```
 *
 * Note: If a value is not provided in a definition, the name of the enum value
 * will be used as its internal value.
 */ class GraphQLEnumType {
    /* <T> */ constructor(config){
        var _config$extensionASTN5;
        this.name = (0, _assertName.assertName)(config.name);
        this.description = config.description;
        this.extensions = (0, _toObjMap.toObjMap)(config.extensions);
        this.astNode = config.astNode;
        this.extensionASTNodes = (_config$extensionASTN5 = config.extensionASTNodes) !== null && _config$extensionASTN5 !== void 0 ? _config$extensionASTN5 : [];
        this._values = defineEnumValues(this.name, config.values);
        this._valueLookup = new Map(this._values.map((enumValue)=>[
                enumValue.value,
                enumValue
            ]));
        this._nameLookup = (0, _keyMap.keyMap)(this._values, (value)=>value.name);
    }
    get [Symbol.toStringTag]() {
        return "GraphQLEnumType";
    }
    getValues() {
        return this._values;
    }
    getValue(name) {
        return this._nameLookup[name];
    }
    serialize(outputValue) {
        const enumValue = this._valueLookup.get(outputValue);
        if (enumValue === undefined) {
            throw new _GraphQLError.GraphQLError(`Enum "${this.name}" cannot represent value: ${(0, _inspect.inspect)(outputValue)}`);
        }
        return enumValue.name;
    }
    parseValue(inputValue) /* T */ {
        if (typeof inputValue !== "string") {
            const valueStr = (0, _inspect.inspect)(inputValue);
            throw new _GraphQLError.GraphQLError(`Enum "${this.name}" cannot represent non-string value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr));
        }
        const enumValue = this.getValue(inputValue);
        if (enumValue == null) {
            throw new _GraphQLError.GraphQLError(`Value "${inputValue}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, inputValue));
        }
        return enumValue.value;
    }
    parseLiteral(valueNode, _variables) /* T */ {
        // Note: variables will be resolved to a value before calling this function.
        if (valueNode.kind !== _kinds.Kind.ENUM) {
            const valueStr = (0, _printer.print)(valueNode);
            throw new _GraphQLError.GraphQLError(`Enum "${this.name}" cannot represent non-enum value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr), {
                nodes: valueNode
            });
        }
        const enumValue = this.getValue(valueNode.value);
        if (enumValue == null) {
            const valueStr = (0, _printer.print)(valueNode);
            throw new _GraphQLError.GraphQLError(`Value "${valueStr}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, valueStr), {
                nodes: valueNode
            });
        }
        return enumValue.value;
    }
    toConfig() {
        const values = (0, _keyValMap.keyValMap)(this.getValues(), (value)=>value.name, (value)=>({
                description: value.description,
                value: value.value,
                deprecationReason: value.deprecationReason,
                extensions: value.extensions,
                astNode: value.astNode
            }));
        return {
            name: this.name,
            description: this.description,
            values,
            extensions: this.extensions,
            astNode: this.astNode,
            extensionASTNodes: this.extensionASTNodes
        };
    }
    toString() {
        return this.name;
    }
    toJSON() {
        return this.toString();
    }
}
exports.GraphQLEnumType = GraphQLEnumType;
function didYouMeanEnumValue(enumType, unknownValueStr) {
    const allNames = enumType.getValues().map((value)=>value.name);
    const suggestedValues = (0, _suggestionList.suggestionList)(unknownValueStr, allNames);
    return (0, _didYouMean.didYouMean)("the enum value", suggestedValues);
}
function defineEnumValues(typeName, valueMap) {
    isPlainObj(valueMap) || (0, _devAssert.devAssert)(false, `${typeName} values must be an object with value names as keys.`);
    return Object.entries(valueMap).map(([valueName, valueConfig])=>{
        isPlainObj(valueConfig) || (0, _devAssert.devAssert)(false, `${typeName}.${valueName} must refer to an object with a "value" key ` + `representing an internal value but got: ${(0, _inspect.inspect)(valueConfig)}.`);
        return {
            name: (0, _assertName.assertEnumValueName)(valueName),
            description: valueConfig.description,
            value: valueConfig.value !== undefined ? valueConfig.value : valueName,
            deprecationReason: valueConfig.deprecationReason,
            extensions: (0, _toObjMap.toObjMap)(valueConfig.extensions),
            astNode: valueConfig.astNode
        };
    });
}
/**
 * Input Object Type Definition
 *
 * An input object defines a structured collection of fields which may be
 * supplied to a field argument.
 *
 * Using `NonNull` will ensure that a value must be provided by the query
 *
 * Example:
 *
 * ```ts
 * const GeoPoint = new GraphQLInputObjectType({
 *   name: 'GeoPoint',
 *   fields: {
 *     lat: { type: new GraphQLNonNull(GraphQLFloat) },
 *     lon: { type: new GraphQLNonNull(GraphQLFloat) },
 *     alt: { type: GraphQLFloat, defaultValue: 0 },
 *   }
 * });
 * ```
 */ class GraphQLInputObjectType {
    constructor(config){
        var _config$extensionASTN6;
        this.name = (0, _assertName.assertName)(config.name);
        this.description = config.description;
        this.extensions = (0, _toObjMap.toObjMap)(config.extensions);
        this.astNode = config.astNode;
        this.extensionASTNodes = (_config$extensionASTN6 = config.extensionASTNodes) !== null && _config$extensionASTN6 !== void 0 ? _config$extensionASTN6 : [];
        this._fields = defineInputFieldMap.bind(undefined, config);
    }
    get [Symbol.toStringTag]() {
        return "GraphQLInputObjectType";
    }
    getFields() {
        if (typeof this._fields === "function") {
            this._fields = this._fields();
        }
        return this._fields;
    }
    toConfig() {
        const fields = (0, _mapValue.mapValue)(this.getFields(), (field)=>({
                description: field.description,
                type: field.type,
                defaultValue: field.defaultValue,
                deprecationReason: field.deprecationReason,
                extensions: field.extensions,
                astNode: field.astNode
            }));
        return {
            name: this.name,
            description: this.description,
            fields,
            extensions: this.extensions,
            astNode: this.astNode,
            extensionASTNodes: this.extensionASTNodes
        };
    }
    toString() {
        return this.name;
    }
    toJSON() {
        return this.toString();
    }
}
exports.GraphQLInputObjectType = GraphQLInputObjectType;
function defineInputFieldMap(config) {
    const fieldMap = resolveObjMapThunk(config.fields);
    isPlainObj(fieldMap) || (0, _devAssert.devAssert)(false, `${config.name} fields must be an object with field names as keys or a function which returns such an object.`);
    return (0, _mapValue.mapValue)(fieldMap, (fieldConfig, fieldName)=>{
        !("resolve" in fieldConfig) || (0, _devAssert.devAssert)(false, `${config.name}.${fieldName} field has a resolve property, but Input Types cannot define resolvers.`);
        return {
            name: (0, _assertName.assertName)(fieldName),
            description: fieldConfig.description,
            type: fieldConfig.type,
            defaultValue: fieldConfig.defaultValue,
            deprecationReason: fieldConfig.deprecationReason,
            extensions: (0, _toObjMap.toObjMap)(fieldConfig.extensions),
            astNode: fieldConfig.astNode
        };
    });
}
function isRequiredInputField(field) {
    return isNonNullType(field.type) && field.defaultValue === undefined;
}


/***/ }),

/***/ 3554:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.GraphQLSpecifiedByDirective = exports.GraphQLSkipDirective = exports.GraphQLIncludeDirective = exports.GraphQLDirective = exports.GraphQLDeprecatedDirective = exports.DEFAULT_DEPRECATION_REASON = void 0;
exports.assertDirective = assertDirective;
exports.isDirective = isDirective;
exports.isSpecifiedDirective = isSpecifiedDirective;
exports.specifiedDirectives = void 0;
var _devAssert = __webpack_require__(90);
var _inspect = __webpack_require__(8089);
var _instanceOf = __webpack_require__(9738);
var _isObjectLike = __webpack_require__(5564);
var _toObjMap = __webpack_require__(5891);
var _directiveLocation = __webpack_require__(7936);
var _assertName = __webpack_require__(2039);
var _definition = __webpack_require__(7982);
var _scalars = __webpack_require__(9570);
/**
 * Test if the given value is a GraphQL directive.
 */ function isDirective(directive) {
    return (0, _instanceOf.instanceOf)(directive, GraphQLDirective);
}
function assertDirective(directive) {
    if (!isDirective(directive)) {
        throw new Error(`Expected ${(0, _inspect.inspect)(directive)} to be a GraphQL directive.`);
    }
    return directive;
}
/**
 * Custom extensions
 *
 * @remarks
 * Use a unique identifier name for your extension, for example the name of
 * your library or project. Do not use a shortened identifier as this increases
 * the risk of conflicts. We recommend you add at most one extension field,
 * an object which can contain all the values you need.
 */ /**
 * Directives are used by the GraphQL runtime as a way of modifying execution
 * behavior. Type system creators will usually not create these directly.
 */ class GraphQLDirective {
    constructor(config){
        var _config$isRepeatable, _config$args;
        this.name = (0, _assertName.assertName)(config.name);
        this.description = config.description;
        this.locations = config.locations;
        this.isRepeatable = (_config$isRepeatable = config.isRepeatable) !== null && _config$isRepeatable !== void 0 ? _config$isRepeatable : false;
        this.extensions = (0, _toObjMap.toObjMap)(config.extensions);
        this.astNode = config.astNode;
        Array.isArray(config.locations) || (0, _devAssert.devAssert)(false, `@${config.name} locations must be an Array.`);
        const args = (_config$args = config.args) !== null && _config$args !== void 0 ? _config$args : {};
        (0, _isObjectLike.isObjectLike)(args) && !Array.isArray(args) || (0, _devAssert.devAssert)(false, `@${config.name} args must be an object with argument names as keys.`);
        this.args = (0, _definition.defineArguments)(args);
    }
    get [Symbol.toStringTag]() {
        return "GraphQLDirective";
    }
    toConfig() {
        return {
            name: this.name,
            description: this.description,
            locations: this.locations,
            args: (0, _definition.argsToArgsConfig)(this.args),
            isRepeatable: this.isRepeatable,
            extensions: this.extensions,
            astNode: this.astNode
        };
    }
    toString() {
        return "@" + this.name;
    }
    toJSON() {
        return this.toString();
    }
}
exports.GraphQLDirective = GraphQLDirective;
/**
 * Used to conditionally include fields or fragments.
 */ const GraphQLIncludeDirective = new GraphQLDirective({
    name: "include",
    description: "Directs the executor to include this field or fragment only when the `if` argument is true.",
    locations: [
        _directiveLocation.DirectiveLocation.FIELD,
        _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD,
        _directiveLocation.DirectiveLocation.INLINE_FRAGMENT
    ],
    args: {
        if: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
            description: "Included when true."
        }
    }
});
/**
 * Used to conditionally skip (exclude) fields or fragments.
 */ exports.GraphQLIncludeDirective = GraphQLIncludeDirective;
const GraphQLSkipDirective = new GraphQLDirective({
    name: "skip",
    description: "Directs the executor to skip this field or fragment when the `if` argument is true.",
    locations: [
        _directiveLocation.DirectiveLocation.FIELD,
        _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD,
        _directiveLocation.DirectiveLocation.INLINE_FRAGMENT
    ],
    args: {
        if: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
            description: "Skipped when true."
        }
    }
});
/**
 * Constant string used for default reason for a deprecation.
 */ exports.GraphQLSkipDirective = GraphQLSkipDirective;
const DEFAULT_DEPRECATION_REASON = "No longer supported";
/**
 * Used to declare element of a GraphQL schema as deprecated.
 */ exports.DEFAULT_DEPRECATION_REASON = DEFAULT_DEPRECATION_REASON;
const GraphQLDeprecatedDirective = new GraphQLDirective({
    name: "deprecated",
    description: "Marks an element of a GraphQL schema as no longer supported.",
    locations: [
        _directiveLocation.DirectiveLocation.FIELD_DEFINITION,
        _directiveLocation.DirectiveLocation.ARGUMENT_DEFINITION,
        _directiveLocation.DirectiveLocation.INPUT_FIELD_DEFINITION,
        _directiveLocation.DirectiveLocation.ENUM_VALUE
    ],
    args: {
        reason: {
            type: _scalars.GraphQLString,
            description: "Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax, as specified by [CommonMark](https://commonmark.org/).",
            defaultValue: DEFAULT_DEPRECATION_REASON
        }
    }
});
/**
 * Used to provide a URL for specifying the behavior of custom scalar definitions.
 */ exports.GraphQLDeprecatedDirective = GraphQLDeprecatedDirective;
const GraphQLSpecifiedByDirective = new GraphQLDirective({
    name: "specifiedBy",
    description: "Exposes a URL that specifies the behavior of this scalar.",
    locations: [
        _directiveLocation.DirectiveLocation.SCALAR
    ],
    args: {
        url: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
            description: "The URL that specifies the behavior of this scalar."
        }
    }
});
/**
 * The full list of specified directives.
 */ exports.GraphQLSpecifiedByDirective = GraphQLSpecifiedByDirective;
const specifiedDirectives = Object.freeze([
    GraphQLIncludeDirective,
    GraphQLSkipDirective,
    GraphQLDeprecatedDirective,
    GraphQLSpecifiedByDirective
]);
exports.specifiedDirectives = specifiedDirectives;
function isSpecifiedDirective(directive) {
    return specifiedDirectives.some(({ name  })=>name === directive.name);
}


/***/ }),

/***/ 6351:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "DEFAULT_DEPRECATION_REASON", ({
    enumerable: true,
    get: function() {
        return _directives.DEFAULT_DEPRECATION_REASON;
    }
}));
Object.defineProperty(exports, "GRAPHQL_MAX_INT", ({
    enumerable: true,
    get: function() {
        return _scalars.GRAPHQL_MAX_INT;
    }
}));
Object.defineProperty(exports, "GRAPHQL_MIN_INT", ({
    enumerable: true,
    get: function() {
        return _scalars.GRAPHQL_MIN_INT;
    }
}));
Object.defineProperty(exports, "GraphQLBoolean", ({
    enumerable: true,
    get: function() {
        return _scalars.GraphQLBoolean;
    }
}));
Object.defineProperty(exports, "GraphQLDeprecatedDirective", ({
    enumerable: true,
    get: function() {
        return _directives.GraphQLDeprecatedDirective;
    }
}));
Object.defineProperty(exports, "GraphQLDirective", ({
    enumerable: true,
    get: function() {
        return _directives.GraphQLDirective;
    }
}));
Object.defineProperty(exports, "GraphQLEnumType", ({
    enumerable: true,
    get: function() {
        return _definition.GraphQLEnumType;
    }
}));
Object.defineProperty(exports, "GraphQLFloat", ({
    enumerable: true,
    get: function() {
        return _scalars.GraphQLFloat;
    }
}));
Object.defineProperty(exports, "GraphQLID", ({
    enumerable: true,
    get: function() {
        return _scalars.GraphQLID;
    }
}));
Object.defineProperty(exports, "GraphQLIncludeDirective", ({
    enumerable: true,
    get: function() {
        return _directives.GraphQLIncludeDirective;
    }
}));
Object.defineProperty(exports, "GraphQLInputObjectType", ({
    enumerable: true,
    get: function() {
        return _definition.GraphQLInputObjectType;
    }
}));
Object.defineProperty(exports, "GraphQLInt", ({
    enumerable: true,
    get: function() {
        return _scalars.GraphQLInt;
    }
}));
Object.defineProperty(exports, "GraphQLInterfaceType", ({
    enumerable: true,
    get: function() {
        return _definition.GraphQLInterfaceType;
    }
}));
Object.defineProperty(exports, "GraphQLList", ({
    enumerable: true,
    get: function() {
        return _definition.GraphQLList;
    }
}));
Object.defineProperty(exports, "GraphQLNonNull", ({
    enumerable: true,
    get: function() {
        return _definition.GraphQLNonNull;
    }
}));
Object.defineProperty(exports, "GraphQLObjectType", ({
    enumerable: true,
    get: function() {
        return _definition.GraphQLObjectType;
    }
}));
Object.defineProperty(exports, "GraphQLScalarType", ({
    enumerable: true,
    get: function() {
        return _definition.GraphQLScalarType;
    }
}));
Object.defineProperty(exports, "GraphQLSchema", ({
    enumerable: true,
    get: function() {
        return _schema.GraphQLSchema;
    }
}));
Object.defineProperty(exports, "GraphQLSkipDirective", ({
    enumerable: true,
    get: function() {
        return _directives.GraphQLSkipDirective;
    }
}));
Object.defineProperty(exports, "GraphQLSpecifiedByDirective", ({
    enumerable: true,
    get: function() {
        return _directives.GraphQLSpecifiedByDirective;
    }
}));
Object.defineProperty(exports, "GraphQLString", ({
    enumerable: true,
    get: function() {
        return _scalars.GraphQLString;
    }
}));
Object.defineProperty(exports, "GraphQLUnionType", ({
    enumerable: true,
    get: function() {
        return _definition.GraphQLUnionType;
    }
}));
Object.defineProperty(exports, "SchemaMetaFieldDef", ({
    enumerable: true,
    get: function() {
        return _introspection.SchemaMetaFieldDef;
    }
}));
Object.defineProperty(exports, "TypeKind", ({
    enumerable: true,
    get: function() {
        return _introspection.TypeKind;
    }
}));
Object.defineProperty(exports, "TypeMetaFieldDef", ({
    enumerable: true,
    get: function() {
        return _introspection.TypeMetaFieldDef;
    }
}));
Object.defineProperty(exports, "TypeNameMetaFieldDef", ({
    enumerable: true,
    get: function() {
        return _introspection.TypeNameMetaFieldDef;
    }
}));
Object.defineProperty(exports, "__Directive", ({
    enumerable: true,
    get: function() {
        return _introspection.__Directive;
    }
}));
Object.defineProperty(exports, "__DirectiveLocation", ({
    enumerable: true,
    get: function() {
        return _introspection.__DirectiveLocation;
    }
}));
Object.defineProperty(exports, "__EnumValue", ({
    enumerable: true,
    get: function() {
        return _introspection.__EnumValue;
    }
}));
Object.defineProperty(exports, "__Field", ({
    enumerable: true,
    get: function() {
        return _introspection.__Field;
    }
}));
Object.defineProperty(exports, "__InputValue", ({
    enumerable: true,
    get: function() {
        return _introspection.__InputValue;
    }
}));
Object.defineProperty(exports, "__Schema", ({
    enumerable: true,
    get: function() {
        return _introspection.__Schema;
    }
}));
Object.defineProperty(exports, "__Type", ({
    enumerable: true,
    get: function() {
        return _introspection.__Type;
    }
}));
Object.defineProperty(exports, "__TypeKind", ({
    enumerable: true,
    get: function() {
        return _introspection.__TypeKind;
    }
}));
Object.defineProperty(exports, "assertAbstractType", ({
    enumerable: true,
    get: function() {
        return _definition.assertAbstractType;
    }
}));
Object.defineProperty(exports, "assertCompositeType", ({
    enumerable: true,
    get: function() {
        return _definition.assertCompositeType;
    }
}));
Object.defineProperty(exports, "assertDirective", ({
    enumerable: true,
    get: function() {
        return _directives.assertDirective;
    }
}));
Object.defineProperty(exports, "assertEnumType", ({
    enumerable: true,
    get: function() {
        return _definition.assertEnumType;
    }
}));
Object.defineProperty(exports, "assertEnumValueName", ({
    enumerable: true,
    get: function() {
        return _assertName.assertEnumValueName;
    }
}));
Object.defineProperty(exports, "assertInputObjectType", ({
    enumerable: true,
    get: function() {
        return _definition.assertInputObjectType;
    }
}));
Object.defineProperty(exports, "assertInputType", ({
    enumerable: true,
    get: function() {
        return _definition.assertInputType;
    }
}));
Object.defineProperty(exports, "assertInterfaceType", ({
    enumerable: true,
    get: function() {
        return _definition.assertInterfaceType;
    }
}));
Object.defineProperty(exports, "assertLeafType", ({
    enumerable: true,
    get: function() {
        return _definition.assertLeafType;
    }
}));
Object.defineProperty(exports, "assertListType", ({
    enumerable: true,
    get: function() {
        return _definition.assertListType;
    }
}));
Object.defineProperty(exports, "assertName", ({
    enumerable: true,
    get: function() {
        return _assertName.assertName;
    }
}));
Object.defineProperty(exports, "assertNamedType", ({
    enumerable: true,
    get: function() {
        return _definition.assertNamedType;
    }
}));
Object.defineProperty(exports, "assertNonNullType", ({
    enumerable: true,
    get: function() {
        return _definition.assertNonNullType;
    }
}));
Object.defineProperty(exports, "assertNullableType", ({
    enumerable: true,
    get: function() {
        return _definition.assertNullableType;
    }
}));
Object.defineProperty(exports, "assertObjectType", ({
    enumerable: true,
    get: function() {
        return _definition.assertObjectType;
    }
}));
Object.defineProperty(exports, "assertOutputType", ({
    enumerable: true,
    get: function() {
        return _definition.assertOutputType;
    }
}));
Object.defineProperty(exports, "assertScalarType", ({
    enumerable: true,
    get: function() {
        return _definition.assertScalarType;
    }
}));
Object.defineProperty(exports, "assertSchema", ({
    enumerable: true,
    get: function() {
        return _schema.assertSchema;
    }
}));
Object.defineProperty(exports, "assertType", ({
    enumerable: true,
    get: function() {
        return _definition.assertType;
    }
}));
Object.defineProperty(exports, "assertUnionType", ({
    enumerable: true,
    get: function() {
        return _definition.assertUnionType;
    }
}));
Object.defineProperty(exports, "assertValidSchema", ({
    enumerable: true,
    get: function() {
        return _validate.assertValidSchema;
    }
}));
Object.defineProperty(exports, "assertWrappingType", ({
    enumerable: true,
    get: function() {
        return _definition.assertWrappingType;
    }
}));
Object.defineProperty(exports, "getNamedType", ({
    enumerable: true,
    get: function() {
        return _definition.getNamedType;
    }
}));
Object.defineProperty(exports, "getNullableType", ({
    enumerable: true,
    get: function() {
        return _definition.getNullableType;
    }
}));
Object.defineProperty(exports, "introspectionTypes", ({
    enumerable: true,
    get: function() {
        return _introspection.introspectionTypes;
    }
}));
Object.defineProperty(exports, "isAbstractType", ({
    enumerable: true,
    get: function() {
        return _definition.isAbstractType;
    }
}));
Object.defineProperty(exports, "isCompositeType", ({
    enumerable: true,
    get: function() {
        return _definition.isCompositeType;
    }
}));
Object.defineProperty(exports, "isDirective", ({
    enumerable: true,
    get: function() {
        return _directives.isDirective;
    }
}));
Object.defineProperty(exports, "isEnumType", ({
    enumerable: true,
    get: function() {
        return _definition.isEnumType;
    }
}));
Object.defineProperty(exports, "isInputObjectType", ({
    enumerable: true,
    get: function() {
        return _definition.isInputObjectType;
    }
}));
Object.defineProperty(exports, "isInputType", ({
    enumerable: true,
    get: function() {
        return _definition.isInputType;
    }
}));
Object.defineProperty(exports, "isInterfaceType", ({
    enumerable: true,
    get: function() {
        return _definition.isInterfaceType;
    }
}));
Object.defineProperty(exports, "isIntrospectionType", ({
    enumerable: true,
    get: function() {
        return _introspection.isIntrospectionType;
    }
}));
Object.defineProperty(exports, "isLeafType", ({
    enumerable: true,
    get: function() {
        return _definition.isLeafType;
    }
}));
Object.defineProperty(exports, "isListType", ({
    enumerable: true,
    get: function() {
        return _definition.isListType;
    }
}));
Object.defineProperty(exports, "isNamedType", ({
    enumerable: true,
    get: function() {
        return _definition.isNamedType;
    }
}));
Object.defineProperty(exports, "isNonNullType", ({
    enumerable: true,
    get: function() {
        return _definition.isNonNullType;
    }
}));
Object.defineProperty(exports, "isNullableType", ({
    enumerable: true,
    get: function() {
        return _definition.isNullableType;
    }
}));
Object.defineProperty(exports, "isObjectType", ({
    enumerable: true,
    get: function() {
        return _definition.isObjectType;
    }
}));
Object.defineProperty(exports, "isOutputType", ({
    enumerable: true,
    get: function() {
        return _definition.isOutputType;
    }
}));
Object.defineProperty(exports, "isRequiredArgument", ({
    enumerable: true,
    get: function() {
        return _definition.isRequiredArgument;
    }
}));
Object.defineProperty(exports, "isRequiredInputField", ({
    enumerable: true,
    get: function() {
        return _definition.isRequiredInputField;
    }
}));
Object.defineProperty(exports, "isScalarType", ({
    enumerable: true,
    get: function() {
        return _definition.isScalarType;
    }
}));
Object.defineProperty(exports, "isSchema", ({
    enumerable: true,
    get: function() {
        return _schema.isSchema;
    }
}));
Object.defineProperty(exports, "isSpecifiedDirective", ({
    enumerable: true,
    get: function() {
        return _directives.isSpecifiedDirective;
    }
}));
Object.defineProperty(exports, "isSpecifiedScalarType", ({
    enumerable: true,
    get: function() {
        return _scalars.isSpecifiedScalarType;
    }
}));
Object.defineProperty(exports, "isType", ({
    enumerable: true,
    get: function() {
        return _definition.isType;
    }
}));
Object.defineProperty(exports, "isUnionType", ({
    enumerable: true,
    get: function() {
        return _definition.isUnionType;
    }
}));
Object.defineProperty(exports, "isWrappingType", ({
    enumerable: true,
    get: function() {
        return _definition.isWrappingType;
    }
}));
Object.defineProperty(exports, "resolveObjMapThunk", ({
    enumerable: true,
    get: function() {
        return _definition.resolveObjMapThunk;
    }
}));
Object.defineProperty(exports, "resolveReadonlyArrayThunk", ({
    enumerable: true,
    get: function() {
        return _definition.resolveReadonlyArrayThunk;
    }
}));
Object.defineProperty(exports, "specifiedDirectives", ({
    enumerable: true,
    get: function() {
        return _directives.specifiedDirectives;
    }
}));
Object.defineProperty(exports, "specifiedScalarTypes", ({
    enumerable: true,
    get: function() {
        return _scalars.specifiedScalarTypes;
    }
}));
Object.defineProperty(exports, "validateSchema", ({
    enumerable: true,
    get: function() {
        return _validate.validateSchema;
    }
}));
var _schema = __webpack_require__(9723);
var _definition = __webpack_require__(7982);
var _directives = __webpack_require__(3554);
var _scalars = __webpack_require__(9570);
var _introspection = __webpack_require__(1472);
var _validate = __webpack_require__(4968);
var _assertName = __webpack_require__(2039);


/***/ }),

/***/ 1472:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.introspectionTypes = exports.__TypeKind = exports.__Type = exports.__Schema = exports.__InputValue = exports.__Field = exports.__EnumValue = exports.__DirectiveLocation = exports.__Directive = exports.TypeNameMetaFieldDef = exports.TypeMetaFieldDef = exports.TypeKind = exports.SchemaMetaFieldDef = void 0;
exports.isIntrospectionType = isIntrospectionType;
var _inspect = __webpack_require__(8089);
var _invariant = __webpack_require__(5210);
var _directiveLocation = __webpack_require__(7936);
var _printer = __webpack_require__(800);
var _astFromValue = __webpack_require__(8042);
var _definition = __webpack_require__(7982);
var _scalars = __webpack_require__(9570);
const __Schema = new _definition.GraphQLObjectType({
    name: "__Schema",
    description: "A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations.",
    fields: ()=>({
            description: {
                type: _scalars.GraphQLString,
                resolve: (schema)=>schema.description
            },
            types: {
                description: "A list of all types supported by this server.",
                type: new _definition.GraphQLNonNull(new _definition.GraphQLList(new _definition.GraphQLNonNull(__Type))),
                resolve (schema) {
                    return Object.values(schema.getTypeMap());
                }
            },
            queryType: {
                description: "The type that query operations will be rooted at.",
                type: new _definition.GraphQLNonNull(__Type),
                resolve: (schema)=>schema.getQueryType()
            },
            mutationType: {
                description: "If this server supports mutation, the type that mutation operations will be rooted at.",
                type: __Type,
                resolve: (schema)=>schema.getMutationType()
            },
            subscriptionType: {
                description: "If this server support subscription, the type that subscription operations will be rooted at.",
                type: __Type,
                resolve: (schema)=>schema.getSubscriptionType()
            },
            directives: {
                description: "A list of all directives supported by this server.",
                type: new _definition.GraphQLNonNull(new _definition.GraphQLList(new _definition.GraphQLNonNull(__Directive))),
                resolve: (schema)=>schema.getDirectives()
            }
        })
});
exports.__Schema = __Schema;
const __Directive = new _definition.GraphQLObjectType({
    name: "__Directive",
    description: "A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.\n\nIn some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.",
    fields: ()=>({
            name: {
                type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
                resolve: (directive)=>directive.name
            },
            description: {
                type: _scalars.GraphQLString,
                resolve: (directive)=>directive.description
            },
            isRepeatable: {
                type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
                resolve: (directive)=>directive.isRepeatable
            },
            locations: {
                type: new _definition.GraphQLNonNull(new _definition.GraphQLList(new _definition.GraphQLNonNull(__DirectiveLocation))),
                resolve: (directive)=>directive.locations
            },
            args: {
                type: new _definition.GraphQLNonNull(new _definition.GraphQLList(new _definition.GraphQLNonNull(__InputValue))),
                args: {
                    includeDeprecated: {
                        type: _scalars.GraphQLBoolean,
                        defaultValue: false
                    }
                },
                resolve (field, { includeDeprecated  }) {
                    return includeDeprecated ? field.args : field.args.filter((arg)=>arg.deprecationReason == null);
                }
            }
        })
});
exports.__Directive = __Directive;
const __DirectiveLocation = new _definition.GraphQLEnumType({
    name: "__DirectiveLocation",
    description: "A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies.",
    values: {
        QUERY: {
            value: _directiveLocation.DirectiveLocation.QUERY,
            description: "Location adjacent to a query operation."
        },
        MUTATION: {
            value: _directiveLocation.DirectiveLocation.MUTATION,
            description: "Location adjacent to a mutation operation."
        },
        SUBSCRIPTION: {
            value: _directiveLocation.DirectiveLocation.SUBSCRIPTION,
            description: "Location adjacent to a subscription operation."
        },
        FIELD: {
            value: _directiveLocation.DirectiveLocation.FIELD,
            description: "Location adjacent to a field."
        },
        FRAGMENT_DEFINITION: {
            value: _directiveLocation.DirectiveLocation.FRAGMENT_DEFINITION,
            description: "Location adjacent to a fragment definition."
        },
        FRAGMENT_SPREAD: {
            value: _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD,
            description: "Location adjacent to a fragment spread."
        },
        INLINE_FRAGMENT: {
            value: _directiveLocation.DirectiveLocation.INLINE_FRAGMENT,
            description: "Location adjacent to an inline fragment."
        },
        VARIABLE_DEFINITION: {
            value: _directiveLocation.DirectiveLocation.VARIABLE_DEFINITION,
            description: "Location adjacent to a variable definition."
        },
        SCHEMA: {
            value: _directiveLocation.DirectiveLocation.SCHEMA,
            description: "Location adjacent to a schema definition."
        },
        SCALAR: {
            value: _directiveLocation.DirectiveLocation.SCALAR,
            description: "Location adjacent to a scalar definition."
        },
        OBJECT: {
            value: _directiveLocation.DirectiveLocation.OBJECT,
            description: "Location adjacent to an object type definition."
        },
        FIELD_DEFINITION: {
            value: _directiveLocation.DirectiveLocation.FIELD_DEFINITION,
            description: "Location adjacent to a field definition."
        },
        ARGUMENT_DEFINITION: {
            value: _directiveLocation.DirectiveLocation.ARGUMENT_DEFINITION,
            description: "Location adjacent to an argument definition."
        },
        INTERFACE: {
            value: _directiveLocation.DirectiveLocation.INTERFACE,
            description: "Location adjacent to an interface definition."
        },
        UNION: {
            value: _directiveLocation.DirectiveLocation.UNION,
            description: "Location adjacent to a union definition."
        },
        ENUM: {
            value: _directiveLocation.DirectiveLocation.ENUM,
            description: "Location adjacent to an enum definition."
        },
        ENUM_VALUE: {
            value: _directiveLocation.DirectiveLocation.ENUM_VALUE,
            description: "Location adjacent to an enum value definition."
        },
        INPUT_OBJECT: {
            value: _directiveLocation.DirectiveLocation.INPUT_OBJECT,
            description: "Location adjacent to an input object type definition."
        },
        INPUT_FIELD_DEFINITION: {
            value: _directiveLocation.DirectiveLocation.INPUT_FIELD_DEFINITION,
            description: "Location adjacent to an input object field definition."
        }
    }
});
exports.__DirectiveLocation = __DirectiveLocation;
const __Type = new _definition.GraphQLObjectType({
    name: "__Type",
    description: "The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.\n\nDepending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name, description and optional `specifiedByURL`, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.",
    fields: ()=>({
            kind: {
                type: new _definition.GraphQLNonNull(__TypeKind),
                resolve (type) {
                    if ((0, _definition.isScalarType)(type)) {
                        return TypeKind.SCALAR;
                    }
                    if ((0, _definition.isObjectType)(type)) {
                        return TypeKind.OBJECT;
                    }
                    if ((0, _definition.isInterfaceType)(type)) {
                        return TypeKind.INTERFACE;
                    }
                    if ((0, _definition.isUnionType)(type)) {
                        return TypeKind.UNION;
                    }
                    if ((0, _definition.isEnumType)(type)) {
                        return TypeKind.ENUM;
                    }
                    if ((0, _definition.isInputObjectType)(type)) {
                        return TypeKind.INPUT_OBJECT;
                    }
                    if ((0, _definition.isListType)(type)) {
                        return TypeKind.LIST;
                    }
                    if ((0, _definition.isNonNullType)(type)) {
                        return TypeKind.NON_NULL;
                    }
                    /* c8 ignore next 3 */ // Not reachable, all possible types have been considered)
                     false || (0, _invariant.invariant)(false, `Unexpected type: "${(0, _inspect.inspect)(type)}".`);
                }
            },
            name: {
                type: _scalars.GraphQLString,
                resolve: (type)=>"name" in type ? type.name : undefined
            },
            description: {
                type: _scalars.GraphQLString,
                resolve: (type)=>/* c8 ignore next */ "description" in type ? type.description : undefined
            },
            specifiedByURL: {
                type: _scalars.GraphQLString,
                resolve: (obj)=>"specifiedByURL" in obj ? obj.specifiedByURL : undefined
            },
            fields: {
                type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__Field)),
                args: {
                    includeDeprecated: {
                        type: _scalars.GraphQLBoolean,
                        defaultValue: false
                    }
                },
                resolve (type, { includeDeprecated  }) {
                    if ((0, _definition.isObjectType)(type) || (0, _definition.isInterfaceType)(type)) {
                        const fields = Object.values(type.getFields());
                        return includeDeprecated ? fields : fields.filter((field)=>field.deprecationReason == null);
                    }
                }
            },
            interfaces: {
                type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__Type)),
                resolve (type) {
                    if ((0, _definition.isObjectType)(type) || (0, _definition.isInterfaceType)(type)) {
                        return type.getInterfaces();
                    }
                }
            },
            possibleTypes: {
                type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__Type)),
                resolve (type, _args, _context, { schema  }) {
                    if ((0, _definition.isAbstractType)(type)) {
                        return schema.getPossibleTypes(type);
                    }
                }
            },
            enumValues: {
                type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__EnumValue)),
                args: {
                    includeDeprecated: {
                        type: _scalars.GraphQLBoolean,
                        defaultValue: false
                    }
                },
                resolve (type, { includeDeprecated  }) {
                    if ((0, _definition.isEnumType)(type)) {
                        const values = type.getValues();
                        return includeDeprecated ? values : values.filter((field)=>field.deprecationReason == null);
                    }
                }
            },
            inputFields: {
                type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__InputValue)),
                args: {
                    includeDeprecated: {
                        type: _scalars.GraphQLBoolean,
                        defaultValue: false
                    }
                },
                resolve (type, { includeDeprecated  }) {
                    if ((0, _definition.isInputObjectType)(type)) {
                        const values = Object.values(type.getFields());
                        return includeDeprecated ? values : values.filter((field)=>field.deprecationReason == null);
                    }
                }
            },
            ofType: {
                type: __Type,
                resolve: (type)=>"ofType" in type ? type.ofType : undefined
            }
        })
});
exports.__Type = __Type;
const __Field = new _definition.GraphQLObjectType({
    name: "__Field",
    description: "Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type.",
    fields: ()=>({
            name: {
                type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
                resolve: (field)=>field.name
            },
            description: {
                type: _scalars.GraphQLString,
                resolve: (field)=>field.description
            },
            args: {
                type: new _definition.GraphQLNonNull(new _definition.GraphQLList(new _definition.GraphQLNonNull(__InputValue))),
                args: {
                    includeDeprecated: {
                        type: _scalars.GraphQLBoolean,
                        defaultValue: false
                    }
                },
                resolve (field, { includeDeprecated  }) {
                    return includeDeprecated ? field.args : field.args.filter((arg)=>arg.deprecationReason == null);
                }
            },
            type: {
                type: new _definition.GraphQLNonNull(__Type),
                resolve: (field)=>field.type
            },
            isDeprecated: {
                type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
                resolve: (field)=>field.deprecationReason != null
            },
            deprecationReason: {
                type: _scalars.GraphQLString,
                resolve: (field)=>field.deprecationReason
            }
        })
});
exports.__Field = __Field;
const __InputValue = new _definition.GraphQLObjectType({
    name: "__InputValue",
    description: "Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value.",
    fields: ()=>({
            name: {
                type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
                resolve: (inputValue)=>inputValue.name
            },
            description: {
                type: _scalars.GraphQLString,
                resolve: (inputValue)=>inputValue.description
            },
            type: {
                type: new _definition.GraphQLNonNull(__Type),
                resolve: (inputValue)=>inputValue.type
            },
            defaultValue: {
                type: _scalars.GraphQLString,
                description: "A GraphQL-formatted string representing the default value for this input value.",
                resolve (inputValue) {
                    const { type , defaultValue  } = inputValue;
                    const valueAST = (0, _astFromValue.astFromValue)(defaultValue, type);
                    return valueAST ? (0, _printer.print)(valueAST) : null;
                }
            },
            isDeprecated: {
                type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
                resolve: (field)=>field.deprecationReason != null
            },
            deprecationReason: {
                type: _scalars.GraphQLString,
                resolve: (obj)=>obj.deprecationReason
            }
        })
});
exports.__InputValue = __InputValue;
const __EnumValue = new _definition.GraphQLObjectType({
    name: "__EnumValue",
    description: "One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string.",
    fields: ()=>({
            name: {
                type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
                resolve: (enumValue)=>enumValue.name
            },
            description: {
                type: _scalars.GraphQLString,
                resolve: (enumValue)=>enumValue.description
            },
            isDeprecated: {
                type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
                resolve: (enumValue)=>enumValue.deprecationReason != null
            },
            deprecationReason: {
                type: _scalars.GraphQLString,
                resolve: (enumValue)=>enumValue.deprecationReason
            }
        })
});
exports.__EnumValue = __EnumValue;
var TypeKind;
exports.TypeKind = TypeKind;
(function(TypeKind) {
    TypeKind["SCALAR"] = "SCALAR";
    TypeKind["OBJECT"] = "OBJECT";
    TypeKind["INTERFACE"] = "INTERFACE";
    TypeKind["UNION"] = "UNION";
    TypeKind["ENUM"] = "ENUM";
    TypeKind["INPUT_OBJECT"] = "INPUT_OBJECT";
    TypeKind["LIST"] = "LIST";
    TypeKind["NON_NULL"] = "NON_NULL";
})(TypeKind || (exports.TypeKind = TypeKind = {}));
const __TypeKind = new _definition.GraphQLEnumType({
    name: "__TypeKind",
    description: "An enum describing what kind of type a given `__Type` is.",
    values: {
        SCALAR: {
            value: TypeKind.SCALAR,
            description: "Indicates this type is a scalar."
        },
        OBJECT: {
            value: TypeKind.OBJECT,
            description: "Indicates this type is an object. `fields` and `interfaces` are valid fields."
        },
        INTERFACE: {
            value: TypeKind.INTERFACE,
            description: "Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields."
        },
        UNION: {
            value: TypeKind.UNION,
            description: "Indicates this type is a union. `possibleTypes` is a valid field."
        },
        ENUM: {
            value: TypeKind.ENUM,
            description: "Indicates this type is an enum. `enumValues` is a valid field."
        },
        INPUT_OBJECT: {
            value: TypeKind.INPUT_OBJECT,
            description: "Indicates this type is an input object. `inputFields` is a valid field."
        },
        LIST: {
            value: TypeKind.LIST,
            description: "Indicates this type is a list. `ofType` is a valid field."
        },
        NON_NULL: {
            value: TypeKind.NON_NULL,
            description: "Indicates this type is a non-null. `ofType` is a valid field."
        }
    }
});
/**
 * Note that these are GraphQLField and not GraphQLFieldConfig,
 * so the format for args is different.
 */ exports.__TypeKind = __TypeKind;
const SchemaMetaFieldDef = {
    name: "__schema",
    type: new _definition.GraphQLNonNull(__Schema),
    description: "Access the current type schema of this server.",
    args: [],
    resolve: (_source, _args, _context, { schema  })=>schema,
    deprecationReason: undefined,
    extensions: Object.create(null),
    astNode: undefined
};
exports.SchemaMetaFieldDef = SchemaMetaFieldDef;
const TypeMetaFieldDef = {
    name: "__type",
    type: __Type,
    description: "Request the type information of a single type.",
    args: [
        {
            name: "name",
            description: undefined,
            type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
            defaultValue: undefined,
            deprecationReason: undefined,
            extensions: Object.create(null),
            astNode: undefined
        }
    ],
    resolve: (_source, { name  }, _context, { schema  })=>schema.getType(name),
    deprecationReason: undefined,
    extensions: Object.create(null),
    astNode: undefined
};
exports.TypeMetaFieldDef = TypeMetaFieldDef;
const TypeNameMetaFieldDef = {
    name: "__typename",
    type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
    description: "The name of the current Object type at runtime.",
    args: [],
    resolve: (_source, _args, _context, { parentType  })=>parentType.name,
    deprecationReason: undefined,
    extensions: Object.create(null),
    astNode: undefined
};
exports.TypeNameMetaFieldDef = TypeNameMetaFieldDef;
const introspectionTypes = Object.freeze([
    __Schema,
    __Directive,
    __DirectiveLocation,
    __Type,
    __Field,
    __InputValue,
    __EnumValue,
    __TypeKind
]);
exports.introspectionTypes = introspectionTypes;
function isIntrospectionType(type) {
    return introspectionTypes.some(({ name  })=>type.name === name);
}


/***/ }),

/***/ 9570:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.GraphQLString = exports.GraphQLInt = exports.GraphQLID = exports.GraphQLFloat = exports.GraphQLBoolean = exports.GRAPHQL_MIN_INT = exports.GRAPHQL_MAX_INT = void 0;
exports.isSpecifiedScalarType = isSpecifiedScalarType;
exports.specifiedScalarTypes = void 0;
var _inspect = __webpack_require__(8089);
var _isObjectLike = __webpack_require__(5564);
var _GraphQLError = __webpack_require__(2169);
var _kinds = __webpack_require__(5923);
var _printer = __webpack_require__(800);
var _definition = __webpack_require__(7982);
/**
 * Maximum possible Int value as per GraphQL Spec (32-bit signed integer).
 * n.b. This differs from JavaScript's numbers that are IEEE 754 doubles safe up-to 2^53 - 1
 * */ const GRAPHQL_MAX_INT = 2147483647;
/**
 * Minimum possible Int value as per GraphQL Spec (32-bit signed integer).
 * n.b. This differs from JavaScript's numbers that are IEEE 754 doubles safe starting at -(2^53 - 1)
 * */ exports.GRAPHQL_MAX_INT = GRAPHQL_MAX_INT;
const GRAPHQL_MIN_INT = -2147483648;
exports.GRAPHQL_MIN_INT = GRAPHQL_MIN_INT;
const GraphQLInt = new _definition.GraphQLScalarType({
    name: "Int",
    description: "The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.",
    serialize (outputValue) {
        const coercedValue = serializeObject(outputValue);
        if (typeof coercedValue === "boolean") {
            return coercedValue ? 1 : 0;
        }
        let num = coercedValue;
        if (typeof coercedValue === "string" && coercedValue !== "") {
            num = Number(coercedValue);
        }
        if (typeof num !== "number" || !Number.isInteger(num)) {
            throw new _GraphQLError.GraphQLError(`Int cannot represent non-integer value: ${(0, _inspect.inspect)(coercedValue)}`);
        }
        if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
            throw new _GraphQLError.GraphQLError("Int cannot represent non 32-bit signed integer value: " + (0, _inspect.inspect)(coercedValue));
        }
        return num;
    },
    parseValue (inputValue) {
        if (typeof inputValue !== "number" || !Number.isInteger(inputValue)) {
            throw new _GraphQLError.GraphQLError(`Int cannot represent non-integer value: ${(0, _inspect.inspect)(inputValue)}`);
        }
        if (inputValue > GRAPHQL_MAX_INT || inputValue < GRAPHQL_MIN_INT) {
            throw new _GraphQLError.GraphQLError(`Int cannot represent non 32-bit signed integer value: ${inputValue}`);
        }
        return inputValue;
    },
    parseLiteral (valueNode) {
        if (valueNode.kind !== _kinds.Kind.INT) {
            throw new _GraphQLError.GraphQLError(`Int cannot represent non-integer value: ${(0, _printer.print)(valueNode)}`, {
                nodes: valueNode
            });
        }
        const num = parseInt(valueNode.value, 10);
        if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
            throw new _GraphQLError.GraphQLError(`Int cannot represent non 32-bit signed integer value: ${valueNode.value}`, {
                nodes: valueNode
            });
        }
        return num;
    }
});
exports.GraphQLInt = GraphQLInt;
const GraphQLFloat = new _definition.GraphQLScalarType({
    name: "Float",
    description: "The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).",
    serialize (outputValue) {
        const coercedValue = serializeObject(outputValue);
        if (typeof coercedValue === "boolean") {
            return coercedValue ? 1 : 0;
        }
        let num = coercedValue;
        if (typeof coercedValue === "string" && coercedValue !== "") {
            num = Number(coercedValue);
        }
        if (typeof num !== "number" || !Number.isFinite(num)) {
            throw new _GraphQLError.GraphQLError(`Float cannot represent non numeric value: ${(0, _inspect.inspect)(coercedValue)}`);
        }
        return num;
    },
    parseValue (inputValue) {
        if (typeof inputValue !== "number" || !Number.isFinite(inputValue)) {
            throw new _GraphQLError.GraphQLError(`Float cannot represent non numeric value: ${(0, _inspect.inspect)(inputValue)}`);
        }
        return inputValue;
    },
    parseLiteral (valueNode) {
        if (valueNode.kind !== _kinds.Kind.FLOAT && valueNode.kind !== _kinds.Kind.INT) {
            throw new _GraphQLError.GraphQLError(`Float cannot represent non numeric value: ${(0, _printer.print)(valueNode)}`, valueNode);
        }
        return parseFloat(valueNode.value);
    }
});
exports.GraphQLFloat = GraphQLFloat;
const GraphQLString = new _definition.GraphQLScalarType({
    name: "String",
    description: "The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.",
    serialize (outputValue) {
        const coercedValue = serializeObject(outputValue); // Serialize string, boolean and number values to a string, but do not
        // attempt to coerce object, function, symbol, or other types as strings.
        if (typeof coercedValue === "string") {
            return coercedValue;
        }
        if (typeof coercedValue === "boolean") {
            return coercedValue ? "true" : "false";
        }
        if (typeof coercedValue === "number" && Number.isFinite(coercedValue)) {
            return coercedValue.toString();
        }
        throw new _GraphQLError.GraphQLError(`String cannot represent value: ${(0, _inspect.inspect)(outputValue)}`);
    },
    parseValue (inputValue) {
        if (typeof inputValue !== "string") {
            throw new _GraphQLError.GraphQLError(`String cannot represent a non string value: ${(0, _inspect.inspect)(inputValue)}`);
        }
        return inputValue;
    },
    parseLiteral (valueNode) {
        if (valueNode.kind !== _kinds.Kind.STRING) {
            throw new _GraphQLError.GraphQLError(`String cannot represent a non string value: ${(0, _printer.print)(valueNode)}`, {
                nodes: valueNode
            });
        }
        return valueNode.value;
    }
});
exports.GraphQLString = GraphQLString;
const GraphQLBoolean = new _definition.GraphQLScalarType({
    name: "Boolean",
    description: "The `Boolean` scalar type represents `true` or `false`.",
    serialize (outputValue) {
        const coercedValue = serializeObject(outputValue);
        if (typeof coercedValue === "boolean") {
            return coercedValue;
        }
        if (Number.isFinite(coercedValue)) {
            return coercedValue !== 0;
        }
        throw new _GraphQLError.GraphQLError(`Boolean cannot represent a non boolean value: ${(0, _inspect.inspect)(coercedValue)}`);
    },
    parseValue (inputValue) {
        if (typeof inputValue !== "boolean") {
            throw new _GraphQLError.GraphQLError(`Boolean cannot represent a non boolean value: ${(0, _inspect.inspect)(inputValue)}`);
        }
        return inputValue;
    },
    parseLiteral (valueNode) {
        if (valueNode.kind !== _kinds.Kind.BOOLEAN) {
            throw new _GraphQLError.GraphQLError(`Boolean cannot represent a non boolean value: ${(0, _printer.print)(valueNode)}`, {
                nodes: valueNode
            });
        }
        return valueNode.value;
    }
});
exports.GraphQLBoolean = GraphQLBoolean;
const GraphQLID = new _definition.GraphQLScalarType({
    name: "ID",
    description: 'The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.',
    serialize (outputValue) {
        const coercedValue = serializeObject(outputValue);
        if (typeof coercedValue === "string") {
            return coercedValue;
        }
        if (Number.isInteger(coercedValue)) {
            return String(coercedValue);
        }
        throw new _GraphQLError.GraphQLError(`ID cannot represent value: ${(0, _inspect.inspect)(outputValue)}`);
    },
    parseValue (inputValue) {
        if (typeof inputValue === "string") {
            return inputValue;
        }
        if (typeof inputValue === "number" && Number.isInteger(inputValue)) {
            return inputValue.toString();
        }
        throw new _GraphQLError.GraphQLError(`ID cannot represent value: ${(0, _inspect.inspect)(inputValue)}`);
    },
    parseLiteral (valueNode) {
        if (valueNode.kind !== _kinds.Kind.STRING && valueNode.kind !== _kinds.Kind.INT) {
            throw new _GraphQLError.GraphQLError("ID cannot represent a non-string and non-integer value: " + (0, _printer.print)(valueNode), {
                nodes: valueNode
            });
        }
        return valueNode.value;
    }
});
exports.GraphQLID = GraphQLID;
const specifiedScalarTypes = Object.freeze([
    GraphQLString,
    GraphQLInt,
    GraphQLFloat,
    GraphQLBoolean,
    GraphQLID
]);
exports.specifiedScalarTypes = specifiedScalarTypes;
function isSpecifiedScalarType(type) {
    return specifiedScalarTypes.some(({ name  })=>type.name === name);
} // Support serializing objects with custom valueOf() or toJSON() functions -
// a common way to represent a complex value which can be represented as
// a string (ex: MongoDB id objects).
function serializeObject(outputValue) {
    if ((0, _isObjectLike.isObjectLike)(outputValue)) {
        if (typeof outputValue.valueOf === "function") {
            const valueOfResult = outputValue.valueOf();
            if (!(0, _isObjectLike.isObjectLike)(valueOfResult)) {
                return valueOfResult;
            }
        }
        if (typeof outputValue.toJSON === "function") {
            return outputValue.toJSON();
        }
    }
    return outputValue;
}


/***/ }),

/***/ 9723:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.GraphQLSchema = void 0;
exports.assertSchema = assertSchema;
exports.isSchema = isSchema;
var _devAssert = __webpack_require__(90);
var _inspect = __webpack_require__(8089);
var _instanceOf = __webpack_require__(9738);
var _isObjectLike = __webpack_require__(5564);
var _toObjMap = __webpack_require__(5891);
var _ast = __webpack_require__(9344);
var _definition = __webpack_require__(7982);
var _directives = __webpack_require__(3554);
var _introspection = __webpack_require__(1472);
/**
 * Test if the given value is a GraphQL schema.
 */ function isSchema(schema) {
    return (0, _instanceOf.instanceOf)(schema, GraphQLSchema);
}
function assertSchema(schema) {
    if (!isSchema(schema)) {
        throw new Error(`Expected ${(0, _inspect.inspect)(schema)} to be a GraphQL schema.`);
    }
    return schema;
}
/**
 * Custom extensions
 *
 * @remarks
 * Use a unique identifier name for your extension, for example the name of
 * your library or project. Do not use a shortened identifier as this increases
 * the risk of conflicts. We recommend you add at most one extension field,
 * an object which can contain all the values you need.
 */ /**
 * Schema Definition
 *
 * A Schema is created by supplying the root types of each type of operation,
 * query and mutation (optional). A schema definition is then supplied to the
 * validator and executor.
 *
 * Example:
 *
 * ```ts
 * const MyAppSchema = new GraphQLSchema({
 *   query: MyAppQueryRootType,
 *   mutation: MyAppMutationRootType,
 * })
 * ```
 *
 * Note: When the schema is constructed, by default only the types that are
 * reachable by traversing the root types are included, other types must be
 * explicitly referenced.
 *
 * Example:
 *
 * ```ts
 * const characterInterface = new GraphQLInterfaceType({
 *   name: 'Character',
 *   ...
 * });
 *
 * const humanType = new GraphQLObjectType({
 *   name: 'Human',
 *   interfaces: [characterInterface],
 *   ...
 * });
 *
 * const droidType = new GraphQLObjectType({
 *   name: 'Droid',
 *   interfaces: [characterInterface],
 *   ...
 * });
 *
 * const schema = new GraphQLSchema({
 *   query: new GraphQLObjectType({
 *     name: 'Query',
 *     fields: {
 *       hero: { type: characterInterface, ... },
 *     }
 *   }),
 *   ...
 *   // Since this schema references only the `Character` interface it's
 *   // necessary to explicitly list the types that implement it if
 *   // you want them to be included in the final schema.
 *   types: [humanType, droidType],
 * })
 * ```
 *
 * Note: If an array of `directives` are provided to GraphQLSchema, that will be
 * the exact list of directives represented and allowed. If `directives` is not
 * provided then a default set of the specified directives (e.g. `@include` and
 * `@skip`) will be used. If you wish to provide *additional* directives to these
 * specified directives, you must explicitly declare them. Example:
 *
 * ```ts
 * const MyAppSchema = new GraphQLSchema({
 *   ...
 *   directives: specifiedDirectives.concat([ myCustomDirective ]),
 * })
 * ```
 */ class GraphQLSchema {
    // Used as a cache for validateSchema().
    constructor(config){
        var _config$extensionASTN, _config$directives;
        // If this schema was built from a source known to be valid, then it may be
        // marked with assumeValid to avoid an additional type system validation.
        this.__validationErrors = config.assumeValid === true ? [] : undefined; // Check for common mistakes during construction to produce early errors.
        (0, _isObjectLike.isObjectLike)(config) || (0, _devAssert.devAssert)(false, "Must provide configuration object.");
        !config.types || Array.isArray(config.types) || (0, _devAssert.devAssert)(false, `"types" must be Array if provided but got: ${(0, _inspect.inspect)(config.types)}.`);
        !config.directives || Array.isArray(config.directives) || (0, _devAssert.devAssert)(false, '"directives" must be Array if provided but got: ' + `${(0, _inspect.inspect)(config.directives)}.`);
        this.description = config.description;
        this.extensions = (0, _toObjMap.toObjMap)(config.extensions);
        this.astNode = config.astNode;
        this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];
        this._queryType = config.query;
        this._mutationType = config.mutation;
        this._subscriptionType = config.subscription; // Provide specified directives (e.g. @include and @skip) by default.
        this._directives = (_config$directives = config.directives) !== null && _config$directives !== void 0 ? _config$directives : _directives.specifiedDirectives; // To preserve order of user-provided types, we add first to add them to
        // the set of "collected" types, so `collectReferencedTypes` ignore them.
        const allReferencedTypes = new Set(config.types);
        if (config.types != null) {
            for (const type of config.types){
                // When we ready to process this type, we remove it from "collected" types
                // and then add it together with all dependent types in the correct position.
                allReferencedTypes.delete(type);
                collectReferencedTypes(type, allReferencedTypes);
            }
        }
        if (this._queryType != null) {
            collectReferencedTypes(this._queryType, allReferencedTypes);
        }
        if (this._mutationType != null) {
            collectReferencedTypes(this._mutationType, allReferencedTypes);
        }
        if (this._subscriptionType != null) {
            collectReferencedTypes(this._subscriptionType, allReferencedTypes);
        }
        for (const directive of this._directives){
            // Directives are not validated until validateSchema() is called.
            if ((0, _directives.isDirective)(directive)) {
                for (const arg of directive.args){
                    collectReferencedTypes(arg.type, allReferencedTypes);
                }
            }
        }
        collectReferencedTypes(_introspection.__Schema, allReferencedTypes); // Storing the resulting map for reference by the schema.
        this._typeMap = Object.create(null);
        this._subTypeMap = Object.create(null); // Keep track of all implementations by interface name.
        this._implementationsMap = Object.create(null);
        for (const namedType of allReferencedTypes){
            if (namedType == null) {
                continue;
            }
            const typeName = namedType.name;
            typeName || (0, _devAssert.devAssert)(false, "One of the provided types for building the Schema is missing a name.");
            if (this._typeMap[typeName] !== undefined) {
                throw new Error(`Schema must contain uniquely named types but contains multiple types named "${typeName}".`);
            }
            this._typeMap[typeName] = namedType;
            if ((0, _definition.isInterfaceType)(namedType)) {
                // Store implementations by interface.
                for (const iface of namedType.getInterfaces()){
                    if ((0, _definition.isInterfaceType)(iface)) {
                        let implementations = this._implementationsMap[iface.name];
                        if (implementations === undefined) {
                            implementations = this._implementationsMap[iface.name] = {
                                objects: [],
                                interfaces: []
                            };
                        }
                        implementations.interfaces.push(namedType);
                    }
                }
            } else if ((0, _definition.isObjectType)(namedType)) {
                // Store implementations by objects.
                for (const iface of namedType.getInterfaces()){
                    if ((0, _definition.isInterfaceType)(iface)) {
                        let implementations = this._implementationsMap[iface.name];
                        if (implementations === undefined) {
                            implementations = this._implementationsMap[iface.name] = {
                                objects: [],
                                interfaces: []
                            };
                        }
                        implementations.objects.push(namedType);
                    }
                }
            }
        }
    }
    get [Symbol.toStringTag]() {
        return "GraphQLSchema";
    }
    getQueryType() {
        return this._queryType;
    }
    getMutationType() {
        return this._mutationType;
    }
    getSubscriptionType() {
        return this._subscriptionType;
    }
    getRootType(operation) {
        switch(operation){
            case _ast.OperationTypeNode.QUERY:
                return this.getQueryType();
            case _ast.OperationTypeNode.MUTATION:
                return this.getMutationType();
            case _ast.OperationTypeNode.SUBSCRIPTION:
                return this.getSubscriptionType();
        }
    }
    getTypeMap() {
        return this._typeMap;
    }
    getType(name) {
        return this.getTypeMap()[name];
    }
    getPossibleTypes(abstractType) {
        return (0, _definition.isUnionType)(abstractType) ? abstractType.getTypes() : this.getImplementations(abstractType).objects;
    }
    getImplementations(interfaceType) {
        const implementations = this._implementationsMap[interfaceType.name];
        return implementations !== null && implementations !== void 0 ? implementations : {
            objects: [],
            interfaces: []
        };
    }
    isSubType(abstractType, maybeSubType) {
        let map = this._subTypeMap[abstractType.name];
        if (map === undefined) {
            map = Object.create(null);
            if ((0, _definition.isUnionType)(abstractType)) {
                for (const type of abstractType.getTypes()){
                    map[type.name] = true;
                }
            } else {
                const implementations = this.getImplementations(abstractType);
                for (const type of implementations.objects){
                    map[type.name] = true;
                }
                for (const type of implementations.interfaces){
                    map[type.name] = true;
                }
            }
            this._subTypeMap[abstractType.name] = map;
        }
        return map[maybeSubType.name] !== undefined;
    }
    getDirectives() {
        return this._directives;
    }
    getDirective(name) {
        return this.getDirectives().find((directive)=>directive.name === name);
    }
    toConfig() {
        return {
            description: this.description,
            query: this.getQueryType(),
            mutation: this.getMutationType(),
            subscription: this.getSubscriptionType(),
            types: Object.values(this.getTypeMap()),
            directives: this.getDirectives(),
            extensions: this.extensions,
            astNode: this.astNode,
            extensionASTNodes: this.extensionASTNodes,
            assumeValid: this.__validationErrors !== undefined
        };
    }
}
exports.GraphQLSchema = GraphQLSchema;
function collectReferencedTypes(type, typeSet) {
    const namedType = (0, _definition.getNamedType)(type);
    if (!typeSet.has(namedType)) {
        typeSet.add(namedType);
        if ((0, _definition.isUnionType)(namedType)) {
            for (const memberType of namedType.getTypes()){
                collectReferencedTypes(memberType, typeSet);
            }
        } else if ((0, _definition.isObjectType)(namedType) || (0, _definition.isInterfaceType)(namedType)) {
            for (const interfaceType of namedType.getInterfaces()){
                collectReferencedTypes(interfaceType, typeSet);
            }
            for (const field of Object.values(namedType.getFields())){
                collectReferencedTypes(field.type, typeSet);
                for (const arg of field.args){
                    collectReferencedTypes(arg.type, typeSet);
                }
            }
        } else if ((0, _definition.isInputObjectType)(namedType)) {
            for (const field of Object.values(namedType.getFields())){
                collectReferencedTypes(field.type, typeSet);
            }
        }
    }
    return typeSet;
}


/***/ }),

/***/ 4968:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.assertValidSchema = assertValidSchema;
exports.validateSchema = validateSchema;
var _inspect = __webpack_require__(8089);
var _GraphQLError = __webpack_require__(2169);
var _ast = __webpack_require__(9344);
var _typeComparators = __webpack_require__(5392);
var _definition = __webpack_require__(7982);
var _directives = __webpack_require__(3554);
var _introspection = __webpack_require__(1472);
var _schema = __webpack_require__(9723);
/**
 * Implements the "Type Validation" sub-sections of the specification's
 * "Type System" section.
 *
 * Validation runs synchronously, returning an array of encountered errors, or
 * an empty array if no errors were encountered and the Schema is valid.
 */ function validateSchema(schema) {
    // First check to ensure the provided value is in fact a GraphQLSchema.
    (0, _schema.assertSchema)(schema); // If this Schema has already been validated, return the previous results.
    if (schema.__validationErrors) {
        return schema.__validationErrors;
    } // Validate the schema, producing a list of errors.
    const context = new SchemaValidationContext(schema);
    validateRootTypes(context);
    validateDirectives(context);
    validateTypes(context); // Persist the results of validation before returning to ensure validation
    // does not run multiple times for this schema.
    const errors = context.getErrors();
    schema.__validationErrors = errors;
    return errors;
}
/**
 * Utility function which asserts a schema is valid by throwing an error if
 * it is invalid.
 */ function assertValidSchema(schema) {
    const errors = validateSchema(schema);
    if (errors.length !== 0) {
        throw new Error(errors.map((error)=>error.message).join("\n\n"));
    }
}
class SchemaValidationContext {
    constructor(schema){
        this._errors = [];
        this.schema = schema;
    }
    reportError(message, nodes) {
        const _nodes = Array.isArray(nodes) ? nodes.filter(Boolean) : nodes;
        this._errors.push(new _GraphQLError.GraphQLError(message, {
            nodes: _nodes
        }));
    }
    getErrors() {
        return this._errors;
    }
}
function validateRootTypes(context) {
    const schema = context.schema;
    const queryType = schema.getQueryType();
    if (!queryType) {
        context.reportError("Query root type must be provided.", schema.astNode);
    } else if (!(0, _definition.isObjectType)(queryType)) {
        var _getOperationTypeNode;
        context.reportError(`Query root type must be Object type, it cannot be ${(0, _inspect.inspect)(queryType)}.`, (_getOperationTypeNode = getOperationTypeNode(schema, _ast.OperationTypeNode.QUERY)) !== null && _getOperationTypeNode !== void 0 ? _getOperationTypeNode : queryType.astNode);
    }
    const mutationType = schema.getMutationType();
    if (mutationType && !(0, _definition.isObjectType)(mutationType)) {
        var _getOperationTypeNode2;
        context.reportError("Mutation root type must be Object type if provided, it cannot be " + `${(0, _inspect.inspect)(mutationType)}.`, (_getOperationTypeNode2 = getOperationTypeNode(schema, _ast.OperationTypeNode.MUTATION)) !== null && _getOperationTypeNode2 !== void 0 ? _getOperationTypeNode2 : mutationType.astNode);
    }
    const subscriptionType = schema.getSubscriptionType();
    if (subscriptionType && !(0, _definition.isObjectType)(subscriptionType)) {
        var _getOperationTypeNode3;
        context.reportError("Subscription root type must be Object type if provided, it cannot be " + `${(0, _inspect.inspect)(subscriptionType)}.`, (_getOperationTypeNode3 = getOperationTypeNode(schema, _ast.OperationTypeNode.SUBSCRIPTION)) !== null && _getOperationTypeNode3 !== void 0 ? _getOperationTypeNode3 : subscriptionType.astNode);
    }
}
function getOperationTypeNode(schema, operation) {
    var _flatMap$find;
    return (_flatMap$find = [
        schema.astNode,
        ...schema.extensionASTNodes
    ].flatMap(// FIXME: https://github.com/graphql/graphql-js/issues/2203
    (schemaNode)=>{
        var _schemaNode$operation;
        return /* c8 ignore next */ (_schemaNode$operation = schemaNode === null || schemaNode === void 0 ? void 0 : schemaNode.operationTypes) !== null && _schemaNode$operation !== void 0 ? _schemaNode$operation : [];
    }).find((operationNode)=>operationNode.operation === operation)) === null || _flatMap$find === void 0 ? void 0 : _flatMap$find.type;
}
function validateDirectives(context) {
    for (const directive of context.schema.getDirectives()){
        // Ensure all directives are in fact GraphQL directives.
        if (!(0, _directives.isDirective)(directive)) {
            context.reportError(`Expected directive but got: ${(0, _inspect.inspect)(directive)}.`, directive === null || directive === void 0 ? void 0 : directive.astNode);
            continue;
        } // Ensure they are named correctly.
        validateName(context, directive); // TODO: Ensure proper locations.
        // Ensure the arguments are valid.
        for (const arg of directive.args){
            // Ensure they are named correctly.
            validateName(context, arg); // Ensure the type is an input type.
            if (!(0, _definition.isInputType)(arg.type)) {
                context.reportError(`The type of @${directive.name}(${arg.name}:) must be Input Type ` + `but got: ${(0, _inspect.inspect)(arg.type)}.`, arg.astNode);
            }
            if ((0, _definition.isRequiredArgument)(arg) && arg.deprecationReason != null) {
                var _arg$astNode;
                context.reportError(`Required argument @${directive.name}(${arg.name}:) cannot be deprecated.`, [
                    getDeprecatedDirectiveNode(arg.astNode),
                    (_arg$astNode = arg.astNode) === null || _arg$astNode === void 0 ? void 0 : _arg$astNode.type
                ]);
            }
        }
    }
}
function validateName(context, node) {
    // Ensure names are valid, however introspection types opt out.
    if (node.name.startsWith("__")) {
        context.reportError(`Name "${node.name}" must not begin with "__", which is reserved by GraphQL introspection.`, node.astNode);
    }
}
function validateTypes(context) {
    const validateInputObjectCircularRefs = createInputObjectCircularRefsValidator(context);
    const typeMap = context.schema.getTypeMap();
    for (const type of Object.values(typeMap)){
        // Ensure all provided types are in fact GraphQL type.
        if (!(0, _definition.isNamedType)(type)) {
            context.reportError(`Expected GraphQL named type but got: ${(0, _inspect.inspect)(type)}.`, type.astNode);
            continue;
        } // Ensure it is named correctly (excluding introspection types).
        if (!(0, _introspection.isIntrospectionType)(type)) {
            validateName(context, type);
        }
        if ((0, _definition.isObjectType)(type)) {
            // Ensure fields are valid
            validateFields(context, type); // Ensure objects implement the interfaces they claim to.
            validateInterfaces(context, type);
        } else if ((0, _definition.isInterfaceType)(type)) {
            // Ensure fields are valid.
            validateFields(context, type); // Ensure interfaces implement the interfaces they claim to.
            validateInterfaces(context, type);
        } else if ((0, _definition.isUnionType)(type)) {
            // Ensure Unions include valid member types.
            validateUnionMembers(context, type);
        } else if ((0, _definition.isEnumType)(type)) {
            // Ensure Enums have valid values.
            validateEnumValues(context, type);
        } else if ((0, _definition.isInputObjectType)(type)) {
            // Ensure Input Object fields are valid.
            validateInputFields(context, type); // Ensure Input Objects do not contain non-nullable circular references
            validateInputObjectCircularRefs(type);
        }
    }
}
function validateFields(context, type) {
    const fields = Object.values(type.getFields()); // Objects and Interfaces both must define one or more fields.
    if (fields.length === 0) {
        context.reportError(`Type ${type.name} must define one or more fields.`, [
            type.astNode,
            ...type.extensionASTNodes
        ]);
    }
    for (const field of fields){
        // Ensure they are named correctly.
        validateName(context, field); // Ensure the type is an output type
        if (!(0, _definition.isOutputType)(field.type)) {
            var _field$astNode;
            context.reportError(`The type of ${type.name}.${field.name} must be Output Type ` + `but got: ${(0, _inspect.inspect)(field.type)}.`, (_field$astNode = field.astNode) === null || _field$astNode === void 0 ? void 0 : _field$astNode.type);
        } // Ensure the arguments are valid
        for (const arg of field.args){
            const argName = arg.name; // Ensure they are named correctly.
            validateName(context, arg); // Ensure the type is an input type
            if (!(0, _definition.isInputType)(arg.type)) {
                var _arg$astNode2;
                context.reportError(`The type of ${type.name}.${field.name}(${argName}:) must be Input ` + `Type but got: ${(0, _inspect.inspect)(arg.type)}.`, (_arg$astNode2 = arg.astNode) === null || _arg$astNode2 === void 0 ? void 0 : _arg$astNode2.type);
            }
            if ((0, _definition.isRequiredArgument)(arg) && arg.deprecationReason != null) {
                var _arg$astNode3;
                context.reportError(`Required argument ${type.name}.${field.name}(${argName}:) cannot be deprecated.`, [
                    getDeprecatedDirectiveNode(arg.astNode),
                    (_arg$astNode3 = arg.astNode) === null || _arg$astNode3 === void 0 ? void 0 : _arg$astNode3.type
                ]);
            }
        }
    }
}
function validateInterfaces(context, type) {
    const ifaceTypeNames = Object.create(null);
    for (const iface of type.getInterfaces()){
        if (!(0, _definition.isInterfaceType)(iface)) {
            context.reportError(`Type ${(0, _inspect.inspect)(type)} must only implement Interface types, ` + `it cannot implement ${(0, _inspect.inspect)(iface)}.`, getAllImplementsInterfaceNodes(type, iface));
            continue;
        }
        if (type === iface) {
            context.reportError(`Type ${type.name} cannot implement itself because it would create a circular reference.`, getAllImplementsInterfaceNodes(type, iface));
            continue;
        }
        if (ifaceTypeNames[iface.name]) {
            context.reportError(`Type ${type.name} can only implement ${iface.name} once.`, getAllImplementsInterfaceNodes(type, iface));
            continue;
        }
        ifaceTypeNames[iface.name] = true;
        validateTypeImplementsAncestors(context, type, iface);
        validateTypeImplementsInterface(context, type, iface);
    }
}
function validateTypeImplementsInterface(context, type, iface) {
    const typeFieldMap = type.getFields(); // Assert each interface field is implemented.
    for (const ifaceField of Object.values(iface.getFields())){
        const fieldName = ifaceField.name;
        const typeField = typeFieldMap[fieldName]; // Assert interface field exists on type.
        if (!typeField) {
            context.reportError(`Interface field ${iface.name}.${fieldName} expected but ${type.name} does not provide it.`, [
                ifaceField.astNode,
                type.astNode,
                ...type.extensionASTNodes
            ]);
            continue;
        } // Assert interface field type is satisfied by type field type, by being
        // a valid subtype. (covariant)
        if (!(0, _typeComparators.isTypeSubTypeOf)(context.schema, typeField.type, ifaceField.type)) {
            var _ifaceField$astNode, _typeField$astNode;
            context.reportError(`Interface field ${iface.name}.${fieldName} expects type ` + `${(0, _inspect.inspect)(ifaceField.type)} but ${type.name}.${fieldName} ` + `is type ${(0, _inspect.inspect)(typeField.type)}.`, [
                (_ifaceField$astNode = ifaceField.astNode) === null || _ifaceField$astNode === void 0 ? void 0 : _ifaceField$astNode.type,
                (_typeField$astNode = typeField.astNode) === null || _typeField$astNode === void 0 ? void 0 : _typeField$astNode.type
            ]);
        } // Assert each interface field arg is implemented.
        for (const ifaceArg of ifaceField.args){
            const argName = ifaceArg.name;
            const typeArg = typeField.args.find((arg)=>arg.name === argName); // Assert interface field arg exists on object field.
            if (!typeArg) {
                context.reportError(`Interface field argument ${iface.name}.${fieldName}(${argName}:) expected but ${type.name}.${fieldName} does not provide it.`, [
                    ifaceArg.astNode,
                    typeField.astNode
                ]);
                continue;
            } // Assert interface field arg type matches object field arg type.
            // (invariant)
            // TODO: change to contravariant?
            if (!(0, _typeComparators.isEqualType)(ifaceArg.type, typeArg.type)) {
                var _ifaceArg$astNode, _typeArg$astNode;
                context.reportError(`Interface field argument ${iface.name}.${fieldName}(${argName}:) ` + `expects type ${(0, _inspect.inspect)(ifaceArg.type)} but ` + `${type.name}.${fieldName}(${argName}:) is type ` + `${(0, _inspect.inspect)(typeArg.type)}.`, [
                    (_ifaceArg$astNode = ifaceArg.astNode) === null || _ifaceArg$astNode === void 0 ? void 0 : _ifaceArg$astNode.type,
                    (_typeArg$astNode = typeArg.astNode) === null || _typeArg$astNode === void 0 ? void 0 : _typeArg$astNode.type
                ]);
            } // TODO: validate default values?
        } // Assert additional arguments must not be required.
        for (const typeArg of typeField.args){
            const argName = typeArg.name;
            const ifaceArg = ifaceField.args.find((arg)=>arg.name === argName);
            if (!ifaceArg && (0, _definition.isRequiredArgument)(typeArg)) {
                context.reportError(`Object field ${type.name}.${fieldName} includes required argument ${argName} that is missing from the Interface field ${iface.name}.${fieldName}.`, [
                    typeArg.astNode,
                    ifaceField.astNode
                ]);
            }
        }
    }
}
function validateTypeImplementsAncestors(context, type, iface) {
    const ifaceInterfaces = type.getInterfaces();
    for (const transitive of iface.getInterfaces()){
        if (!ifaceInterfaces.includes(transitive)) {
            context.reportError(transitive === type ? `Type ${type.name} cannot implement ${iface.name} because it would create a circular reference.` : `Type ${type.name} must implement ${transitive.name} because it is implemented by ${iface.name}.`, [
                ...getAllImplementsInterfaceNodes(iface, transitive),
                ...getAllImplementsInterfaceNodes(type, iface)
            ]);
        }
    }
}
function validateUnionMembers(context, union) {
    const memberTypes = union.getTypes();
    if (memberTypes.length === 0) {
        context.reportError(`Union type ${union.name} must define one or more member types.`, [
            union.astNode,
            ...union.extensionASTNodes
        ]);
    }
    const includedTypeNames = Object.create(null);
    for (const memberType of memberTypes){
        if (includedTypeNames[memberType.name]) {
            context.reportError(`Union type ${union.name} can only include type ${memberType.name} once.`, getUnionMemberTypeNodes(union, memberType.name));
            continue;
        }
        includedTypeNames[memberType.name] = true;
        if (!(0, _definition.isObjectType)(memberType)) {
            context.reportError(`Union type ${union.name} can only include Object types, ` + `it cannot include ${(0, _inspect.inspect)(memberType)}.`, getUnionMemberTypeNodes(union, String(memberType)));
        }
    }
}
function validateEnumValues(context, enumType) {
    const enumValues = enumType.getValues();
    if (enumValues.length === 0) {
        context.reportError(`Enum type ${enumType.name} must define one or more values.`, [
            enumType.astNode,
            ...enumType.extensionASTNodes
        ]);
    }
    for (const enumValue of enumValues){
        // Ensure valid name.
        validateName(context, enumValue);
    }
}
function validateInputFields(context, inputObj) {
    const fields = Object.values(inputObj.getFields());
    if (fields.length === 0) {
        context.reportError(`Input Object type ${inputObj.name} must define one or more fields.`, [
            inputObj.astNode,
            ...inputObj.extensionASTNodes
        ]);
    } // Ensure the arguments are valid
    for (const field of fields){
        // Ensure they are named correctly.
        validateName(context, field); // Ensure the type is an input type
        if (!(0, _definition.isInputType)(field.type)) {
            var _field$astNode2;
            context.reportError(`The type of ${inputObj.name}.${field.name} must be Input Type ` + `but got: ${(0, _inspect.inspect)(field.type)}.`, (_field$astNode2 = field.astNode) === null || _field$astNode2 === void 0 ? void 0 : _field$astNode2.type);
        }
        if ((0, _definition.isRequiredInputField)(field) && field.deprecationReason != null) {
            var _field$astNode3;
            context.reportError(`Required input field ${inputObj.name}.${field.name} cannot be deprecated.`, [
                getDeprecatedDirectiveNode(field.astNode),
                (_field$astNode3 = field.astNode) === null || _field$astNode3 === void 0 ? void 0 : _field$astNode3.type
            ]);
        }
    }
}
function createInputObjectCircularRefsValidator(context) {
    // Modified copy of algorithm from 'src/validation/rules/NoFragmentCycles.js'.
    // Tracks already visited types to maintain O(N) and to ensure that cycles
    // are not redundantly reported.
    const visitedTypes = Object.create(null); // Array of types nodes used to produce meaningful errors
    const fieldPath = []; // Position in the type path
    const fieldPathIndexByTypeName = Object.create(null);
    return detectCycleRecursive; // This does a straight-forward DFS to find cycles.
    // It does not terminate when a cycle was found but continues to explore
    // the graph to find all possible cycles.
    function detectCycleRecursive(inputObj) {
        if (visitedTypes[inputObj.name]) {
            return;
        }
        visitedTypes[inputObj.name] = true;
        fieldPathIndexByTypeName[inputObj.name] = fieldPath.length;
        const fields = Object.values(inputObj.getFields());
        for (const field of fields){
            if ((0, _definition.isNonNullType)(field.type) && (0, _definition.isInputObjectType)(field.type.ofType)) {
                const fieldType = field.type.ofType;
                const cycleIndex = fieldPathIndexByTypeName[fieldType.name];
                fieldPath.push(field);
                if (cycleIndex === undefined) {
                    detectCycleRecursive(fieldType);
                } else {
                    const cyclePath = fieldPath.slice(cycleIndex);
                    const pathStr = cyclePath.map((fieldObj)=>fieldObj.name).join(".");
                    context.reportError(`Cannot reference Input Object "${fieldType.name}" within itself through a series of non-null fields: "${pathStr}".`, cyclePath.map((fieldObj)=>fieldObj.astNode));
                }
                fieldPath.pop();
            }
        }
        fieldPathIndexByTypeName[inputObj.name] = undefined;
    }
}
function getAllImplementsInterfaceNodes(type, iface) {
    const { astNode , extensionASTNodes  } = type;
    const nodes = astNode != null ? [
        astNode,
        ...extensionASTNodes
    ] : extensionASTNodes; // FIXME: https://github.com/graphql/graphql-js/issues/2203
    return nodes.flatMap((typeNode)=>{
        var _typeNode$interfaces;
        return /* c8 ignore next */ (_typeNode$interfaces = typeNode.interfaces) !== null && _typeNode$interfaces !== void 0 ? _typeNode$interfaces : [];
    }).filter((ifaceNode)=>ifaceNode.name.value === iface.name);
}
function getUnionMemberTypeNodes(union, typeName) {
    const { astNode , extensionASTNodes  } = union;
    const nodes = astNode != null ? [
        astNode,
        ...extensionASTNodes
    ] : extensionASTNodes; // FIXME: https://github.com/graphql/graphql-js/issues/2203
    return nodes.flatMap((unionNode)=>{
        var _unionNode$types;
        return /* c8 ignore next */ (_unionNode$types = unionNode.types) !== null && _unionNode$types !== void 0 ? _unionNode$types : [];
    }).filter((typeNode)=>typeNode.name.value === typeName);
}
function getDeprecatedDirectiveNode(definitionNode) {
    var _definitionNode$direc;
    return definitionNode === null || definitionNode === void 0 ? void 0 : (_definitionNode$direc = definitionNode.directives) === null || _definitionNode$direc === void 0 ? void 0 : _definitionNode$direc.find((node)=>node.name.value === _directives.GraphQLDeprecatedDirective.name);
}


/***/ }),

/***/ 5790:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.TypeInfo = void 0;
exports.visitWithTypeInfo = visitWithTypeInfo;
var _ast = __webpack_require__(9344);
var _kinds = __webpack_require__(5923);
var _visitor = __webpack_require__(4256);
var _definition = __webpack_require__(7982);
var _introspection = __webpack_require__(1472);
var _typeFromAST = __webpack_require__(6013);
/**
 * TypeInfo is a utility class which, given a GraphQL schema, can keep track
 * of the current field and type definitions at any point in a GraphQL document
 * AST during a recursive descent by calling `enter(node)` and `leave(node)`.
 */ class TypeInfo {
    constructor(schema, /**
     * Initial type may be provided in rare cases to facilitate traversals
     *  beginning somewhere other than documents.
     */ initialType, /** @deprecated will be removed in 17.0.0 */ getFieldDefFn){
        this._schema = schema;
        this._typeStack = [];
        this._parentTypeStack = [];
        this._inputTypeStack = [];
        this._fieldDefStack = [];
        this._defaultValueStack = [];
        this._directive = null;
        this._argument = null;
        this._enumValue = null;
        this._getFieldDef = getFieldDefFn !== null && getFieldDefFn !== void 0 ? getFieldDefFn : getFieldDef;
        if (initialType) {
            if ((0, _definition.isInputType)(initialType)) {
                this._inputTypeStack.push(initialType);
            }
            if ((0, _definition.isCompositeType)(initialType)) {
                this._parentTypeStack.push(initialType);
            }
            if ((0, _definition.isOutputType)(initialType)) {
                this._typeStack.push(initialType);
            }
        }
    }
    get [Symbol.toStringTag]() {
        return "TypeInfo";
    }
    getType() {
        if (this._typeStack.length > 0) {
            return this._typeStack[this._typeStack.length - 1];
        }
    }
    getParentType() {
        if (this._parentTypeStack.length > 0) {
            return this._parentTypeStack[this._parentTypeStack.length - 1];
        }
    }
    getInputType() {
        if (this._inputTypeStack.length > 0) {
            return this._inputTypeStack[this._inputTypeStack.length - 1];
        }
    }
    getParentInputType() {
        if (this._inputTypeStack.length > 1) {
            return this._inputTypeStack[this._inputTypeStack.length - 2];
        }
    }
    getFieldDef() {
        if (this._fieldDefStack.length > 0) {
            return this._fieldDefStack[this._fieldDefStack.length - 1];
        }
    }
    getDefaultValue() {
        if (this._defaultValueStack.length > 0) {
            return this._defaultValueStack[this._defaultValueStack.length - 1];
        }
    }
    getDirective() {
        return this._directive;
    }
    getArgument() {
        return this._argument;
    }
    getEnumValue() {
        return this._enumValue;
    }
    enter(node) {
        const schema = this._schema; // Note: many of the types below are explicitly typed as "unknown" to drop
        // any assumptions of a valid schema to ensure runtime types are properly
        // checked before continuing since TypeInfo is used as part of validation
        // which occurs before guarantees of schema and document validity.
        switch(node.kind){
            case _kinds.Kind.SELECTION_SET:
                {
                    const namedType = (0, _definition.getNamedType)(this.getType());
                    this._parentTypeStack.push((0, _definition.isCompositeType)(namedType) ? namedType : undefined);
                    break;
                }
            case _kinds.Kind.FIELD:
                {
                    const parentType = this.getParentType();
                    let fieldDef;
                    let fieldType;
                    if (parentType) {
                        fieldDef = this._getFieldDef(schema, parentType, node);
                        if (fieldDef) {
                            fieldType = fieldDef.type;
                        }
                    }
                    this._fieldDefStack.push(fieldDef);
                    this._typeStack.push((0, _definition.isOutputType)(fieldType) ? fieldType : undefined);
                    break;
                }
            case _kinds.Kind.DIRECTIVE:
                this._directive = schema.getDirective(node.name.value);
                break;
            case _kinds.Kind.OPERATION_DEFINITION:
                {
                    const rootType = schema.getRootType(node.operation);
                    this._typeStack.push((0, _definition.isObjectType)(rootType) ? rootType : undefined);
                    break;
                }
            case _kinds.Kind.INLINE_FRAGMENT:
            case _kinds.Kind.FRAGMENT_DEFINITION:
                {
                    const typeConditionAST = node.typeCondition;
                    const outputType = typeConditionAST ? (0, _typeFromAST.typeFromAST)(schema, typeConditionAST) : (0, _definition.getNamedType)(this.getType());
                    this._typeStack.push((0, _definition.isOutputType)(outputType) ? outputType : undefined);
                    break;
                }
            case _kinds.Kind.VARIABLE_DEFINITION:
                {
                    const inputType = (0, _typeFromAST.typeFromAST)(schema, node.type);
                    this._inputTypeStack.push((0, _definition.isInputType)(inputType) ? inputType : undefined);
                    break;
                }
            case _kinds.Kind.ARGUMENT:
                {
                    var _this$getDirective;
                    let argDef;
                    let argType;
                    const fieldOrDirective = (_this$getDirective = this.getDirective()) !== null && _this$getDirective !== void 0 ? _this$getDirective : this.getFieldDef();
                    if (fieldOrDirective) {
                        argDef = fieldOrDirective.args.find((arg)=>arg.name === node.name.value);
                        if (argDef) {
                            argType = argDef.type;
                        }
                    }
                    this._argument = argDef;
                    this._defaultValueStack.push(argDef ? argDef.defaultValue : undefined);
                    this._inputTypeStack.push((0, _definition.isInputType)(argType) ? argType : undefined);
                    break;
                }
            case _kinds.Kind.LIST:
                {
                    const listType = (0, _definition.getNullableType)(this.getInputType());
                    const itemType = (0, _definition.isListType)(listType) ? listType.ofType : listType; // List positions never have a default value.
                    this._defaultValueStack.push(undefined);
                    this._inputTypeStack.push((0, _definition.isInputType)(itemType) ? itemType : undefined);
                    break;
                }
            case _kinds.Kind.OBJECT_FIELD:
                {
                    const objectType = (0, _definition.getNamedType)(this.getInputType());
                    let inputFieldType;
                    let inputField;
                    if ((0, _definition.isInputObjectType)(objectType)) {
                        inputField = objectType.getFields()[node.name.value];
                        if (inputField) {
                            inputFieldType = inputField.type;
                        }
                    }
                    this._defaultValueStack.push(inputField ? inputField.defaultValue : undefined);
                    this._inputTypeStack.push((0, _definition.isInputType)(inputFieldType) ? inputFieldType : undefined);
                    break;
                }
            case _kinds.Kind.ENUM:
                {
                    const enumType = (0, _definition.getNamedType)(this.getInputType());
                    let enumValue;
                    if ((0, _definition.isEnumType)(enumType)) {
                        enumValue = enumType.getValue(node.value);
                    }
                    this._enumValue = enumValue;
                    break;
                }
            default:
        }
    }
    leave(node) {
        switch(node.kind){
            case _kinds.Kind.SELECTION_SET:
                this._parentTypeStack.pop();
                break;
            case _kinds.Kind.FIELD:
                this._fieldDefStack.pop();
                this._typeStack.pop();
                break;
            case _kinds.Kind.DIRECTIVE:
                this._directive = null;
                break;
            case _kinds.Kind.OPERATION_DEFINITION:
            case _kinds.Kind.INLINE_FRAGMENT:
            case _kinds.Kind.FRAGMENT_DEFINITION:
                this._typeStack.pop();
                break;
            case _kinds.Kind.VARIABLE_DEFINITION:
                this._inputTypeStack.pop();
                break;
            case _kinds.Kind.ARGUMENT:
                this._argument = null;
                this._defaultValueStack.pop();
                this._inputTypeStack.pop();
                break;
            case _kinds.Kind.LIST:
            case _kinds.Kind.OBJECT_FIELD:
                this._defaultValueStack.pop();
                this._inputTypeStack.pop();
                break;
            case _kinds.Kind.ENUM:
                this._enumValue = null;
                break;
            default:
        }
    }
}
exports.TypeInfo = TypeInfo;
/**
 * Not exactly the same as the executor's definition of getFieldDef, in this
 * statically evaluated environment we do not always have an Object type,
 * and need to handle Interface and Union types.
 */ function getFieldDef(schema, parentType, fieldNode) {
    const name = fieldNode.name.value;
    if (name === _introspection.SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {
        return _introspection.SchemaMetaFieldDef;
    }
    if (name === _introspection.TypeMetaFieldDef.name && schema.getQueryType() === parentType) {
        return _introspection.TypeMetaFieldDef;
    }
    if (name === _introspection.TypeNameMetaFieldDef.name && (0, _definition.isCompositeType)(parentType)) {
        return _introspection.TypeNameMetaFieldDef;
    }
    if ((0, _definition.isObjectType)(parentType) || (0, _definition.isInterfaceType)(parentType)) {
        return parentType.getFields()[name];
    }
}
/**
 * Creates a new visitor instance which maintains a provided TypeInfo instance
 * along with visiting visitor.
 */ function visitWithTypeInfo(typeInfo, visitor) {
    return {
        enter (...args) {
            const node = args[0];
            typeInfo.enter(node);
            const fn = (0, _visitor.getEnterLeaveForKind)(visitor, node.kind).enter;
            if (fn) {
                const result = fn.apply(visitor, args);
                if (result !== undefined) {
                    typeInfo.leave(node);
                    if ((0, _ast.isNode)(result)) {
                        typeInfo.enter(result);
                    }
                }
                return result;
            }
        },
        leave (...args) {
            const node = args[0];
            const fn = (0, _visitor.getEnterLeaveForKind)(visitor, node.kind).leave;
            let result;
            if (fn) {
                result = fn.apply(visitor, args);
            }
            typeInfo.leave(node);
            return result;
        }
    };
}


/***/ }),

/***/ 2062:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.assertValidName = assertValidName;
exports.isValidNameError = isValidNameError;
var _devAssert = __webpack_require__(90);
var _GraphQLError = __webpack_require__(2169);
var _assertName = __webpack_require__(2039);
/* c8 ignore start */ /**
 * Upholds the spec rules about naming.
 * @deprecated Please use `assertName` instead. Will be removed in v17
 */ function assertValidName(name) {
    const error = isValidNameError(name);
    if (error) {
        throw error;
    }
    return name;
}
/**
 * Returns an Error if a name is invalid.
 * @deprecated Please use `assertName` instead. Will be removed in v17
 */ function isValidNameError(name) {
    typeof name === "string" || (0, _devAssert.devAssert)(false, "Expected name to be a string.");
    if (name.startsWith("__")) {
        return new _GraphQLError.GraphQLError(`Name "${name}" must not begin with "__", which is reserved by GraphQL introspection.`);
    }
    try {
        (0, _assertName.assertName)(name);
    } catch (error) {
        return error;
    }
} /* c8 ignore stop */ 


/***/ }),

/***/ 8042:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.astFromValue = astFromValue;
var _inspect = __webpack_require__(8089);
var _invariant = __webpack_require__(5210);
var _isIterableObject = __webpack_require__(1167);
var _isObjectLike = __webpack_require__(5564);
var _kinds = __webpack_require__(5923);
var _definition = __webpack_require__(7982);
var _scalars = __webpack_require__(9570);
/**
 * Produces a GraphQL Value AST given a JavaScript object.
 * Function will match JavaScript/JSON values to GraphQL AST schema format
 * by using suggested GraphQLInputType. For example:
 *
 *     astFromValue("value", GraphQLString)
 *
 * A GraphQL type must be provided, which will be used to interpret different
 * JavaScript values.
 *
 * | JSON Value    | GraphQL Value        |
 * | ------------- | -------------------- |
 * | Object        | Input Object         |
 * | Array         | List                 |
 * | Boolean       | Boolean              |
 * | String        | String / Enum Value  |
 * | Number        | Int / Float          |
 * | Unknown       | Enum Value           |
 * | null          | NullValue            |
 *
 */ function astFromValue(value, type) {
    if ((0, _definition.isNonNullType)(type)) {
        const astValue = astFromValue(value, type.ofType);
        if ((astValue === null || astValue === void 0 ? void 0 : astValue.kind) === _kinds.Kind.NULL) {
            return null;
        }
        return astValue;
    } // only explicit null, not undefined, NaN
    if (value === null) {
        return {
            kind: _kinds.Kind.NULL
        };
    } // undefined
    if (value === undefined) {
        return null;
    } // Convert JavaScript array to GraphQL list. If the GraphQLType is a list, but
    // the value is not an array, convert the value using the list's item type.
    if ((0, _definition.isListType)(type)) {
        const itemType = type.ofType;
        if ((0, _isIterableObject.isIterableObject)(value)) {
            const valuesNodes = [];
            for (const item of value){
                const itemNode = astFromValue(item, itemType);
                if (itemNode != null) {
                    valuesNodes.push(itemNode);
                }
            }
            return {
                kind: _kinds.Kind.LIST,
                values: valuesNodes
            };
        }
        return astFromValue(value, itemType);
    } // Populate the fields of the input object by creating ASTs from each value
    // in the JavaScript object according to the fields in the input type.
    if ((0, _definition.isInputObjectType)(type)) {
        if (!(0, _isObjectLike.isObjectLike)(value)) {
            return null;
        }
        const fieldNodes = [];
        for (const field of Object.values(type.getFields())){
            const fieldValue = astFromValue(value[field.name], field.type);
            if (fieldValue) {
                fieldNodes.push({
                    kind: _kinds.Kind.OBJECT_FIELD,
                    name: {
                        kind: _kinds.Kind.NAME,
                        value: field.name
                    },
                    value: fieldValue
                });
            }
        }
        return {
            kind: _kinds.Kind.OBJECT,
            fields: fieldNodes
        };
    }
    if ((0, _definition.isLeafType)(type)) {
        // Since value is an internally represented value, it must be serialized
        // to an externally represented value before converting into an AST.
        const serialized = type.serialize(value);
        if (serialized == null) {
            return null;
        } // Others serialize based on their corresponding JavaScript scalar types.
        if (typeof serialized === "boolean") {
            return {
                kind: _kinds.Kind.BOOLEAN,
                value: serialized
            };
        } // JavaScript numbers can be Int or Float values.
        if (typeof serialized === "number" && Number.isFinite(serialized)) {
            const stringNum = String(serialized);
            return integerStringRegExp.test(stringNum) ? {
                kind: _kinds.Kind.INT,
                value: stringNum
            } : {
                kind: _kinds.Kind.FLOAT,
                value: stringNum
            };
        }
        if (typeof serialized === "string") {
            // Enum types use Enum literals.
            if ((0, _definition.isEnumType)(type)) {
                return {
                    kind: _kinds.Kind.ENUM,
                    value: serialized
                };
            } // ID types can use Int literals.
            if (type === _scalars.GraphQLID && integerStringRegExp.test(serialized)) {
                return {
                    kind: _kinds.Kind.INT,
                    value: serialized
                };
            }
            return {
                kind: _kinds.Kind.STRING,
                value: serialized
            };
        }
        throw new TypeError(`Cannot convert value to AST: ${(0, _inspect.inspect)(serialized)}.`);
    }
    /* c8 ignore next 3 */ // Not reachable, all possible types have been considered.
     false || (0, _invariant.invariant)(false, "Unexpected input type: " + (0, _inspect.inspect)(type));
}
/**
 * IntValue:
 *   - NegativeSign? 0
 *   - NegativeSign? NonZeroDigit ( Digit+ )?
 */ const integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;


/***/ }),

/***/ 3169:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.buildASTSchema = buildASTSchema;
exports.buildSchema = buildSchema;
var _devAssert = __webpack_require__(90);
var _kinds = __webpack_require__(5923);
var _parser = __webpack_require__(8208);
var _directives = __webpack_require__(3554);
var _schema = __webpack_require__(9723);
var _validate = __webpack_require__(9571);
var _extendSchema = __webpack_require__(4189);
/**
 * This takes the ast of a schema document produced by the parse function in
 * src/language/parser.js.
 *
 * If no schema definition is provided, then it will look for types named Query,
 * Mutation and Subscription.
 *
 * Given that AST it constructs a GraphQLSchema. The resulting schema
 * has no resolve methods, so execution will use default resolvers.
 */ function buildASTSchema(documentAST, options) {
    documentAST != null && documentAST.kind === _kinds.Kind.DOCUMENT || (0, _devAssert.devAssert)(false, "Must provide valid Document AST.");
    if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {
        (0, _validate.assertValidSDL)(documentAST);
    }
    const emptySchemaConfig = {
        description: undefined,
        types: [],
        directives: [],
        extensions: Object.create(null),
        extensionASTNodes: [],
        assumeValid: false
    };
    const config = (0, _extendSchema.extendSchemaImpl)(emptySchemaConfig, documentAST, options);
    if (config.astNode == null) {
        for (const type of config.types){
            switch(type.name){
                // Note: While this could make early assertions to get the correctly
                // typed values below, that would throw immediately while type system
                // validation with validateSchema() will produce more actionable results.
                case "Query":
                    // @ts-expect-error validated in `validateSchema`
                    config.query = type;
                    break;
                case "Mutation":
                    // @ts-expect-error validated in `validateSchema`
                    config.mutation = type;
                    break;
                case "Subscription":
                    // @ts-expect-error validated in `validateSchema`
                    config.subscription = type;
                    break;
            }
        }
    }
    const directives = [
        ...config.directives,
        ..._directives.specifiedDirectives.filter((stdDirective)=>config.directives.every((directive)=>directive.name !== stdDirective.name))
    ];
    return new _schema.GraphQLSchema({
        ...config,
        directives
    });
}
/**
 * A helper function to build a GraphQLSchema directly from a source
 * document.
 */ function buildSchema(source, options) {
    const document = (0, _parser.parse)(source, {
        noLocation: options === null || options === void 0 ? void 0 : options.noLocation,
        allowLegacyFragmentVariables: options === null || options === void 0 ? void 0 : options.allowLegacyFragmentVariables
    });
    return buildASTSchema(document, {
        assumeValidSDL: options === null || options === void 0 ? void 0 : options.assumeValidSDL,
        assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid
    });
}


/***/ }),

/***/ 4462:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.buildClientSchema = buildClientSchema;
var _devAssert = __webpack_require__(90);
var _inspect = __webpack_require__(8089);
var _isObjectLike = __webpack_require__(5564);
var _keyValMap = __webpack_require__(370);
var _parser = __webpack_require__(8208);
var _definition = __webpack_require__(7982);
var _directives = __webpack_require__(3554);
var _introspection = __webpack_require__(1472);
var _scalars = __webpack_require__(9570);
var _schema = __webpack_require__(9723);
var _valueFromAST = __webpack_require__(7735);
/**
 * Build a GraphQLSchema for use by client tools.
 *
 * Given the result of a client running the introspection query, creates and
 * returns a GraphQLSchema instance which can be then used with all graphql-js
 * tools, but cannot be used to execute a query, as introspection does not
 * represent the "resolver", "parse" or "serialize" functions or any other
 * server-internal mechanisms.
 *
 * This function expects a complete introspection result. Don't forget to check
 * the "errors" field of a server response before calling this function.
 */ function buildClientSchema(introspection, options) {
    (0, _isObjectLike.isObjectLike)(introspection) && (0, _isObjectLike.isObjectLike)(introspection.__schema) || (0, _devAssert.devAssert)(false, `Invalid or incomplete introspection result. Ensure that you are passing "data" property of introspection response and no "errors" was returned alongside: ${(0, _inspect.inspect)(introspection)}.`); // Get the schema from the introspection result.
    const schemaIntrospection = introspection.__schema; // Iterate through all types, getting the type definition for each.
    const typeMap = (0, _keyValMap.keyValMap)(schemaIntrospection.types, (typeIntrospection)=>typeIntrospection.name, (typeIntrospection)=>buildType(typeIntrospection)); // Include standard types only if they are used.
    for (const stdType of [
        ..._scalars.specifiedScalarTypes,
        ..._introspection.introspectionTypes
    ]){
        if (typeMap[stdType.name]) {
            typeMap[stdType.name] = stdType;
        }
    } // Get the root Query, Mutation, and Subscription types.
    const queryType = schemaIntrospection.queryType ? getObjectType(schemaIntrospection.queryType) : null;
    const mutationType = schemaIntrospection.mutationType ? getObjectType(schemaIntrospection.mutationType) : null;
    const subscriptionType = schemaIntrospection.subscriptionType ? getObjectType(schemaIntrospection.subscriptionType) : null; // Get the directives supported by Introspection, assuming empty-set if
    // directives were not queried for.
    const directives = schemaIntrospection.directives ? schemaIntrospection.directives.map(buildDirective) : []; // Then produce and return a Schema with these types.
    return new _schema.GraphQLSchema({
        description: schemaIntrospection.description,
        query: queryType,
        mutation: mutationType,
        subscription: subscriptionType,
        types: Object.values(typeMap),
        directives,
        assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid
    }); // Given a type reference in introspection, return the GraphQLType instance.
    // preferring cached instances before building new instances.
    function getType(typeRef) {
        if (typeRef.kind === _introspection.TypeKind.LIST) {
            const itemRef = typeRef.ofType;
            if (!itemRef) {
                throw new Error("Decorated type deeper than introspection query.");
            }
            return new _definition.GraphQLList(getType(itemRef));
        }
        if (typeRef.kind === _introspection.TypeKind.NON_NULL) {
            const nullableRef = typeRef.ofType;
            if (!nullableRef) {
                throw new Error("Decorated type deeper than introspection query.");
            }
            const nullableType = getType(nullableRef);
            return new _definition.GraphQLNonNull((0, _definition.assertNullableType)(nullableType));
        }
        return getNamedType(typeRef);
    }
    function getNamedType(typeRef) {
        const typeName = typeRef.name;
        if (!typeName) {
            throw new Error(`Unknown type reference: ${(0, _inspect.inspect)(typeRef)}.`);
        }
        const type = typeMap[typeName];
        if (!type) {
            throw new Error(`Invalid or incomplete schema, unknown type: ${typeName}. Ensure that a full introspection query is used in order to build a client schema.`);
        }
        return type;
    }
    function getObjectType(typeRef) {
        return (0, _definition.assertObjectType)(getNamedType(typeRef));
    }
    function getInterfaceType(typeRef) {
        return (0, _definition.assertInterfaceType)(getNamedType(typeRef));
    } // Given a type's introspection result, construct the correct
    // GraphQLType instance.
    function buildType(type) {
        // eslint-disable-next-line @typescript-eslint/prefer-optional-chain
        if (type != null && type.name != null && type.kind != null) {
            // FIXME: Properly type IntrospectionType, it's a breaking change so fix in v17
            // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check
            switch(type.kind){
                case _introspection.TypeKind.SCALAR:
                    return buildScalarDef(type);
                case _introspection.TypeKind.OBJECT:
                    return buildObjectDef(type);
                case _introspection.TypeKind.INTERFACE:
                    return buildInterfaceDef(type);
                case _introspection.TypeKind.UNION:
                    return buildUnionDef(type);
                case _introspection.TypeKind.ENUM:
                    return buildEnumDef(type);
                case _introspection.TypeKind.INPUT_OBJECT:
                    return buildInputObjectDef(type);
            }
        }
        const typeStr = (0, _inspect.inspect)(type);
        throw new Error(`Invalid or incomplete introspection result. Ensure that a full introspection query is used in order to build a client schema: ${typeStr}.`);
    }
    function buildScalarDef(scalarIntrospection) {
        return new _definition.GraphQLScalarType({
            name: scalarIntrospection.name,
            description: scalarIntrospection.description,
            specifiedByURL: scalarIntrospection.specifiedByURL
        });
    }
    function buildImplementationsList(implementingIntrospection) {
        // TODO: Temporary workaround until GraphQL ecosystem will fully support
        // 'interfaces' on interface types.
        if (implementingIntrospection.interfaces === null && implementingIntrospection.kind === _introspection.TypeKind.INTERFACE) {
            return [];
        }
        if (!implementingIntrospection.interfaces) {
            const implementingIntrospectionStr = (0, _inspect.inspect)(implementingIntrospection);
            throw new Error(`Introspection result missing interfaces: ${implementingIntrospectionStr}.`);
        }
        return implementingIntrospection.interfaces.map(getInterfaceType);
    }
    function buildObjectDef(objectIntrospection) {
        return new _definition.GraphQLObjectType({
            name: objectIntrospection.name,
            description: objectIntrospection.description,
            interfaces: ()=>buildImplementationsList(objectIntrospection),
            fields: ()=>buildFieldDefMap(objectIntrospection)
        });
    }
    function buildInterfaceDef(interfaceIntrospection) {
        return new _definition.GraphQLInterfaceType({
            name: interfaceIntrospection.name,
            description: interfaceIntrospection.description,
            interfaces: ()=>buildImplementationsList(interfaceIntrospection),
            fields: ()=>buildFieldDefMap(interfaceIntrospection)
        });
    }
    function buildUnionDef(unionIntrospection) {
        if (!unionIntrospection.possibleTypes) {
            const unionIntrospectionStr = (0, _inspect.inspect)(unionIntrospection);
            throw new Error(`Introspection result missing possibleTypes: ${unionIntrospectionStr}.`);
        }
        return new _definition.GraphQLUnionType({
            name: unionIntrospection.name,
            description: unionIntrospection.description,
            types: ()=>unionIntrospection.possibleTypes.map(getObjectType)
        });
    }
    function buildEnumDef(enumIntrospection) {
        if (!enumIntrospection.enumValues) {
            const enumIntrospectionStr = (0, _inspect.inspect)(enumIntrospection);
            throw new Error(`Introspection result missing enumValues: ${enumIntrospectionStr}.`);
        }
        return new _definition.GraphQLEnumType({
            name: enumIntrospection.name,
            description: enumIntrospection.description,
            values: (0, _keyValMap.keyValMap)(enumIntrospection.enumValues, (valueIntrospection)=>valueIntrospection.name, (valueIntrospection)=>({
                    description: valueIntrospection.description,
                    deprecationReason: valueIntrospection.deprecationReason
                }))
        });
    }
    function buildInputObjectDef(inputObjectIntrospection) {
        if (!inputObjectIntrospection.inputFields) {
            const inputObjectIntrospectionStr = (0, _inspect.inspect)(inputObjectIntrospection);
            throw new Error(`Introspection result missing inputFields: ${inputObjectIntrospectionStr}.`);
        }
        return new _definition.GraphQLInputObjectType({
            name: inputObjectIntrospection.name,
            description: inputObjectIntrospection.description,
            fields: ()=>buildInputValueDefMap(inputObjectIntrospection.inputFields)
        });
    }
    function buildFieldDefMap(typeIntrospection) {
        if (!typeIntrospection.fields) {
            throw new Error(`Introspection result missing fields: ${(0, _inspect.inspect)(typeIntrospection)}.`);
        }
        return (0, _keyValMap.keyValMap)(typeIntrospection.fields, (fieldIntrospection)=>fieldIntrospection.name, buildField);
    }
    function buildField(fieldIntrospection) {
        const type = getType(fieldIntrospection.type);
        if (!(0, _definition.isOutputType)(type)) {
            const typeStr = (0, _inspect.inspect)(type);
            throw new Error(`Introspection must provide output type for fields, but received: ${typeStr}.`);
        }
        if (!fieldIntrospection.args) {
            const fieldIntrospectionStr = (0, _inspect.inspect)(fieldIntrospection);
            throw new Error(`Introspection result missing field args: ${fieldIntrospectionStr}.`);
        }
        return {
            description: fieldIntrospection.description,
            deprecationReason: fieldIntrospection.deprecationReason,
            type,
            args: buildInputValueDefMap(fieldIntrospection.args)
        };
    }
    function buildInputValueDefMap(inputValueIntrospections) {
        return (0, _keyValMap.keyValMap)(inputValueIntrospections, (inputValue)=>inputValue.name, buildInputValue);
    }
    function buildInputValue(inputValueIntrospection) {
        const type = getType(inputValueIntrospection.type);
        if (!(0, _definition.isInputType)(type)) {
            const typeStr = (0, _inspect.inspect)(type);
            throw new Error(`Introspection must provide input type for arguments, but received: ${typeStr}.`);
        }
        const defaultValue = inputValueIntrospection.defaultValue != null ? (0, _valueFromAST.valueFromAST)((0, _parser.parseValue)(inputValueIntrospection.defaultValue), type) : undefined;
        return {
            description: inputValueIntrospection.description,
            type,
            defaultValue,
            deprecationReason: inputValueIntrospection.deprecationReason
        };
    }
    function buildDirective(directiveIntrospection) {
        if (!directiveIntrospection.args) {
            const directiveIntrospectionStr = (0, _inspect.inspect)(directiveIntrospection);
            throw new Error(`Introspection result missing directive args: ${directiveIntrospectionStr}.`);
        }
        if (!directiveIntrospection.locations) {
            const directiveIntrospectionStr = (0, _inspect.inspect)(directiveIntrospection);
            throw new Error(`Introspection result missing directive locations: ${directiveIntrospectionStr}.`);
        }
        return new _directives.GraphQLDirective({
            name: directiveIntrospection.name,
            description: directiveIntrospection.description,
            isRepeatable: directiveIntrospection.isRepeatable,
            locations: directiveIntrospection.locations.slice(),
            args: buildInputValueDefMap(directiveIntrospection.args)
        });
    }
}


/***/ }),

/***/ 1401:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.coerceInputValue = coerceInputValue;
var _didYouMean = __webpack_require__(2228);
var _inspect = __webpack_require__(8089);
var _invariant = __webpack_require__(5210);
var _isIterableObject = __webpack_require__(1167);
var _isObjectLike = __webpack_require__(5564);
var _Path = __webpack_require__(6032);
var _printPathArray = __webpack_require__(7884);
var _suggestionList = __webpack_require__(6347);
var _GraphQLError = __webpack_require__(2169);
var _definition = __webpack_require__(7982);
/**
 * Coerces a JavaScript value given a GraphQL Input Type.
 */ function coerceInputValue(inputValue, type, onError = defaultOnError) {
    return coerceInputValueImpl(inputValue, type, onError, undefined);
}
function defaultOnError(path, invalidValue, error) {
    let errorPrefix = "Invalid value " + (0, _inspect.inspect)(invalidValue);
    if (path.length > 0) {
        errorPrefix += ` at "value${(0, _printPathArray.printPathArray)(path)}"`;
    }
    error.message = errorPrefix + ": " + error.message;
    throw error;
}
function coerceInputValueImpl(inputValue, type, onError, path) {
    if ((0, _definition.isNonNullType)(type)) {
        if (inputValue != null) {
            return coerceInputValueImpl(inputValue, type.ofType, onError, path);
        }
        onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError(`Expected non-nullable type "${(0, _inspect.inspect)(type)}" not to be null.`));
        return;
    }
    if (inputValue == null) {
        // Explicitly return the value null.
        return null;
    }
    if ((0, _definition.isListType)(type)) {
        const itemType = type.ofType;
        if ((0, _isIterableObject.isIterableObject)(inputValue)) {
            return Array.from(inputValue, (itemValue, index)=>{
                const itemPath = (0, _Path.addPath)(path, index, undefined);
                return coerceInputValueImpl(itemValue, itemType, onError, itemPath);
            });
        } // Lists accept a non-list value as a list of one.
        return [
            coerceInputValueImpl(inputValue, itemType, onError, path)
        ];
    }
    if ((0, _definition.isInputObjectType)(type)) {
        if (!(0, _isObjectLike.isObjectLike)(inputValue)) {
            onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError(`Expected type "${type.name}" to be an object.`));
            return;
        }
        const coercedValue = {};
        const fieldDefs = type.getFields();
        for (const field of Object.values(fieldDefs)){
            const fieldValue = inputValue[field.name];
            if (fieldValue === undefined) {
                if (field.defaultValue !== undefined) {
                    coercedValue[field.name] = field.defaultValue;
                } else if ((0, _definition.isNonNullType)(field.type)) {
                    const typeStr = (0, _inspect.inspect)(field.type);
                    onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError(`Field "${field.name}" of required type "${typeStr}" was not provided.`));
                }
                continue;
            }
            coercedValue[field.name] = coerceInputValueImpl(fieldValue, field.type, onError, (0, _Path.addPath)(path, field.name, type.name));
        } // Ensure every provided field is defined.
        for (const fieldName of Object.keys(inputValue)){
            if (!fieldDefs[fieldName]) {
                const suggestions = (0, _suggestionList.suggestionList)(fieldName, Object.keys(type.getFields()));
                onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError(`Field "${fieldName}" is not defined by type "${type.name}".` + (0, _didYouMean.didYouMean)(suggestions)));
            }
        }
        return coercedValue;
    }
    if ((0, _definition.isLeafType)(type)) {
        let parseResult; // Scalars and Enums determine if a input value is valid via parseValue(),
        // which can throw to indicate failure. If it throws, maintain a reference
        // to the original error.
        try {
            parseResult = type.parseValue(inputValue);
        } catch (error) {
            if (error instanceof _GraphQLError.GraphQLError) {
                onError((0, _Path.pathToArray)(path), inputValue, error);
            } else {
                onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError(`Expected type "${type.name}". ` + error.message, {
                    originalError: error
                }));
            }
            return;
        }
        if (parseResult === undefined) {
            onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError(`Expected type "${type.name}".`));
        }
        return parseResult;
    }
    /* c8 ignore next 3 */ // Not reachable, all possible types have been considered.
     false || (0, _invariant.invariant)(false, "Unexpected input type: " + (0, _inspect.inspect)(type));
}


/***/ }),

/***/ 9095:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.concatAST = concatAST;
var _kinds = __webpack_require__(5923);
/**
 * Provided a collection of ASTs, presumably each from different files,
 * concatenate the ASTs together into batched AST, useful for validating many
 * GraphQL source files which together represent one conceptual application.
 */ function concatAST(documents) {
    const definitions = [];
    for (const doc of documents){
        definitions.push(...doc.definitions);
    }
    return {
        kind: _kinds.Kind.DOCUMENT,
        definitions
    };
}


/***/ }),

/***/ 4189:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.extendSchema = extendSchema;
exports.extendSchemaImpl = extendSchemaImpl;
var _devAssert = __webpack_require__(90);
var _inspect = __webpack_require__(8089);
var _invariant = __webpack_require__(5210);
var _keyMap = __webpack_require__(2512);
var _mapValue = __webpack_require__(1030);
var _kinds = __webpack_require__(5923);
var _predicates = __webpack_require__(3288);
var _definition = __webpack_require__(7982);
var _directives = __webpack_require__(3554);
var _introspection = __webpack_require__(1472);
var _scalars = __webpack_require__(9570);
var _schema = __webpack_require__(9723);
var _validate = __webpack_require__(9571);
var _values = __webpack_require__(8732);
var _valueFromAST = __webpack_require__(7735);
/**
 * Produces a new schema given an existing schema and a document which may
 * contain GraphQL type extensions and definitions. The original schema will
 * remain unaltered.
 *
 * Because a schema represents a graph of references, a schema cannot be
 * extended without effectively making an entire copy. We do not know until it's
 * too late if subgraphs remain unchanged.
 *
 * This algorithm copies the provided schema, applying extensions while
 * producing the copy. The original schema remains unaltered.
 */ function extendSchema(schema, documentAST, options) {
    (0, _schema.assertSchema)(schema);
    documentAST != null && documentAST.kind === _kinds.Kind.DOCUMENT || (0, _devAssert.devAssert)(false, "Must provide valid Document AST.");
    if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {
        (0, _validate.assertValidSDLExtension)(documentAST, schema);
    }
    const schemaConfig = schema.toConfig();
    const extendedConfig = extendSchemaImpl(schemaConfig, documentAST, options);
    return schemaConfig === extendedConfig ? schema : new _schema.GraphQLSchema(extendedConfig);
}
/**
 * @internal
 */ function extendSchemaImpl(schemaConfig, documentAST, options) {
    var _schemaDef, _schemaDef$descriptio, _schemaDef2, _options$assumeValid;
    // Collect the type definitions and extensions found in the document.
    const typeDefs = [];
    const typeExtensionsMap = Object.create(null); // New directives and types are separate because a directives and types can
    // have the same name. For example, a type named "skip".
    const directiveDefs = [];
    let schemaDef; // Schema extensions are collected which may add additional operation types.
    const schemaExtensions = [];
    for (const def of documentAST.definitions){
        if (def.kind === _kinds.Kind.SCHEMA_DEFINITION) {
            schemaDef = def;
        } else if (def.kind === _kinds.Kind.SCHEMA_EXTENSION) {
            schemaExtensions.push(def);
        } else if ((0, _predicates.isTypeDefinitionNode)(def)) {
            typeDefs.push(def);
        } else if ((0, _predicates.isTypeExtensionNode)(def)) {
            const extendedTypeName = def.name.value;
            const existingTypeExtensions = typeExtensionsMap[extendedTypeName];
            typeExtensionsMap[extendedTypeName] = existingTypeExtensions ? existingTypeExtensions.concat([
                def
            ]) : [
                def
            ];
        } else if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
            directiveDefs.push(def);
        }
    } // If this document contains no new types, extensions, or directives then
    // return the same unmodified GraphQLSchema instance.
    if (Object.keys(typeExtensionsMap).length === 0 && typeDefs.length === 0 && directiveDefs.length === 0 && schemaExtensions.length === 0 && schemaDef == null) {
        return schemaConfig;
    }
    const typeMap = Object.create(null);
    for (const existingType of schemaConfig.types){
        typeMap[existingType.name] = extendNamedType(existingType);
    }
    for (const typeNode of typeDefs){
        var _stdTypeMap$name;
        const name = typeNode.name.value;
        typeMap[name] = (_stdTypeMap$name = stdTypeMap[name]) !== null && _stdTypeMap$name !== void 0 ? _stdTypeMap$name : buildType(typeNode);
    }
    const operationTypes = {
        // Get the extended root operation types.
        query: schemaConfig.query && replaceNamedType(schemaConfig.query),
        mutation: schemaConfig.mutation && replaceNamedType(schemaConfig.mutation),
        subscription: schemaConfig.subscription && replaceNamedType(schemaConfig.subscription),
        // Then, incorporate schema definition and all schema extensions.
        ...schemaDef && getOperationTypes([
            schemaDef
        ]),
        ...getOperationTypes(schemaExtensions)
    }; // Then produce and return a Schema config with these types.
    return {
        description: (_schemaDef = schemaDef) === null || _schemaDef === void 0 ? void 0 : (_schemaDef$descriptio = _schemaDef.description) === null || _schemaDef$descriptio === void 0 ? void 0 : _schemaDef$descriptio.value,
        ...operationTypes,
        types: Object.values(typeMap),
        directives: [
            ...schemaConfig.directives.map(replaceDirective),
            ...directiveDefs.map(buildDirective)
        ],
        extensions: Object.create(null),
        astNode: (_schemaDef2 = schemaDef) !== null && _schemaDef2 !== void 0 ? _schemaDef2 : schemaConfig.astNode,
        extensionASTNodes: schemaConfig.extensionASTNodes.concat(schemaExtensions),
        assumeValid: (_options$assumeValid = options === null || options === void 0 ? void 0 : options.assumeValid) !== null && _options$assumeValid !== void 0 ? _options$assumeValid : false
    }; // Below are functions used for producing this schema that have closed over
    // this scope and have access to the schema, cache, and newly defined types.
    function replaceType(type) {
        if ((0, _definition.isListType)(type)) {
            // @ts-expect-error
            return new _definition.GraphQLList(replaceType(type.ofType));
        }
        if ((0, _definition.isNonNullType)(type)) {
            // @ts-expect-error
            return new _definition.GraphQLNonNull(replaceType(type.ofType));
        } // @ts-expect-error FIXME
        return replaceNamedType(type);
    }
    function replaceNamedType(type) {
        // Note: While this could make early assertions to get the correctly
        // typed values, that would throw immediately while type system
        // validation with validateSchema() will produce more actionable results.
        return typeMap[type.name];
    }
    function replaceDirective(directive) {
        const config = directive.toConfig();
        return new _directives.GraphQLDirective({
            ...config,
            args: (0, _mapValue.mapValue)(config.args, extendArg)
        });
    }
    function extendNamedType(type) {
        if ((0, _introspection.isIntrospectionType)(type) || (0, _scalars.isSpecifiedScalarType)(type)) {
            // Builtin types are not extended.
            return type;
        }
        if ((0, _definition.isScalarType)(type)) {
            return extendScalarType(type);
        }
        if ((0, _definition.isObjectType)(type)) {
            return extendObjectType(type);
        }
        if ((0, _definition.isInterfaceType)(type)) {
            return extendInterfaceType(type);
        }
        if ((0, _definition.isUnionType)(type)) {
            return extendUnionType(type);
        }
        if ((0, _definition.isEnumType)(type)) {
            return extendEnumType(type);
        }
        if ((0, _definition.isInputObjectType)(type)) {
            return extendInputObjectType(type);
        }
        /* c8 ignore next 3 */ // Not reachable, all possible type definition nodes have been considered.
         false || (0, _invariant.invariant)(false, "Unexpected type: " + (0, _inspect.inspect)(type));
    }
    function extendInputObjectType(type) {
        var _typeExtensionsMap$co;
        const config = type.toConfig();
        const extensions = (_typeExtensionsMap$co = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co !== void 0 ? _typeExtensionsMap$co : [];
        return new _definition.GraphQLInputObjectType({
            ...config,
            fields: ()=>({
                    ...(0, _mapValue.mapValue)(config.fields, (field)=>({
                            ...field,
                            type: replaceType(field.type)
                        })),
                    ...buildInputFieldMap(extensions)
                }),
            extensionASTNodes: config.extensionASTNodes.concat(extensions)
        });
    }
    function extendEnumType(type) {
        var _typeExtensionsMap$ty;
        const config = type.toConfig();
        const extensions = (_typeExtensionsMap$ty = typeExtensionsMap[type.name]) !== null && _typeExtensionsMap$ty !== void 0 ? _typeExtensionsMap$ty : [];
        return new _definition.GraphQLEnumType({
            ...config,
            values: {
                ...config.values,
                ...buildEnumValueMap(extensions)
            },
            extensionASTNodes: config.extensionASTNodes.concat(extensions)
        });
    }
    function extendScalarType(type) {
        var _typeExtensionsMap$co2;
        const config = type.toConfig();
        const extensions = (_typeExtensionsMap$co2 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co2 !== void 0 ? _typeExtensionsMap$co2 : [];
        let specifiedByURL = config.specifiedByURL;
        for (const extensionNode of extensions){
            var _getSpecifiedByURL;
            specifiedByURL = (_getSpecifiedByURL = getSpecifiedByURL(extensionNode)) !== null && _getSpecifiedByURL !== void 0 ? _getSpecifiedByURL : specifiedByURL;
        }
        return new _definition.GraphQLScalarType({
            ...config,
            specifiedByURL,
            extensionASTNodes: config.extensionASTNodes.concat(extensions)
        });
    }
    function extendObjectType(type) {
        var _typeExtensionsMap$co3;
        const config = type.toConfig();
        const extensions = (_typeExtensionsMap$co3 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co3 !== void 0 ? _typeExtensionsMap$co3 : [];
        return new _definition.GraphQLObjectType({
            ...config,
            interfaces: ()=>[
                    ...type.getInterfaces().map(replaceNamedType),
                    ...buildInterfaces(extensions)
                ],
            fields: ()=>({
                    ...(0, _mapValue.mapValue)(config.fields, extendField),
                    ...buildFieldMap(extensions)
                }),
            extensionASTNodes: config.extensionASTNodes.concat(extensions)
        });
    }
    function extendInterfaceType(type) {
        var _typeExtensionsMap$co4;
        const config = type.toConfig();
        const extensions = (_typeExtensionsMap$co4 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co4 !== void 0 ? _typeExtensionsMap$co4 : [];
        return new _definition.GraphQLInterfaceType({
            ...config,
            interfaces: ()=>[
                    ...type.getInterfaces().map(replaceNamedType),
                    ...buildInterfaces(extensions)
                ],
            fields: ()=>({
                    ...(0, _mapValue.mapValue)(config.fields, extendField),
                    ...buildFieldMap(extensions)
                }),
            extensionASTNodes: config.extensionASTNodes.concat(extensions)
        });
    }
    function extendUnionType(type) {
        var _typeExtensionsMap$co5;
        const config = type.toConfig();
        const extensions = (_typeExtensionsMap$co5 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co5 !== void 0 ? _typeExtensionsMap$co5 : [];
        return new _definition.GraphQLUnionType({
            ...config,
            types: ()=>[
                    ...type.getTypes().map(replaceNamedType),
                    ...buildUnionTypes(extensions)
                ],
            extensionASTNodes: config.extensionASTNodes.concat(extensions)
        });
    }
    function extendField(field) {
        return {
            ...field,
            type: replaceType(field.type),
            args: field.args && (0, _mapValue.mapValue)(field.args, extendArg)
        };
    }
    function extendArg(arg) {
        return {
            ...arg,
            type: replaceType(arg.type)
        };
    }
    function getOperationTypes(nodes) {
        const opTypes = {};
        for (const node of nodes){
            var _node$operationTypes;
            // FIXME: https://github.com/graphql/graphql-js/issues/2203
            const operationTypesNodes = /* c8 ignore next */ (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];
            for (const operationType of operationTypesNodes){
                // Note: While this could make early assertions to get the correctly
                // typed values below, that would throw immediately while type system
                // validation with validateSchema() will produce more actionable results.
                // @ts-expect-error
                opTypes[operationType.operation] = getNamedType(operationType.type);
            }
        }
        return opTypes;
    }
    function getNamedType(node) {
        var _stdTypeMap$name2;
        const name = node.name.value;
        const type = (_stdTypeMap$name2 = stdTypeMap[name]) !== null && _stdTypeMap$name2 !== void 0 ? _stdTypeMap$name2 : typeMap[name];
        if (type === undefined) {
            throw new Error(`Unknown type: "${name}".`);
        }
        return type;
    }
    function getWrappedType(node) {
        if (node.kind === _kinds.Kind.LIST_TYPE) {
            return new _definition.GraphQLList(getWrappedType(node.type));
        }
        if (node.kind === _kinds.Kind.NON_NULL_TYPE) {
            return new _definition.GraphQLNonNull(getWrappedType(node.type));
        }
        return getNamedType(node);
    }
    function buildDirective(node) {
        var _node$description;
        return new _directives.GraphQLDirective({
            name: node.name.value,
            description: (_node$description = node.description) === null || _node$description === void 0 ? void 0 : _node$description.value,
            // @ts-expect-error
            locations: node.locations.map(({ value  })=>value),
            isRepeatable: node.repeatable,
            args: buildArgumentMap(node.arguments),
            astNode: node
        });
    }
    function buildFieldMap(nodes) {
        const fieldConfigMap = Object.create(null);
        for (const node of nodes){
            var _node$fields;
            // FIXME: https://github.com/graphql/graphql-js/issues/2203
            const nodeFields = /* c8 ignore next */ (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];
            for (const field of nodeFields){
                var _field$description;
                fieldConfigMap[field.name.value] = {
                    // Note: While this could make assertions to get the correctly typed
                    // value, that would throw immediately while type system validation
                    // with validateSchema() will produce more actionable results.
                    type: getWrappedType(field.type),
                    description: (_field$description = field.description) === null || _field$description === void 0 ? void 0 : _field$description.value,
                    args: buildArgumentMap(field.arguments),
                    deprecationReason: getDeprecationReason(field),
                    astNode: field
                };
            }
        }
        return fieldConfigMap;
    }
    function buildArgumentMap(args) {
        // FIXME: https://github.com/graphql/graphql-js/issues/2203
        const argsNodes = /* c8 ignore next */ args !== null && args !== void 0 ? args : [];
        const argConfigMap = Object.create(null);
        for (const arg of argsNodes){
            var _arg$description;
            // Note: While this could make assertions to get the correctly typed
            // value, that would throw immediately while type system validation
            // with validateSchema() will produce more actionable results.
            const type = getWrappedType(arg.type);
            argConfigMap[arg.name.value] = {
                type,
                description: (_arg$description = arg.description) === null || _arg$description === void 0 ? void 0 : _arg$description.value,
                defaultValue: (0, _valueFromAST.valueFromAST)(arg.defaultValue, type),
                deprecationReason: getDeprecationReason(arg),
                astNode: arg
            };
        }
        return argConfigMap;
    }
    function buildInputFieldMap(nodes) {
        const inputFieldMap = Object.create(null);
        for (const node of nodes){
            var _node$fields2;
            // FIXME: https://github.com/graphql/graphql-js/issues/2203
            const fieldsNodes = /* c8 ignore next */ (_node$fields2 = node.fields) !== null && _node$fields2 !== void 0 ? _node$fields2 : [];
            for (const field of fieldsNodes){
                var _field$description2;
                // Note: While this could make assertions to get the correctly typed
                // value, that would throw immediately while type system validation
                // with validateSchema() will produce more actionable results.
                const type = getWrappedType(field.type);
                inputFieldMap[field.name.value] = {
                    type,
                    description: (_field$description2 = field.description) === null || _field$description2 === void 0 ? void 0 : _field$description2.value,
                    defaultValue: (0, _valueFromAST.valueFromAST)(field.defaultValue, type),
                    deprecationReason: getDeprecationReason(field),
                    astNode: field
                };
            }
        }
        return inputFieldMap;
    }
    function buildEnumValueMap(nodes) {
        const enumValueMap = Object.create(null);
        for (const node of nodes){
            var _node$values;
            // FIXME: https://github.com/graphql/graphql-js/issues/2203
            const valuesNodes = /* c8 ignore next */ (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];
            for (const value of valuesNodes){
                var _value$description;
                enumValueMap[value.name.value] = {
                    description: (_value$description = value.description) === null || _value$description === void 0 ? void 0 : _value$description.value,
                    deprecationReason: getDeprecationReason(value),
                    astNode: value
                };
            }
        }
        return enumValueMap;
    }
    function buildInterfaces(nodes) {
        // Note: While this could make assertions to get the correctly typed
        // values below, that would throw immediately while type system
        // validation with validateSchema() will produce more actionable results.
        // @ts-expect-error
        return nodes.flatMap(// FIXME: https://github.com/graphql/graphql-js/issues/2203
        (node)=>{
            var _node$interfaces$map, _node$interfaces;
            return /* c8 ignore next */ (_node$interfaces$map = (_node$interfaces = node.interfaces) === null || _node$interfaces === void 0 ? void 0 : _node$interfaces.map(getNamedType)) !== null && _node$interfaces$map !== void 0 ? _node$interfaces$map : [];
        });
    }
    function buildUnionTypes(nodes) {
        // Note: While this could make assertions to get the correctly typed
        // values below, that would throw immediately while type system
        // validation with validateSchema() will produce more actionable results.
        // @ts-expect-error
        return nodes.flatMap(// FIXME: https://github.com/graphql/graphql-js/issues/2203
        (node)=>{
            var _node$types$map, _node$types;
            return /* c8 ignore next */ (_node$types$map = (_node$types = node.types) === null || _node$types === void 0 ? void 0 : _node$types.map(getNamedType)) !== null && _node$types$map !== void 0 ? _node$types$map : [];
        });
    }
    function buildType(astNode) {
        var _typeExtensionsMap$na;
        const name = astNode.name.value;
        const extensionASTNodes = (_typeExtensionsMap$na = typeExtensionsMap[name]) !== null && _typeExtensionsMap$na !== void 0 ? _typeExtensionsMap$na : [];
        switch(astNode.kind){
            case _kinds.Kind.OBJECT_TYPE_DEFINITION:
                {
                    var _astNode$description;
                    const allNodes = [
                        astNode,
                        ...extensionASTNodes
                    ];
                    return new _definition.GraphQLObjectType({
                        name,
                        description: (_astNode$description = astNode.description) === null || _astNode$description === void 0 ? void 0 : _astNode$description.value,
                        interfaces: ()=>buildInterfaces(allNodes),
                        fields: ()=>buildFieldMap(allNodes),
                        astNode,
                        extensionASTNodes
                    });
                }
            case _kinds.Kind.INTERFACE_TYPE_DEFINITION:
                {
                    var _astNode$description2;
                    const allNodes = [
                        astNode,
                        ...extensionASTNodes
                    ];
                    return new _definition.GraphQLInterfaceType({
                        name,
                        description: (_astNode$description2 = astNode.description) === null || _astNode$description2 === void 0 ? void 0 : _astNode$description2.value,
                        interfaces: ()=>buildInterfaces(allNodes),
                        fields: ()=>buildFieldMap(allNodes),
                        astNode,
                        extensionASTNodes
                    });
                }
            case _kinds.Kind.ENUM_TYPE_DEFINITION:
                {
                    var _astNode$description3;
                    const allNodes = [
                        astNode,
                        ...extensionASTNodes
                    ];
                    return new _definition.GraphQLEnumType({
                        name,
                        description: (_astNode$description3 = astNode.description) === null || _astNode$description3 === void 0 ? void 0 : _astNode$description3.value,
                        values: buildEnumValueMap(allNodes),
                        astNode,
                        extensionASTNodes
                    });
                }
            case _kinds.Kind.UNION_TYPE_DEFINITION:
                {
                    var _astNode$description4;
                    const allNodes = [
                        astNode,
                        ...extensionASTNodes
                    ];
                    return new _definition.GraphQLUnionType({
                        name,
                        description: (_astNode$description4 = astNode.description) === null || _astNode$description4 === void 0 ? void 0 : _astNode$description4.value,
                        types: ()=>buildUnionTypes(allNodes),
                        astNode,
                        extensionASTNodes
                    });
                }
            case _kinds.Kind.SCALAR_TYPE_DEFINITION:
                {
                    var _astNode$description5;
                    return new _definition.GraphQLScalarType({
                        name,
                        description: (_astNode$description5 = astNode.description) === null || _astNode$description5 === void 0 ? void 0 : _astNode$description5.value,
                        specifiedByURL: getSpecifiedByURL(astNode),
                        astNode,
                        extensionASTNodes
                    });
                }
            case _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION:
                {
                    var _astNode$description6;
                    const allNodes = [
                        astNode,
                        ...extensionASTNodes
                    ];
                    return new _definition.GraphQLInputObjectType({
                        name,
                        description: (_astNode$description6 = astNode.description) === null || _astNode$description6 === void 0 ? void 0 : _astNode$description6.value,
                        fields: ()=>buildInputFieldMap(allNodes),
                        astNode,
                        extensionASTNodes
                    });
                }
        }
    }
}
const stdTypeMap = (0, _keyMap.keyMap)([
    ..._scalars.specifiedScalarTypes,
    ..._introspection.introspectionTypes
], (type)=>type.name);
/**
 * Given a field or enum value node, returns the string value for the
 * deprecation reason.
 */ function getDeprecationReason(node) {
    const deprecated = (0, _values.getDirectiveValues)(_directives.GraphQLDeprecatedDirective, node); // @ts-expect-error validated by `getDirectiveValues`
    return deprecated === null || deprecated === void 0 ? void 0 : deprecated.reason;
}
/**
 * Given a scalar node, returns the string value for the specifiedByURL.
 */ function getSpecifiedByURL(node) {
    const specifiedBy = (0, _values.getDirectiveValues)(_directives.GraphQLSpecifiedByDirective, node); // @ts-expect-error validated by `getDirectiveValues`
    return specifiedBy === null || specifiedBy === void 0 ? void 0 : specifiedBy.url;
}


/***/ }),

/***/ 8015:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.DangerousChangeType = exports.BreakingChangeType = void 0;
exports.findBreakingChanges = findBreakingChanges;
exports.findDangerousChanges = findDangerousChanges;
var _inspect = __webpack_require__(8089);
var _invariant = __webpack_require__(5210);
var _keyMap = __webpack_require__(2512);
var _printer = __webpack_require__(800);
var _definition = __webpack_require__(7982);
var _scalars = __webpack_require__(9570);
var _astFromValue = __webpack_require__(8042);
var _sortValueNode = __webpack_require__(6063);
var BreakingChangeType;
exports.BreakingChangeType = BreakingChangeType;
(function(BreakingChangeType) {
    BreakingChangeType["TYPE_REMOVED"] = "TYPE_REMOVED";
    BreakingChangeType["TYPE_CHANGED_KIND"] = "TYPE_CHANGED_KIND";
    BreakingChangeType["TYPE_REMOVED_FROM_UNION"] = "TYPE_REMOVED_FROM_UNION";
    BreakingChangeType["VALUE_REMOVED_FROM_ENUM"] = "VALUE_REMOVED_FROM_ENUM";
    BreakingChangeType["REQUIRED_INPUT_FIELD_ADDED"] = "REQUIRED_INPUT_FIELD_ADDED";
    BreakingChangeType["IMPLEMENTED_INTERFACE_REMOVED"] = "IMPLEMENTED_INTERFACE_REMOVED";
    BreakingChangeType["FIELD_REMOVED"] = "FIELD_REMOVED";
    BreakingChangeType["FIELD_CHANGED_KIND"] = "FIELD_CHANGED_KIND";
    BreakingChangeType["REQUIRED_ARG_ADDED"] = "REQUIRED_ARG_ADDED";
    BreakingChangeType["ARG_REMOVED"] = "ARG_REMOVED";
    BreakingChangeType["ARG_CHANGED_KIND"] = "ARG_CHANGED_KIND";
    BreakingChangeType["DIRECTIVE_REMOVED"] = "DIRECTIVE_REMOVED";
    BreakingChangeType["DIRECTIVE_ARG_REMOVED"] = "DIRECTIVE_ARG_REMOVED";
    BreakingChangeType["REQUIRED_DIRECTIVE_ARG_ADDED"] = "REQUIRED_DIRECTIVE_ARG_ADDED";
    BreakingChangeType["DIRECTIVE_REPEATABLE_REMOVED"] = "DIRECTIVE_REPEATABLE_REMOVED";
    BreakingChangeType["DIRECTIVE_LOCATION_REMOVED"] = "DIRECTIVE_LOCATION_REMOVED";
})(BreakingChangeType || (exports.BreakingChangeType = BreakingChangeType = {}));
var DangerousChangeType;
exports.DangerousChangeType = DangerousChangeType;
(function(DangerousChangeType) {
    DangerousChangeType["VALUE_ADDED_TO_ENUM"] = "VALUE_ADDED_TO_ENUM";
    DangerousChangeType["TYPE_ADDED_TO_UNION"] = "TYPE_ADDED_TO_UNION";
    DangerousChangeType["OPTIONAL_INPUT_FIELD_ADDED"] = "OPTIONAL_INPUT_FIELD_ADDED";
    DangerousChangeType["OPTIONAL_ARG_ADDED"] = "OPTIONAL_ARG_ADDED";
    DangerousChangeType["IMPLEMENTED_INTERFACE_ADDED"] = "IMPLEMENTED_INTERFACE_ADDED";
    DangerousChangeType["ARG_DEFAULT_VALUE_CHANGE"] = "ARG_DEFAULT_VALUE_CHANGE";
})(DangerousChangeType || (exports.DangerousChangeType = DangerousChangeType = {}));
/**
 * Given two schemas, returns an Array containing descriptions of all the types
 * of breaking changes covered by the other functions down below.
 */ function findBreakingChanges(oldSchema, newSchema) {
    // @ts-expect-error
    return findSchemaChanges(oldSchema, newSchema).filter((change)=>change.type in BreakingChangeType);
}
/**
 * Given two schemas, returns an Array containing descriptions of all the types
 * of potentially dangerous changes covered by the other functions down below.
 */ function findDangerousChanges(oldSchema, newSchema) {
    // @ts-expect-error
    return findSchemaChanges(oldSchema, newSchema).filter((change)=>change.type in DangerousChangeType);
}
function findSchemaChanges(oldSchema, newSchema) {
    return [
        ...findTypeChanges(oldSchema, newSchema),
        ...findDirectiveChanges(oldSchema, newSchema)
    ];
}
function findDirectiveChanges(oldSchema, newSchema) {
    const schemaChanges = [];
    const directivesDiff = diff(oldSchema.getDirectives(), newSchema.getDirectives());
    for (const oldDirective of directivesDiff.removed){
        schemaChanges.push({
            type: BreakingChangeType.DIRECTIVE_REMOVED,
            description: `${oldDirective.name} was removed.`
        });
    }
    for (const [oldDirective, newDirective] of directivesDiff.persisted){
        const argsDiff = diff(oldDirective.args, newDirective.args);
        for (const newArg of argsDiff.added){
            if ((0, _definition.isRequiredArgument)(newArg)) {
                schemaChanges.push({
                    type: BreakingChangeType.REQUIRED_DIRECTIVE_ARG_ADDED,
                    description: `A required arg ${newArg.name} on directive ${oldDirective.name} was added.`
                });
            }
        }
        for (const oldArg of argsDiff.removed){
            schemaChanges.push({
                type: BreakingChangeType.DIRECTIVE_ARG_REMOVED,
                description: `${oldArg.name} was removed from ${oldDirective.name}.`
            });
        }
        if (oldDirective.isRepeatable && !newDirective.isRepeatable) {
            schemaChanges.push({
                type: BreakingChangeType.DIRECTIVE_REPEATABLE_REMOVED,
                description: `Repeatable flag was removed from ${oldDirective.name}.`
            });
        }
        for (const location of oldDirective.locations){
            if (!newDirective.locations.includes(location)) {
                schemaChanges.push({
                    type: BreakingChangeType.DIRECTIVE_LOCATION_REMOVED,
                    description: `${location} was removed from ${oldDirective.name}.`
                });
            }
        }
    }
    return schemaChanges;
}
function findTypeChanges(oldSchema, newSchema) {
    const schemaChanges = [];
    const typesDiff = diff(Object.values(oldSchema.getTypeMap()), Object.values(newSchema.getTypeMap()));
    for (const oldType of typesDiff.removed){
        schemaChanges.push({
            type: BreakingChangeType.TYPE_REMOVED,
            description: (0, _scalars.isSpecifiedScalarType)(oldType) ? `Standard scalar ${oldType.name} was removed because it is not referenced anymore.` : `${oldType.name} was removed.`
        });
    }
    for (const [oldType, newType] of typesDiff.persisted){
        if ((0, _definition.isEnumType)(oldType) && (0, _definition.isEnumType)(newType)) {
            schemaChanges.push(...findEnumTypeChanges(oldType, newType));
        } else if ((0, _definition.isUnionType)(oldType) && (0, _definition.isUnionType)(newType)) {
            schemaChanges.push(...findUnionTypeChanges(oldType, newType));
        } else if ((0, _definition.isInputObjectType)(oldType) && (0, _definition.isInputObjectType)(newType)) {
            schemaChanges.push(...findInputObjectTypeChanges(oldType, newType));
        } else if ((0, _definition.isObjectType)(oldType) && (0, _definition.isObjectType)(newType)) {
            schemaChanges.push(...findFieldChanges(oldType, newType), ...findImplementedInterfacesChanges(oldType, newType));
        } else if ((0, _definition.isInterfaceType)(oldType) && (0, _definition.isInterfaceType)(newType)) {
            schemaChanges.push(...findFieldChanges(oldType, newType), ...findImplementedInterfacesChanges(oldType, newType));
        } else if (oldType.constructor !== newType.constructor) {
            schemaChanges.push({
                type: BreakingChangeType.TYPE_CHANGED_KIND,
                description: `${oldType.name} changed from ` + `${typeKindName(oldType)} to ${typeKindName(newType)}.`
            });
        }
    }
    return schemaChanges;
}
function findInputObjectTypeChanges(oldType, newType) {
    const schemaChanges = [];
    const fieldsDiff = diff(Object.values(oldType.getFields()), Object.values(newType.getFields()));
    for (const newField of fieldsDiff.added){
        if ((0, _definition.isRequiredInputField)(newField)) {
            schemaChanges.push({
                type: BreakingChangeType.REQUIRED_INPUT_FIELD_ADDED,
                description: `A required field ${newField.name} on input type ${oldType.name} was added.`
            });
        } else {
            schemaChanges.push({
                type: DangerousChangeType.OPTIONAL_INPUT_FIELD_ADDED,
                description: `An optional field ${newField.name} on input type ${oldType.name} was added.`
            });
        }
    }
    for (const oldField of fieldsDiff.removed){
        schemaChanges.push({
            type: BreakingChangeType.FIELD_REMOVED,
            description: `${oldType.name}.${oldField.name} was removed.`
        });
    }
    for (const [oldField, newField] of fieldsDiff.persisted){
        const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(oldField.type, newField.type);
        if (!isSafe) {
            schemaChanges.push({
                type: BreakingChangeType.FIELD_CHANGED_KIND,
                description: `${oldType.name}.${oldField.name} changed type from ` + `${String(oldField.type)} to ${String(newField.type)}.`
            });
        }
    }
    return schemaChanges;
}
function findUnionTypeChanges(oldType, newType) {
    const schemaChanges = [];
    const possibleTypesDiff = diff(oldType.getTypes(), newType.getTypes());
    for (const newPossibleType of possibleTypesDiff.added){
        schemaChanges.push({
            type: DangerousChangeType.TYPE_ADDED_TO_UNION,
            description: `${newPossibleType.name} was added to union type ${oldType.name}.`
        });
    }
    for (const oldPossibleType of possibleTypesDiff.removed){
        schemaChanges.push({
            type: BreakingChangeType.TYPE_REMOVED_FROM_UNION,
            description: `${oldPossibleType.name} was removed from union type ${oldType.name}.`
        });
    }
    return schemaChanges;
}
function findEnumTypeChanges(oldType, newType) {
    const schemaChanges = [];
    const valuesDiff = diff(oldType.getValues(), newType.getValues());
    for (const newValue of valuesDiff.added){
        schemaChanges.push({
            type: DangerousChangeType.VALUE_ADDED_TO_ENUM,
            description: `${newValue.name} was added to enum type ${oldType.name}.`
        });
    }
    for (const oldValue of valuesDiff.removed){
        schemaChanges.push({
            type: BreakingChangeType.VALUE_REMOVED_FROM_ENUM,
            description: `${oldValue.name} was removed from enum type ${oldType.name}.`
        });
    }
    return schemaChanges;
}
function findImplementedInterfacesChanges(oldType, newType) {
    const schemaChanges = [];
    const interfacesDiff = diff(oldType.getInterfaces(), newType.getInterfaces());
    for (const newInterface of interfacesDiff.added){
        schemaChanges.push({
            type: DangerousChangeType.IMPLEMENTED_INTERFACE_ADDED,
            description: `${newInterface.name} added to interfaces implemented by ${oldType.name}.`
        });
    }
    for (const oldInterface of interfacesDiff.removed){
        schemaChanges.push({
            type: BreakingChangeType.IMPLEMENTED_INTERFACE_REMOVED,
            description: `${oldType.name} no longer implements interface ${oldInterface.name}.`
        });
    }
    return schemaChanges;
}
function findFieldChanges(oldType, newType) {
    const schemaChanges = [];
    const fieldsDiff = diff(Object.values(oldType.getFields()), Object.values(newType.getFields()));
    for (const oldField of fieldsDiff.removed){
        schemaChanges.push({
            type: BreakingChangeType.FIELD_REMOVED,
            description: `${oldType.name}.${oldField.name} was removed.`
        });
    }
    for (const [oldField, newField] of fieldsDiff.persisted){
        schemaChanges.push(...findArgChanges(oldType, oldField, newField));
        const isSafe = isChangeSafeForObjectOrInterfaceField(oldField.type, newField.type);
        if (!isSafe) {
            schemaChanges.push({
                type: BreakingChangeType.FIELD_CHANGED_KIND,
                description: `${oldType.name}.${oldField.name} changed type from ` + `${String(oldField.type)} to ${String(newField.type)}.`
            });
        }
    }
    return schemaChanges;
}
function findArgChanges(oldType, oldField, newField) {
    const schemaChanges = [];
    const argsDiff = diff(oldField.args, newField.args);
    for (const oldArg of argsDiff.removed){
        schemaChanges.push({
            type: BreakingChangeType.ARG_REMOVED,
            description: `${oldType.name}.${oldField.name} arg ${oldArg.name} was removed.`
        });
    }
    for (const [oldArg, newArg] of argsDiff.persisted){
        const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(oldArg.type, newArg.type);
        if (!isSafe) {
            schemaChanges.push({
                type: BreakingChangeType.ARG_CHANGED_KIND,
                description: `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed type from ` + `${String(oldArg.type)} to ${String(newArg.type)}.`
            });
        } else if (oldArg.defaultValue !== undefined) {
            if (newArg.defaultValue === undefined) {
                schemaChanges.push({
                    type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,
                    description: `${oldType.name}.${oldField.name} arg ${oldArg.name} defaultValue was removed.`
                });
            } else {
                // Since we looking only for client's observable changes we should
                // compare default values in the same representation as they are
                // represented inside introspection.
                const oldValueStr = stringifyValue(oldArg.defaultValue, oldArg.type);
                const newValueStr = stringifyValue(newArg.defaultValue, newArg.type);
                if (oldValueStr !== newValueStr) {
                    schemaChanges.push({
                        type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,
                        description: `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed defaultValue from ${oldValueStr} to ${newValueStr}.`
                    });
                }
            }
        }
    }
    for (const newArg of argsDiff.added){
        if ((0, _definition.isRequiredArgument)(newArg)) {
            schemaChanges.push({
                type: BreakingChangeType.REQUIRED_ARG_ADDED,
                description: `A required arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`
            });
        } else {
            schemaChanges.push({
                type: DangerousChangeType.OPTIONAL_ARG_ADDED,
                description: `An optional arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`
            });
        }
    }
    return schemaChanges;
}
function isChangeSafeForObjectOrInterfaceField(oldType, newType) {
    if ((0, _definition.isListType)(oldType)) {
        return(// if they're both lists, make sure the underlying types are compatible
        (0, _definition.isListType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType) || // moving from nullable to non-null of the same underlying type is safe
        (0, _definition.isNonNullType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType));
    }
    if ((0, _definition.isNonNullType)(oldType)) {
        // if they're both non-null, make sure the underlying types are compatible
        return (0, _definition.isNonNullType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType);
    }
    return(// if they're both named types, see if their names are equivalent
    (0, _definition.isNamedType)(newType) && oldType.name === newType.name || // moving from nullable to non-null of the same underlying type is safe
    (0, _definition.isNonNullType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType));
}
function isChangeSafeForInputObjectFieldOrFieldArg(oldType, newType) {
    if ((0, _definition.isListType)(oldType)) {
        // if they're both lists, make sure the underlying types are compatible
        return (0, _definition.isListType)(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType);
    }
    if ((0, _definition.isNonNullType)(oldType)) {
        return(// if they're both non-null, make sure the underlying types are
        // compatible
        (0, _definition.isNonNullType)(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType) || // moving from non-null to nullable of the same underlying type is safe
        !(0, _definition.isNonNullType)(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType));
    } // if they're both named types, see if their names are equivalent
    return (0, _definition.isNamedType)(newType) && oldType.name === newType.name;
}
function typeKindName(type) {
    if ((0, _definition.isScalarType)(type)) {
        return "a Scalar type";
    }
    if ((0, _definition.isObjectType)(type)) {
        return "an Object type";
    }
    if ((0, _definition.isInterfaceType)(type)) {
        return "an Interface type";
    }
    if ((0, _definition.isUnionType)(type)) {
        return "a Union type";
    }
    if ((0, _definition.isEnumType)(type)) {
        return "an Enum type";
    }
    if ((0, _definition.isInputObjectType)(type)) {
        return "an Input type";
    }
    /* c8 ignore next 3 */ // Not reachable, all possible types have been considered.
     false || (0, _invariant.invariant)(false, "Unexpected type: " + (0, _inspect.inspect)(type));
}
function stringifyValue(value, type) {
    const ast = (0, _astFromValue.astFromValue)(value, type);
    ast != null || (0, _invariant.invariant)(false);
    return (0, _printer.print)((0, _sortValueNode.sortValueNode)(ast));
}
function diff(oldArray, newArray) {
    const added = [];
    const removed = [];
    const persisted = [];
    const oldMap = (0, _keyMap.keyMap)(oldArray, ({ name  })=>name);
    const newMap = (0, _keyMap.keyMap)(newArray, ({ name  })=>name);
    for (const oldItem of oldArray){
        const newItem = newMap[oldItem.name];
        if (newItem === undefined) {
            removed.push(oldItem);
        } else {
            persisted.push([
                oldItem,
                newItem
            ]);
        }
    }
    for (const newItem of newArray){
        if (oldMap[newItem.name] === undefined) {
            added.push(newItem);
        }
    }
    return {
        added,
        persisted,
        removed
    };
}


/***/ }),

/***/ 8314:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getIntrospectionQuery = getIntrospectionQuery;
/**
 * Produce the GraphQL query recommended for a full schema introspection.
 * Accepts optional IntrospectionOptions.
 */ function getIntrospectionQuery(options) {
    const optionsWithDefault = {
        descriptions: true,
        specifiedByUrl: false,
        directiveIsRepeatable: false,
        schemaDescription: false,
        inputValueDeprecation: false,
        ...options
    };
    const descriptions = optionsWithDefault.descriptions ? "description" : "";
    const specifiedByUrl = optionsWithDefault.specifiedByUrl ? "specifiedByURL" : "";
    const directiveIsRepeatable = optionsWithDefault.directiveIsRepeatable ? "isRepeatable" : "";
    const schemaDescription = optionsWithDefault.schemaDescription ? descriptions : "";
    function inputDeprecation(str) {
        return optionsWithDefault.inputValueDeprecation ? str : "";
    }
    return `
    query IntrospectionQuery {
      __schema {
        ${schemaDescription}
        queryType { name }
        mutationType { name }
        subscriptionType { name }
        types {
          ...FullType
        }
        directives {
          name
          ${descriptions}
          ${directiveIsRepeatable}
          locations
          args${inputDeprecation("(includeDeprecated: true)")} {
            ...InputValue
          }
        }
      }
    }

    fragment FullType on __Type {
      kind
      name
      ${descriptions}
      ${specifiedByUrl}
      fields(includeDeprecated: true) {
        name
        ${descriptions}
        args${inputDeprecation("(includeDeprecated: true)")} {
          ...InputValue
        }
        type {
          ...TypeRef
        }
        isDeprecated
        deprecationReason
      }
      inputFields${inputDeprecation("(includeDeprecated: true)")} {
        ...InputValue
      }
      interfaces {
        ...TypeRef
      }
      enumValues(includeDeprecated: true) {
        name
        ${descriptions}
        isDeprecated
        deprecationReason
      }
      possibleTypes {
        ...TypeRef
      }
    }

    fragment InputValue on __InputValue {
      name
      ${descriptions}
      type { ...TypeRef }
      defaultValue
      ${inputDeprecation("isDeprecated")}
      ${inputDeprecation("deprecationReason")}
    }

    fragment TypeRef on __Type {
      kind
      name
      ofType {
        kind
        name
        ofType {
          kind
          name
          ofType {
            kind
            name
            ofType {
              kind
              name
              ofType {
                kind
                name
                ofType {
                  kind
                  name
                  ofType {
                    kind
                    name
                  }
                }
              }
            }
          }
        }
      }
    }
  `;
}


/***/ }),

/***/ 4286:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getOperationAST = getOperationAST;
var _kinds = __webpack_require__(5923);
/**
 * Returns an operation AST given a document AST and optionally an operation
 * name. If a name is not provided, an operation is only returned if only one is
 * provided in the document.
 */ function getOperationAST(documentAST, operationName) {
    let operation = null;
    for (const definition of documentAST.definitions){
        if (definition.kind === _kinds.Kind.OPERATION_DEFINITION) {
            var _definition$name;
            if (operationName == null) {
                // If no operation name was provided, only return an Operation if there
                // is one defined in the document. Upon encountering the second, return
                // null.
                if (operation) {
                    return null;
                }
                operation = definition;
            } else if (((_definition$name = definition.name) === null || _definition$name === void 0 ? void 0 : _definition$name.value) === operationName) {
                return definition;
            }
        }
    }
    return operation;
}


/***/ }),

/***/ 5760:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getOperationRootType = getOperationRootType;
var _GraphQLError = __webpack_require__(2169);
/**
 * Extracts the root type of the operation from the schema.
 *
 * @deprecated Please use `GraphQLSchema.getRootType` instead. Will be removed in v17
 */ function getOperationRootType(schema, operation) {
    if (operation.operation === "query") {
        const queryType = schema.getQueryType();
        if (!queryType) {
            throw new _GraphQLError.GraphQLError("Schema does not define the required query root type.", {
                nodes: operation
            });
        }
        return queryType;
    }
    if (operation.operation === "mutation") {
        const mutationType = schema.getMutationType();
        if (!mutationType) {
            throw new _GraphQLError.GraphQLError("Schema is not configured for mutations.", {
                nodes: operation
            });
        }
        return mutationType;
    }
    if (operation.operation === "subscription") {
        const subscriptionType = schema.getSubscriptionType();
        if (!subscriptionType) {
            throw new _GraphQLError.GraphQLError("Schema is not configured for subscriptions.", {
                nodes: operation
            });
        }
        return subscriptionType;
    }
    throw new _GraphQLError.GraphQLError("Can only have query, mutation and subscription operations.", {
        nodes: operation
    });
}


/***/ }),

/***/ 853:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "BreakingChangeType", ({
    enumerable: true,
    get: function() {
        return _findBreakingChanges.BreakingChangeType;
    }
}));
Object.defineProperty(exports, "DangerousChangeType", ({
    enumerable: true,
    get: function() {
        return _findBreakingChanges.DangerousChangeType;
    }
}));
Object.defineProperty(exports, "TypeInfo", ({
    enumerable: true,
    get: function() {
        return _TypeInfo.TypeInfo;
    }
}));
Object.defineProperty(exports, "assertValidName", ({
    enumerable: true,
    get: function() {
        return _assertValidName.assertValidName;
    }
}));
Object.defineProperty(exports, "astFromValue", ({
    enumerable: true,
    get: function() {
        return _astFromValue.astFromValue;
    }
}));
Object.defineProperty(exports, "buildASTSchema", ({
    enumerable: true,
    get: function() {
        return _buildASTSchema.buildASTSchema;
    }
}));
Object.defineProperty(exports, "buildClientSchema", ({
    enumerable: true,
    get: function() {
        return _buildClientSchema.buildClientSchema;
    }
}));
Object.defineProperty(exports, "buildSchema", ({
    enumerable: true,
    get: function() {
        return _buildASTSchema.buildSchema;
    }
}));
Object.defineProperty(exports, "coerceInputValue", ({
    enumerable: true,
    get: function() {
        return _coerceInputValue.coerceInputValue;
    }
}));
Object.defineProperty(exports, "concatAST", ({
    enumerable: true,
    get: function() {
        return _concatAST.concatAST;
    }
}));
Object.defineProperty(exports, "doTypesOverlap", ({
    enumerable: true,
    get: function() {
        return _typeComparators.doTypesOverlap;
    }
}));
Object.defineProperty(exports, "extendSchema", ({
    enumerable: true,
    get: function() {
        return _extendSchema.extendSchema;
    }
}));
Object.defineProperty(exports, "findBreakingChanges", ({
    enumerable: true,
    get: function() {
        return _findBreakingChanges.findBreakingChanges;
    }
}));
Object.defineProperty(exports, "findDangerousChanges", ({
    enumerable: true,
    get: function() {
        return _findBreakingChanges.findDangerousChanges;
    }
}));
Object.defineProperty(exports, "getIntrospectionQuery", ({
    enumerable: true,
    get: function() {
        return _getIntrospectionQuery.getIntrospectionQuery;
    }
}));
Object.defineProperty(exports, "getOperationAST", ({
    enumerable: true,
    get: function() {
        return _getOperationAST.getOperationAST;
    }
}));
Object.defineProperty(exports, "getOperationRootType", ({
    enumerable: true,
    get: function() {
        return _getOperationRootType.getOperationRootType;
    }
}));
Object.defineProperty(exports, "introspectionFromSchema", ({
    enumerable: true,
    get: function() {
        return _introspectionFromSchema.introspectionFromSchema;
    }
}));
Object.defineProperty(exports, "isEqualType", ({
    enumerable: true,
    get: function() {
        return _typeComparators.isEqualType;
    }
}));
Object.defineProperty(exports, "isTypeSubTypeOf", ({
    enumerable: true,
    get: function() {
        return _typeComparators.isTypeSubTypeOf;
    }
}));
Object.defineProperty(exports, "isValidNameError", ({
    enumerable: true,
    get: function() {
        return _assertValidName.isValidNameError;
    }
}));
Object.defineProperty(exports, "lexicographicSortSchema", ({
    enumerable: true,
    get: function() {
        return _lexicographicSortSchema.lexicographicSortSchema;
    }
}));
Object.defineProperty(exports, "printIntrospectionSchema", ({
    enumerable: true,
    get: function() {
        return _printSchema.printIntrospectionSchema;
    }
}));
Object.defineProperty(exports, "printSchema", ({
    enumerable: true,
    get: function() {
        return _printSchema.printSchema;
    }
}));
Object.defineProperty(exports, "printType", ({
    enumerable: true,
    get: function() {
        return _printSchema.printType;
    }
}));
Object.defineProperty(exports, "separateOperations", ({
    enumerable: true,
    get: function() {
        return _separateOperations.separateOperations;
    }
}));
Object.defineProperty(exports, "stripIgnoredCharacters", ({
    enumerable: true,
    get: function() {
        return _stripIgnoredCharacters.stripIgnoredCharacters;
    }
}));
Object.defineProperty(exports, "typeFromAST", ({
    enumerable: true,
    get: function() {
        return _typeFromAST.typeFromAST;
    }
}));
Object.defineProperty(exports, "valueFromAST", ({
    enumerable: true,
    get: function() {
        return _valueFromAST.valueFromAST;
    }
}));
Object.defineProperty(exports, "valueFromASTUntyped", ({
    enumerable: true,
    get: function() {
        return _valueFromASTUntyped.valueFromASTUntyped;
    }
}));
Object.defineProperty(exports, "visitWithTypeInfo", ({
    enumerable: true,
    get: function() {
        return _TypeInfo.visitWithTypeInfo;
    }
}));
var _getIntrospectionQuery = __webpack_require__(8314);
var _getOperationAST = __webpack_require__(4286);
var _getOperationRootType = __webpack_require__(5760);
var _introspectionFromSchema = __webpack_require__(9280);
var _buildClientSchema = __webpack_require__(4462);
var _buildASTSchema = __webpack_require__(3169);
var _extendSchema = __webpack_require__(4189);
var _lexicographicSortSchema = __webpack_require__(3874);
var _printSchema = __webpack_require__(22);
var _typeFromAST = __webpack_require__(6013);
var _valueFromAST = __webpack_require__(7735);
var _valueFromASTUntyped = __webpack_require__(9267);
var _astFromValue = __webpack_require__(8042);
var _TypeInfo = __webpack_require__(5790);
var _coerceInputValue = __webpack_require__(1401);
var _concatAST = __webpack_require__(9095);
var _separateOperations = __webpack_require__(5508);
var _stripIgnoredCharacters = __webpack_require__(6899);
var _typeComparators = __webpack_require__(5392);
var _assertValidName = __webpack_require__(2062);
var _findBreakingChanges = __webpack_require__(8015);


/***/ }),

/***/ 9280:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.introspectionFromSchema = introspectionFromSchema;
var _invariant = __webpack_require__(5210);
var _parser = __webpack_require__(8208);
var _execute = __webpack_require__(6678);
var _getIntrospectionQuery = __webpack_require__(8314);
/**
 * Build an IntrospectionQuery from a GraphQLSchema
 *
 * IntrospectionQuery is useful for utilities that care about type and field
 * relationships, but do not need to traverse through those relationships.
 *
 * This is the inverse of buildClientSchema. The primary use case is outside
 * of the server context, for instance when doing schema comparisons.
 */ function introspectionFromSchema(schema, options) {
    const optionsWithDefaults = {
        specifiedByUrl: true,
        directiveIsRepeatable: true,
        schemaDescription: true,
        inputValueDeprecation: true,
        ...options
    };
    const document = (0, _parser.parse)((0, _getIntrospectionQuery.getIntrospectionQuery)(optionsWithDefaults));
    const result = (0, _execute.executeSync)({
        schema,
        document
    });
    !result.errors && result.data || (0, _invariant.invariant)(false);
    return result.data;
}


/***/ }),

/***/ 3874:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.lexicographicSortSchema = lexicographicSortSchema;
var _inspect = __webpack_require__(8089);
var _invariant = __webpack_require__(5210);
var _keyValMap = __webpack_require__(370);
var _naturalCompare = __webpack_require__(135);
var _definition = __webpack_require__(7982);
var _directives = __webpack_require__(3554);
var _introspection = __webpack_require__(1472);
var _schema = __webpack_require__(9723);
/**
 * Sort GraphQLSchema.
 *
 * This function returns a sorted copy of the given GraphQLSchema.
 */ function lexicographicSortSchema(schema) {
    const schemaConfig = schema.toConfig();
    const typeMap = (0, _keyValMap.keyValMap)(sortByName(schemaConfig.types), (type)=>type.name, sortNamedType);
    return new _schema.GraphQLSchema({
        ...schemaConfig,
        types: Object.values(typeMap),
        directives: sortByName(schemaConfig.directives).map(sortDirective),
        query: replaceMaybeType(schemaConfig.query),
        mutation: replaceMaybeType(schemaConfig.mutation),
        subscription: replaceMaybeType(schemaConfig.subscription)
    });
    function replaceType(type) {
        if ((0, _definition.isListType)(type)) {
            // @ts-expect-error
            return new _definition.GraphQLList(replaceType(type.ofType));
        } else if ((0, _definition.isNonNullType)(type)) {
            // @ts-expect-error
            return new _definition.GraphQLNonNull(replaceType(type.ofType));
        } // @ts-expect-error FIXME: TS Conversion
        return replaceNamedType(type);
    }
    function replaceNamedType(type) {
        return typeMap[type.name];
    }
    function replaceMaybeType(maybeType) {
        return maybeType && replaceNamedType(maybeType);
    }
    function sortDirective(directive) {
        const config = directive.toConfig();
        return new _directives.GraphQLDirective({
            ...config,
            locations: sortBy(config.locations, (x)=>x),
            args: sortArgs(config.args)
        });
    }
    function sortArgs(args) {
        return sortObjMap(args, (arg)=>({
                ...arg,
                type: replaceType(arg.type)
            }));
    }
    function sortFields(fieldsMap) {
        return sortObjMap(fieldsMap, (field)=>({
                ...field,
                type: replaceType(field.type),
                args: field.args && sortArgs(field.args)
            }));
    }
    function sortInputFields(fieldsMap) {
        return sortObjMap(fieldsMap, (field)=>({
                ...field,
                type: replaceType(field.type)
            }));
    }
    function sortTypes(array) {
        return sortByName(array).map(replaceNamedType);
    }
    function sortNamedType(type) {
        if ((0, _definition.isScalarType)(type) || (0, _introspection.isIntrospectionType)(type)) {
            return type;
        }
        if ((0, _definition.isObjectType)(type)) {
            const config = type.toConfig();
            return new _definition.GraphQLObjectType({
                ...config,
                interfaces: ()=>sortTypes(config.interfaces),
                fields: ()=>sortFields(config.fields)
            });
        }
        if ((0, _definition.isInterfaceType)(type)) {
            const config = type.toConfig();
            return new _definition.GraphQLInterfaceType({
                ...config,
                interfaces: ()=>sortTypes(config.interfaces),
                fields: ()=>sortFields(config.fields)
            });
        }
        if ((0, _definition.isUnionType)(type)) {
            const config = type.toConfig();
            return new _definition.GraphQLUnionType({
                ...config,
                types: ()=>sortTypes(config.types)
            });
        }
        if ((0, _definition.isEnumType)(type)) {
            const config = type.toConfig();
            return new _definition.GraphQLEnumType({
                ...config,
                values: sortObjMap(config.values, (value)=>value)
            });
        }
        if ((0, _definition.isInputObjectType)(type)) {
            const config = type.toConfig();
            return new _definition.GraphQLInputObjectType({
                ...config,
                fields: ()=>sortInputFields(config.fields)
            });
        }
        /* c8 ignore next 3 */ // Not reachable, all possible types have been considered.
         false || (0, _invariant.invariant)(false, "Unexpected type: " + (0, _inspect.inspect)(type));
    }
}
function sortObjMap(map, sortValueFn) {
    const sortedMap = Object.create(null);
    for (const key of Object.keys(map).sort(_naturalCompare.naturalCompare)){
        sortedMap[key] = sortValueFn(map[key]);
    }
    return sortedMap;
}
function sortByName(array) {
    return sortBy(array, (obj)=>obj.name);
}
function sortBy(array, mapToKey) {
    return array.slice().sort((obj1, obj2)=>{
        const key1 = mapToKey(obj1);
        const key2 = mapToKey(obj2);
        return (0, _naturalCompare.naturalCompare)(key1, key2);
    });
}


/***/ }),

/***/ 22:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.printIntrospectionSchema = printIntrospectionSchema;
exports.printSchema = printSchema;
exports.printType = printType;
var _inspect = __webpack_require__(8089);
var _invariant = __webpack_require__(5210);
var _blockString = __webpack_require__(9121);
var _kinds = __webpack_require__(5923);
var _printer = __webpack_require__(800);
var _definition = __webpack_require__(7982);
var _directives = __webpack_require__(3554);
var _introspection = __webpack_require__(1472);
var _scalars = __webpack_require__(9570);
var _astFromValue = __webpack_require__(8042);
function printSchema(schema) {
    return printFilteredSchema(schema, (n)=>!(0, _directives.isSpecifiedDirective)(n), isDefinedType);
}
function printIntrospectionSchema(schema) {
    return printFilteredSchema(schema, _directives.isSpecifiedDirective, _introspection.isIntrospectionType);
}
function isDefinedType(type) {
    return !(0, _scalars.isSpecifiedScalarType)(type) && !(0, _introspection.isIntrospectionType)(type);
}
function printFilteredSchema(schema, directiveFilter, typeFilter) {
    const directives = schema.getDirectives().filter(directiveFilter);
    const types = Object.values(schema.getTypeMap()).filter(typeFilter);
    return [
        printSchemaDefinition(schema),
        ...directives.map((directive)=>printDirective(directive)),
        ...types.map((type)=>printType(type))
    ].filter(Boolean).join("\n\n");
}
function printSchemaDefinition(schema) {
    if (schema.description == null && isSchemaOfCommonNames(schema)) {
        return;
    }
    const operationTypes = [];
    const queryType = schema.getQueryType();
    if (queryType) {
        operationTypes.push(`  query: ${queryType.name}`);
    }
    const mutationType = schema.getMutationType();
    if (mutationType) {
        operationTypes.push(`  mutation: ${mutationType.name}`);
    }
    const subscriptionType = schema.getSubscriptionType();
    if (subscriptionType) {
        operationTypes.push(`  subscription: ${subscriptionType.name}`);
    }
    return printDescription(schema) + `schema {\n${operationTypes.join("\n")}\n}`;
}
/**
 * GraphQL schema define root types for each type of operation. These types are
 * the same as any other type and can be named in any manner, however there is
 * a common naming convention:
 *
 * ```graphql
 *   schema {
 *     query: Query
 *     mutation: Mutation
 *     subscription: Subscription
 *   }
 * ```
 *
 * When using this naming convention, the schema description can be omitted.
 */ function isSchemaOfCommonNames(schema) {
    const queryType = schema.getQueryType();
    if (queryType && queryType.name !== "Query") {
        return false;
    }
    const mutationType = schema.getMutationType();
    if (mutationType && mutationType.name !== "Mutation") {
        return false;
    }
    const subscriptionType = schema.getSubscriptionType();
    if (subscriptionType && subscriptionType.name !== "Subscription") {
        return false;
    }
    return true;
}
function printType(type) {
    if ((0, _definition.isScalarType)(type)) {
        return printScalar(type);
    }
    if ((0, _definition.isObjectType)(type)) {
        return printObject(type);
    }
    if ((0, _definition.isInterfaceType)(type)) {
        return printInterface(type);
    }
    if ((0, _definition.isUnionType)(type)) {
        return printUnion(type);
    }
    if ((0, _definition.isEnumType)(type)) {
        return printEnum(type);
    }
    if ((0, _definition.isInputObjectType)(type)) {
        return printInputObject(type);
    }
    /* c8 ignore next 3 */ // Not reachable, all possible types have been considered.
     false || (0, _invariant.invariant)(false, "Unexpected type: " + (0, _inspect.inspect)(type));
}
function printScalar(type) {
    return printDescription(type) + `scalar ${type.name}` + printSpecifiedByURL(type);
}
function printImplementedInterfaces(type) {
    const interfaces = type.getInterfaces();
    return interfaces.length ? " implements " + interfaces.map((i)=>i.name).join(" & ") : "";
}
function printObject(type) {
    return printDescription(type) + `type ${type.name}` + printImplementedInterfaces(type) + printFields(type);
}
function printInterface(type) {
    return printDescription(type) + `interface ${type.name}` + printImplementedInterfaces(type) + printFields(type);
}
function printUnion(type) {
    const types = type.getTypes();
    const possibleTypes = types.length ? " = " + types.join(" | ") : "";
    return printDescription(type) + "union " + type.name + possibleTypes;
}
function printEnum(type) {
    const values = type.getValues().map((value, i)=>printDescription(value, "  ", !i) + "  " + value.name + printDeprecated(value.deprecationReason));
    return printDescription(type) + `enum ${type.name}` + printBlock(values);
}
function printInputObject(type) {
    const fields = Object.values(type.getFields()).map((f, i)=>printDescription(f, "  ", !i) + "  " + printInputValue(f));
    return printDescription(type) + `input ${type.name}` + printBlock(fields);
}
function printFields(type) {
    const fields = Object.values(type.getFields()).map((f, i)=>printDescription(f, "  ", !i) + "  " + f.name + printArgs(f.args, "  ") + ": " + String(f.type) + printDeprecated(f.deprecationReason));
    return printBlock(fields);
}
function printBlock(items) {
    return items.length !== 0 ? " {\n" + items.join("\n") + "\n}" : "";
}
function printArgs(args, indentation = "") {
    if (args.length === 0) {
        return "";
    } // If every arg does not have a description, print them on one line.
    if (args.every((arg)=>!arg.description)) {
        return "(" + args.map(printInputValue).join(", ") + ")";
    }
    return "(\n" + args.map((arg, i)=>printDescription(arg, "  " + indentation, !i) + "  " + indentation + printInputValue(arg)).join("\n") + "\n" + indentation + ")";
}
function printInputValue(arg) {
    const defaultAST = (0, _astFromValue.astFromValue)(arg.defaultValue, arg.type);
    let argDecl = arg.name + ": " + String(arg.type);
    if (defaultAST) {
        argDecl += ` = ${(0, _printer.print)(defaultAST)}`;
    }
    return argDecl + printDeprecated(arg.deprecationReason);
}
function printDirective(directive) {
    return printDescription(directive) + "directive @" + directive.name + printArgs(directive.args) + (directive.isRepeatable ? " repeatable" : "") + " on " + directive.locations.join(" | ");
}
function printDeprecated(reason) {
    if (reason == null) {
        return "";
    }
    if (reason !== _directives.DEFAULT_DEPRECATION_REASON) {
        const astValue = (0, _printer.print)({
            kind: _kinds.Kind.STRING,
            value: reason
        });
        return ` @deprecated(reason: ${astValue})`;
    }
    return " @deprecated";
}
function printSpecifiedByURL(scalar) {
    if (scalar.specifiedByURL == null) {
        return "";
    }
    const astValue = (0, _printer.print)({
        kind: _kinds.Kind.STRING,
        value: scalar.specifiedByURL
    });
    return ` @specifiedBy(url: ${astValue})`;
}
function printDescription(def, indentation = "", firstInBlock = true) {
    const { description  } = def;
    if (description == null) {
        return "";
    }
    const blockString = (0, _printer.print)({
        kind: _kinds.Kind.STRING,
        value: description,
        block: (0, _blockString.isPrintableAsBlockString)(description)
    });
    const prefix = indentation && !firstInBlock ? "\n" + indentation : indentation;
    return prefix + blockString.replace(/\n/g, "\n" + indentation) + "\n";
}


/***/ }),

/***/ 5508:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.separateOperations = separateOperations;
var _kinds = __webpack_require__(5923);
var _visitor = __webpack_require__(4256);
/**
 * separateOperations accepts a single AST document which may contain many
 * operations and fragments and returns a collection of AST documents each of
 * which contains a single operation as well the fragment definitions it
 * refers to.
 */ function separateOperations(documentAST) {
    const operations = [];
    const depGraph = Object.create(null); // Populate metadata and build a dependency graph.
    for (const definitionNode of documentAST.definitions){
        switch(definitionNode.kind){
            case _kinds.Kind.OPERATION_DEFINITION:
                operations.push(definitionNode);
                break;
            case _kinds.Kind.FRAGMENT_DEFINITION:
                depGraph[definitionNode.name.value] = collectDependencies(definitionNode.selectionSet);
                break;
            default:
        }
    } // For each operation, produce a new synthesized AST which includes only what
    // is necessary for completing that operation.
    const separatedDocumentASTs = Object.create(null);
    for (const operation of operations){
        const dependencies = new Set();
        for (const fragmentName of collectDependencies(operation.selectionSet)){
            collectTransitiveDependencies(dependencies, depGraph, fragmentName);
        } // Provides the empty string for anonymous operations.
        const operationName = operation.name ? operation.name.value : ""; // The list of definition nodes to be included for this operation, sorted
        // to retain the same order as the original document.
        separatedDocumentASTs[operationName] = {
            kind: _kinds.Kind.DOCUMENT,
            definitions: documentAST.definitions.filter((node)=>node === operation || node.kind === _kinds.Kind.FRAGMENT_DEFINITION && dependencies.has(node.name.value))
        };
    }
    return separatedDocumentASTs;
}
// From a dependency graph, collects a list of transitive dependencies by
// recursing through a dependency graph.
function collectTransitiveDependencies(collected, depGraph, fromName) {
    if (!collected.has(fromName)) {
        collected.add(fromName);
        const immediateDeps = depGraph[fromName];
        if (immediateDeps !== undefined) {
            for (const toName of immediateDeps){
                collectTransitiveDependencies(collected, depGraph, toName);
            }
        }
    }
}
function collectDependencies(selectionSet) {
    const dependencies = [];
    (0, _visitor.visit)(selectionSet, {
        FragmentSpread (node) {
            dependencies.push(node.name.value);
        }
    });
    return dependencies;
}


/***/ }),

/***/ 6063:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.sortValueNode = sortValueNode;
var _naturalCompare = __webpack_require__(135);
var _kinds = __webpack_require__(5923);
/**
 * Sort ValueNode.
 *
 * This function returns a sorted copy of the given ValueNode.
 *
 * @internal
 */ function sortValueNode(valueNode) {
    switch(valueNode.kind){
        case _kinds.Kind.OBJECT:
            return {
                ...valueNode,
                fields: sortFields(valueNode.fields)
            };
        case _kinds.Kind.LIST:
            return {
                ...valueNode,
                values: valueNode.values.map(sortValueNode)
            };
        case _kinds.Kind.INT:
        case _kinds.Kind.FLOAT:
        case _kinds.Kind.STRING:
        case _kinds.Kind.BOOLEAN:
        case _kinds.Kind.NULL:
        case _kinds.Kind.ENUM:
        case _kinds.Kind.VARIABLE:
            return valueNode;
    }
}
function sortFields(fields) {
    return fields.map((fieldNode)=>({
            ...fieldNode,
            value: sortValueNode(fieldNode.value)
        })).sort((fieldA, fieldB)=>(0, _naturalCompare.naturalCompare)(fieldA.name.value, fieldB.name.value));
}


/***/ }),

/***/ 6899:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.stripIgnoredCharacters = stripIgnoredCharacters;
var _blockString = __webpack_require__(9121);
var _lexer = __webpack_require__(8225);
var _source = __webpack_require__(8509);
var _tokenKind = __webpack_require__(8845);
/**
 * Strips characters that are not significant to the validity or execution
 * of a GraphQL document:
 *   - UnicodeBOM
 *   - WhiteSpace
 *   - LineTerminator
 *   - Comment
 *   - Comma
 *   - BlockString indentation
 *
 * Note: It is required to have a delimiter character between neighboring
 * non-punctuator tokens and this function always uses single space as delimiter.
 *
 * It is guaranteed that both input and output documents if parsed would result
 * in the exact same AST except for nodes location.
 *
 * Warning: It is guaranteed that this function will always produce stable results.
 * However, it's not guaranteed that it will stay the same between different
 * releases due to bugfixes or changes in the GraphQL specification.
 *
 * Query example:
 *
 * ```graphql
 * query SomeQuery($foo: String!, $bar: String) {
 *   someField(foo: $foo, bar: $bar) {
 *     a
 *     b {
 *       c
 *       d
 *     }
 *   }
 * }
 * ```
 *
 * Becomes:
 *
 * ```graphql
 * query SomeQuery($foo:String!$bar:String){someField(foo:$foo bar:$bar){a b{c d}}}
 * ```
 *
 * SDL example:
 *
 * ```graphql
 * """
 * Type description
 * """
 * type Foo {
 *   """
 *   Field description
 *   """
 *   bar: String
 * }
 * ```
 *
 * Becomes:
 *
 * ```graphql
 * """Type description""" type Foo{"""Field description""" bar:String}
 * ```
 */ function stripIgnoredCharacters(source) {
    const sourceObj = (0, _source.isSource)(source) ? source : new _source.Source(source);
    const body = sourceObj.body;
    const lexer = new _lexer.Lexer(sourceObj);
    let strippedBody = "";
    let wasLastAddedTokenNonPunctuator = false;
    while(lexer.advance().kind !== _tokenKind.TokenKind.EOF){
        const currentToken = lexer.token;
        const tokenKind = currentToken.kind;
        /**
     * Every two non-punctuator tokens should have space between them.
     * Also prevent case of non-punctuator token following by spread resulting
     * in invalid token (e.g. `1...` is invalid Float token).
     */ const isNonPunctuator = !(0, _lexer.isPunctuatorTokenKind)(currentToken.kind);
        if (wasLastAddedTokenNonPunctuator) {
            if (isNonPunctuator || currentToken.kind === _tokenKind.TokenKind.SPREAD) {
                strippedBody += " ";
            }
        }
        const tokenBody = body.slice(currentToken.start, currentToken.end);
        if (tokenKind === _tokenKind.TokenKind.BLOCK_STRING) {
            strippedBody += (0, _blockString.printBlockString)(currentToken.value, {
                minimize: true
            });
        } else {
            strippedBody += tokenBody;
        }
        wasLastAddedTokenNonPunctuator = isNonPunctuator;
    }
    return strippedBody;
}


/***/ }),

/***/ 5392:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.doTypesOverlap = doTypesOverlap;
exports.isEqualType = isEqualType;
exports.isTypeSubTypeOf = isTypeSubTypeOf;
var _definition = __webpack_require__(7982);
/**
 * Provided two types, return true if the types are equal (invariant).
 */ function isEqualType(typeA, typeB) {
    // Equivalent types are equal.
    if (typeA === typeB) {
        return true;
    } // If either type is non-null, the other must also be non-null.
    if ((0, _definition.isNonNullType)(typeA) && (0, _definition.isNonNullType)(typeB)) {
        return isEqualType(typeA.ofType, typeB.ofType);
    } // If either type is a list, the other must also be a list.
    if ((0, _definition.isListType)(typeA) && (0, _definition.isListType)(typeB)) {
        return isEqualType(typeA.ofType, typeB.ofType);
    } // Otherwise the types are not equal.
    return false;
}
/**
 * Provided a type and a super type, return true if the first type is either
 * equal or a subset of the second super type (covariant).
 */ function isTypeSubTypeOf(schema, maybeSubType, superType) {
    // Equivalent type is a valid subtype
    if (maybeSubType === superType) {
        return true;
    } // If superType is non-null, maybeSubType must also be non-null.
    if ((0, _definition.isNonNullType)(superType)) {
        if ((0, _definition.isNonNullType)(maybeSubType)) {
            return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
        }
        return false;
    }
    if ((0, _definition.isNonNullType)(maybeSubType)) {
        // If superType is nullable, maybeSubType may be non-null or nullable.
        return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);
    } // If superType type is a list, maybeSubType type must also be a list.
    if ((0, _definition.isListType)(superType)) {
        if ((0, _definition.isListType)(maybeSubType)) {
            return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
        }
        return false;
    }
    if ((0, _definition.isListType)(maybeSubType)) {
        // If superType is not a list, maybeSubType must also be not a list.
        return false;
    } // If superType type is an abstract type, check if it is super type of maybeSubType.
    // Otherwise, the child type is not a valid subtype of the parent type.
    return (0, _definition.isAbstractType)(superType) && ((0, _definition.isInterfaceType)(maybeSubType) || (0, _definition.isObjectType)(maybeSubType)) && schema.isSubType(superType, maybeSubType);
}
/**
 * Provided two composite types, determine if they "overlap". Two composite
 * types overlap when the Sets of possible concrete types for each intersect.
 *
 * This is often used to determine if a fragment of a given type could possibly
 * be visited in a context of another type.
 *
 * This function is commutative.
 */ function doTypesOverlap(schema, typeA, typeB) {
    // Equivalent types overlap
    if (typeA === typeB) {
        return true;
    }
    if ((0, _definition.isAbstractType)(typeA)) {
        if ((0, _definition.isAbstractType)(typeB)) {
            // If both types are abstract, then determine if there is any intersection
            // between possible concrete types of each.
            return schema.getPossibleTypes(typeA).some((type)=>schema.isSubType(typeB, type));
        } // Determine if the latter type is a possible concrete type of the former.
        return schema.isSubType(typeA, typeB);
    }
    if ((0, _definition.isAbstractType)(typeB)) {
        // Determine if the former type is a possible concrete type of the latter.
        return schema.isSubType(typeB, typeA);
    } // Otherwise the types do not overlap.
    return false;
}


/***/ }),

/***/ 6013:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.typeFromAST = typeFromAST;
var _kinds = __webpack_require__(5923);
var _definition = __webpack_require__(7982);
function typeFromAST(schema, typeNode) {
    switch(typeNode.kind){
        case _kinds.Kind.LIST_TYPE:
            {
                const innerType = typeFromAST(schema, typeNode.type);
                return innerType && new _definition.GraphQLList(innerType);
            }
        case _kinds.Kind.NON_NULL_TYPE:
            {
                const innerType = typeFromAST(schema, typeNode.type);
                return innerType && new _definition.GraphQLNonNull(innerType);
            }
        case _kinds.Kind.NAMED_TYPE:
            return schema.getType(typeNode.name.value);
    }
}


/***/ }),

/***/ 7735:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.valueFromAST = valueFromAST;
var _inspect = __webpack_require__(8089);
var _invariant = __webpack_require__(5210);
var _keyMap = __webpack_require__(2512);
var _kinds = __webpack_require__(5923);
var _definition = __webpack_require__(7982);
/**
 * Produces a JavaScript value given a GraphQL Value AST.
 *
 * A GraphQL type must be provided, which will be used to interpret different
 * GraphQL Value literals.
 *
 * Returns `undefined` when the value could not be validly coerced according to
 * the provided type.
 *
 * | GraphQL Value        | JSON Value    |
 * | -------------------- | ------------- |
 * | Input Object         | Object        |
 * | List                 | Array         |
 * | Boolean              | Boolean       |
 * | String               | String        |
 * | Int / Float          | Number        |
 * | Enum Value           | Unknown       |
 * | NullValue            | null          |
 *
 */ function valueFromAST(valueNode, type, variables) {
    if (!valueNode) {
        // When there is no node, then there is also no value.
        // Importantly, this is different from returning the value null.
        return;
    }
    if (valueNode.kind === _kinds.Kind.VARIABLE) {
        const variableName = valueNode.name.value;
        if (variables == null || variables[variableName] === undefined) {
            // No valid return value.
            return;
        }
        const variableValue = variables[variableName];
        if (variableValue === null && (0, _definition.isNonNullType)(type)) {
            return; // Invalid: intentionally return no value.
        } // Note: This does no further checking that this variable is correct.
        // This assumes that this query has been validated and the variable
        // usage here is of the correct type.
        return variableValue;
    }
    if ((0, _definition.isNonNullType)(type)) {
        if (valueNode.kind === _kinds.Kind.NULL) {
            return; // Invalid: intentionally return no value.
        }
        return valueFromAST(valueNode, type.ofType, variables);
    }
    if (valueNode.kind === _kinds.Kind.NULL) {
        // This is explicitly returning the value null.
        return null;
    }
    if ((0, _definition.isListType)(type)) {
        const itemType = type.ofType;
        if (valueNode.kind === _kinds.Kind.LIST) {
            const coercedValues = [];
            for (const itemNode of valueNode.values){
                if (isMissingVariable(itemNode, variables)) {
                    // If an array contains a missing variable, it is either coerced to
                    // null or if the item type is non-null, it considered invalid.
                    if ((0, _definition.isNonNullType)(itemType)) {
                        return; // Invalid: intentionally return no value.
                    }
                    coercedValues.push(null);
                } else {
                    const itemValue = valueFromAST(itemNode, itemType, variables);
                    if (itemValue === undefined) {
                        return; // Invalid: intentionally return no value.
                    }
                    coercedValues.push(itemValue);
                }
            }
            return coercedValues;
        }
        const coercedValue = valueFromAST(valueNode, itemType, variables);
        if (coercedValue === undefined) {
            return; // Invalid: intentionally return no value.
        }
        return [
            coercedValue
        ];
    }
    if ((0, _definition.isInputObjectType)(type)) {
        if (valueNode.kind !== _kinds.Kind.OBJECT) {
            return; // Invalid: intentionally return no value.
        }
        const coercedObj = Object.create(null);
        const fieldNodes = (0, _keyMap.keyMap)(valueNode.fields, (field)=>field.name.value);
        for (const field of Object.values(type.getFields())){
            const fieldNode = fieldNodes[field.name];
            if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {
                if (field.defaultValue !== undefined) {
                    coercedObj[field.name] = field.defaultValue;
                } else if ((0, _definition.isNonNullType)(field.type)) {
                    return; // Invalid: intentionally return no value.
                }
                continue;
            }
            const fieldValue = valueFromAST(fieldNode.value, field.type, variables);
            if (fieldValue === undefined) {
                return; // Invalid: intentionally return no value.
            }
            coercedObj[field.name] = fieldValue;
        }
        return coercedObj;
    }
    if ((0, _definition.isLeafType)(type)) {
        // Scalars and Enums fulfill parsing a literal value via parseLiteral().
        // Invalid values represent a failure to parse correctly, in which case
        // no value is returned.
        let result;
        try {
            result = type.parseLiteral(valueNode, variables);
        } catch (_error) {
            return; // Invalid: intentionally return no value.
        }
        if (result === undefined) {
            return; // Invalid: intentionally return no value.
        }
        return result;
    }
    /* c8 ignore next 3 */ // Not reachable, all possible input types have been considered.
     false || (0, _invariant.invariant)(false, "Unexpected input type: " + (0, _inspect.inspect)(type));
} // Returns true if the provided valueNode is a variable which is not defined
// in the set of variables.
function isMissingVariable(valueNode, variables) {
    return valueNode.kind === _kinds.Kind.VARIABLE && (variables == null || variables[valueNode.name.value] === undefined);
}


/***/ }),

/***/ 9267:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.valueFromASTUntyped = valueFromASTUntyped;
var _keyValMap = __webpack_require__(370);
var _kinds = __webpack_require__(5923);
/**
 * Produces a JavaScript value given a GraphQL Value AST.
 *
 * Unlike `valueFromAST()`, no type is provided. The resulting JavaScript value
 * will reflect the provided GraphQL value AST.
 *
 * | GraphQL Value        | JavaScript Value |
 * | -------------------- | ---------------- |
 * | Input Object         | Object           |
 * | List                 | Array            |
 * | Boolean              | Boolean          |
 * | String / Enum        | String           |
 * | Int / Float          | Number           |
 * | Null                 | null             |
 *
 */ function valueFromASTUntyped(valueNode, variables) {
    switch(valueNode.kind){
        case _kinds.Kind.NULL:
            return null;
        case _kinds.Kind.INT:
            return parseInt(valueNode.value, 10);
        case _kinds.Kind.FLOAT:
            return parseFloat(valueNode.value);
        case _kinds.Kind.STRING:
        case _kinds.Kind.ENUM:
        case _kinds.Kind.BOOLEAN:
            return valueNode.value;
        case _kinds.Kind.LIST:
            return valueNode.values.map((node)=>valueFromASTUntyped(node, variables));
        case _kinds.Kind.OBJECT:
            return (0, _keyValMap.keyValMap)(valueNode.fields, (field)=>field.name.value, (field)=>valueFromASTUntyped(field.value, variables));
        case _kinds.Kind.VARIABLE:
            return variables === null || variables === void 0 ? void 0 : variables[valueNode.name.value];
    }
}


/***/ }),

/***/ 3929:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.ValidationContext = exports.SDLValidationContext = exports.ASTValidationContext = void 0;
var _kinds = __webpack_require__(5923);
var _visitor = __webpack_require__(4256);
var _TypeInfo = __webpack_require__(5790);
/**
 * An instance of this class is passed as the "this" context to all validators,
 * allowing access to commonly useful contextual information from within a
 * validation rule.
 */ class ASTValidationContext {
    constructor(ast, onError){
        this._ast = ast;
        this._fragments = undefined;
        this._fragmentSpreads = new Map();
        this._recursivelyReferencedFragments = new Map();
        this._onError = onError;
    }
    get [Symbol.toStringTag]() {
        return "ASTValidationContext";
    }
    reportError(error) {
        this._onError(error);
    }
    getDocument() {
        return this._ast;
    }
    getFragment(name) {
        let fragments;
        if (this._fragments) {
            fragments = this._fragments;
        } else {
            fragments = Object.create(null);
            for (const defNode of this.getDocument().definitions){
                if (defNode.kind === _kinds.Kind.FRAGMENT_DEFINITION) {
                    fragments[defNode.name.value] = defNode;
                }
            }
            this._fragments = fragments;
        }
        return fragments[name];
    }
    getFragmentSpreads(node) {
        let spreads = this._fragmentSpreads.get(node);
        if (!spreads) {
            spreads = [];
            const setsToVisit = [
                node
            ];
            let set;
            while(set = setsToVisit.pop()){
                for (const selection of set.selections){
                    if (selection.kind === _kinds.Kind.FRAGMENT_SPREAD) {
                        spreads.push(selection);
                    } else if (selection.selectionSet) {
                        setsToVisit.push(selection.selectionSet);
                    }
                }
            }
            this._fragmentSpreads.set(node, spreads);
        }
        return spreads;
    }
    getRecursivelyReferencedFragments(operation) {
        let fragments = this._recursivelyReferencedFragments.get(operation);
        if (!fragments) {
            fragments = [];
            const collectedNames = Object.create(null);
            const nodesToVisit = [
                operation.selectionSet
            ];
            let node;
            while(node = nodesToVisit.pop()){
                for (const spread of this.getFragmentSpreads(node)){
                    const fragName = spread.name.value;
                    if (collectedNames[fragName] !== true) {
                        collectedNames[fragName] = true;
                        const fragment = this.getFragment(fragName);
                        if (fragment) {
                            fragments.push(fragment);
                            nodesToVisit.push(fragment.selectionSet);
                        }
                    }
                }
            }
            this._recursivelyReferencedFragments.set(operation, fragments);
        }
        return fragments;
    }
}
exports.ASTValidationContext = ASTValidationContext;
class SDLValidationContext extends ASTValidationContext {
    constructor(ast, schema, onError){
        super(ast, onError);
        this._schema = schema;
    }
    get [Symbol.toStringTag]() {
        return "SDLValidationContext";
    }
    getSchema() {
        return this._schema;
    }
}
exports.SDLValidationContext = SDLValidationContext;
class ValidationContext extends ASTValidationContext {
    constructor(schema, ast, typeInfo, onError){
        super(ast, onError);
        this._schema = schema;
        this._typeInfo = typeInfo;
        this._variableUsages = new Map();
        this._recursiveVariableUsages = new Map();
    }
    get [Symbol.toStringTag]() {
        return "ValidationContext";
    }
    getSchema() {
        return this._schema;
    }
    getVariableUsages(node) {
        let usages = this._variableUsages.get(node);
        if (!usages) {
            const newUsages = [];
            const typeInfo = new _TypeInfo.TypeInfo(this._schema);
            (0, _visitor.visit)(node, (0, _TypeInfo.visitWithTypeInfo)(typeInfo, {
                VariableDefinition: ()=>false,
                Variable (variable) {
                    newUsages.push({
                        node: variable,
                        type: typeInfo.getInputType(),
                        defaultValue: typeInfo.getDefaultValue()
                    });
                }
            }));
            usages = newUsages;
            this._variableUsages.set(node, usages);
        }
        return usages;
    }
    getRecursiveVariableUsages(operation) {
        let usages = this._recursiveVariableUsages.get(operation);
        if (!usages) {
            usages = this.getVariableUsages(operation);
            for (const frag of this.getRecursivelyReferencedFragments(operation)){
                usages = usages.concat(this.getVariableUsages(frag));
            }
            this._recursiveVariableUsages.set(operation, usages);
        }
        return usages;
    }
    getType() {
        return this._typeInfo.getType();
    }
    getParentType() {
        return this._typeInfo.getParentType();
    }
    getInputType() {
        return this._typeInfo.getInputType();
    }
    getParentInputType() {
        return this._typeInfo.getParentInputType();
    }
    getFieldDef() {
        return this._typeInfo.getFieldDef();
    }
    getDirective() {
        return this._typeInfo.getDirective();
    }
    getArgument() {
        return this._typeInfo.getArgument();
    }
    getEnumValue() {
        return this._typeInfo.getEnumValue();
    }
}
exports.ValidationContext = ValidationContext;


/***/ }),

/***/ 1340:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "ExecutableDefinitionsRule", ({
    enumerable: true,
    get: function() {
        return _ExecutableDefinitionsRule.ExecutableDefinitionsRule;
    }
}));
Object.defineProperty(exports, "FieldsOnCorrectTypeRule", ({
    enumerable: true,
    get: function() {
        return _FieldsOnCorrectTypeRule.FieldsOnCorrectTypeRule;
    }
}));
Object.defineProperty(exports, "FragmentsOnCompositeTypesRule", ({
    enumerable: true,
    get: function() {
        return _FragmentsOnCompositeTypesRule.FragmentsOnCompositeTypesRule;
    }
}));
Object.defineProperty(exports, "KnownArgumentNamesRule", ({
    enumerable: true,
    get: function() {
        return _KnownArgumentNamesRule.KnownArgumentNamesRule;
    }
}));
Object.defineProperty(exports, "KnownDirectivesRule", ({
    enumerable: true,
    get: function() {
        return _KnownDirectivesRule.KnownDirectivesRule;
    }
}));
Object.defineProperty(exports, "KnownFragmentNamesRule", ({
    enumerable: true,
    get: function() {
        return _KnownFragmentNamesRule.KnownFragmentNamesRule;
    }
}));
Object.defineProperty(exports, "KnownTypeNamesRule", ({
    enumerable: true,
    get: function() {
        return _KnownTypeNamesRule.KnownTypeNamesRule;
    }
}));
Object.defineProperty(exports, "LoneAnonymousOperationRule", ({
    enumerable: true,
    get: function() {
        return _LoneAnonymousOperationRule.LoneAnonymousOperationRule;
    }
}));
Object.defineProperty(exports, "LoneSchemaDefinitionRule", ({
    enumerable: true,
    get: function() {
        return _LoneSchemaDefinitionRule.LoneSchemaDefinitionRule;
    }
}));
Object.defineProperty(exports, "NoDeprecatedCustomRule", ({
    enumerable: true,
    get: function() {
        return _NoDeprecatedCustomRule.NoDeprecatedCustomRule;
    }
}));
Object.defineProperty(exports, "NoFragmentCyclesRule", ({
    enumerable: true,
    get: function() {
        return _NoFragmentCyclesRule.NoFragmentCyclesRule;
    }
}));
Object.defineProperty(exports, "NoSchemaIntrospectionCustomRule", ({
    enumerable: true,
    get: function() {
        return _NoSchemaIntrospectionCustomRule.NoSchemaIntrospectionCustomRule;
    }
}));
Object.defineProperty(exports, "NoUndefinedVariablesRule", ({
    enumerable: true,
    get: function() {
        return _NoUndefinedVariablesRule.NoUndefinedVariablesRule;
    }
}));
Object.defineProperty(exports, "NoUnusedFragmentsRule", ({
    enumerable: true,
    get: function() {
        return _NoUnusedFragmentsRule.NoUnusedFragmentsRule;
    }
}));
Object.defineProperty(exports, "NoUnusedVariablesRule", ({
    enumerable: true,
    get: function() {
        return _NoUnusedVariablesRule.NoUnusedVariablesRule;
    }
}));
Object.defineProperty(exports, "OverlappingFieldsCanBeMergedRule", ({
    enumerable: true,
    get: function() {
        return _OverlappingFieldsCanBeMergedRule.OverlappingFieldsCanBeMergedRule;
    }
}));
Object.defineProperty(exports, "PossibleFragmentSpreadsRule", ({
    enumerable: true,
    get: function() {
        return _PossibleFragmentSpreadsRule.PossibleFragmentSpreadsRule;
    }
}));
Object.defineProperty(exports, "PossibleTypeExtensionsRule", ({
    enumerable: true,
    get: function() {
        return _PossibleTypeExtensionsRule.PossibleTypeExtensionsRule;
    }
}));
Object.defineProperty(exports, "ProvidedRequiredArgumentsRule", ({
    enumerable: true,
    get: function() {
        return _ProvidedRequiredArgumentsRule.ProvidedRequiredArgumentsRule;
    }
}));
Object.defineProperty(exports, "ScalarLeafsRule", ({
    enumerable: true,
    get: function() {
        return _ScalarLeafsRule.ScalarLeafsRule;
    }
}));
Object.defineProperty(exports, "SingleFieldSubscriptionsRule", ({
    enumerable: true,
    get: function() {
        return _SingleFieldSubscriptionsRule.SingleFieldSubscriptionsRule;
    }
}));
Object.defineProperty(exports, "UniqueArgumentDefinitionNamesRule", ({
    enumerable: true,
    get: function() {
        return _UniqueArgumentDefinitionNamesRule.UniqueArgumentDefinitionNamesRule;
    }
}));
Object.defineProperty(exports, "UniqueArgumentNamesRule", ({
    enumerable: true,
    get: function() {
        return _UniqueArgumentNamesRule.UniqueArgumentNamesRule;
    }
}));
Object.defineProperty(exports, "UniqueDirectiveNamesRule", ({
    enumerable: true,
    get: function() {
        return _UniqueDirectiveNamesRule.UniqueDirectiveNamesRule;
    }
}));
Object.defineProperty(exports, "UniqueDirectivesPerLocationRule", ({
    enumerable: true,
    get: function() {
        return _UniqueDirectivesPerLocationRule.UniqueDirectivesPerLocationRule;
    }
}));
Object.defineProperty(exports, "UniqueEnumValueNamesRule", ({
    enumerable: true,
    get: function() {
        return _UniqueEnumValueNamesRule.UniqueEnumValueNamesRule;
    }
}));
Object.defineProperty(exports, "UniqueFieldDefinitionNamesRule", ({
    enumerable: true,
    get: function() {
        return _UniqueFieldDefinitionNamesRule.UniqueFieldDefinitionNamesRule;
    }
}));
Object.defineProperty(exports, "UniqueFragmentNamesRule", ({
    enumerable: true,
    get: function() {
        return _UniqueFragmentNamesRule.UniqueFragmentNamesRule;
    }
}));
Object.defineProperty(exports, "UniqueInputFieldNamesRule", ({
    enumerable: true,
    get: function() {
        return _UniqueInputFieldNamesRule.UniqueInputFieldNamesRule;
    }
}));
Object.defineProperty(exports, "UniqueOperationNamesRule", ({
    enumerable: true,
    get: function() {
        return _UniqueOperationNamesRule.UniqueOperationNamesRule;
    }
}));
Object.defineProperty(exports, "UniqueOperationTypesRule", ({
    enumerable: true,
    get: function() {
        return _UniqueOperationTypesRule.UniqueOperationTypesRule;
    }
}));
Object.defineProperty(exports, "UniqueTypeNamesRule", ({
    enumerable: true,
    get: function() {
        return _UniqueTypeNamesRule.UniqueTypeNamesRule;
    }
}));
Object.defineProperty(exports, "UniqueVariableNamesRule", ({
    enumerable: true,
    get: function() {
        return _UniqueVariableNamesRule.UniqueVariableNamesRule;
    }
}));
Object.defineProperty(exports, "ValidationContext", ({
    enumerable: true,
    get: function() {
        return _ValidationContext.ValidationContext;
    }
}));
Object.defineProperty(exports, "ValuesOfCorrectTypeRule", ({
    enumerable: true,
    get: function() {
        return _ValuesOfCorrectTypeRule.ValuesOfCorrectTypeRule;
    }
}));
Object.defineProperty(exports, "VariablesAreInputTypesRule", ({
    enumerable: true,
    get: function() {
        return _VariablesAreInputTypesRule.VariablesAreInputTypesRule;
    }
}));
Object.defineProperty(exports, "VariablesInAllowedPositionRule", ({
    enumerable: true,
    get: function() {
        return _VariablesInAllowedPositionRule.VariablesInAllowedPositionRule;
    }
}));
Object.defineProperty(exports, "specifiedRules", ({
    enumerable: true,
    get: function() {
        return _specifiedRules.specifiedRules;
    }
}));
Object.defineProperty(exports, "validate", ({
    enumerable: true,
    get: function() {
        return _validate.validate;
    }
}));
var _validate = __webpack_require__(9571);
var _ValidationContext = __webpack_require__(3929);
var _specifiedRules = __webpack_require__(3593);
var _ExecutableDefinitionsRule = __webpack_require__(7287);
var _FieldsOnCorrectTypeRule = __webpack_require__(3902);
var _FragmentsOnCompositeTypesRule = __webpack_require__(3894);
var _KnownArgumentNamesRule = __webpack_require__(7282);
var _KnownDirectivesRule = __webpack_require__(3641);
var _KnownFragmentNamesRule = __webpack_require__(8210);
var _KnownTypeNamesRule = __webpack_require__(8203);
var _LoneAnonymousOperationRule = __webpack_require__(9901);
var _NoFragmentCyclesRule = __webpack_require__(1710);
var _NoUndefinedVariablesRule = __webpack_require__(6869);
var _NoUnusedFragmentsRule = __webpack_require__(4484);
var _NoUnusedVariablesRule = __webpack_require__(447);
var _OverlappingFieldsCanBeMergedRule = __webpack_require__(2870);
var _PossibleFragmentSpreadsRule = __webpack_require__(5934);
var _ProvidedRequiredArgumentsRule = __webpack_require__(7455);
var _ScalarLeafsRule = __webpack_require__(5497);
var _SingleFieldSubscriptionsRule = __webpack_require__(3829);
var _UniqueArgumentNamesRule = __webpack_require__(6076);
var _UniqueDirectivesPerLocationRule = __webpack_require__(7705);
var _UniqueFragmentNamesRule = __webpack_require__(211);
var _UniqueInputFieldNamesRule = __webpack_require__(5475);
var _UniqueOperationNamesRule = __webpack_require__(5850);
var _UniqueVariableNamesRule = __webpack_require__(5156);
var _ValuesOfCorrectTypeRule = __webpack_require__(3716);
var _VariablesAreInputTypesRule = __webpack_require__(8669);
var _VariablesInAllowedPositionRule = __webpack_require__(4813);
var _LoneSchemaDefinitionRule = __webpack_require__(5240);
var _UniqueOperationTypesRule = __webpack_require__(9387);
var _UniqueTypeNamesRule = __webpack_require__(7381);
var _UniqueEnumValueNamesRule = __webpack_require__(7239);
var _UniqueFieldDefinitionNamesRule = __webpack_require__(214);
var _UniqueArgumentDefinitionNamesRule = __webpack_require__(274);
var _UniqueDirectiveNamesRule = __webpack_require__(727);
var _PossibleTypeExtensionsRule = __webpack_require__(5346);
var _NoDeprecatedCustomRule = __webpack_require__(5474);
var _NoSchemaIntrospectionCustomRule = __webpack_require__(5989);


/***/ }),

/***/ 7287:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.ExecutableDefinitionsRule = ExecutableDefinitionsRule;
var _GraphQLError = __webpack_require__(2169);
var _kinds = __webpack_require__(5923);
var _predicates = __webpack_require__(3288);
/**
 * Executable definitions
 *
 * A GraphQL document is only valid for execution if all definitions are either
 * operation or fragment definitions.
 *
 * See https://spec.graphql.org/draft/#sec-Executable-Definitions
 */ function ExecutableDefinitionsRule(context) {
    return {
        Document (node) {
            for (const definition of node.definitions){
                if (!(0, _predicates.isExecutableDefinitionNode)(definition)) {
                    const defName = definition.kind === _kinds.Kind.SCHEMA_DEFINITION || definition.kind === _kinds.Kind.SCHEMA_EXTENSION ? "schema" : '"' + definition.name.value + '"';
                    context.reportError(new _GraphQLError.GraphQLError(`The ${defName} definition is not executable.`, {
                        nodes: definition
                    }));
                }
            }
            return false;
        }
    };
}


/***/ }),

/***/ 3902:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.FieldsOnCorrectTypeRule = FieldsOnCorrectTypeRule;
var _didYouMean = __webpack_require__(2228);
var _naturalCompare = __webpack_require__(135);
var _suggestionList = __webpack_require__(6347);
var _GraphQLError = __webpack_require__(2169);
var _definition = __webpack_require__(7982);
/**
 * Fields on correct type
 *
 * A GraphQL document is only valid if all fields selected are defined by the
 * parent type, or are an allowed meta field such as __typename.
 *
 * See https://spec.graphql.org/draft/#sec-Field-Selections
 */ function FieldsOnCorrectTypeRule(context) {
    return {
        Field (node) {
            const type = context.getParentType();
            if (type) {
                const fieldDef = context.getFieldDef();
                if (!fieldDef) {
                    // This field doesn't exist, lets look for suggestions.
                    const schema = context.getSchema();
                    const fieldName = node.name.value; // First determine if there are any suggested types to condition on.
                    let suggestion = (0, _didYouMean.didYouMean)("to use an inline fragment on", getSuggestedTypeNames(schema, type, fieldName)); // If there are no suggested types, then perhaps this was a typo?
                    if (suggestion === "") {
                        suggestion = (0, _didYouMean.didYouMean)(getSuggestedFieldNames(type, fieldName));
                    } // Report an error, including helpful suggestions.
                    context.reportError(new _GraphQLError.GraphQLError(`Cannot query field "${fieldName}" on type "${type.name}".` + suggestion, {
                        nodes: node
                    }));
                }
            }
        }
    };
}
/**
 * Go through all of the implementations of type, as well as the interfaces that
 * they implement. If any of those types include the provided field, suggest them,
 * sorted by how often the type is referenced.
 */ function getSuggestedTypeNames(schema, type, fieldName) {
    if (!(0, _definition.isAbstractType)(type)) {
        // Must be an Object type, which does not have possible fields.
        return [];
    }
    const suggestedTypes = new Set();
    const usageCount = Object.create(null);
    for (const possibleType of schema.getPossibleTypes(type)){
        if (!possibleType.getFields()[fieldName]) {
            continue;
        } // This object type defines this field.
        suggestedTypes.add(possibleType);
        usageCount[possibleType.name] = 1;
        for (const possibleInterface of possibleType.getInterfaces()){
            var _usageCount$possibleI;
            if (!possibleInterface.getFields()[fieldName]) {
                continue;
            } // This interface type defines this field.
            suggestedTypes.add(possibleInterface);
            usageCount[possibleInterface.name] = ((_usageCount$possibleI = usageCount[possibleInterface.name]) !== null && _usageCount$possibleI !== void 0 ? _usageCount$possibleI : 0) + 1;
        }
    }
    return [
        ...suggestedTypes
    ].sort((typeA, typeB)=>{
        // Suggest both interface and object types based on how common they are.
        const usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];
        if (usageCountDiff !== 0) {
            return usageCountDiff;
        } // Suggest super types first followed by subtypes
        if ((0, _definition.isInterfaceType)(typeA) && schema.isSubType(typeA, typeB)) {
            return -1;
        }
        if ((0, _definition.isInterfaceType)(typeB) && schema.isSubType(typeB, typeA)) {
            return 1;
        }
        return (0, _naturalCompare.naturalCompare)(typeA.name, typeB.name);
    }).map((x)=>x.name);
}
/**
 * For the field name provided, determine if there are any similar field names
 * that may be the result of a typo.
 */ function getSuggestedFieldNames(type, fieldName) {
    if ((0, _definition.isObjectType)(type) || (0, _definition.isInterfaceType)(type)) {
        const possibleFieldNames = Object.keys(type.getFields());
        return (0, _suggestionList.suggestionList)(fieldName, possibleFieldNames);
    } // Otherwise, must be a Union type, which does not define fields.
    return [];
}


/***/ }),

/***/ 3894:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.FragmentsOnCompositeTypesRule = FragmentsOnCompositeTypesRule;
var _GraphQLError = __webpack_require__(2169);
var _printer = __webpack_require__(800);
var _definition = __webpack_require__(7982);
var _typeFromAST = __webpack_require__(6013);
/**
 * Fragments on composite type
 *
 * Fragments use a type condition to determine if they apply, since fragments
 * can only be spread into a composite type (object, interface, or union), the
 * type condition must also be a composite type.
 *
 * See https://spec.graphql.org/draft/#sec-Fragments-On-Composite-Types
 */ function FragmentsOnCompositeTypesRule(context) {
    return {
        InlineFragment (node) {
            const typeCondition = node.typeCondition;
            if (typeCondition) {
                const type = (0, _typeFromAST.typeFromAST)(context.getSchema(), typeCondition);
                if (type && !(0, _definition.isCompositeType)(type)) {
                    const typeStr = (0, _printer.print)(typeCondition);
                    context.reportError(new _GraphQLError.GraphQLError(`Fragment cannot condition on non composite type "${typeStr}".`, {
                        nodes: typeCondition
                    }));
                }
            }
        },
        FragmentDefinition (node) {
            const type = (0, _typeFromAST.typeFromAST)(context.getSchema(), node.typeCondition);
            if (type && !(0, _definition.isCompositeType)(type)) {
                const typeStr = (0, _printer.print)(node.typeCondition);
                context.reportError(new _GraphQLError.GraphQLError(`Fragment "${node.name.value}" cannot condition on non composite type "${typeStr}".`, {
                    nodes: node.typeCondition
                }));
            }
        }
    };
}


/***/ }),

/***/ 7282:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.KnownArgumentNamesOnDirectivesRule = KnownArgumentNamesOnDirectivesRule;
exports.KnownArgumentNamesRule = KnownArgumentNamesRule;
var _didYouMean = __webpack_require__(2228);
var _suggestionList = __webpack_require__(6347);
var _GraphQLError = __webpack_require__(2169);
var _kinds = __webpack_require__(5923);
var _directives = __webpack_require__(3554);
/**
 * Known argument names
 *
 * A GraphQL field is only valid if all supplied arguments are defined by
 * that field.
 *
 * See https://spec.graphql.org/draft/#sec-Argument-Names
 * See https://spec.graphql.org/draft/#sec-Directives-Are-In-Valid-Locations
 */ function KnownArgumentNamesRule(context) {
    return {
        // eslint-disable-next-line new-cap
        ...KnownArgumentNamesOnDirectivesRule(context),
        Argument (argNode) {
            const argDef = context.getArgument();
            const fieldDef = context.getFieldDef();
            const parentType = context.getParentType();
            if (!argDef && fieldDef && parentType) {
                const argName = argNode.name.value;
                const knownArgsNames = fieldDef.args.map((arg)=>arg.name);
                const suggestions = (0, _suggestionList.suggestionList)(argName, knownArgsNames);
                context.reportError(new _GraphQLError.GraphQLError(`Unknown argument "${argName}" on field "${parentType.name}.${fieldDef.name}".` + (0, _didYouMean.didYouMean)(suggestions), {
                    nodes: argNode
                }));
            }
        }
    };
}
/**
 * @internal
 */ function KnownArgumentNamesOnDirectivesRule(context) {
    const directiveArgs = Object.create(null);
    const schema = context.getSchema();
    const definedDirectives = schema ? schema.getDirectives() : _directives.specifiedDirectives;
    for (const directive of definedDirectives){
        directiveArgs[directive.name] = directive.args.map((arg)=>arg.name);
    }
    const astDefinitions = context.getDocument().definitions;
    for (const def of astDefinitions){
        if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
            var _def$arguments;
            // FIXME: https://github.com/graphql/graphql-js/issues/2203
            /* c8 ignore next */ const argsNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
            directiveArgs[def.name.value] = argsNodes.map((arg)=>arg.name.value);
        }
    }
    return {
        Directive (directiveNode) {
            const directiveName = directiveNode.name.value;
            const knownArgs = directiveArgs[directiveName];
            if (directiveNode.arguments && knownArgs) {
                for (const argNode of directiveNode.arguments){
                    const argName = argNode.name.value;
                    if (!knownArgs.includes(argName)) {
                        const suggestions = (0, _suggestionList.suggestionList)(argName, knownArgs);
                        context.reportError(new _GraphQLError.GraphQLError(`Unknown argument "${argName}" on directive "@${directiveName}".` + (0, _didYouMean.didYouMean)(suggestions), {
                            nodes: argNode
                        }));
                    }
                }
            }
            return false;
        }
    };
}


/***/ }),

/***/ 3641:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.KnownDirectivesRule = KnownDirectivesRule;
var _inspect = __webpack_require__(8089);
var _invariant = __webpack_require__(5210);
var _GraphQLError = __webpack_require__(2169);
var _ast = __webpack_require__(9344);
var _directiveLocation = __webpack_require__(7936);
var _kinds = __webpack_require__(5923);
var _directives = __webpack_require__(3554);
/**
 * Known directives
 *
 * A GraphQL document is only valid if all `@directives` are known by the
 * schema and legally positioned.
 *
 * See https://spec.graphql.org/draft/#sec-Directives-Are-Defined
 */ function KnownDirectivesRule(context) {
    const locationsMap = Object.create(null);
    const schema = context.getSchema();
    const definedDirectives = schema ? schema.getDirectives() : _directives.specifiedDirectives;
    for (const directive of definedDirectives){
        locationsMap[directive.name] = directive.locations;
    }
    const astDefinitions = context.getDocument().definitions;
    for (const def of astDefinitions){
        if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
            locationsMap[def.name.value] = def.locations.map((name)=>name.value);
        }
    }
    return {
        Directive (node, _key, _parent, _path, ancestors) {
            const name = node.name.value;
            const locations = locationsMap[name];
            if (!locations) {
                context.reportError(new _GraphQLError.GraphQLError(`Unknown directive "@${name}".`, {
                    nodes: node
                }));
                return;
            }
            const candidateLocation = getDirectiveLocationForASTPath(ancestors);
            if (candidateLocation && !locations.includes(candidateLocation)) {
                context.reportError(new _GraphQLError.GraphQLError(`Directive "@${name}" may not be used on ${candidateLocation}.`, {
                    nodes: node
                }));
            }
        }
    };
}
function getDirectiveLocationForASTPath(ancestors) {
    const appliedTo = ancestors[ancestors.length - 1];
    "kind" in appliedTo || (0, _invariant.invariant)(false);
    switch(appliedTo.kind){
        case _kinds.Kind.OPERATION_DEFINITION:
            return getDirectiveLocationForOperation(appliedTo.operation);
        case _kinds.Kind.FIELD:
            return _directiveLocation.DirectiveLocation.FIELD;
        case _kinds.Kind.FRAGMENT_SPREAD:
            return _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD;
        case _kinds.Kind.INLINE_FRAGMENT:
            return _directiveLocation.DirectiveLocation.INLINE_FRAGMENT;
        case _kinds.Kind.FRAGMENT_DEFINITION:
            return _directiveLocation.DirectiveLocation.FRAGMENT_DEFINITION;
        case _kinds.Kind.VARIABLE_DEFINITION:
            return _directiveLocation.DirectiveLocation.VARIABLE_DEFINITION;
        case _kinds.Kind.SCHEMA_DEFINITION:
        case _kinds.Kind.SCHEMA_EXTENSION:
            return _directiveLocation.DirectiveLocation.SCHEMA;
        case _kinds.Kind.SCALAR_TYPE_DEFINITION:
        case _kinds.Kind.SCALAR_TYPE_EXTENSION:
            return _directiveLocation.DirectiveLocation.SCALAR;
        case _kinds.Kind.OBJECT_TYPE_DEFINITION:
        case _kinds.Kind.OBJECT_TYPE_EXTENSION:
            return _directiveLocation.DirectiveLocation.OBJECT;
        case _kinds.Kind.FIELD_DEFINITION:
            return _directiveLocation.DirectiveLocation.FIELD_DEFINITION;
        case _kinds.Kind.INTERFACE_TYPE_DEFINITION:
        case _kinds.Kind.INTERFACE_TYPE_EXTENSION:
            return _directiveLocation.DirectiveLocation.INTERFACE;
        case _kinds.Kind.UNION_TYPE_DEFINITION:
        case _kinds.Kind.UNION_TYPE_EXTENSION:
            return _directiveLocation.DirectiveLocation.UNION;
        case _kinds.Kind.ENUM_TYPE_DEFINITION:
        case _kinds.Kind.ENUM_TYPE_EXTENSION:
            return _directiveLocation.DirectiveLocation.ENUM;
        case _kinds.Kind.ENUM_VALUE_DEFINITION:
            return _directiveLocation.DirectiveLocation.ENUM_VALUE;
        case _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION:
        case _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION:
            return _directiveLocation.DirectiveLocation.INPUT_OBJECT;
        case _kinds.Kind.INPUT_VALUE_DEFINITION:
            {
                const parentNode = ancestors[ancestors.length - 3];
                "kind" in parentNode || (0, _invariant.invariant)(false);
                return parentNode.kind === _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION ? _directiveLocation.DirectiveLocation.INPUT_FIELD_DEFINITION : _directiveLocation.DirectiveLocation.ARGUMENT_DEFINITION;
            }
        // Not reachable, all possible types have been considered.
        /* c8 ignore next */ default:
             false || (0, _invariant.invariant)(false, "Unexpected kind: " + (0, _inspect.inspect)(appliedTo.kind));
    }
}
function getDirectiveLocationForOperation(operation) {
    switch(operation){
        case _ast.OperationTypeNode.QUERY:
            return _directiveLocation.DirectiveLocation.QUERY;
        case _ast.OperationTypeNode.MUTATION:
            return _directiveLocation.DirectiveLocation.MUTATION;
        case _ast.OperationTypeNode.SUBSCRIPTION:
            return _directiveLocation.DirectiveLocation.SUBSCRIPTION;
    }
}


/***/ }),

/***/ 8210:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.KnownFragmentNamesRule = KnownFragmentNamesRule;
var _GraphQLError = __webpack_require__(2169);
/**
 * Known fragment names
 *
 * A GraphQL document is only valid if all `...Fragment` fragment spreads refer
 * to fragments defined in the same document.
 *
 * See https://spec.graphql.org/draft/#sec-Fragment-spread-target-defined
 */ function KnownFragmentNamesRule(context) {
    return {
        FragmentSpread (node) {
            const fragmentName = node.name.value;
            const fragment = context.getFragment(fragmentName);
            if (!fragment) {
                context.reportError(new _GraphQLError.GraphQLError(`Unknown fragment "${fragmentName}".`, {
                    nodes: node.name
                }));
            }
        }
    };
}


/***/ }),

/***/ 8203:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.KnownTypeNamesRule = KnownTypeNamesRule;
var _didYouMean = __webpack_require__(2228);
var _suggestionList = __webpack_require__(6347);
var _GraphQLError = __webpack_require__(2169);
var _predicates = __webpack_require__(3288);
var _introspection = __webpack_require__(1472);
var _scalars = __webpack_require__(9570);
/**
 * Known type names
 *
 * A GraphQL document is only valid if referenced types (specifically
 * variable definitions and fragment conditions) are defined by the type schema.
 *
 * See https://spec.graphql.org/draft/#sec-Fragment-Spread-Type-Existence
 */ function KnownTypeNamesRule(context) {
    const schema = context.getSchema();
    const existingTypesMap = schema ? schema.getTypeMap() : Object.create(null);
    const definedTypes = Object.create(null);
    for (const def of context.getDocument().definitions){
        if ((0, _predicates.isTypeDefinitionNode)(def)) {
            definedTypes[def.name.value] = true;
        }
    }
    const typeNames = [
        ...Object.keys(existingTypesMap),
        ...Object.keys(definedTypes)
    ];
    return {
        NamedType (node, _1, parent, _2, ancestors) {
            const typeName = node.name.value;
            if (!existingTypesMap[typeName] && !definedTypes[typeName]) {
                var _ancestors$;
                const definitionNode = (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0 ? _ancestors$ : parent;
                const isSDL = definitionNode != null && isSDLNode(definitionNode);
                if (isSDL && standardTypeNames.includes(typeName)) {
                    return;
                }
                const suggestedTypes = (0, _suggestionList.suggestionList)(typeName, isSDL ? standardTypeNames.concat(typeNames) : typeNames);
                context.reportError(new _GraphQLError.GraphQLError(`Unknown type "${typeName}".` + (0, _didYouMean.didYouMean)(suggestedTypes), {
                    nodes: node
                }));
            }
        }
    };
}
const standardTypeNames = [
    ..._scalars.specifiedScalarTypes,
    ..._introspection.introspectionTypes
].map((type)=>type.name);
function isSDLNode(value) {
    return "kind" in value && ((0, _predicates.isTypeSystemDefinitionNode)(value) || (0, _predicates.isTypeSystemExtensionNode)(value));
}


/***/ }),

/***/ 9901:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.LoneAnonymousOperationRule = LoneAnonymousOperationRule;
var _GraphQLError = __webpack_require__(2169);
var _kinds = __webpack_require__(5923);
/**
 * Lone anonymous operation
 *
 * A GraphQL document is only valid if when it contains an anonymous operation
 * (the query short-hand) that it contains only that one operation definition.
 *
 * See https://spec.graphql.org/draft/#sec-Lone-Anonymous-Operation
 */ function LoneAnonymousOperationRule(context) {
    let operationCount = 0;
    return {
        Document (node) {
            operationCount = node.definitions.filter((definition)=>definition.kind === _kinds.Kind.OPERATION_DEFINITION).length;
        },
        OperationDefinition (node) {
            if (!node.name && operationCount > 1) {
                context.reportError(new _GraphQLError.GraphQLError("This anonymous operation must be the only defined operation.", {
                    nodes: node
                }));
            }
        }
    };
}


/***/ }),

/***/ 5240:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.LoneSchemaDefinitionRule = LoneSchemaDefinitionRule;
var _GraphQLError = __webpack_require__(2169);
/**
 * Lone Schema definition
 *
 * A GraphQL document is only valid if it contains only one schema definition.
 */ function LoneSchemaDefinitionRule(context) {
    var _ref, _ref2, _oldSchema$astNode;
    const oldSchema = context.getSchema();
    const alreadyDefined = (_ref = (_ref2 = (_oldSchema$astNode = oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.astNode) !== null && _oldSchema$astNode !== void 0 ? _oldSchema$astNode : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getQueryType()) !== null && _ref2 !== void 0 ? _ref2 : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getMutationType()) !== null && _ref !== void 0 ? _ref : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getSubscriptionType();
    let schemaDefinitionsCount = 0;
    return {
        SchemaDefinition (node) {
            if (alreadyDefined) {
                context.reportError(new _GraphQLError.GraphQLError("Cannot define a new schema within a schema extension.", {
                    nodes: node
                }));
                return;
            }
            if (schemaDefinitionsCount > 0) {
                context.reportError(new _GraphQLError.GraphQLError("Must provide only one schema definition.", {
                    nodes: node
                }));
            }
            ++schemaDefinitionsCount;
        }
    };
}


/***/ }),

/***/ 1710:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.NoFragmentCyclesRule = NoFragmentCyclesRule;
var _GraphQLError = __webpack_require__(2169);
/**
 * No fragment cycles
 *
 * The graph of fragment spreads must not form any cycles including spreading itself.
 * Otherwise an operation could infinitely spread or infinitely execute on cycles in the underlying data.
 *
 * See https://spec.graphql.org/draft/#sec-Fragment-spreads-must-not-form-cycles
 */ function NoFragmentCyclesRule(context) {
    // Tracks already visited fragments to maintain O(N) and to ensure that cycles
    // are not redundantly reported.
    const visitedFrags = Object.create(null); // Array of AST nodes used to produce meaningful errors
    const spreadPath = []; // Position in the spread path
    const spreadPathIndexByName = Object.create(null);
    return {
        OperationDefinition: ()=>false,
        FragmentDefinition (node) {
            detectCycleRecursive(node);
            return false;
        }
    }; // This does a straight-forward DFS to find cycles.
    // It does not terminate when a cycle was found but continues to explore
    // the graph to find all possible cycles.
    function detectCycleRecursive(fragment) {
        if (visitedFrags[fragment.name.value]) {
            return;
        }
        const fragmentName = fragment.name.value;
        visitedFrags[fragmentName] = true;
        const spreadNodes = context.getFragmentSpreads(fragment.selectionSet);
        if (spreadNodes.length === 0) {
            return;
        }
        spreadPathIndexByName[fragmentName] = spreadPath.length;
        for (const spreadNode of spreadNodes){
            const spreadName = spreadNode.name.value;
            const cycleIndex = spreadPathIndexByName[spreadName];
            spreadPath.push(spreadNode);
            if (cycleIndex === undefined) {
                const spreadFragment = context.getFragment(spreadName);
                if (spreadFragment) {
                    detectCycleRecursive(spreadFragment);
                }
            } else {
                const cyclePath = spreadPath.slice(cycleIndex);
                const viaPath = cyclePath.slice(0, -1).map((s)=>'"' + s.name.value + '"').join(", ");
                context.reportError(new _GraphQLError.GraphQLError(`Cannot spread fragment "${spreadName}" within itself` + (viaPath !== "" ? ` via ${viaPath}.` : "."), {
                    nodes: cyclePath
                }));
            }
            spreadPath.pop();
        }
        spreadPathIndexByName[fragmentName] = undefined;
    }
}


/***/ }),

/***/ 6869:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.NoUndefinedVariablesRule = NoUndefinedVariablesRule;
var _GraphQLError = __webpack_require__(2169);
/**
 * No undefined variables
 *
 * A GraphQL operation is only valid if all variables encountered, both directly
 * and via fragment spreads, are defined by that operation.
 *
 * See https://spec.graphql.org/draft/#sec-All-Variable-Uses-Defined
 */ function NoUndefinedVariablesRule(context) {
    let variableNameDefined = Object.create(null);
    return {
        OperationDefinition: {
            enter () {
                variableNameDefined = Object.create(null);
            },
            leave (operation) {
                const usages = context.getRecursiveVariableUsages(operation);
                for (const { node  } of usages){
                    const varName = node.name.value;
                    if (variableNameDefined[varName] !== true) {
                        context.reportError(new _GraphQLError.GraphQLError(operation.name ? `Variable "$${varName}" is not defined by operation "${operation.name.value}".` : `Variable "$${varName}" is not defined.`, {
                            nodes: [
                                node,
                                operation
                            ]
                        }));
                    }
                }
            }
        },
        VariableDefinition (node) {
            variableNameDefined[node.variable.name.value] = true;
        }
    };
}


/***/ }),

/***/ 4484:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.NoUnusedFragmentsRule = NoUnusedFragmentsRule;
var _GraphQLError = __webpack_require__(2169);
/**
 * No unused fragments
 *
 * A GraphQL document is only valid if all fragment definitions are spread
 * within operations, or spread within other fragments spread within operations.
 *
 * See https://spec.graphql.org/draft/#sec-Fragments-Must-Be-Used
 */ function NoUnusedFragmentsRule(context) {
    const operationDefs = [];
    const fragmentDefs = [];
    return {
        OperationDefinition (node) {
            operationDefs.push(node);
            return false;
        },
        FragmentDefinition (node) {
            fragmentDefs.push(node);
            return false;
        },
        Document: {
            leave () {
                const fragmentNameUsed = Object.create(null);
                for (const operation of operationDefs){
                    for (const fragment of context.getRecursivelyReferencedFragments(operation)){
                        fragmentNameUsed[fragment.name.value] = true;
                    }
                }
                for (const fragmentDef of fragmentDefs){
                    const fragName = fragmentDef.name.value;
                    if (fragmentNameUsed[fragName] !== true) {
                        context.reportError(new _GraphQLError.GraphQLError(`Fragment "${fragName}" is never used.`, {
                            nodes: fragmentDef
                        }));
                    }
                }
            }
        }
    };
}


/***/ }),

/***/ 447:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.NoUnusedVariablesRule = NoUnusedVariablesRule;
var _GraphQLError = __webpack_require__(2169);
/**
 * No unused variables
 *
 * A GraphQL operation is only valid if all variables defined by an operation
 * are used, either directly or within a spread fragment.
 *
 * See https://spec.graphql.org/draft/#sec-All-Variables-Used
 */ function NoUnusedVariablesRule(context) {
    let variableDefs = [];
    return {
        OperationDefinition: {
            enter () {
                variableDefs = [];
            },
            leave (operation) {
                const variableNameUsed = Object.create(null);
                const usages = context.getRecursiveVariableUsages(operation);
                for (const { node  } of usages){
                    variableNameUsed[node.name.value] = true;
                }
                for (const variableDef of variableDefs){
                    const variableName = variableDef.variable.name.value;
                    if (variableNameUsed[variableName] !== true) {
                        context.reportError(new _GraphQLError.GraphQLError(operation.name ? `Variable "$${variableName}" is never used in operation "${operation.name.value}".` : `Variable "$${variableName}" is never used.`, {
                            nodes: variableDef
                        }));
                    }
                }
            }
        },
        VariableDefinition (def) {
            variableDefs.push(def);
        }
    };
}


/***/ }),

/***/ 2870:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.OverlappingFieldsCanBeMergedRule = OverlappingFieldsCanBeMergedRule;
var _inspect = __webpack_require__(8089);
var _GraphQLError = __webpack_require__(2169);
var _kinds = __webpack_require__(5923);
var _printer = __webpack_require__(800);
var _definition = __webpack_require__(7982);
var _sortValueNode = __webpack_require__(6063);
var _typeFromAST = __webpack_require__(6013);
function reasonMessage(reason) {
    if (Array.isArray(reason)) {
        return reason.map(([responseName, subReason])=>`subfields "${responseName}" conflict because ` + reasonMessage(subReason)).join(" and ");
    }
    return reason;
}
/**
 * Overlapping fields can be merged
 *
 * A selection set is only valid if all fields (including spreading any
 * fragments) either correspond to distinct response names or can be merged
 * without ambiguity.
 *
 * See https://spec.graphql.org/draft/#sec-Field-Selection-Merging
 */ function OverlappingFieldsCanBeMergedRule(context) {
    // A memoization for when two fragments are compared "between" each other for
    // conflicts. Two fragments may be compared many times, so memoizing this can
    // dramatically improve the performance of this validator.
    const comparedFragmentPairs = new PairSet(); // A cache for the "field map" and list of fragment names found in any given
    // selection set. Selection sets may be asked for this information multiple
    // times, so this improves the performance of this validator.
    const cachedFieldsAndFragmentNames = new Map();
    return {
        SelectionSet (selectionSet) {
            const conflicts = findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, context.getParentType(), selectionSet);
            for (const [[responseName, reason], fields1, fields2] of conflicts){
                const reasonMsg = reasonMessage(reason);
                context.reportError(new _GraphQLError.GraphQLError(`Fields "${responseName}" conflict because ${reasonMsg}. Use different aliases on the fields to fetch both if this was intentional.`, {
                    nodes: fields1.concat(fields2)
                }));
            }
        }
    };
}
/**
 * Algorithm:
 *
 * Conflicts occur when two fields exist in a query which will produce the same
 * response name, but represent differing values, thus creating a conflict.
 * The algorithm below finds all conflicts via making a series of comparisons
 * between fields. In order to compare as few fields as possible, this makes
 * a series of comparisons "within" sets of fields and "between" sets of fields.
 *
 * Given any selection set, a collection produces both a set of fields by
 * also including all inline fragments, as well as a list of fragments
 * referenced by fragment spreads.
 *
 * A) Each selection set represented in the document first compares "within" its
 * collected set of fields, finding any conflicts between every pair of
 * overlapping fields.
 * Note: This is the *only time* that a the fields "within" a set are compared
 * to each other. After this only fields "between" sets are compared.
 *
 * B) Also, if any fragment is referenced in a selection set, then a
 * comparison is made "between" the original set of fields and the
 * referenced fragment.
 *
 * C) Also, if multiple fragments are referenced, then comparisons
 * are made "between" each referenced fragment.
 *
 * D) When comparing "between" a set of fields and a referenced fragment, first
 * a comparison is made between each field in the original set of fields and
 * each field in the the referenced set of fields.
 *
 * E) Also, if any fragment is referenced in the referenced selection set,
 * then a comparison is made "between" the original set of fields and the
 * referenced fragment (recursively referring to step D).
 *
 * F) When comparing "between" two fragments, first a comparison is made between
 * each field in the first referenced set of fields and each field in the the
 * second referenced set of fields.
 *
 * G) Also, any fragments referenced by the first must be compared to the
 * second, and any fragments referenced by the second must be compared to the
 * first (recursively referring to step F).
 *
 * H) When comparing two fields, if both have selection sets, then a comparison
 * is made "between" both selection sets, first comparing the set of fields in
 * the first selection set with the set of fields in the second.
 *
 * I) Also, if any fragment is referenced in either selection set, then a
 * comparison is made "between" the other set of fields and the
 * referenced fragment.
 *
 * J) Also, if two fragments are referenced in both selection sets, then a
 * comparison is made "between" the two fragments.
 *
 */ // Find all conflicts found "within" a selection set, including those found
// via spreading in fragments. Called when visiting each SelectionSet in the
// GraphQL Document.
function findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentType, selectionSet) {
    const conflicts = [];
    const [fieldMap, fragmentNames] = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet); // (A) Find find all conflicts "within" the fields of this selection set.
    // Note: this is the *only place* `collectConflictsWithin` is called.
    collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap);
    if (fragmentNames.length !== 0) {
        // (B) Then collect conflicts between these fields and those represented by
        // each spread fragment name found.
        for(let i = 0; i < fragmentNames.length; i++){
            collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fieldMap, fragmentNames[i]); // (C) Then compare this fragment with all other fragments found in this
            // selection set to collect conflicts between fragments spread together.
            // This compares each item in the list of fragment names to every other
            // item in that same list (except for itself).
            for(let j = i + 1; j < fragmentNames.length; j++){
                collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fragmentNames[i], fragmentNames[j]);
            }
        }
    }
    return conflicts;
} // Collect all conflicts found between a set of fields and a fragment reference
// including via spreading in any nested fragments.
function collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {
    const fragment = context.getFragment(fragmentName);
    if (!fragment) {
        return;
    }
    const [fieldMap2, referencedFragmentNames] = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment); // Do not compare a fragment's fieldMap to itself.
    if (fieldMap === fieldMap2) {
        return;
    } // (D) First collect any conflicts between the provided collection of fields
    // and the collection of fields represented by the given fragment.
    collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fieldMap2); // (E) Then collect any conflicts between the provided collection of fields
    // and any fragment names found in the given fragment.
    for (const referencedFragmentName of referencedFragmentNames){
        // Memoize so two fragments are not compared for conflicts more than once.
        if (comparedFragmentPairs.has(referencedFragmentName, fragmentName, areMutuallyExclusive)) {
            continue;
        }
        comparedFragmentPairs.add(referencedFragmentName, fragmentName, areMutuallyExclusive);
        collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, referencedFragmentName);
    }
} // Collect all conflicts found between two fragments, including via spreading in
// any nested fragments.
function collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {
    // No need to compare a fragment to itself.
    if (fragmentName1 === fragmentName2) {
        return;
    } // Memoize so two fragments are not compared for conflicts more than once.
    if (comparedFragmentPairs.has(fragmentName1, fragmentName2, areMutuallyExclusive)) {
        return;
    }
    comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);
    const fragment1 = context.getFragment(fragmentName1);
    const fragment2 = context.getFragment(fragmentName2);
    if (!fragment1 || !fragment2) {
        return;
    }
    const [fieldMap1, referencedFragmentNames1] = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment1);
    const [fieldMap2, referencedFragmentNames2] = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment2); // (F) First, collect all conflicts between these two collections of fields
    // (not including any nested fragments).
    collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2); // (G) Then collect conflicts between the first fragment and any nested
    // fragments spread in the second fragment.
    for (const referencedFragmentName2 of referencedFragmentNames2){
        collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, referencedFragmentName2);
    } // (G) Then collect conflicts between the second fragment and any nested
    // fragments spread in the first fragment.
    for (const referencedFragmentName1 of referencedFragmentNames1){
        collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, referencedFragmentName1, fragmentName2);
    }
} // Find all conflicts found between two selection sets, including those found
// via spreading in fragments. Called when determining if conflicts exist
// between the sub-fields of two overlapping fields.
function findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {
    const conflicts = [];
    const [fieldMap1, fragmentNames1] = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType1, selectionSet1);
    const [fieldMap2, fragmentNames2] = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType2, selectionSet2); // (H) First, collect all conflicts between these two collections of field.
    collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2); // (I) Then collect conflicts between the first collection of fields and
    // those referenced by each fragment name associated with the second.
    for (const fragmentName2 of fragmentNames2){
        collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fragmentName2);
    } // (I) Then collect conflicts between the second collection of fields and
    // those referenced by each fragment name associated with the first.
    for (const fragmentName1 of fragmentNames1){
        collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap2, fragmentName1);
    } // (J) Also collect conflicts between any fragment names by the first and
    // fragment names by the second. This compares each item in the first set of
    // names to each item in the second set of names.
    for (const fragmentName1 of fragmentNames1){
        for (const fragmentName2 of fragmentNames2){
            collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2);
        }
    }
    return conflicts;
} // Collect all Conflicts "within" one collection of fields.
function collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap) {
    // A field map is a keyed collection, where each key represents a response
    // name and the value at that key is a list of all fields which provide that
    // response name. For every response name, if there are multiple fields, they
    // must be compared to find a potential conflict.
    for (const [responseName, fields] of Object.entries(fieldMap)){
        // This compares every field in the list to every other field in this list
        // (except to itself). If the list only has one item, nothing needs to
        // be compared.
        if (fields.length > 1) {
            for(let i = 0; i < fields.length; i++){
                for(let j = i + 1; j < fields.length; j++){
                    const conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, responseName, fields[i], fields[j]);
                    if (conflict) {
                        conflicts.push(conflict);
                    }
                }
            }
        }
    }
} // Collect all Conflicts between two collections of fields. This is similar to,
// but different from the `collectConflictsWithin` function above. This check
// assumes that `collectConflictsWithin` has already been called on each
// provided collection of fields. This is true because this validator traverses
// each individual selection set.
function collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {
    // A field map is a keyed collection, where each key represents a response
    // name and the value at that key is a list of all fields which provide that
    // response name. For any response name which appears in both provided field
    // maps, each field from the first field map must be compared to every field
    // in the second field map to find potential conflicts.
    for (const [responseName, fields1] of Object.entries(fieldMap1)){
        const fields2 = fieldMap2[responseName];
        if (fields2) {
            for (const field1 of fields1){
                for (const field2 of fields2){
                    const conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2);
                    if (conflict) {
                        conflicts.push(conflict);
                    }
                }
            }
        }
    }
} // Determines if there is a conflict between two particular fields, including
// comparing their sub-fields.
function findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {
    const [parentType1, node1, def1] = field1;
    const [parentType2, node2, def2] = field2; // If it is known that two fields could not possibly apply at the same
    // time, due to the parent types, then it is safe to permit them to diverge
    // in aliased field or arguments used as they will not present any ambiguity
    // by differing.
    // It is known that two parent types could never overlap if they are
    // different Object types. Interface or Union types might overlap - if not
    // in the current state of the schema, then perhaps in some future version,
    // thus may not safely diverge.
    const areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && (0, _definition.isObjectType)(parentType1) && (0, _definition.isObjectType)(parentType2);
    if (!areMutuallyExclusive) {
        // Two aliases must refer to the same field.
        const name1 = node1.name.value;
        const name2 = node2.name.value;
        if (name1 !== name2) {
            return [
                [
                    responseName,
                    `"${name1}" and "${name2}" are different fields`
                ],
                [
                    node1
                ],
                [
                    node2
                ]
            ];
        } // Two field calls must have the same arguments.
        if (stringifyArguments(node1) !== stringifyArguments(node2)) {
            return [
                [
                    responseName,
                    "they have differing arguments"
                ],
                [
                    node1
                ],
                [
                    node2
                ]
            ];
        }
    } // The return type for each field.
    const type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;
    const type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;
    if (type1 && type2 && doTypesConflict(type1, type2)) {
        return [
            [
                responseName,
                `they return conflicting types "${(0, _inspect.inspect)(type1)}" and "${(0, _inspect.inspect)(type2)}"`
            ],
            [
                node1
            ],
            [
                node2
            ]
        ];
    } // Collect and compare sub-fields. Use the same "visited fragment names" list
    // for both collections so fields in a fragment reference are never
    // compared to themselves.
    const selectionSet1 = node1.selectionSet;
    const selectionSet2 = node2.selectionSet;
    if (selectionSet1 && selectionSet2) {
        const conflicts = findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, (0, _definition.getNamedType)(type1), selectionSet1, (0, _definition.getNamedType)(type2), selectionSet2);
        return subfieldConflicts(conflicts, responseName, node1, node2);
    }
}
function stringifyArguments(fieldNode) {
    var _fieldNode$arguments;
    // FIXME https://github.com/graphql/graphql-js/issues/2203
    const args = /* c8 ignore next */ (_fieldNode$arguments = fieldNode.arguments) !== null && _fieldNode$arguments !== void 0 ? _fieldNode$arguments : [];
    const inputObjectWithArgs = {
        kind: _kinds.Kind.OBJECT,
        fields: args.map((argNode)=>({
                kind: _kinds.Kind.OBJECT_FIELD,
                name: argNode.name,
                value: argNode.value
            }))
    };
    return (0, _printer.print)((0, _sortValueNode.sortValueNode)(inputObjectWithArgs));
} // Two types conflict if both types could not apply to a value simultaneously.
// Composite types are ignored as their individual field types will be compared
// later recursively. However List and Non-Null types must match.
function doTypesConflict(type1, type2) {
    if ((0, _definition.isListType)(type1)) {
        return (0, _definition.isListType)(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
    }
    if ((0, _definition.isListType)(type2)) {
        return true;
    }
    if ((0, _definition.isNonNullType)(type1)) {
        return (0, _definition.isNonNullType)(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
    }
    if ((0, _definition.isNonNullType)(type2)) {
        return true;
    }
    if ((0, _definition.isLeafType)(type1) || (0, _definition.isLeafType)(type2)) {
        return type1 !== type2;
    }
    return false;
} // Given a selection set, return the collection of fields (a mapping of response
// name to field nodes and definitions) as well as a list of fragment names
// referenced via fragment spreads.
function getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet) {
    const cached = cachedFieldsAndFragmentNames.get(selectionSet);
    if (cached) {
        return cached;
    }
    const nodeAndDefs = Object.create(null);
    const fragmentNames = Object.create(null);
    _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames);
    const result = [
        nodeAndDefs,
        Object.keys(fragmentNames)
    ];
    cachedFieldsAndFragmentNames.set(selectionSet, result);
    return result;
} // Given a reference to a fragment, return the represented collection of fields
// as well as a list of nested fragment names referenced via fragment spreads.
function getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment) {
    // Short-circuit building a type from the node if possible.
    const cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);
    if (cached) {
        return cached;
    }
    const fragmentType = (0, _typeFromAST.typeFromAST)(context.getSchema(), fragment.typeCondition);
    return getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragmentType, fragment.selectionSet);
}
function _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames) {
    for (const selection of selectionSet.selections){
        switch(selection.kind){
            case _kinds.Kind.FIELD:
                {
                    const fieldName = selection.name.value;
                    let fieldDef;
                    if ((0, _definition.isObjectType)(parentType) || (0, _definition.isInterfaceType)(parentType)) {
                        fieldDef = parentType.getFields()[fieldName];
                    }
                    const responseName = selection.alias ? selection.alias.value : fieldName;
                    if (!nodeAndDefs[responseName]) {
                        nodeAndDefs[responseName] = [];
                    }
                    nodeAndDefs[responseName].push([
                        parentType,
                        selection,
                        fieldDef
                    ]);
                    break;
                }
            case _kinds.Kind.FRAGMENT_SPREAD:
                fragmentNames[selection.name.value] = true;
                break;
            case _kinds.Kind.INLINE_FRAGMENT:
                {
                    const typeCondition = selection.typeCondition;
                    const inlineFragmentType = typeCondition ? (0, _typeFromAST.typeFromAST)(context.getSchema(), typeCondition) : parentType;
                    _collectFieldsAndFragmentNames(context, inlineFragmentType, selection.selectionSet, nodeAndDefs, fragmentNames);
                    break;
                }
        }
    }
} // Given a series of Conflicts which occurred between two sub-fields, generate
// a single Conflict.
function subfieldConflicts(conflicts, responseName, node1, node2) {
    if (conflicts.length > 0) {
        return [
            [
                responseName,
                conflicts.map(([reason])=>reason)
            ],
            [
                node1,
                ...conflicts.map(([, fields1])=>fields1).flat()
            ],
            [
                node2,
                ...conflicts.map(([, , fields2])=>fields2).flat()
            ]
        ];
    }
}
/**
 * A way to keep track of pairs of things when the ordering of the pair does not matter.
 */ class PairSet {
    constructor(){
        this._data = new Map();
    }
    has(a, b, areMutuallyExclusive) {
        var _this$_data$get;
        const [key1, key2] = a < b ? [
            a,
            b
        ] : [
            b,
            a
        ];
        const result = (_this$_data$get = this._data.get(key1)) === null || _this$_data$get === void 0 ? void 0 : _this$_data$get.get(key2);
        if (result === undefined) {
            return false;
        } // areMutuallyExclusive being false is a superset of being true, hence if
        // we want to know if this PairSet "has" these two with no exclusivity,
        // we have to ensure it was added as such.
        return areMutuallyExclusive ? true : areMutuallyExclusive === result;
    }
    add(a, b, areMutuallyExclusive) {
        const [key1, key2] = a < b ? [
            a,
            b
        ] : [
            b,
            a
        ];
        const map = this._data.get(key1);
        if (map === undefined) {
            this._data.set(key1, new Map([
                [
                    key2,
                    areMutuallyExclusive
                ]
            ]));
        } else {
            map.set(key2, areMutuallyExclusive);
        }
    }
}


/***/ }),

/***/ 5934:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.PossibleFragmentSpreadsRule = PossibleFragmentSpreadsRule;
var _inspect = __webpack_require__(8089);
var _GraphQLError = __webpack_require__(2169);
var _definition = __webpack_require__(7982);
var _typeComparators = __webpack_require__(5392);
var _typeFromAST = __webpack_require__(6013);
/**
 * Possible fragment spread
 *
 * A fragment spread is only valid if the type condition could ever possibly
 * be true: if there is a non-empty intersection of the possible parent types,
 * and possible types which pass the type condition.
 */ function PossibleFragmentSpreadsRule(context) {
    return {
        InlineFragment (node) {
            const fragType = context.getType();
            const parentType = context.getParentType();
            if ((0, _definition.isCompositeType)(fragType) && (0, _definition.isCompositeType)(parentType) && !(0, _typeComparators.doTypesOverlap)(context.getSchema(), fragType, parentType)) {
                const parentTypeStr = (0, _inspect.inspect)(parentType);
                const fragTypeStr = (0, _inspect.inspect)(fragType);
                context.reportError(new _GraphQLError.GraphQLError(`Fragment cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`, {
                    nodes: node
                }));
            }
        },
        FragmentSpread (node) {
            const fragName = node.name.value;
            const fragType = getFragmentType(context, fragName);
            const parentType = context.getParentType();
            if (fragType && parentType && !(0, _typeComparators.doTypesOverlap)(context.getSchema(), fragType, parentType)) {
                const parentTypeStr = (0, _inspect.inspect)(parentType);
                const fragTypeStr = (0, _inspect.inspect)(fragType);
                context.reportError(new _GraphQLError.GraphQLError(`Fragment "${fragName}" cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`, {
                    nodes: node
                }));
            }
        }
    };
}
function getFragmentType(context, name) {
    const frag = context.getFragment(name);
    if (frag) {
        const type = (0, _typeFromAST.typeFromAST)(context.getSchema(), frag.typeCondition);
        if ((0, _definition.isCompositeType)(type)) {
            return type;
        }
    }
}


/***/ }),

/***/ 5346:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.PossibleTypeExtensionsRule = PossibleTypeExtensionsRule;
var _didYouMean = __webpack_require__(2228);
var _inspect = __webpack_require__(8089);
var _invariant = __webpack_require__(5210);
var _suggestionList = __webpack_require__(6347);
var _GraphQLError = __webpack_require__(2169);
var _kinds = __webpack_require__(5923);
var _predicates = __webpack_require__(3288);
var _definition = __webpack_require__(7982);
/**
 * Possible type extension
 *
 * A type extension is only valid if the type is defined and has the same kind.
 */ function PossibleTypeExtensionsRule(context) {
    const schema = context.getSchema();
    const definedTypes = Object.create(null);
    for (const def of context.getDocument().definitions){
        if ((0, _predicates.isTypeDefinitionNode)(def)) {
            definedTypes[def.name.value] = def;
        }
    }
    return {
        ScalarTypeExtension: checkExtension,
        ObjectTypeExtension: checkExtension,
        InterfaceTypeExtension: checkExtension,
        UnionTypeExtension: checkExtension,
        EnumTypeExtension: checkExtension,
        InputObjectTypeExtension: checkExtension
    };
    function checkExtension(node) {
        const typeName = node.name.value;
        const defNode = definedTypes[typeName];
        const existingType = schema === null || schema === void 0 ? void 0 : schema.getType(typeName);
        let expectedKind;
        if (defNode) {
            expectedKind = defKindToExtKind[defNode.kind];
        } else if (existingType) {
            expectedKind = typeToExtKind(existingType);
        }
        if (expectedKind) {
            if (expectedKind !== node.kind) {
                const kindStr = extensionKindToTypeName(node.kind);
                context.reportError(new _GraphQLError.GraphQLError(`Cannot extend non-${kindStr} type "${typeName}".`, {
                    nodes: defNode ? [
                        defNode,
                        node
                    ] : node
                }));
            }
        } else {
            const allTypeNames = Object.keys({
                ...definedTypes,
                ...schema === null || schema === void 0 ? void 0 : schema.getTypeMap()
            });
            const suggestedTypes = (0, _suggestionList.suggestionList)(typeName, allTypeNames);
            context.reportError(new _GraphQLError.GraphQLError(`Cannot extend type "${typeName}" because it is not defined.` + (0, _didYouMean.didYouMean)(suggestedTypes), {
                nodes: node.name
            }));
        }
    }
}
const defKindToExtKind = {
    [_kinds.Kind.SCALAR_TYPE_DEFINITION]: _kinds.Kind.SCALAR_TYPE_EXTENSION,
    [_kinds.Kind.OBJECT_TYPE_DEFINITION]: _kinds.Kind.OBJECT_TYPE_EXTENSION,
    [_kinds.Kind.INTERFACE_TYPE_DEFINITION]: _kinds.Kind.INTERFACE_TYPE_EXTENSION,
    [_kinds.Kind.UNION_TYPE_DEFINITION]: _kinds.Kind.UNION_TYPE_EXTENSION,
    [_kinds.Kind.ENUM_TYPE_DEFINITION]: _kinds.Kind.ENUM_TYPE_EXTENSION,
    [_kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION]: _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION
};
function typeToExtKind(type) {
    if ((0, _definition.isScalarType)(type)) {
        return _kinds.Kind.SCALAR_TYPE_EXTENSION;
    }
    if ((0, _definition.isObjectType)(type)) {
        return _kinds.Kind.OBJECT_TYPE_EXTENSION;
    }
    if ((0, _definition.isInterfaceType)(type)) {
        return _kinds.Kind.INTERFACE_TYPE_EXTENSION;
    }
    if ((0, _definition.isUnionType)(type)) {
        return _kinds.Kind.UNION_TYPE_EXTENSION;
    }
    if ((0, _definition.isEnumType)(type)) {
        return _kinds.Kind.ENUM_TYPE_EXTENSION;
    }
    if ((0, _definition.isInputObjectType)(type)) {
        return _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION;
    }
    /* c8 ignore next 3 */ // Not reachable. All possible types have been considered
     false || (0, _invariant.invariant)(false, "Unexpected type: " + (0, _inspect.inspect)(type));
}
function extensionKindToTypeName(kind) {
    switch(kind){
        case _kinds.Kind.SCALAR_TYPE_EXTENSION:
            return "scalar";
        case _kinds.Kind.OBJECT_TYPE_EXTENSION:
            return "object";
        case _kinds.Kind.INTERFACE_TYPE_EXTENSION:
            return "interface";
        case _kinds.Kind.UNION_TYPE_EXTENSION:
            return "union";
        case _kinds.Kind.ENUM_TYPE_EXTENSION:
            return "enum";
        case _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION:
            return "input object";
        // Not reachable. All possible types have been considered
        /* c8 ignore next */ default:
             false || (0, _invariant.invariant)(false, "Unexpected kind: " + (0, _inspect.inspect)(kind));
    }
}


/***/ }),

/***/ 7455:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.ProvidedRequiredArgumentsOnDirectivesRule = ProvidedRequiredArgumentsOnDirectivesRule;
exports.ProvidedRequiredArgumentsRule = ProvidedRequiredArgumentsRule;
var _inspect = __webpack_require__(8089);
var _keyMap = __webpack_require__(2512);
var _GraphQLError = __webpack_require__(2169);
var _kinds = __webpack_require__(5923);
var _printer = __webpack_require__(800);
var _definition = __webpack_require__(7982);
var _directives = __webpack_require__(3554);
/**
 * Provided required arguments
 *
 * A field or directive is only valid if all required (non-null without a
 * default value) field arguments have been provided.
 */ function ProvidedRequiredArgumentsRule(context) {
    return {
        // eslint-disable-next-line new-cap
        ...ProvidedRequiredArgumentsOnDirectivesRule(context),
        Field: {
            // Validate on leave to allow for deeper errors to appear first.
            leave (fieldNode) {
                var _fieldNode$arguments;
                const fieldDef = context.getFieldDef();
                if (!fieldDef) {
                    return false;
                }
                const providedArgs = new Set(/* c8 ignore next */ (_fieldNode$arguments = fieldNode.arguments) === null || _fieldNode$arguments === void 0 ? void 0 : _fieldNode$arguments.map((arg)=>arg.name.value));
                for (const argDef of fieldDef.args){
                    if (!providedArgs.has(argDef.name) && (0, _definition.isRequiredArgument)(argDef)) {
                        const argTypeStr = (0, _inspect.inspect)(argDef.type);
                        context.reportError(new _GraphQLError.GraphQLError(`Field "${fieldDef.name}" argument "${argDef.name}" of type "${argTypeStr}" is required, but it was not provided.`, {
                            nodes: fieldNode
                        }));
                    }
                }
            }
        }
    };
}
/**
 * @internal
 */ function ProvidedRequiredArgumentsOnDirectivesRule(context) {
    var _schema$getDirectives;
    const requiredArgsMap = Object.create(null);
    const schema = context.getSchema();
    const definedDirectives = (_schema$getDirectives = schema === null || schema === void 0 ? void 0 : schema.getDirectives()) !== null && _schema$getDirectives !== void 0 ? _schema$getDirectives : _directives.specifiedDirectives;
    for (const directive of definedDirectives){
        requiredArgsMap[directive.name] = (0, _keyMap.keyMap)(directive.args.filter(_definition.isRequiredArgument), (arg)=>arg.name);
    }
    const astDefinitions = context.getDocument().definitions;
    for (const def of astDefinitions){
        if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
            var _def$arguments;
            // FIXME: https://github.com/graphql/graphql-js/issues/2203
            /* c8 ignore next */ const argNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
            requiredArgsMap[def.name.value] = (0, _keyMap.keyMap)(argNodes.filter(isRequiredArgumentNode), (arg)=>arg.name.value);
        }
    }
    return {
        Directive: {
            // Validate on leave to allow for deeper errors to appear first.
            leave (directiveNode) {
                const directiveName = directiveNode.name.value;
                const requiredArgs = requiredArgsMap[directiveName];
                if (requiredArgs) {
                    var _directiveNode$argume;
                    // FIXME: https://github.com/graphql/graphql-js/issues/2203
                    /* c8 ignore next */ const argNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
                    const argNodeMap = new Set(argNodes.map((arg)=>arg.name.value));
                    for (const [argName, argDef] of Object.entries(requiredArgs)){
                        if (!argNodeMap.has(argName)) {
                            const argType = (0, _definition.isType)(argDef.type) ? (0, _inspect.inspect)(argDef.type) : (0, _printer.print)(argDef.type);
                            context.reportError(new _GraphQLError.GraphQLError(`Directive "@${directiveName}" argument "${argName}" of type "${argType}" is required, but it was not provided.`, {
                                nodes: directiveNode
                            }));
                        }
                    }
                }
            }
        }
    };
}
function isRequiredArgumentNode(arg) {
    return arg.type.kind === _kinds.Kind.NON_NULL_TYPE && arg.defaultValue == null;
}


/***/ }),

/***/ 5497:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.ScalarLeafsRule = ScalarLeafsRule;
var _inspect = __webpack_require__(8089);
var _GraphQLError = __webpack_require__(2169);
var _definition = __webpack_require__(7982);
/**
 * Scalar leafs
 *
 * A GraphQL document is valid only if all leaf fields (fields without
 * sub selections) are of scalar or enum types.
 */ function ScalarLeafsRule(context) {
    return {
        Field (node) {
            const type = context.getType();
            const selectionSet = node.selectionSet;
            if (type) {
                if ((0, _definition.isLeafType)((0, _definition.getNamedType)(type))) {
                    if (selectionSet) {
                        const fieldName = node.name.value;
                        const typeStr = (0, _inspect.inspect)(type);
                        context.reportError(new _GraphQLError.GraphQLError(`Field "${fieldName}" must not have a selection since type "${typeStr}" has no subfields.`, {
                            nodes: selectionSet
                        }));
                    }
                } else if (!selectionSet) {
                    const fieldName = node.name.value;
                    const typeStr = (0, _inspect.inspect)(type);
                    context.reportError(new _GraphQLError.GraphQLError(`Field "${fieldName}" of type "${typeStr}" must have a selection of subfields. Did you mean "${fieldName} { ... }"?`, {
                        nodes: node
                    }));
                }
            }
        }
    };
}


/***/ }),

/***/ 3829:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.SingleFieldSubscriptionsRule = SingleFieldSubscriptionsRule;
var _GraphQLError = __webpack_require__(2169);
var _kinds = __webpack_require__(5923);
var _collectFields = __webpack_require__(6271);
/**
 * Subscriptions must only include a non-introspection field.
 *
 * A GraphQL subscription is valid only if it contains a single root field and
 * that root field is not an introspection field.
 *
 * See https://spec.graphql.org/draft/#sec-Single-root-field
 */ function SingleFieldSubscriptionsRule(context) {
    return {
        OperationDefinition (node) {
            if (node.operation === "subscription") {
                const schema = context.getSchema();
                const subscriptionType = schema.getSubscriptionType();
                if (subscriptionType) {
                    const operationName = node.name ? node.name.value : null;
                    const variableValues = Object.create(null);
                    const document = context.getDocument();
                    const fragments = Object.create(null);
                    for (const definition of document.definitions){
                        if (definition.kind === _kinds.Kind.FRAGMENT_DEFINITION) {
                            fragments[definition.name.value] = definition;
                        }
                    }
                    const fields = (0, _collectFields.collectFields)(schema, fragments, variableValues, subscriptionType, node.selectionSet);
                    if (fields.size > 1) {
                        const fieldSelectionLists = [
                            ...fields.values()
                        ];
                        const extraFieldSelectionLists = fieldSelectionLists.slice(1);
                        const extraFieldSelections = extraFieldSelectionLists.flat();
                        context.reportError(new _GraphQLError.GraphQLError(operationName != null ? `Subscription "${operationName}" must select only one top level field.` : "Anonymous Subscription must select only one top level field.", {
                            nodes: extraFieldSelections
                        }));
                    }
                    for (const fieldNodes of fields.values()){
                        const field = fieldNodes[0];
                        const fieldName = field.name.value;
                        if (fieldName.startsWith("__")) {
                            context.reportError(new _GraphQLError.GraphQLError(operationName != null ? `Subscription "${operationName}" must not select an introspection top level field.` : "Anonymous Subscription must not select an introspection top level field.", {
                                nodes: fieldNodes
                            }));
                        }
                    }
                }
            }
        }
    };
}


/***/ }),

/***/ 274:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.UniqueArgumentDefinitionNamesRule = UniqueArgumentDefinitionNamesRule;
var _groupBy = __webpack_require__(6344);
var _GraphQLError = __webpack_require__(2169);
/**
 * Unique argument definition names
 *
 * A GraphQL Object or Interface type is only valid if all its fields have uniquely named arguments.
 * A GraphQL Directive is only valid if all its arguments are uniquely named.
 */ function UniqueArgumentDefinitionNamesRule(context) {
    return {
        DirectiveDefinition (directiveNode) {
            var _directiveNode$argume;
            // FIXME: https://github.com/graphql/graphql-js/issues/2203
            /* c8 ignore next */ const argumentNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
            return checkArgUniqueness(`@${directiveNode.name.value}`, argumentNodes);
        },
        InterfaceTypeDefinition: checkArgUniquenessPerField,
        InterfaceTypeExtension: checkArgUniquenessPerField,
        ObjectTypeDefinition: checkArgUniquenessPerField,
        ObjectTypeExtension: checkArgUniquenessPerField
    };
    function checkArgUniquenessPerField(typeNode) {
        var _typeNode$fields;
        const typeName = typeNode.name.value; // FIXME: https://github.com/graphql/graphql-js/issues/2203
        /* c8 ignore next */ const fieldNodes = (_typeNode$fields = typeNode.fields) !== null && _typeNode$fields !== void 0 ? _typeNode$fields : [];
        for (const fieldDef of fieldNodes){
            var _fieldDef$arguments;
            const fieldName = fieldDef.name.value; // FIXME: https://github.com/graphql/graphql-js/issues/2203
            /* c8 ignore next */ const argumentNodes = (_fieldDef$arguments = fieldDef.arguments) !== null && _fieldDef$arguments !== void 0 ? _fieldDef$arguments : [];
            checkArgUniqueness(`${typeName}.${fieldName}`, argumentNodes);
        }
        return false;
    }
    function checkArgUniqueness(parentName, argumentNodes) {
        const seenArgs = (0, _groupBy.groupBy)(argumentNodes, (arg)=>arg.name.value);
        for (const [argName, argNodes] of seenArgs){
            if (argNodes.length > 1) {
                context.reportError(new _GraphQLError.GraphQLError(`Argument "${parentName}(${argName}:)" can only be defined once.`, {
                    nodes: argNodes.map((node)=>node.name)
                }));
            }
        }
        return false;
    }
}


/***/ }),

/***/ 6076:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.UniqueArgumentNamesRule = UniqueArgumentNamesRule;
var _groupBy = __webpack_require__(6344);
var _GraphQLError = __webpack_require__(2169);
/**
 * Unique argument names
 *
 * A GraphQL field or directive is only valid if all supplied arguments are
 * uniquely named.
 *
 * See https://spec.graphql.org/draft/#sec-Argument-Names
 */ function UniqueArgumentNamesRule(context) {
    return {
        Field: checkArgUniqueness,
        Directive: checkArgUniqueness
    };
    function checkArgUniqueness(parentNode) {
        var _parentNode$arguments;
        // FIXME: https://github.com/graphql/graphql-js/issues/2203
        /* c8 ignore next */ const argumentNodes = (_parentNode$arguments = parentNode.arguments) !== null && _parentNode$arguments !== void 0 ? _parentNode$arguments : [];
        const seenArgs = (0, _groupBy.groupBy)(argumentNodes, (arg)=>arg.name.value);
        for (const [argName, argNodes] of seenArgs){
            if (argNodes.length > 1) {
                context.reportError(new _GraphQLError.GraphQLError(`There can be only one argument named "${argName}".`, {
                    nodes: argNodes.map((node)=>node.name)
                }));
            }
        }
    }
}


/***/ }),

/***/ 727:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.UniqueDirectiveNamesRule = UniqueDirectiveNamesRule;
var _GraphQLError = __webpack_require__(2169);
/**
 * Unique directive names
 *
 * A GraphQL document is only valid if all defined directives have unique names.
 */ function UniqueDirectiveNamesRule(context) {
    const knownDirectiveNames = Object.create(null);
    const schema = context.getSchema();
    return {
        DirectiveDefinition (node) {
            const directiveName = node.name.value;
            if (schema !== null && schema !== void 0 && schema.getDirective(directiveName)) {
                context.reportError(new _GraphQLError.GraphQLError(`Directive "@${directiveName}" already exists in the schema. It cannot be redefined.`, {
                    nodes: node.name
                }));
                return;
            }
            if (knownDirectiveNames[directiveName]) {
                context.reportError(new _GraphQLError.GraphQLError(`There can be only one directive named "@${directiveName}".`, {
                    nodes: [
                        knownDirectiveNames[directiveName],
                        node.name
                    ]
                }));
            } else {
                knownDirectiveNames[directiveName] = node.name;
            }
            return false;
        }
    };
}


/***/ }),

/***/ 7705:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.UniqueDirectivesPerLocationRule = UniqueDirectivesPerLocationRule;
var _GraphQLError = __webpack_require__(2169);
var _kinds = __webpack_require__(5923);
var _predicates = __webpack_require__(3288);
var _directives = __webpack_require__(3554);
/**
 * Unique directive names per location
 *
 * A GraphQL document is only valid if all non-repeatable directives at
 * a given location are uniquely named.
 *
 * See https://spec.graphql.org/draft/#sec-Directives-Are-Unique-Per-Location
 */ function UniqueDirectivesPerLocationRule(context) {
    const uniqueDirectiveMap = Object.create(null);
    const schema = context.getSchema();
    const definedDirectives = schema ? schema.getDirectives() : _directives.specifiedDirectives;
    for (const directive of definedDirectives){
        uniqueDirectiveMap[directive.name] = !directive.isRepeatable;
    }
    const astDefinitions = context.getDocument().definitions;
    for (const def of astDefinitions){
        if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
            uniqueDirectiveMap[def.name.value] = !def.repeatable;
        }
    }
    const schemaDirectives = Object.create(null);
    const typeDirectivesMap = Object.create(null);
    return {
        // Many different AST nodes may contain directives. Rather than listing
        // them all, just listen for entering any node, and check to see if it
        // defines any directives.
        enter (node) {
            if (!("directives" in node) || !node.directives) {
                return;
            }
            let seenDirectives;
            if (node.kind === _kinds.Kind.SCHEMA_DEFINITION || node.kind === _kinds.Kind.SCHEMA_EXTENSION) {
                seenDirectives = schemaDirectives;
            } else if ((0, _predicates.isTypeDefinitionNode)(node) || (0, _predicates.isTypeExtensionNode)(node)) {
                const typeName = node.name.value;
                seenDirectives = typeDirectivesMap[typeName];
                if (seenDirectives === undefined) {
                    typeDirectivesMap[typeName] = seenDirectives = Object.create(null);
                }
            } else {
                seenDirectives = Object.create(null);
            }
            for (const directive of node.directives){
                const directiveName = directive.name.value;
                if (uniqueDirectiveMap[directiveName]) {
                    if (seenDirectives[directiveName]) {
                        context.reportError(new _GraphQLError.GraphQLError(`The directive "@${directiveName}" can only be used once at this location.`, {
                            nodes: [
                                seenDirectives[directiveName],
                                directive
                            ]
                        }));
                    } else {
                        seenDirectives[directiveName] = directive;
                    }
                }
            }
        }
    };
}


/***/ }),

/***/ 7239:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.UniqueEnumValueNamesRule = UniqueEnumValueNamesRule;
var _GraphQLError = __webpack_require__(2169);
var _definition = __webpack_require__(7982);
/**
 * Unique enum value names
 *
 * A GraphQL enum type is only valid if all its values are uniquely named.
 */ function UniqueEnumValueNamesRule(context) {
    const schema = context.getSchema();
    const existingTypeMap = schema ? schema.getTypeMap() : Object.create(null);
    const knownValueNames = Object.create(null);
    return {
        EnumTypeDefinition: checkValueUniqueness,
        EnumTypeExtension: checkValueUniqueness
    };
    function checkValueUniqueness(node) {
        var _node$values;
        const typeName = node.name.value;
        if (!knownValueNames[typeName]) {
            knownValueNames[typeName] = Object.create(null);
        } // FIXME: https://github.com/graphql/graphql-js/issues/2203
        /* c8 ignore next */ const valueNodes = (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];
        const valueNames = knownValueNames[typeName];
        for (const valueDef of valueNodes){
            const valueName = valueDef.name.value;
            const existingType = existingTypeMap[typeName];
            if ((0, _definition.isEnumType)(existingType) && existingType.getValue(valueName)) {
                context.reportError(new _GraphQLError.GraphQLError(`Enum value "${typeName}.${valueName}" already exists in the schema. It cannot also be defined in this type extension.`, {
                    nodes: valueDef.name
                }));
            } else if (valueNames[valueName]) {
                context.reportError(new _GraphQLError.GraphQLError(`Enum value "${typeName}.${valueName}" can only be defined once.`, {
                    nodes: [
                        valueNames[valueName],
                        valueDef.name
                    ]
                }));
            } else {
                valueNames[valueName] = valueDef.name;
            }
        }
        return false;
    }
}


/***/ }),

/***/ 214:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.UniqueFieldDefinitionNamesRule = UniqueFieldDefinitionNamesRule;
var _GraphQLError = __webpack_require__(2169);
var _definition = __webpack_require__(7982);
/**
 * Unique field definition names
 *
 * A GraphQL complex type is only valid if all its fields are uniquely named.
 */ function UniqueFieldDefinitionNamesRule(context) {
    const schema = context.getSchema();
    const existingTypeMap = schema ? schema.getTypeMap() : Object.create(null);
    const knownFieldNames = Object.create(null);
    return {
        InputObjectTypeDefinition: checkFieldUniqueness,
        InputObjectTypeExtension: checkFieldUniqueness,
        InterfaceTypeDefinition: checkFieldUniqueness,
        InterfaceTypeExtension: checkFieldUniqueness,
        ObjectTypeDefinition: checkFieldUniqueness,
        ObjectTypeExtension: checkFieldUniqueness
    };
    function checkFieldUniqueness(node) {
        var _node$fields;
        const typeName = node.name.value;
        if (!knownFieldNames[typeName]) {
            knownFieldNames[typeName] = Object.create(null);
        } // FIXME: https://github.com/graphql/graphql-js/issues/2203
        /* c8 ignore next */ const fieldNodes = (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];
        const fieldNames = knownFieldNames[typeName];
        for (const fieldDef of fieldNodes){
            const fieldName = fieldDef.name.value;
            if (hasField(existingTypeMap[typeName], fieldName)) {
                context.reportError(new _GraphQLError.GraphQLError(`Field "${typeName}.${fieldName}" already exists in the schema. It cannot also be defined in this type extension.`, {
                    nodes: fieldDef.name
                }));
            } else if (fieldNames[fieldName]) {
                context.reportError(new _GraphQLError.GraphQLError(`Field "${typeName}.${fieldName}" can only be defined once.`, {
                    nodes: [
                        fieldNames[fieldName],
                        fieldDef.name
                    ]
                }));
            } else {
                fieldNames[fieldName] = fieldDef.name;
            }
        }
        return false;
    }
}
function hasField(type, fieldName) {
    if ((0, _definition.isObjectType)(type) || (0, _definition.isInterfaceType)(type) || (0, _definition.isInputObjectType)(type)) {
        return type.getFields()[fieldName] != null;
    }
    return false;
}


/***/ }),

/***/ 211:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.UniqueFragmentNamesRule = UniqueFragmentNamesRule;
var _GraphQLError = __webpack_require__(2169);
/**
 * Unique fragment names
 *
 * A GraphQL document is only valid if all defined fragments have unique names.
 *
 * See https://spec.graphql.org/draft/#sec-Fragment-Name-Uniqueness
 */ function UniqueFragmentNamesRule(context) {
    const knownFragmentNames = Object.create(null);
    return {
        OperationDefinition: ()=>false,
        FragmentDefinition (node) {
            const fragmentName = node.name.value;
            if (knownFragmentNames[fragmentName]) {
                context.reportError(new _GraphQLError.GraphQLError(`There can be only one fragment named "${fragmentName}".`, {
                    nodes: [
                        knownFragmentNames[fragmentName],
                        node.name
                    ]
                }));
            } else {
                knownFragmentNames[fragmentName] = node.name;
            }
            return false;
        }
    };
}


/***/ }),

/***/ 5475:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.UniqueInputFieldNamesRule = UniqueInputFieldNamesRule;
var _invariant = __webpack_require__(5210);
var _GraphQLError = __webpack_require__(2169);
/**
 * Unique input field names
 *
 * A GraphQL input object value is only valid if all supplied fields are
 * uniquely named.
 *
 * See https://spec.graphql.org/draft/#sec-Input-Object-Field-Uniqueness
 */ function UniqueInputFieldNamesRule(context) {
    const knownNameStack = [];
    let knownNames = Object.create(null);
    return {
        ObjectValue: {
            enter () {
                knownNameStack.push(knownNames);
                knownNames = Object.create(null);
            },
            leave () {
                const prevKnownNames = knownNameStack.pop();
                prevKnownNames || (0, _invariant.invariant)(false);
                knownNames = prevKnownNames;
            }
        },
        ObjectField (node) {
            const fieldName = node.name.value;
            if (knownNames[fieldName]) {
                context.reportError(new _GraphQLError.GraphQLError(`There can be only one input field named "${fieldName}".`, {
                    nodes: [
                        knownNames[fieldName],
                        node.name
                    ]
                }));
            } else {
                knownNames[fieldName] = node.name;
            }
        }
    };
}


/***/ }),

/***/ 5850:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.UniqueOperationNamesRule = UniqueOperationNamesRule;
var _GraphQLError = __webpack_require__(2169);
/**
 * Unique operation names
 *
 * A GraphQL document is only valid if all defined operations have unique names.
 *
 * See https://spec.graphql.org/draft/#sec-Operation-Name-Uniqueness
 */ function UniqueOperationNamesRule(context) {
    const knownOperationNames = Object.create(null);
    return {
        OperationDefinition (node) {
            const operationName = node.name;
            if (operationName) {
                if (knownOperationNames[operationName.value]) {
                    context.reportError(new _GraphQLError.GraphQLError(`There can be only one operation named "${operationName.value}".`, {
                        nodes: [
                            knownOperationNames[operationName.value],
                            operationName
                        ]
                    }));
                } else {
                    knownOperationNames[operationName.value] = operationName;
                }
            }
            return false;
        },
        FragmentDefinition: ()=>false
    };
}


/***/ }),

/***/ 9387:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.UniqueOperationTypesRule = UniqueOperationTypesRule;
var _GraphQLError = __webpack_require__(2169);
/**
 * Unique operation types
 *
 * A GraphQL document is only valid if it has only one type per operation.
 */ function UniqueOperationTypesRule(context) {
    const schema = context.getSchema();
    const definedOperationTypes = Object.create(null);
    const existingOperationTypes = schema ? {
        query: schema.getQueryType(),
        mutation: schema.getMutationType(),
        subscription: schema.getSubscriptionType()
    } : {};
    return {
        SchemaDefinition: checkOperationTypes,
        SchemaExtension: checkOperationTypes
    };
    function checkOperationTypes(node) {
        var _node$operationTypes;
        // See: https://github.com/graphql/graphql-js/issues/2203
        /* c8 ignore next */ const operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];
        for (const operationType of operationTypesNodes){
            const operation = operationType.operation;
            const alreadyDefinedOperationType = definedOperationTypes[operation];
            if (existingOperationTypes[operation]) {
                context.reportError(new _GraphQLError.GraphQLError(`Type for ${operation} already defined in the schema. It cannot be redefined.`, {
                    nodes: operationType
                }));
            } else if (alreadyDefinedOperationType) {
                context.reportError(new _GraphQLError.GraphQLError(`There can be only one ${operation} type in schema.`, {
                    nodes: [
                        alreadyDefinedOperationType,
                        operationType
                    ]
                }));
            } else {
                definedOperationTypes[operation] = operationType;
            }
        }
        return false;
    }
}


/***/ }),

/***/ 7381:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.UniqueTypeNamesRule = UniqueTypeNamesRule;
var _GraphQLError = __webpack_require__(2169);
/**
 * Unique type names
 *
 * A GraphQL document is only valid if all defined types have unique names.
 */ function UniqueTypeNamesRule(context) {
    const knownTypeNames = Object.create(null);
    const schema = context.getSchema();
    return {
        ScalarTypeDefinition: checkTypeName,
        ObjectTypeDefinition: checkTypeName,
        InterfaceTypeDefinition: checkTypeName,
        UnionTypeDefinition: checkTypeName,
        EnumTypeDefinition: checkTypeName,
        InputObjectTypeDefinition: checkTypeName
    };
    function checkTypeName(node) {
        const typeName = node.name.value;
        if (schema !== null && schema !== void 0 && schema.getType(typeName)) {
            context.reportError(new _GraphQLError.GraphQLError(`Type "${typeName}" already exists in the schema. It cannot also be defined in this type definition.`, {
                nodes: node.name
            }));
            return;
        }
        if (knownTypeNames[typeName]) {
            context.reportError(new _GraphQLError.GraphQLError(`There can be only one type named "${typeName}".`, {
                nodes: [
                    knownTypeNames[typeName],
                    node.name
                ]
            }));
        } else {
            knownTypeNames[typeName] = node.name;
        }
        return false;
    }
}


/***/ }),

/***/ 5156:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.UniqueVariableNamesRule = UniqueVariableNamesRule;
var _groupBy = __webpack_require__(6344);
var _GraphQLError = __webpack_require__(2169);
/**
 * Unique variable names
 *
 * A GraphQL operation is only valid if all its variables are uniquely named.
 */ function UniqueVariableNamesRule(context) {
    return {
        OperationDefinition (operationNode) {
            var _operationNode$variab;
            // See: https://github.com/graphql/graphql-js/issues/2203
            /* c8 ignore next */ const variableDefinitions = (_operationNode$variab = operationNode.variableDefinitions) !== null && _operationNode$variab !== void 0 ? _operationNode$variab : [];
            const seenVariableDefinitions = (0, _groupBy.groupBy)(variableDefinitions, (node)=>node.variable.name.value);
            for (const [variableName, variableNodes] of seenVariableDefinitions){
                if (variableNodes.length > 1) {
                    context.reportError(new _GraphQLError.GraphQLError(`There can be only one variable named "$${variableName}".`, {
                        nodes: variableNodes.map((node)=>node.variable.name)
                    }));
                }
            }
        }
    };
}


/***/ }),

/***/ 3716:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.ValuesOfCorrectTypeRule = ValuesOfCorrectTypeRule;
var _didYouMean = __webpack_require__(2228);
var _inspect = __webpack_require__(8089);
var _keyMap = __webpack_require__(2512);
var _suggestionList = __webpack_require__(6347);
var _GraphQLError = __webpack_require__(2169);
var _printer = __webpack_require__(800);
var _definition = __webpack_require__(7982);
/**
 * Value literals of correct type
 *
 * A GraphQL document is only valid if all value literals are of the type
 * expected at their position.
 *
 * See https://spec.graphql.org/draft/#sec-Values-of-Correct-Type
 */ function ValuesOfCorrectTypeRule(context) {
    return {
        ListValue (node) {
            // Note: TypeInfo will traverse into a list's item type, so look to the
            // parent input type to check if it is a list.
            const type = (0, _definition.getNullableType)(context.getParentInputType());
            if (!(0, _definition.isListType)(type)) {
                isValidValueNode(context, node);
                return false; // Don't traverse further.
            }
        },
        ObjectValue (node) {
            const type = (0, _definition.getNamedType)(context.getInputType());
            if (!(0, _definition.isInputObjectType)(type)) {
                isValidValueNode(context, node);
                return false; // Don't traverse further.
            } // Ensure every required field exists.
            const fieldNodeMap = (0, _keyMap.keyMap)(node.fields, (field)=>field.name.value);
            for (const fieldDef of Object.values(type.getFields())){
                const fieldNode = fieldNodeMap[fieldDef.name];
                if (!fieldNode && (0, _definition.isRequiredInputField)(fieldDef)) {
                    const typeStr = (0, _inspect.inspect)(fieldDef.type);
                    context.reportError(new _GraphQLError.GraphQLError(`Field "${type.name}.${fieldDef.name}" of required type "${typeStr}" was not provided.`, {
                        nodes: node
                    }));
                }
            }
        },
        ObjectField (node) {
            const parentType = (0, _definition.getNamedType)(context.getParentInputType());
            const fieldType = context.getInputType();
            if (!fieldType && (0, _definition.isInputObjectType)(parentType)) {
                const suggestions = (0, _suggestionList.suggestionList)(node.name.value, Object.keys(parentType.getFields()));
                context.reportError(new _GraphQLError.GraphQLError(`Field "${node.name.value}" is not defined by type "${parentType.name}".` + (0, _didYouMean.didYouMean)(suggestions), {
                    nodes: node
                }));
            }
        },
        NullValue (node) {
            const type = context.getInputType();
            if ((0, _definition.isNonNullType)(type)) {
                context.reportError(new _GraphQLError.GraphQLError(`Expected value of type "${(0, _inspect.inspect)(type)}", found ${(0, _printer.print)(node)}.`, {
                    nodes: node
                }));
            }
        },
        EnumValue: (node)=>isValidValueNode(context, node),
        IntValue: (node)=>isValidValueNode(context, node),
        FloatValue: (node)=>isValidValueNode(context, node),
        StringValue: (node)=>isValidValueNode(context, node),
        BooleanValue: (node)=>isValidValueNode(context, node)
    };
}
/**
 * Any value literal may be a valid representation of a Scalar, depending on
 * that scalar type.
 */ function isValidValueNode(context, node) {
    // Report any error at the full type expected by the location.
    const locationType = context.getInputType();
    if (!locationType) {
        return;
    }
    const type = (0, _definition.getNamedType)(locationType);
    if (!(0, _definition.isLeafType)(type)) {
        const typeStr = (0, _inspect.inspect)(locationType);
        context.reportError(new _GraphQLError.GraphQLError(`Expected value of type "${typeStr}", found ${(0, _printer.print)(node)}.`, {
            nodes: node
        }));
        return;
    } // Scalars and Enums determine if a literal value is valid via parseLiteral(),
    // which may throw or return an invalid value to indicate failure.
    try {
        const parseResult = type.parseLiteral(node, undefined);
        if (parseResult === undefined) {
            const typeStr = (0, _inspect.inspect)(locationType);
            context.reportError(new _GraphQLError.GraphQLError(`Expected value of type "${typeStr}", found ${(0, _printer.print)(node)}.`, {
                nodes: node
            }));
        }
    } catch (error) {
        const typeStr = (0, _inspect.inspect)(locationType);
        if (error instanceof _GraphQLError.GraphQLError) {
            context.reportError(error);
        } else {
            context.reportError(new _GraphQLError.GraphQLError(`Expected value of type "${typeStr}", found ${(0, _printer.print)(node)}; ` + error.message, {
                nodes: node,
                originalError: error
            }));
        }
    }
}


/***/ }),

/***/ 8669:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.VariablesAreInputTypesRule = VariablesAreInputTypesRule;
var _GraphQLError = __webpack_require__(2169);
var _printer = __webpack_require__(800);
var _definition = __webpack_require__(7982);
var _typeFromAST = __webpack_require__(6013);
/**
 * Variables are input types
 *
 * A GraphQL operation is only valid if all the variables it defines are of
 * input types (scalar, enum, or input object).
 *
 * See https://spec.graphql.org/draft/#sec-Variables-Are-Input-Types
 */ function VariablesAreInputTypesRule(context) {
    return {
        VariableDefinition (node) {
            const type = (0, _typeFromAST.typeFromAST)(context.getSchema(), node.type);
            if (type !== undefined && !(0, _definition.isInputType)(type)) {
                const variableName = node.variable.name.value;
                const typeName = (0, _printer.print)(node.type);
                context.reportError(new _GraphQLError.GraphQLError(`Variable "$${variableName}" cannot be non-input type "${typeName}".`, {
                    nodes: node.type
                }));
            }
        }
    };
}


/***/ }),

/***/ 4813:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.VariablesInAllowedPositionRule = VariablesInAllowedPositionRule;
var _inspect = __webpack_require__(8089);
var _GraphQLError = __webpack_require__(2169);
var _kinds = __webpack_require__(5923);
var _definition = __webpack_require__(7982);
var _typeComparators = __webpack_require__(5392);
var _typeFromAST = __webpack_require__(6013);
/**
 * Variables in allowed position
 *
 * Variable usages must be compatible with the arguments they are passed to.
 *
 * See https://spec.graphql.org/draft/#sec-All-Variable-Usages-are-Allowed
 */ function VariablesInAllowedPositionRule(context) {
    let varDefMap = Object.create(null);
    return {
        OperationDefinition: {
            enter () {
                varDefMap = Object.create(null);
            },
            leave (operation) {
                const usages = context.getRecursiveVariableUsages(operation);
                for (const { node , type , defaultValue  } of usages){
                    const varName = node.name.value;
                    const varDef = varDefMap[varName];
                    if (varDef && type) {
                        // A var type is allowed if it is the same or more strict (e.g. is
                        // a subtype of) than the expected type. It can be more strict if
                        // the variable type is non-null when the expected type is nullable.
                        // If both are list types, the variable item type can be more strict
                        // than the expected item type (contravariant).
                        const schema = context.getSchema();
                        const varType = (0, _typeFromAST.typeFromAST)(schema, varDef.type);
                        if (varType && !allowedVariableUsage(schema, varType, varDef.defaultValue, type, defaultValue)) {
                            const varTypeStr = (0, _inspect.inspect)(varType);
                            const typeStr = (0, _inspect.inspect)(type);
                            context.reportError(new _GraphQLError.GraphQLError(`Variable "$${varName}" of type "${varTypeStr}" used in position expecting type "${typeStr}".`, {
                                nodes: [
                                    varDef,
                                    node
                                ]
                            }));
                        }
                    }
                }
            }
        },
        VariableDefinition (node) {
            varDefMap[node.variable.name.value] = node;
        }
    };
}
/**
 * Returns true if the variable is allowed in the location it was found,
 * which includes considering if default values exist for either the variable
 * or the location at which it is located.
 */ function allowedVariableUsage(schema, varType, varDefaultValue, locationType, locationDefaultValue) {
    if ((0, _definition.isNonNullType)(locationType) && !(0, _definition.isNonNullType)(varType)) {
        const hasNonNullVariableDefaultValue = varDefaultValue != null && varDefaultValue.kind !== _kinds.Kind.NULL;
        const hasLocationDefaultValue = locationDefaultValue !== undefined;
        if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) {
            return false;
        }
        const nullableLocationType = locationType.ofType;
        return (0, _typeComparators.isTypeSubTypeOf)(schema, varType, nullableLocationType);
    }
    return (0, _typeComparators.isTypeSubTypeOf)(schema, varType, locationType);
}


/***/ }),

/***/ 5474:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.NoDeprecatedCustomRule = NoDeprecatedCustomRule;
var _invariant = __webpack_require__(5210);
var _GraphQLError = __webpack_require__(2169);
var _definition = __webpack_require__(7982);
/**
 * No deprecated
 *
 * A GraphQL document is only valid if all selected fields and all used enum values have not been
 * deprecated.
 *
 * Note: This rule is optional and is not part of the Validation section of the GraphQL
 * Specification. The main purpose of this rule is detection of deprecated usages and not
 * necessarily to forbid their use when querying a service.
 */ function NoDeprecatedCustomRule(context) {
    return {
        Field (node) {
            const fieldDef = context.getFieldDef();
            const deprecationReason = fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.deprecationReason;
            if (fieldDef && deprecationReason != null) {
                const parentType = context.getParentType();
                parentType != null || (0, _invariant.invariant)(false);
                context.reportError(new _GraphQLError.GraphQLError(`The field ${parentType.name}.${fieldDef.name} is deprecated. ${deprecationReason}`, {
                    nodes: node
                }));
            }
        },
        Argument (node) {
            const argDef = context.getArgument();
            const deprecationReason = argDef === null || argDef === void 0 ? void 0 : argDef.deprecationReason;
            if (argDef && deprecationReason != null) {
                const directiveDef = context.getDirective();
                if (directiveDef != null) {
                    context.reportError(new _GraphQLError.GraphQLError(`Directive "@${directiveDef.name}" argument "${argDef.name}" is deprecated. ${deprecationReason}`, {
                        nodes: node
                    }));
                } else {
                    const parentType = context.getParentType();
                    const fieldDef = context.getFieldDef();
                    parentType != null && fieldDef != null || (0, _invariant.invariant)(false);
                    context.reportError(new _GraphQLError.GraphQLError(`Field "${parentType.name}.${fieldDef.name}" argument "${argDef.name}" is deprecated. ${deprecationReason}`, {
                        nodes: node
                    }));
                }
            }
        },
        ObjectField (node) {
            const inputObjectDef = (0, _definition.getNamedType)(context.getParentInputType());
            if ((0, _definition.isInputObjectType)(inputObjectDef)) {
                const inputFieldDef = inputObjectDef.getFields()[node.name.value];
                const deprecationReason = inputFieldDef === null || inputFieldDef === void 0 ? void 0 : inputFieldDef.deprecationReason;
                if (deprecationReason != null) {
                    context.reportError(new _GraphQLError.GraphQLError(`The input field ${inputObjectDef.name}.${inputFieldDef.name} is deprecated. ${deprecationReason}`, {
                        nodes: node
                    }));
                }
            }
        },
        EnumValue (node) {
            const enumValueDef = context.getEnumValue();
            const deprecationReason = enumValueDef === null || enumValueDef === void 0 ? void 0 : enumValueDef.deprecationReason;
            if (enumValueDef && deprecationReason != null) {
                const enumTypeDef = (0, _definition.getNamedType)(context.getInputType());
                enumTypeDef != null || (0, _invariant.invariant)(false);
                context.reportError(new _GraphQLError.GraphQLError(`The enum value "${enumTypeDef.name}.${enumValueDef.name}" is deprecated. ${deprecationReason}`, {
                    nodes: node
                }));
            }
        }
    };
}


/***/ }),

/***/ 5989:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.NoSchemaIntrospectionCustomRule = NoSchemaIntrospectionCustomRule;
var _GraphQLError = __webpack_require__(2169);
var _definition = __webpack_require__(7982);
var _introspection = __webpack_require__(1472);
/**
 * Prohibit introspection queries
 *
 * A GraphQL document is only valid if all fields selected are not fields that
 * return an introspection type.
 *
 * Note: This rule is optional and is not part of the Validation section of the
 * GraphQL Specification. This rule effectively disables introspection, which
 * does not reflect best practices and should only be done if absolutely necessary.
 */ function NoSchemaIntrospectionCustomRule(context) {
    return {
        Field (node) {
            const type = (0, _definition.getNamedType)(context.getType());
            if (type && (0, _introspection.isIntrospectionType)(type)) {
                context.reportError(new _GraphQLError.GraphQLError(`GraphQL introspection has been disabled, but the requested query contained the field "${node.name.value}".`, {
                    nodes: node
                }));
            }
        }
    };
}


/***/ }),

/***/ 3593:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.specifiedSDLRules = exports.specifiedRules = void 0;
var _ExecutableDefinitionsRule = __webpack_require__(7287);
var _FieldsOnCorrectTypeRule = __webpack_require__(3902);
var _FragmentsOnCompositeTypesRule = __webpack_require__(3894);
var _KnownArgumentNamesRule = __webpack_require__(7282);
var _KnownDirectivesRule = __webpack_require__(3641);
var _KnownFragmentNamesRule = __webpack_require__(8210);
var _KnownTypeNamesRule = __webpack_require__(8203);
var _LoneAnonymousOperationRule = __webpack_require__(9901);
var _LoneSchemaDefinitionRule = __webpack_require__(5240);
var _NoFragmentCyclesRule = __webpack_require__(1710);
var _NoUndefinedVariablesRule = __webpack_require__(6869);
var _NoUnusedFragmentsRule = __webpack_require__(4484);
var _NoUnusedVariablesRule = __webpack_require__(447);
var _OverlappingFieldsCanBeMergedRule = __webpack_require__(2870);
var _PossibleFragmentSpreadsRule = __webpack_require__(5934);
var _PossibleTypeExtensionsRule = __webpack_require__(5346);
var _ProvidedRequiredArgumentsRule = __webpack_require__(7455);
var _ScalarLeafsRule = __webpack_require__(5497);
var _SingleFieldSubscriptionsRule = __webpack_require__(3829);
var _UniqueArgumentDefinitionNamesRule = __webpack_require__(274);
var _UniqueArgumentNamesRule = __webpack_require__(6076);
var _UniqueDirectiveNamesRule = __webpack_require__(727);
var _UniqueDirectivesPerLocationRule = __webpack_require__(7705);
var _UniqueEnumValueNamesRule = __webpack_require__(7239);
var _UniqueFieldDefinitionNamesRule = __webpack_require__(214);
var _UniqueFragmentNamesRule = __webpack_require__(211);
var _UniqueInputFieldNamesRule = __webpack_require__(5475);
var _UniqueOperationNamesRule = __webpack_require__(5850);
var _UniqueOperationTypesRule = __webpack_require__(9387);
var _UniqueTypeNamesRule = __webpack_require__(7381);
var _UniqueVariableNamesRule = __webpack_require__(5156);
var _ValuesOfCorrectTypeRule = __webpack_require__(3716);
var _VariablesAreInputTypesRule = __webpack_require__(8669);
var _VariablesInAllowedPositionRule = __webpack_require__(4813);
// Spec Section: "Executable Definitions"
// Spec Section: "Field Selections on Objects, Interfaces, and Unions Types"
// Spec Section: "Fragments on Composite Types"
// Spec Section: "Argument Names"
// Spec Section: "Directives Are Defined"
// Spec Section: "Fragment spread target defined"
// Spec Section: "Fragment Spread Type Existence"
// Spec Section: "Lone Anonymous Operation"
// SDL-specific validation rules
// Spec Section: "Fragments must not form cycles"
// Spec Section: "All Variable Used Defined"
// Spec Section: "Fragments must be used"
// Spec Section: "All Variables Used"
// Spec Section: "Field Selection Merging"
// Spec Section: "Fragment spread is possible"
// Spec Section: "Argument Optionality"
// Spec Section: "Leaf Field Selections"
// Spec Section: "Subscriptions with Single Root Field"
// Spec Section: "Argument Uniqueness"
// Spec Section: "Directives Are Unique Per Location"
// Spec Section: "Fragment Name Uniqueness"
// Spec Section: "Input Object Field Uniqueness"
// Spec Section: "Operation Name Uniqueness"
// Spec Section: "Variable Uniqueness"
// Spec Section: "Value Type Correctness"
// Spec Section: "Variables are Input Types"
// Spec Section: "All Variable Usages Are Allowed"
/**
 * This set includes all validation rules defined by the GraphQL spec.
 *
 * The order of the rules in this list has been adjusted to lead to the
 * most clear output when encountering multiple validation errors.
 */ const specifiedRules = Object.freeze([
    _ExecutableDefinitionsRule.ExecutableDefinitionsRule,
    _UniqueOperationNamesRule.UniqueOperationNamesRule,
    _LoneAnonymousOperationRule.LoneAnonymousOperationRule,
    _SingleFieldSubscriptionsRule.SingleFieldSubscriptionsRule,
    _KnownTypeNamesRule.KnownTypeNamesRule,
    _FragmentsOnCompositeTypesRule.FragmentsOnCompositeTypesRule,
    _VariablesAreInputTypesRule.VariablesAreInputTypesRule,
    _ScalarLeafsRule.ScalarLeafsRule,
    _FieldsOnCorrectTypeRule.FieldsOnCorrectTypeRule,
    _UniqueFragmentNamesRule.UniqueFragmentNamesRule,
    _KnownFragmentNamesRule.KnownFragmentNamesRule,
    _NoUnusedFragmentsRule.NoUnusedFragmentsRule,
    _PossibleFragmentSpreadsRule.PossibleFragmentSpreadsRule,
    _NoFragmentCyclesRule.NoFragmentCyclesRule,
    _UniqueVariableNamesRule.UniqueVariableNamesRule,
    _NoUndefinedVariablesRule.NoUndefinedVariablesRule,
    _NoUnusedVariablesRule.NoUnusedVariablesRule,
    _KnownDirectivesRule.KnownDirectivesRule,
    _UniqueDirectivesPerLocationRule.UniqueDirectivesPerLocationRule,
    _KnownArgumentNamesRule.KnownArgumentNamesRule,
    _UniqueArgumentNamesRule.UniqueArgumentNamesRule,
    _ValuesOfCorrectTypeRule.ValuesOfCorrectTypeRule,
    _ProvidedRequiredArgumentsRule.ProvidedRequiredArgumentsRule,
    _VariablesInAllowedPositionRule.VariablesInAllowedPositionRule,
    _OverlappingFieldsCanBeMergedRule.OverlappingFieldsCanBeMergedRule,
    _UniqueInputFieldNamesRule.UniqueInputFieldNamesRule
]);
/**
 * @internal
 */ exports.specifiedRules = specifiedRules;
const specifiedSDLRules = Object.freeze([
    _LoneSchemaDefinitionRule.LoneSchemaDefinitionRule,
    _UniqueOperationTypesRule.UniqueOperationTypesRule,
    _UniqueTypeNamesRule.UniqueTypeNamesRule,
    _UniqueEnumValueNamesRule.UniqueEnumValueNamesRule,
    _UniqueFieldDefinitionNamesRule.UniqueFieldDefinitionNamesRule,
    _UniqueArgumentDefinitionNamesRule.UniqueArgumentDefinitionNamesRule,
    _UniqueDirectiveNamesRule.UniqueDirectiveNamesRule,
    _KnownTypeNamesRule.KnownTypeNamesRule,
    _KnownDirectivesRule.KnownDirectivesRule,
    _UniqueDirectivesPerLocationRule.UniqueDirectivesPerLocationRule,
    _PossibleTypeExtensionsRule.PossibleTypeExtensionsRule,
    _KnownArgumentNamesRule.KnownArgumentNamesOnDirectivesRule,
    _UniqueArgumentNamesRule.UniqueArgumentNamesRule,
    _UniqueInputFieldNamesRule.UniqueInputFieldNamesRule,
    _ProvidedRequiredArgumentsRule.ProvidedRequiredArgumentsOnDirectivesRule
]);
exports.specifiedSDLRules = specifiedSDLRules;


/***/ }),

/***/ 9571:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.assertValidSDL = assertValidSDL;
exports.assertValidSDLExtension = assertValidSDLExtension;
exports.validate = validate;
exports.validateSDL = validateSDL;
var _devAssert = __webpack_require__(90);
var _GraphQLError = __webpack_require__(2169);
var _visitor = __webpack_require__(4256);
var _validate = __webpack_require__(4968);
var _TypeInfo = __webpack_require__(5790);
var _specifiedRules = __webpack_require__(3593);
var _ValidationContext = __webpack_require__(3929);
/**
 * Implements the "Validation" section of the spec.
 *
 * Validation runs synchronously, returning an array of encountered errors, or
 * an empty array if no errors were encountered and the document is valid.
 *
 * A list of specific validation rules may be provided. If not provided, the
 * default list of rules defined by the GraphQL specification will be used.
 *
 * Each validation rules is a function which returns a visitor
 * (see the language/visitor API). Visitor methods are expected to return
 * GraphQLErrors, or Arrays of GraphQLErrors when invalid.
 *
 * Validate will stop validation after a `maxErrors` limit has been reached.
 * Attackers can send pathologically invalid queries to induce a DoS attack,
 * so by default `maxErrors` set to 100 errors.
 *
 * Optionally a custom TypeInfo instance may be provided. If not provided, one
 * will be created from the provided schema.
 */ function validate(schema, documentAST, rules = _specifiedRules.specifiedRules, options, /** @deprecated will be removed in 17.0.0 */ typeInfo = new _TypeInfo.TypeInfo(schema)) {
    var _options$maxErrors;
    const maxErrors = (_options$maxErrors = options === null || options === void 0 ? void 0 : options.maxErrors) !== null && _options$maxErrors !== void 0 ? _options$maxErrors : 100;
    documentAST || (0, _devAssert.devAssert)(false, "Must provide document."); // If the schema used for validation is invalid, throw an error.
    (0, _validate.assertValidSchema)(schema);
    const abortObj = Object.freeze({});
    const errors = [];
    const context = new _ValidationContext.ValidationContext(schema, documentAST, typeInfo, (error)=>{
        if (errors.length >= maxErrors) {
            errors.push(new _GraphQLError.GraphQLError("Too many validation errors, error limit reached. Validation aborted.")); // eslint-disable-next-line @typescript-eslint/no-throw-literal
            throw abortObj;
        }
        errors.push(error);
    }); // This uses a specialized visitor which runs multiple visitors in parallel,
    // while maintaining the visitor skip and break API.
    const visitor = (0, _visitor.visitInParallel)(rules.map((rule)=>rule(context))); // Visit the whole document with each instance of all provided rules.
    try {
        (0, _visitor.visit)(documentAST, (0, _TypeInfo.visitWithTypeInfo)(typeInfo, visitor));
    } catch (e) {
        if (e !== abortObj) {
            throw e;
        }
    }
    return errors;
}
/**
 * @internal
 */ function validateSDL(documentAST, schemaToExtend, rules = _specifiedRules.specifiedSDLRules) {
    const errors = [];
    const context = new _ValidationContext.SDLValidationContext(documentAST, schemaToExtend, (error)=>{
        errors.push(error);
    });
    const visitors = rules.map((rule)=>rule(context));
    (0, _visitor.visit)(documentAST, (0, _visitor.visitInParallel)(visitors));
    return errors;
}
/**
 * Utility function which asserts a SDL document is valid by throwing an error
 * if it is invalid.
 *
 * @internal
 */ function assertValidSDL(documentAST) {
    const errors = validateSDL(documentAST);
    if (errors.length !== 0) {
        throw new Error(errors.map((error)=>error.message).join("\n\n"));
    }
}
/**
 * Utility function which asserts a SDL document is valid by throwing an error
 * if it is invalid.
 *
 * @internal
 */ function assertValidSDLExtension(documentAST, schema) {
    const errors = validateSDL(documentAST, schema);
    if (errors.length !== 0) {
        throw new Error(errors.map((error)=>error.message).join("\n\n"));
    }
}


/***/ }),

/***/ 4259:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.versionInfo = exports.version = void 0;
// Note: This file is autogenerated using "resources/gen-version.js" script and
// automatically updated by "npm version" command.
/**
 * A string containing the version of the GraphQL.js library
 */ const version = "16.6.0";
/**
 * An object containing the components of the GraphQL.js version string
 */ exports.version = version;
const versionInfo = Object.freeze({
    major: 16,
    minor: 6,
    patch: 0,
    preReleaseTag: null
});
exports.versionInfo = versionInfo;


/***/ }),

/***/ 6276:
/***/ (function(__unused_webpack_module, exports) {

/**
 * MIT License
 * 
 * Copyright (c) 2014-present, Lee Byron and other contributors.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */ (function(global, factory) {
     true ? factory(exports) : 0;
})(this, function(exports1) {
    "use strict";
    var DELETE = "delete";
    // Constants describing the size of trie nodes.
    var SHIFT = 5; // Resulted in best performance after ______?
    var SIZE = 1 << SHIFT;
    var MASK = SIZE - 1;
    // A consistent shared value representing "not set" which equals nothing other
    // than itself, and nothing that could be provided externally.
    var NOT_SET = {};
    // Boolean references, Rough equivalent of `bool &`.
    function MakeRef() {
        return {
            value: false
        };
    }
    function SetRef(ref) {
        if (ref) {
            ref.value = true;
        }
    }
    // A function which returns a value representing an "owner" for transient writes
    // to tries. The return value will only ever equal itself, and will not equal
    // the return of any subsequent call of this function.
    function OwnerID() {}
    function ensureSize(iter) {
        if (iter.size === undefined) {
            iter.size = iter.__iterate(returnTrue);
        }
        return iter.size;
    }
    function wrapIndex(iter, index) {
        // This implements "is array index" which the ECMAString spec defines as:
        //
        //     A String property name P is an array index if and only if
        //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal
        //     to 2^321.
        //
        // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects
        if (typeof index !== "number") {
            var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32
            if ("" + uint32Index !== index || uint32Index === 4294967295) {
                return NaN;
            }
            index = uint32Index;
        }
        return index < 0 ? ensureSize(iter) + index : index;
    }
    function returnTrue() {
        return true;
    }
    function wholeSlice(begin, end, size) {
        return (begin === 0 && !isNeg(begin) || size !== undefined && begin <= -size) && (end === undefined || size !== undefined && end >= size);
    }
    function resolveBegin(begin, size) {
        return resolveIndex(begin, size, 0);
    }
    function resolveEnd(end, size) {
        return resolveIndex(end, size, size);
    }
    function resolveIndex(index, size, defaultIndex) {
        // Sanitize indices using this shorthand for ToInt32(argument)
        // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
        return index === undefined ? defaultIndex : isNeg(index) ? size === Infinity ? size : Math.max(0, size + index) | 0 : size === undefined || size === index ? index : Math.min(size, index) | 0;
    }
    function isNeg(value) {
        // Account for -0 which is negative, but not less than 0.
        return value < 0 || value === 0 && 1 / value === -Infinity;
    }
    var IS_COLLECTION_SYMBOL = "@@__IMMUTABLE_ITERABLE__@@";
    function isCollection(maybeCollection) {
        return Boolean(maybeCollection && maybeCollection[IS_COLLECTION_SYMBOL]);
    }
    var IS_KEYED_SYMBOL = "@@__IMMUTABLE_KEYED__@@";
    function isKeyed(maybeKeyed) {
        return Boolean(maybeKeyed && maybeKeyed[IS_KEYED_SYMBOL]);
    }
    var IS_INDEXED_SYMBOL = "@@__IMMUTABLE_INDEXED__@@";
    function isIndexed(maybeIndexed) {
        return Boolean(maybeIndexed && maybeIndexed[IS_INDEXED_SYMBOL]);
    }
    function isAssociative(maybeAssociative) {
        return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
    }
    var Collection = function Collection(value) {
        return isCollection(value) ? value : Seq(value);
    };
    var KeyedCollection = /*@__PURE__*/ function(Collection) {
        function KeyedCollection(value) {
            return isKeyed(value) ? value : KeyedSeq(value);
        }
        if (Collection) KeyedCollection.__proto__ = Collection;
        KeyedCollection.prototype = Object.create(Collection && Collection.prototype);
        KeyedCollection.prototype.constructor = KeyedCollection;
        return KeyedCollection;
    }(Collection);
    var IndexedCollection = /*@__PURE__*/ function(Collection) {
        function IndexedCollection(value) {
            return isIndexed(value) ? value : IndexedSeq(value);
        }
        if (Collection) IndexedCollection.__proto__ = Collection;
        IndexedCollection.prototype = Object.create(Collection && Collection.prototype);
        IndexedCollection.prototype.constructor = IndexedCollection;
        return IndexedCollection;
    }(Collection);
    var SetCollection = /*@__PURE__*/ function(Collection) {
        function SetCollection(value) {
            return isCollection(value) && !isAssociative(value) ? value : SetSeq(value);
        }
        if (Collection) SetCollection.__proto__ = Collection;
        SetCollection.prototype = Object.create(Collection && Collection.prototype);
        SetCollection.prototype.constructor = SetCollection;
        return SetCollection;
    }(Collection);
    Collection.Keyed = KeyedCollection;
    Collection.Indexed = IndexedCollection;
    Collection.Set = SetCollection;
    var IS_SEQ_SYMBOL = "@@__IMMUTABLE_SEQ__@@";
    function isSeq(maybeSeq) {
        return Boolean(maybeSeq && maybeSeq[IS_SEQ_SYMBOL]);
    }
    var IS_RECORD_SYMBOL = "@@__IMMUTABLE_RECORD__@@";
    function isRecord(maybeRecord) {
        return Boolean(maybeRecord && maybeRecord[IS_RECORD_SYMBOL]);
    }
    function isImmutable(maybeImmutable) {
        return isCollection(maybeImmutable) || isRecord(maybeImmutable);
    }
    var IS_ORDERED_SYMBOL = "@@__IMMUTABLE_ORDERED__@@";
    function isOrdered(maybeOrdered) {
        return Boolean(maybeOrdered && maybeOrdered[IS_ORDERED_SYMBOL]);
    }
    var ITERATE_KEYS = 0;
    var ITERATE_VALUES = 1;
    var ITERATE_ENTRIES = 2;
    var REAL_ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
    var FAUX_ITERATOR_SYMBOL = "@@iterator";
    var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;
    var Iterator = function Iterator(next) {
        this.next = next;
    };
    Iterator.prototype.toString = function toString() {
        return "[Iterator]";
    };
    Iterator.KEYS = ITERATE_KEYS;
    Iterator.VALUES = ITERATE_VALUES;
    Iterator.ENTRIES = ITERATE_ENTRIES;
    Iterator.prototype.inspect = Iterator.prototype.toSource = function() {
        return this.toString();
    };
    Iterator.prototype[ITERATOR_SYMBOL] = function() {
        return this;
    };
    function iteratorValue(type, k, v, iteratorResult) {
        var value = type === 0 ? k : type === 1 ? v : [
            k,
            v
        ];
        iteratorResult ? iteratorResult.value = value : iteratorResult = {
            value: value,
            done: false
        };
        return iteratorResult;
    }
    function iteratorDone() {
        return {
            value: undefined,
            done: true
        };
    }
    function hasIterator(maybeIterable) {
        if (Array.isArray(maybeIterable)) {
            // IE11 trick as it does not support `Symbol.iterator`
            return true;
        }
        return !!getIteratorFn(maybeIterable);
    }
    function isIterator(maybeIterator) {
        return maybeIterator && typeof maybeIterator.next === "function";
    }
    function getIterator(iterable) {
        var iteratorFn = getIteratorFn(iterable);
        return iteratorFn && iteratorFn.call(iterable);
    }
    function getIteratorFn(iterable) {
        var iteratorFn = iterable && (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL] || iterable[FAUX_ITERATOR_SYMBOL]);
        if (typeof iteratorFn === "function") {
            return iteratorFn;
        }
    }
    function isEntriesIterable(maybeIterable) {
        var iteratorFn = getIteratorFn(maybeIterable);
        return iteratorFn && iteratorFn === maybeIterable.entries;
    }
    function isKeysIterable(maybeIterable) {
        var iteratorFn = getIteratorFn(maybeIterable);
        return iteratorFn && iteratorFn === maybeIterable.keys;
    }
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function isArrayLike(value) {
        if (Array.isArray(value) || typeof value === "string") {
            return true;
        }
        return value && typeof value === "object" && Number.isInteger(value.length) && value.length >= 0 && (value.length === 0 ? Object.keys(value).length === 1 : // in the array-like may be found (which could be undefined).
        value.hasOwnProperty(value.length - 1));
    }
    var Seq = /*@__PURE__*/ function(Collection) {
        function Seq(value) {
            return value === undefined || value === null ? emptySequence() : isImmutable(value) ? value.toSeq() : seqFromValue(value);
        }
        if (Collection) Seq.__proto__ = Collection;
        Seq.prototype = Object.create(Collection && Collection.prototype);
        Seq.prototype.constructor = Seq;
        Seq.prototype.toSeq = function toSeq() {
            return this;
        };
        Seq.prototype.toString = function toString() {
            return this.__toString("Seq {", "}");
        };
        Seq.prototype.cacheResult = function cacheResult() {
            if (!this._cache && this.__iterateUncached) {
                this._cache = this.entrySeq().toArray();
                this.size = this._cache.length;
            }
            return this;
        };
        // abstract __iterateUncached(fn, reverse)
        Seq.prototype.__iterate = function __iterate(fn, reverse) {
            var cache = this._cache;
            if (cache) {
                var size = cache.length;
                var i = 0;
                while(i !== size){
                    var entry = cache[reverse ? size - ++i : i++];
                    if (fn(entry[1], entry[0], this) === false) {
                        break;
                    }
                }
                return i;
            }
            return this.__iterateUncached(fn, reverse);
        };
        // abstract __iteratorUncached(type, reverse)
        Seq.prototype.__iterator = function __iterator(type, reverse) {
            var cache = this._cache;
            if (cache) {
                var size = cache.length;
                var i = 0;
                return new Iterator(function() {
                    if (i === size) {
                        return iteratorDone();
                    }
                    var entry = cache[reverse ? size - ++i : i++];
                    return iteratorValue(type, entry[0], entry[1]);
                });
            }
            return this.__iteratorUncached(type, reverse);
        };
        return Seq;
    }(Collection);
    var KeyedSeq = /*@__PURE__*/ function(Seq) {
        function KeyedSeq(value) {
            return value === undefined || value === null ? emptySequence().toKeyedSeq() : isCollection(value) ? isKeyed(value) ? value.toSeq() : value.fromEntrySeq() : isRecord(value) ? value.toSeq() : keyedSeqFromValue(value);
        }
        if (Seq) KeyedSeq.__proto__ = Seq;
        KeyedSeq.prototype = Object.create(Seq && Seq.prototype);
        KeyedSeq.prototype.constructor = KeyedSeq;
        KeyedSeq.prototype.toKeyedSeq = function toKeyedSeq() {
            return this;
        };
        return KeyedSeq;
    }(Seq);
    var IndexedSeq = /*@__PURE__*/ function(Seq) {
        function IndexedSeq(value) {
            return value === undefined || value === null ? emptySequence() : isCollection(value) ? isKeyed(value) ? value.entrySeq() : value.toIndexedSeq() : isRecord(value) ? value.toSeq().entrySeq() : indexedSeqFromValue(value);
        }
        if (Seq) IndexedSeq.__proto__ = Seq;
        IndexedSeq.prototype = Object.create(Seq && Seq.prototype);
        IndexedSeq.prototype.constructor = IndexedSeq;
        IndexedSeq.of = function of() {
            return IndexedSeq(arguments);
        };
        IndexedSeq.prototype.toIndexedSeq = function toIndexedSeq() {
            return this;
        };
        IndexedSeq.prototype.toString = function toString() {
            return this.__toString("Seq [", "]");
        };
        return IndexedSeq;
    }(Seq);
    var SetSeq = /*@__PURE__*/ function(Seq) {
        function SetSeq(value) {
            return (isCollection(value) && !isAssociative(value) ? value : IndexedSeq(value)).toSetSeq();
        }
        if (Seq) SetSeq.__proto__ = Seq;
        SetSeq.prototype = Object.create(Seq && Seq.prototype);
        SetSeq.prototype.constructor = SetSeq;
        SetSeq.of = function of() {
            return SetSeq(arguments);
        };
        SetSeq.prototype.toSetSeq = function toSetSeq() {
            return this;
        };
        return SetSeq;
    }(Seq);
    Seq.isSeq = isSeq;
    Seq.Keyed = KeyedSeq;
    Seq.Set = SetSeq;
    Seq.Indexed = IndexedSeq;
    Seq.prototype[IS_SEQ_SYMBOL] = true;
    // #pragma Root Sequences
    var ArraySeq = /*@__PURE__*/ function(IndexedSeq) {
        function ArraySeq(array) {
            this._array = array;
            this.size = array.length;
        }
        if (IndexedSeq) ArraySeq.__proto__ = IndexedSeq;
        ArraySeq.prototype = Object.create(IndexedSeq && IndexedSeq.prototype);
        ArraySeq.prototype.constructor = ArraySeq;
        ArraySeq.prototype.get = function get(index, notSetValue) {
            return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;
        };
        ArraySeq.prototype.__iterate = function __iterate(fn, reverse) {
            var array = this._array;
            var size = array.length;
            var i = 0;
            while(i !== size){
                var ii = reverse ? size - ++i : i++;
                if (fn(array[ii], ii, this) === false) {
                    break;
                }
            }
            return i;
        };
        ArraySeq.prototype.__iterator = function __iterator(type, reverse) {
            var array = this._array;
            var size = array.length;
            var i = 0;
            return new Iterator(function() {
                if (i === size) {
                    return iteratorDone();
                }
                var ii = reverse ? size - ++i : i++;
                return iteratorValue(type, ii, array[ii]);
            });
        };
        return ArraySeq;
    }(IndexedSeq);
    var ObjectSeq = /*@__PURE__*/ function(KeyedSeq) {
        function ObjectSeq(object) {
            var keys = Object.keys(object).concat(Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(object) : []);
            this._object = object;
            this._keys = keys;
            this.size = keys.length;
        }
        if (KeyedSeq) ObjectSeq.__proto__ = KeyedSeq;
        ObjectSeq.prototype = Object.create(KeyedSeq && KeyedSeq.prototype);
        ObjectSeq.prototype.constructor = ObjectSeq;
        ObjectSeq.prototype.get = function get(key, notSetValue) {
            if (notSetValue !== undefined && !this.has(key)) {
                return notSetValue;
            }
            return this._object[key];
        };
        ObjectSeq.prototype.has = function has(key) {
            return hasOwnProperty.call(this._object, key);
        };
        ObjectSeq.prototype.__iterate = function __iterate(fn, reverse) {
            var object = this._object;
            var keys = this._keys;
            var size = keys.length;
            var i = 0;
            while(i !== size){
                var key = keys[reverse ? size - ++i : i++];
                if (fn(object[key], key, this) === false) {
                    break;
                }
            }
            return i;
        };
        ObjectSeq.prototype.__iterator = function __iterator(type, reverse) {
            var object = this._object;
            var keys = this._keys;
            var size = keys.length;
            var i = 0;
            return new Iterator(function() {
                if (i === size) {
                    return iteratorDone();
                }
                var key = keys[reverse ? size - ++i : i++];
                return iteratorValue(type, key, object[key]);
            });
        };
        return ObjectSeq;
    }(KeyedSeq);
    ObjectSeq.prototype[IS_ORDERED_SYMBOL] = true;
    var CollectionSeq = /*@__PURE__*/ function(IndexedSeq) {
        function CollectionSeq(collection) {
            this._collection = collection;
            this.size = collection.length || collection.size;
        }
        if (IndexedSeq) CollectionSeq.__proto__ = IndexedSeq;
        CollectionSeq.prototype = Object.create(IndexedSeq && IndexedSeq.prototype);
        CollectionSeq.prototype.constructor = CollectionSeq;
        CollectionSeq.prototype.__iterateUncached = function __iterateUncached(fn, reverse) {
            if (reverse) {
                return this.cacheResult().__iterate(fn, reverse);
            }
            var collection = this._collection;
            var iterator = getIterator(collection);
            var iterations = 0;
            if (isIterator(iterator)) {
                var step;
                while(!(step = iterator.next()).done){
                    if (fn(step.value, iterations++, this) === false) {
                        break;
                    }
                }
            }
            return iterations;
        };
        CollectionSeq.prototype.__iteratorUncached = function __iteratorUncached(type, reverse) {
            if (reverse) {
                return this.cacheResult().__iterator(type, reverse);
            }
            var collection = this._collection;
            var iterator = getIterator(collection);
            if (!isIterator(iterator)) {
                return new Iterator(iteratorDone);
            }
            var iterations = 0;
            return new Iterator(function() {
                var step = iterator.next();
                return step.done ? step : iteratorValue(type, iterations++, step.value);
            });
        };
        return CollectionSeq;
    }(IndexedSeq);
    // # pragma Helper functions
    var EMPTY_SEQ;
    function emptySequence() {
        return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
    }
    function keyedSeqFromValue(value) {
        var seq = maybeIndexedSeqFromValue(value);
        if (seq) {
            return seq.fromEntrySeq();
        }
        if (typeof value === "object") {
            return new ObjectSeq(value);
        }
        throw new TypeError("Expected Array or collection object of [k, v] entries, or keyed object: " + value);
    }
    function indexedSeqFromValue(value) {
        var seq = maybeIndexedSeqFromValue(value);
        if (seq) {
            return seq;
        }
        throw new TypeError("Expected Array or collection object of values: " + value);
    }
    function seqFromValue(value) {
        var seq = maybeIndexedSeqFromValue(value);
        if (seq) {
            return isEntriesIterable(value) ? seq.fromEntrySeq() : isKeysIterable(value) ? seq.toSetSeq() : seq;
        }
        if (typeof value === "object") {
            return new ObjectSeq(value);
        }
        throw new TypeError("Expected Array or collection object of values, or keyed object: " + value);
    }
    function maybeIndexedSeqFromValue(value) {
        return isArrayLike(value) ? new ArraySeq(value) : hasIterator(value) ? new CollectionSeq(value) : undefined;
    }
    var IS_MAP_SYMBOL = "@@__IMMUTABLE_MAP__@@";
    function isMap(maybeMap) {
        return Boolean(maybeMap && maybeMap[IS_MAP_SYMBOL]);
    }
    function isOrderedMap(maybeOrderedMap) {
        return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);
    }
    function isValueObject(maybeValue) {
        return Boolean(maybeValue && typeof maybeValue.equals === "function" && typeof maybeValue.hashCode === "function");
    }
    /**
   * An extension of the "same-value" algorithm as [described for use by ES6 Map
   * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)
   *
   * NaN is considered the same as NaN, however -0 and 0 are considered the same
   * value, which is different from the algorithm described by
   * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).
   *
   * This is extended further to allow Objects to describe the values they
   * represent, by way of `valueOf` or `equals` (and `hashCode`).
   *
   * Note: because of this extension, the key equality of Immutable.Map and the
   * value equality of Immutable.Set will differ from ES6 Map and Set.
   *
   * ### Defining custom values
   *
   * The easiest way to describe the value an object represents is by implementing
   * `valueOf`. For example, `Date` represents a value by returning a unix
   * timestamp for `valueOf`:
   *
   *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...
   *     var date2 = new Date(1234567890000);
   *     date1.valueOf(); // 1234567890000
   *     assert( date1 !== date2 );
   *     assert( Immutable.is( date1, date2 ) );
   *
   * Note: overriding `valueOf` may have other implications if you use this object
   * where JavaScript expects a primitive, such as implicit string coercion.
   *
   * For more complex types, especially collections, implementing `valueOf` may
   * not be performant. An alternative is to implement `equals` and `hashCode`.
   *
   * `equals` takes another object, presumably of similar type, and returns true
   * if it is equal. Equality is symmetrical, so the same result should be
   * returned if this and the argument are flipped.
   *
   *     assert( a.equals(b) === b.equals(a) );
   *
   * `hashCode` returns a 32bit integer number representing the object which will
   * be used to determine how to store the value object in a Map or Set. You must
   * provide both or neither methods, one must not exist without the other.
   *
   * Also, an important relationship between these methods must be upheld: if two
   * values are equal, they *must* return the same hashCode. If the values are not
   * equal, they might have the same hashCode; this is called a hash collision,
   * and while undesirable for performance reasons, it is acceptable.
   *
   *     if (a.equals(b)) {
   *       assert( a.hashCode() === b.hashCode() );
   *     }
   *
   * All Immutable collections are Value Objects: they implement `equals()`
   * and `hashCode()`.
   */ function is(valueA, valueB) {
        if (valueA === valueB || valueA !== valueA && valueB !== valueB) {
            return true;
        }
        if (!valueA || !valueB) {
            return false;
        }
        if (typeof valueA.valueOf === "function" && typeof valueB.valueOf === "function") {
            valueA = valueA.valueOf();
            valueB = valueB.valueOf();
            if (valueA === valueB || valueA !== valueA && valueB !== valueB) {
                return true;
            }
            if (!valueA || !valueB) {
                return false;
            }
        }
        return !!(isValueObject(valueA) && isValueObject(valueB) && valueA.equals(valueB));
    }
    var imul = typeof Math.imul === "function" && Math.imul(0xffffffff, 2) === -2 ? Math.imul : function imul(a, b) {
        a |= 0; // int
        b |= 0; // int
        var c = a & 0xffff;
        var d = b & 0xffff;
        // Shift by 0 fixes the sign on the high part.
        return c * d + ((a >>> 16) * d + c * (b >>> 16) << 16 >>> 0) | 0; // int
    };
    // v8 has an optimization for storing 31-bit signed numbers.
    // Values which have either 00 or 11 as the high order bits qualify.
    // This function drops the highest order bit in a signed number, maintaining
    // the sign bit.
    function smi(i32) {
        return i32 >>> 1 & 0x40000000 | i32 & 0xbfffffff;
    }
    var defaultValueOf = Object.prototype.valueOf;
    function hash(o) {
        if (o == null) {
            return hashNullish(o);
        }
        if (typeof o.hashCode === "function") {
            // Drop any high bits from accidentally long hash codes.
            return smi(o.hashCode(o));
        }
        var v = valueOf(o);
        if (v == null) {
            return hashNullish(v);
        }
        switch(typeof v){
            case "boolean":
                // The hash values for built-in constants are a 1 value for each 5-byte
                // shift region expect for the first, which encodes the value. This
                // reduces the odds of a hash collision for these common values.
                return v ? 0x42108421 : 0x42108420;
            case "number":
                return hashNumber(v);
            case "string":
                return v.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(v) : hashString(v);
            case "object":
            case "function":
                return hashJSObj(v);
            case "symbol":
                return hashSymbol(v);
            default:
                if (typeof v.toString === "function") {
                    return hashString(v.toString());
                }
                throw new Error("Value type " + typeof v + " cannot be hashed.");
        }
    }
    function hashNullish(nullish) {
        return nullish === null ? 0x42108422 : /* undefined */ 0x42108423;
    }
    // Compress arbitrarily large numbers into smi hashes.
    function hashNumber(n) {
        if (n !== n || n === Infinity) {
            return 0;
        }
        var hash = n | 0;
        if (hash !== n) {
            hash ^= n * 0xffffffff;
        }
        while(n > 0xffffffff){
            n /= 0xffffffff;
            hash ^= n;
        }
        return smi(hash);
    }
    function cachedHashString(string) {
        var hashed = stringHashCache[string];
        if (hashed === undefined) {
            hashed = hashString(string);
            if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
                STRING_HASH_CACHE_SIZE = 0;
                stringHashCache = {};
            }
            STRING_HASH_CACHE_SIZE++;
            stringHashCache[string] = hashed;
        }
        return hashed;
    }
    // http://jsperf.com/hashing-strings
    function hashString(string) {
        // This is the hash from JVM
        // The hash code for a string is computed as
        // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],
        // where s[i] is the ith character of the string and n is the length of
        // the string. We "mod" the result to make it between 0 (inclusive) and 2^31
        // (exclusive) by dropping high bits.
        var hashed = 0;
        for(var ii = 0; ii < string.length; ii++){
            hashed = 31 * hashed + string.charCodeAt(ii) | 0;
        }
        return smi(hashed);
    }
    function hashSymbol(sym) {
        var hashed = symbolMap[sym];
        if (hashed !== undefined) {
            return hashed;
        }
        hashed = nextHash();
        symbolMap[sym] = hashed;
        return hashed;
    }
    function hashJSObj(obj) {
        var hashed;
        if (usingWeakMap) {
            hashed = weakMap.get(obj);
            if (hashed !== undefined) {
                return hashed;
            }
        }
        hashed = obj[UID_HASH_KEY];
        if (hashed !== undefined) {
            return hashed;
        }
        if (!canDefineProperty) {
            hashed = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];
            if (hashed !== undefined) {
                return hashed;
            }
            hashed = getIENodeHash(obj);
            if (hashed !== undefined) {
                return hashed;
            }
        }
        hashed = nextHash();
        if (usingWeakMap) {
            weakMap.set(obj, hashed);
        } else if (isExtensible !== undefined && isExtensible(obj) === false) {
            throw new Error("Non-extensible objects are not allowed as keys.");
        } else if (canDefineProperty) {
            Object.defineProperty(obj, UID_HASH_KEY, {
                enumerable: false,
                configurable: false,
                writable: false,
                value: hashed
            });
        } else if (obj.propertyIsEnumerable !== undefined && obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
            // Since we can't define a non-enumerable property on the object
            // we'll hijack one of the less-used non-enumerable properties to
            // save our hash on it. Since this is a function it will not show up in
            // `JSON.stringify` which is what we want.
            obj.propertyIsEnumerable = function() {
                return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);
            };
            obj.propertyIsEnumerable[UID_HASH_KEY] = hashed;
        } else if (obj.nodeType !== undefined) {
            // At this point we couldn't get the IE `uniqueID` to use as a hash
            // and we couldn't use a non-enumerable property to exploit the
            // dontEnum bug so we simply add the `UID_HASH_KEY` on the node
            // itself.
            obj[UID_HASH_KEY] = hashed;
        } else {
            throw new Error("Unable to set a non-enumerable property on object.");
        }
        return hashed;
    }
    // Get references to ES5 object methods.
    var isExtensible = Object.isExtensible;
    // True if Object.defineProperty works as expected. IE8 fails this test.
    var canDefineProperty = function() {
        try {
            Object.defineProperty({}, "@", {});
            return true;
        } catch (e) {
            return false;
        }
    }();
    // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it
    // and avoid memory leaks from the IE cloneNode bug.
    function getIENodeHash(node) {
        if (node && node.nodeType > 0) {
            switch(node.nodeType){
                case 1:
                    return node.uniqueID;
                case 9:
                    return node.documentElement && node.documentElement.uniqueID;
            }
        }
    }
    function valueOf(obj) {
        return obj.valueOf !== defaultValueOf && typeof obj.valueOf === "function" ? obj.valueOf(obj) : obj;
    }
    function nextHash() {
        var nextHash = ++_objHashUID;
        if (_objHashUID & 0x40000000) {
            _objHashUID = 0;
        }
        return nextHash;
    }
    // If possible, use a WeakMap.
    var usingWeakMap = typeof WeakMap === "function";
    var weakMap;
    if (usingWeakMap) {
        weakMap = new WeakMap();
    }
    var symbolMap = Object.create(null);
    var _objHashUID = 0;
    var UID_HASH_KEY = "__immutablehash__";
    if (typeof Symbol === "function") {
        UID_HASH_KEY = Symbol(UID_HASH_KEY);
    }
    var STRING_HASH_CACHE_MIN_STRLEN = 16;
    var STRING_HASH_CACHE_MAX_SIZE = 255;
    var STRING_HASH_CACHE_SIZE = 0;
    var stringHashCache = {};
    var ToKeyedSequence = /*@__PURE__*/ function(KeyedSeq) {
        function ToKeyedSequence(indexed, useKeys) {
            this._iter = indexed;
            this._useKeys = useKeys;
            this.size = indexed.size;
        }
        if (KeyedSeq) ToKeyedSequence.__proto__ = KeyedSeq;
        ToKeyedSequence.prototype = Object.create(KeyedSeq && KeyedSeq.prototype);
        ToKeyedSequence.prototype.constructor = ToKeyedSequence;
        ToKeyedSequence.prototype.get = function get(key, notSetValue) {
            return this._iter.get(key, notSetValue);
        };
        ToKeyedSequence.prototype.has = function has(key) {
            return this._iter.has(key);
        };
        ToKeyedSequence.prototype.valueSeq = function valueSeq() {
            return this._iter.valueSeq();
        };
        ToKeyedSequence.prototype.reverse = function reverse() {
            var this$1$1 = this;
            var reversedSequence = reverseFactory(this, true);
            if (!this._useKeys) {
                reversedSequence.valueSeq = function() {
                    return this$1$1._iter.toSeq().reverse();
                };
            }
            return reversedSequence;
        };
        ToKeyedSequence.prototype.map = function map(mapper, context) {
            var this$1$1 = this;
            var mappedSequence = mapFactory(this, mapper, context);
            if (!this._useKeys) {
                mappedSequence.valueSeq = function() {
                    return this$1$1._iter.toSeq().map(mapper, context);
                };
            }
            return mappedSequence;
        };
        ToKeyedSequence.prototype.__iterate = function __iterate(fn, reverse) {
            var this$1$1 = this;
            return this._iter.__iterate(function(v, k) {
                return fn(v, k, this$1$1);
            }, reverse);
        };
        ToKeyedSequence.prototype.__iterator = function __iterator(type, reverse) {
            return this._iter.__iterator(type, reverse);
        };
        return ToKeyedSequence;
    }(KeyedSeq);
    ToKeyedSequence.prototype[IS_ORDERED_SYMBOL] = true;
    var ToIndexedSequence = /*@__PURE__*/ function(IndexedSeq) {
        function ToIndexedSequence(iter) {
            this._iter = iter;
            this.size = iter.size;
        }
        if (IndexedSeq) ToIndexedSequence.__proto__ = IndexedSeq;
        ToIndexedSequence.prototype = Object.create(IndexedSeq && IndexedSeq.prototype);
        ToIndexedSequence.prototype.constructor = ToIndexedSequence;
        ToIndexedSequence.prototype.includes = function includes(value) {
            return this._iter.includes(value);
        };
        ToIndexedSequence.prototype.__iterate = function __iterate(fn, reverse) {
            var this$1$1 = this;
            var i = 0;
            reverse && ensureSize(this);
            return this._iter.__iterate(function(v) {
                return fn(v, reverse ? this$1$1.size - ++i : i++, this$1$1);
            }, reverse);
        };
        ToIndexedSequence.prototype.__iterator = function __iterator(type, reverse) {
            var this$1$1 = this;
            var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
            var i = 0;
            reverse && ensureSize(this);
            return new Iterator(function() {
                var step = iterator.next();
                return step.done ? step : iteratorValue(type, reverse ? this$1$1.size - ++i : i++, step.value, step);
            });
        };
        return ToIndexedSequence;
    }(IndexedSeq);
    var ToSetSequence = /*@__PURE__*/ function(SetSeq) {
        function ToSetSequence(iter) {
            this._iter = iter;
            this.size = iter.size;
        }
        if (SetSeq) ToSetSequence.__proto__ = SetSeq;
        ToSetSequence.prototype = Object.create(SetSeq && SetSeq.prototype);
        ToSetSequence.prototype.constructor = ToSetSequence;
        ToSetSequence.prototype.has = function has(key) {
            return this._iter.includes(key);
        };
        ToSetSequence.prototype.__iterate = function __iterate(fn, reverse) {
            var this$1$1 = this;
            return this._iter.__iterate(function(v) {
                return fn(v, v, this$1$1);
            }, reverse);
        };
        ToSetSequence.prototype.__iterator = function __iterator(type, reverse) {
            var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
            return new Iterator(function() {
                var step = iterator.next();
                return step.done ? step : iteratorValue(type, step.value, step.value, step);
            });
        };
        return ToSetSequence;
    }(SetSeq);
    var FromEntriesSequence = /*@__PURE__*/ function(KeyedSeq) {
        function FromEntriesSequence(entries) {
            this._iter = entries;
            this.size = entries.size;
        }
        if (KeyedSeq) FromEntriesSequence.__proto__ = KeyedSeq;
        FromEntriesSequence.prototype = Object.create(KeyedSeq && KeyedSeq.prototype);
        FromEntriesSequence.prototype.constructor = FromEntriesSequence;
        FromEntriesSequence.prototype.entrySeq = function entrySeq() {
            return this._iter.toSeq();
        };
        FromEntriesSequence.prototype.__iterate = function __iterate(fn, reverse) {
            var this$1$1 = this;
            return this._iter.__iterate(function(entry) {
                // Check if entry exists first so array access doesn't throw for holes
                // in the parent iteration.
                if (entry) {
                    validateEntry(entry);
                    var indexedCollection = isCollection(entry);
                    return fn(indexedCollection ? entry.get(1) : entry[1], indexedCollection ? entry.get(0) : entry[0], this$1$1);
                }
            }, reverse);
        };
        FromEntriesSequence.prototype.__iterator = function __iterator(type, reverse) {
            var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
            return new Iterator(function() {
                while(true){
                    var step = iterator.next();
                    if (step.done) {
                        return step;
                    }
                    var entry = step.value;
                    // Check if entry exists first so array access doesn't throw for holes
                    // in the parent iteration.
                    if (entry) {
                        validateEntry(entry);
                        var indexedCollection = isCollection(entry);
                        return iteratorValue(type, indexedCollection ? entry.get(0) : entry[0], indexedCollection ? entry.get(1) : entry[1], step);
                    }
                }
            });
        };
        return FromEntriesSequence;
    }(KeyedSeq);
    ToIndexedSequence.prototype.cacheResult = ToKeyedSequence.prototype.cacheResult = ToSetSequence.prototype.cacheResult = FromEntriesSequence.prototype.cacheResult = cacheResultThrough;
    function flipFactory(collection) {
        var flipSequence = makeSequence(collection);
        flipSequence._iter = collection;
        flipSequence.size = collection.size;
        flipSequence.flip = function() {
            return collection;
        };
        flipSequence.reverse = function() {
            var reversedSequence = collection.reverse.apply(this); // super.reverse()
            reversedSequence.flip = function() {
                return collection.reverse();
            };
            return reversedSequence;
        };
        flipSequence.has = function(key) {
            return collection.includes(key);
        };
        flipSequence.includes = function(key) {
            return collection.has(key);
        };
        flipSequence.cacheResult = cacheResultThrough;
        flipSequence.__iterateUncached = function(fn, reverse) {
            var this$1$1 = this;
            return collection.__iterate(function(v, k) {
                return fn(k, v, this$1$1) !== false;
            }, reverse);
        };
        flipSequence.__iteratorUncached = function(type, reverse) {
            if (type === ITERATE_ENTRIES) {
                var iterator = collection.__iterator(type, reverse);
                return new Iterator(function() {
                    var step = iterator.next();
                    if (!step.done) {
                        var k = step.value[0];
                        step.value[0] = step.value[1];
                        step.value[1] = k;
                    }
                    return step;
                });
            }
            return collection.__iterator(type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES, reverse);
        };
        return flipSequence;
    }
    function mapFactory(collection, mapper, context) {
        var mappedSequence = makeSequence(collection);
        mappedSequence.size = collection.size;
        mappedSequence.has = function(key) {
            return collection.has(key);
        };
        mappedSequence.get = function(key, notSetValue) {
            var v = collection.get(key, NOT_SET);
            return v === NOT_SET ? notSetValue : mapper.call(context, v, key, collection);
        };
        mappedSequence.__iterateUncached = function(fn, reverse) {
            var this$1$1 = this;
            return collection.__iterate(function(v, k, c) {
                return fn(mapper.call(context, v, k, c), k, this$1$1) !== false;
            }, reverse);
        };
        mappedSequence.__iteratorUncached = function(type, reverse) {
            var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);
            return new Iterator(function() {
                var step = iterator.next();
                if (step.done) {
                    return step;
                }
                var entry = step.value;
                var key = entry[0];
                return iteratorValue(type, key, mapper.call(context, entry[1], key, collection), step);
            });
        };
        return mappedSequence;
    }
    function reverseFactory(collection, useKeys) {
        var this$1$1 = this;
        var reversedSequence = makeSequence(collection);
        reversedSequence._iter = collection;
        reversedSequence.size = collection.size;
        reversedSequence.reverse = function() {
            return collection;
        };
        if (collection.flip) {
            reversedSequence.flip = function() {
                var flipSequence = flipFactory(collection);
                flipSequence.reverse = function() {
                    return collection.flip();
                };
                return flipSequence;
            };
        }
        reversedSequence.get = function(key, notSetValue) {
            return collection.get(useKeys ? key : -1 - key, notSetValue);
        };
        reversedSequence.has = function(key) {
            return collection.has(useKeys ? key : -1 - key);
        };
        reversedSequence.includes = function(value) {
            return collection.includes(value);
        };
        reversedSequence.cacheResult = cacheResultThrough;
        reversedSequence.__iterate = function(fn, reverse) {
            var this$1$1 = this;
            var i = 0;
            reverse && ensureSize(collection);
            return collection.__iterate(function(v, k) {
                return fn(v, useKeys ? k : reverse ? this$1$1.size - ++i : i++, this$1$1);
            }, !reverse);
        };
        reversedSequence.__iterator = function(type, reverse) {
            var i = 0;
            reverse && ensureSize(collection);
            var iterator = collection.__iterator(ITERATE_ENTRIES, !reverse);
            return new Iterator(function() {
                var step = iterator.next();
                if (step.done) {
                    return step;
                }
                var entry = step.value;
                return iteratorValue(type, useKeys ? entry[0] : reverse ? this$1$1.size - ++i : i++, entry[1], step);
            });
        };
        return reversedSequence;
    }
    function filterFactory(collection, predicate, context, useKeys) {
        var filterSequence = makeSequence(collection);
        if (useKeys) {
            filterSequence.has = function(key) {
                var v = collection.get(key, NOT_SET);
                return v !== NOT_SET && !!predicate.call(context, v, key, collection);
            };
            filterSequence.get = function(key, notSetValue) {
                var v = collection.get(key, NOT_SET);
                return v !== NOT_SET && predicate.call(context, v, key, collection) ? v : notSetValue;
            };
        }
        filterSequence.__iterateUncached = function(fn, reverse) {
            var this$1$1 = this;
            var iterations = 0;
            collection.__iterate(function(v, k, c) {
                if (predicate.call(context, v, k, c)) {
                    iterations++;
                    return fn(v, useKeys ? k : iterations - 1, this$1$1);
                }
            }, reverse);
            return iterations;
        };
        filterSequence.__iteratorUncached = function(type, reverse) {
            var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);
            var iterations = 0;
            return new Iterator(function() {
                while(true){
                    var step = iterator.next();
                    if (step.done) {
                        return step;
                    }
                    var entry = step.value;
                    var key = entry[0];
                    var value = entry[1];
                    if (predicate.call(context, value, key, collection)) {
                        return iteratorValue(type, useKeys ? key : iterations++, value, step);
                    }
                }
            });
        };
        return filterSequence;
    }
    function countByFactory(collection, grouper, context) {
        var groups = Map().asMutable();
        collection.__iterate(function(v, k) {
            groups.update(grouper.call(context, v, k, collection), 0, function(a) {
                return a + 1;
            });
        });
        return groups.asImmutable();
    }
    function groupByFactory(collection, grouper, context) {
        var isKeyedIter = isKeyed(collection);
        var groups = (isOrdered(collection) ? OrderedMap() : Map()).asMutable();
        collection.__iterate(function(v, k) {
            groups.update(grouper.call(context, v, k, collection), function(a) {
                return a = a || [], a.push(isKeyedIter ? [
                    k,
                    v
                ] : v), a;
            });
        });
        var coerce = collectionClass(collection);
        return groups.map(function(arr) {
            return reify(collection, coerce(arr));
        }).asImmutable();
    }
    function partitionFactory(collection, predicate, context) {
        var isKeyedIter = isKeyed(collection);
        var groups = [
            [],
            []
        ];
        collection.__iterate(function(v, k) {
            groups[predicate.call(context, v, k, collection) ? 1 : 0].push(isKeyedIter ? [
                k,
                v
            ] : v);
        });
        var coerce = collectionClass(collection);
        return groups.map(function(arr) {
            return reify(collection, coerce(arr));
        });
    }
    function sliceFactory(collection, begin, end, useKeys) {
        var originalSize = collection.size;
        if (wholeSlice(begin, end, originalSize)) {
            return collection;
        }
        var resolvedBegin = resolveBegin(begin, originalSize);
        var resolvedEnd = resolveEnd(end, originalSize);
        // begin or end will be NaN if they were provided as negative numbers and
        // this collection's size is unknown. In that case, cache first so there is
        // a known size and these do not resolve to NaN.
        if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {
            return sliceFactory(collection.toSeq().cacheResult(), begin, end, useKeys);
        }
        // Note: resolvedEnd is undefined when the original sequence's length is
        // unknown and this slice did not supply an end and should contain all
        // elements after resolvedBegin.
        // In that case, resolvedSize will be NaN and sliceSize will remain undefined.
        var resolvedSize = resolvedEnd - resolvedBegin;
        var sliceSize;
        if (resolvedSize === resolvedSize) {
            sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
        }
        var sliceSeq = makeSequence(collection);
        // If collection.size is undefined, the size of the realized sliceSeq is
        // unknown at this point unless the number of items to slice is 0
        sliceSeq.size = sliceSize === 0 ? sliceSize : collection.size && sliceSize || undefined;
        if (!useKeys && isSeq(collection) && sliceSize >= 0) {
            sliceSeq.get = function(index, notSetValue) {
                index = wrapIndex(this, index);
                return index >= 0 && index < sliceSize ? collection.get(index + resolvedBegin, notSetValue) : notSetValue;
            };
        }
        sliceSeq.__iterateUncached = function(fn, reverse) {
            var this$1$1 = this;
            if (sliceSize === 0) {
                return 0;
            }
            if (reverse) {
                return this.cacheResult().__iterate(fn, reverse);
            }
            var skipped = 0;
            var isSkipping = true;
            var iterations = 0;
            collection.__iterate(function(v, k) {
                if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
                    iterations++;
                    return fn(v, useKeys ? k : iterations - 1, this$1$1) !== false && iterations !== sliceSize;
                }
            });
            return iterations;
        };
        sliceSeq.__iteratorUncached = function(type, reverse) {
            if (sliceSize !== 0 && reverse) {
                return this.cacheResult().__iterator(type, reverse);
            }
            // Don't bother instantiating parent iterator if taking 0.
            if (sliceSize === 0) {
                return new Iterator(iteratorDone);
            }
            var iterator = collection.__iterator(type, reverse);
            var skipped = 0;
            var iterations = 0;
            return new Iterator(function() {
                while(skipped++ < resolvedBegin){
                    iterator.next();
                }
                if (++iterations > sliceSize) {
                    return iteratorDone();
                }
                var step = iterator.next();
                if (useKeys || type === ITERATE_VALUES || step.done) {
                    return step;
                }
                if (type === ITERATE_KEYS) {
                    return iteratorValue(type, iterations - 1, undefined, step);
                }
                return iteratorValue(type, iterations - 1, step.value[1], step);
            });
        };
        return sliceSeq;
    }
    function takeWhileFactory(collection, predicate, context) {
        var takeSequence = makeSequence(collection);
        takeSequence.__iterateUncached = function(fn, reverse) {
            var this$1$1 = this;
            if (reverse) {
                return this.cacheResult().__iterate(fn, reverse);
            }
            var iterations = 0;
            collection.__iterate(function(v, k, c) {
                return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$1$1);
            });
            return iterations;
        };
        takeSequence.__iteratorUncached = function(type, reverse) {
            var this$1$1 = this;
            if (reverse) {
                return this.cacheResult().__iterator(type, reverse);
            }
            var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);
            var iterating = true;
            return new Iterator(function() {
                if (!iterating) {
                    return iteratorDone();
                }
                var step = iterator.next();
                if (step.done) {
                    return step;
                }
                var entry = step.value;
                var k = entry[0];
                var v = entry[1];
                if (!predicate.call(context, v, k, this$1$1)) {
                    iterating = false;
                    return iteratorDone();
                }
                return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);
            });
        };
        return takeSequence;
    }
    function skipWhileFactory(collection, predicate, context, useKeys) {
        var skipSequence = makeSequence(collection);
        skipSequence.__iterateUncached = function(fn, reverse) {
            var this$1$1 = this;
            if (reverse) {
                return this.cacheResult().__iterate(fn, reverse);
            }
            var isSkipping = true;
            var iterations = 0;
            collection.__iterate(function(v, k, c) {
                if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {
                    iterations++;
                    return fn(v, useKeys ? k : iterations - 1, this$1$1);
                }
            });
            return iterations;
        };
        skipSequence.__iteratorUncached = function(type, reverse) {
            var this$1$1 = this;
            if (reverse) {
                return this.cacheResult().__iterator(type, reverse);
            }
            var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);
            var skipping = true;
            var iterations = 0;
            return new Iterator(function() {
                var step;
                var k;
                var v;
                do {
                    step = iterator.next();
                    if (step.done) {
                        if (useKeys || type === ITERATE_VALUES) {
                            return step;
                        }
                        if (type === ITERATE_KEYS) {
                            return iteratorValue(type, iterations++, undefined, step);
                        }
                        return iteratorValue(type, iterations++, step.value[1], step);
                    }
                    var entry = step.value;
                    k = entry[0];
                    v = entry[1];
                    skipping && (skipping = predicate.call(context, v, k, this$1$1));
                }while (skipping);
                return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);
            });
        };
        return skipSequence;
    }
    function concatFactory(collection, values) {
        var isKeyedCollection = isKeyed(collection);
        var iters = [
            collection
        ].concat(values).map(function(v) {
            if (!isCollection(v)) {
                v = isKeyedCollection ? keyedSeqFromValue(v) : indexedSeqFromValue(Array.isArray(v) ? v : [
                    v
                ]);
            } else if (isKeyedCollection) {
                v = KeyedCollection(v);
            }
            return v;
        }).filter(function(v) {
            return v.size !== 0;
        });
        if (iters.length === 0) {
            return collection;
        }
        if (iters.length === 1) {
            var singleton = iters[0];
            if (singleton === collection || isKeyedCollection && isKeyed(singleton) || isIndexed(collection) && isIndexed(singleton)) {
                return singleton;
            }
        }
        var concatSeq = new ArraySeq(iters);
        if (isKeyedCollection) {
            concatSeq = concatSeq.toKeyedSeq();
        } else if (!isIndexed(collection)) {
            concatSeq = concatSeq.toSetSeq();
        }
        concatSeq = concatSeq.flatten(true);
        concatSeq.size = iters.reduce(function(sum, seq) {
            if (sum !== undefined) {
                var size = seq.size;
                if (size !== undefined) {
                    return sum + size;
                }
            }
        }, 0);
        return concatSeq;
    }
    function flattenFactory(collection, depth, useKeys) {
        var flatSequence = makeSequence(collection);
        flatSequence.__iterateUncached = function(fn, reverse) {
            if (reverse) {
                return this.cacheResult().__iterate(fn, reverse);
            }
            var iterations = 0;
            var stopped = false;
            function flatDeep(iter, currentDepth) {
                iter.__iterate(function(v, k) {
                    if ((!depth || currentDepth < depth) && isCollection(v)) {
                        flatDeep(v, currentDepth + 1);
                    } else {
                        iterations++;
                        if (fn(v, useKeys ? k : iterations - 1, flatSequence) === false) {
                            stopped = true;
                        }
                    }
                    return !stopped;
                }, reverse);
            }
            flatDeep(collection, 0);
            return iterations;
        };
        flatSequence.__iteratorUncached = function(type, reverse) {
            if (reverse) {
                return this.cacheResult().__iterator(type, reverse);
            }
            var iterator = collection.__iterator(type, reverse);
            var stack = [];
            var iterations = 0;
            return new Iterator(function() {
                while(iterator){
                    var step = iterator.next();
                    if (step.done !== false) {
                        iterator = stack.pop();
                        continue;
                    }
                    var v = step.value;
                    if (type === ITERATE_ENTRIES) {
                        v = v[1];
                    }
                    if ((!depth || stack.length < depth) && isCollection(v)) {
                        stack.push(iterator);
                        iterator = v.__iterator(type, reverse);
                    } else {
                        return useKeys ? step : iteratorValue(type, iterations++, v, step);
                    }
                }
                return iteratorDone();
            });
        };
        return flatSequence;
    }
    function flatMapFactory(collection, mapper, context) {
        var coerce = collectionClass(collection);
        return collection.toSeq().map(function(v, k) {
            return coerce(mapper.call(context, v, k, collection));
        }).flatten(true);
    }
    function interposeFactory(collection, separator) {
        var interposedSequence = makeSequence(collection);
        interposedSequence.size = collection.size && collection.size * 2 - 1;
        interposedSequence.__iterateUncached = function(fn, reverse) {
            var this$1$1 = this;
            var iterations = 0;
            collection.__iterate(function(v) {
                return (!iterations || fn(separator, iterations++, this$1$1) !== false) && fn(v, iterations++, this$1$1) !== false;
            }, reverse);
            return iterations;
        };
        interposedSequence.__iteratorUncached = function(type, reverse) {
            var iterator = collection.__iterator(ITERATE_VALUES, reverse);
            var iterations = 0;
            var step;
            return new Iterator(function() {
                if (!step || iterations % 2) {
                    step = iterator.next();
                    if (step.done) {
                        return step;
                    }
                }
                return iterations % 2 ? iteratorValue(type, iterations++, separator) : iteratorValue(type, iterations++, step.value, step);
            });
        };
        return interposedSequence;
    }
    function sortFactory(collection, comparator, mapper) {
        if (!comparator) {
            comparator = defaultComparator;
        }
        var isKeyedCollection = isKeyed(collection);
        var index = 0;
        var entries = collection.toSeq().map(function(v, k) {
            return [
                k,
                v,
                index++,
                mapper ? mapper(v, k, collection) : v
            ];
        }).valueSeq().toArray();
        entries.sort(function(a, b) {
            return comparator(a[3], b[3]) || a[2] - b[2];
        }).forEach(isKeyedCollection ? function(v, i) {
            entries[i].length = 2;
        } : function(v, i) {
            entries[i] = v[1];
        });
        return isKeyedCollection ? KeyedSeq(entries) : isIndexed(collection) ? IndexedSeq(entries) : SetSeq(entries);
    }
    function maxFactory(collection, comparator, mapper) {
        if (!comparator) {
            comparator = defaultComparator;
        }
        if (mapper) {
            var entry = collection.toSeq().map(function(v, k) {
                return [
                    v,
                    mapper(v, k, collection)
                ];
            }).reduce(function(a, b) {
                return maxCompare(comparator, a[1], b[1]) ? b : a;
            });
            return entry && entry[0];
        }
        return collection.reduce(function(a, b) {
            return maxCompare(comparator, a, b) ? b : a;
        });
    }
    function maxCompare(comparator, a, b) {
        var comp = comparator(b, a);
        // b is considered the new max if the comparator declares them equal, but
        // they are not equal and b is in fact a nullish value.
        return comp === 0 && b !== a && (b === undefined || b === null || b !== b) || comp > 0;
    }
    function zipWithFactory(keyIter, zipper, iters, zipAll) {
        var zipSequence = makeSequence(keyIter);
        var sizes = new ArraySeq(iters).map(function(i) {
            return i.size;
        });
        zipSequence.size = zipAll ? sizes.max() : sizes.min();
        // Note: this a generic base implementation of __iterate in terms of
        // __iterator which may be more generically useful in the future.
        zipSequence.__iterate = function(fn, reverse) {
            /* generic:
      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);
      var step;
      var iterations = 0;
      while (!(step = iterator.next()).done) {
        iterations++;
        if (fn(step.value[1], step.value[0], this) === false) {
          break;
        }
      }
      return iterations;
      */ // indexed:
            var iterator = this.__iterator(ITERATE_VALUES, reverse);
            var step;
            var iterations = 0;
            while(!(step = iterator.next()).done){
                if (fn(step.value, iterations++, this) === false) {
                    break;
                }
            }
            return iterations;
        };
        zipSequence.__iteratorUncached = function(type, reverse) {
            var iterators = iters.map(function(i) {
                return i = Collection(i), getIterator(reverse ? i.reverse() : i);
            });
            var iterations = 0;
            var isDone = false;
            return new Iterator(function() {
                var steps;
                if (!isDone) {
                    steps = iterators.map(function(i) {
                        return i.next();
                    });
                    isDone = zipAll ? steps.every(function(s) {
                        return s.done;
                    }) : steps.some(function(s) {
                        return s.done;
                    });
                }
                if (isDone) {
                    return iteratorDone();
                }
                return iteratorValue(type, iterations++, zipper.apply(null, steps.map(function(s) {
                    return s.value;
                })));
            });
        };
        return zipSequence;
    }
    // #pragma Helper Functions
    function reify(iter, seq) {
        return iter === seq ? iter : isSeq(iter) ? seq : iter.constructor(seq);
    }
    function validateEntry(entry) {
        if (entry !== Object(entry)) {
            throw new TypeError("Expected [K, V] tuple: " + entry);
        }
    }
    function collectionClass(collection) {
        return isKeyed(collection) ? KeyedCollection : isIndexed(collection) ? IndexedCollection : SetCollection;
    }
    function makeSequence(collection) {
        return Object.create((isKeyed(collection) ? KeyedSeq : isIndexed(collection) ? IndexedSeq : SetSeq).prototype);
    }
    function cacheResultThrough() {
        if (this._iter.cacheResult) {
            this._iter.cacheResult();
            this.size = this._iter.size;
            return this;
        }
        return Seq.prototype.cacheResult.call(this);
    }
    function defaultComparator(a, b) {
        if (a === undefined && b === undefined) {
            return 0;
        }
        if (a === undefined) {
            return 1;
        }
        if (b === undefined) {
            return -1;
        }
        return a > b ? 1 : a < b ? -1 : 0;
    }
    function arrCopy(arr, offset) {
        offset = offset || 0;
        var len = Math.max(0, arr.length - offset);
        var newArr = new Array(len);
        for(var ii = 0; ii < len; ii++){
            newArr[ii] = arr[ii + offset];
        }
        return newArr;
    }
    function invariant(condition, error) {
        if (!condition) {
            throw new Error(error);
        }
    }
    function assertNotInfinite(size) {
        invariant(size !== Infinity, "Cannot perform this action with an infinite size.");
    }
    function coerceKeyPath(keyPath) {
        if (isArrayLike(keyPath) && typeof keyPath !== "string") {
            return keyPath;
        }
        if (isOrdered(keyPath)) {
            return keyPath.toArray();
        }
        throw new TypeError("Invalid keyPath: expected Ordered Collection or Array: " + keyPath);
    }
    var toString = Object.prototype.toString;
    function isPlainObject(value) {
        // The base prototype's toString deals with Argument objects and native namespaces like Math
        if (!value || typeof value !== "object" || toString.call(value) !== "[object Object]") {
            return false;
        }
        var proto = Object.getPrototypeOf(value);
        if (proto === null) {
            return true;
        }
        // Iteratively going up the prototype chain is needed for cross-realm environments (differing contexts, iframes, etc)
        var parentProto = proto;
        var nextProto = Object.getPrototypeOf(proto);
        while(nextProto !== null){
            parentProto = nextProto;
            nextProto = Object.getPrototypeOf(parentProto);
        }
        return parentProto === proto;
    }
    /**
   * Returns true if the value is a potentially-persistent data structure, either
   * provided by Immutable.js or a plain Array or Object.
   */ function isDataStructure(value) {
        return typeof value === "object" && (isImmutable(value) || Array.isArray(value) || isPlainObject(value));
    }
    function quoteString(value) {
        try {
            return typeof value === "string" ? JSON.stringify(value) : String(value);
        } catch (_ignoreError) {
            return JSON.stringify(value);
        }
    }
    function has(collection, key) {
        return isImmutable(collection) ? collection.has(key) : isDataStructure(collection) && hasOwnProperty.call(collection, key);
    }
    function get(collection, key, notSetValue) {
        return isImmutable(collection) ? collection.get(key, notSetValue) : !has(collection, key) ? notSetValue : typeof collection.get === "function" ? collection.get(key) : collection[key];
    }
    function shallowCopy(from) {
        if (Array.isArray(from)) {
            return arrCopy(from);
        }
        var to = {};
        for(var key in from){
            if (hasOwnProperty.call(from, key)) {
                to[key] = from[key];
            }
        }
        return to;
    }
    function remove(collection, key) {
        if (!isDataStructure(collection)) {
            throw new TypeError("Cannot update non-data-structure value: " + collection);
        }
        if (isImmutable(collection)) {
            if (!collection.remove) {
                throw new TypeError("Cannot update immutable value without .remove() method: " + collection);
            }
            return collection.remove(key);
        }
        if (!hasOwnProperty.call(collection, key)) {
            return collection;
        }
        var collectionCopy = shallowCopy(collection);
        if (Array.isArray(collectionCopy)) {
            collectionCopy.splice(key, 1);
        } else {
            delete collectionCopy[key];
        }
        return collectionCopy;
    }
    function set(collection, key, value) {
        if (!isDataStructure(collection)) {
            throw new TypeError("Cannot update non-data-structure value: " + collection);
        }
        if (isImmutable(collection)) {
            if (!collection.set) {
                throw new TypeError("Cannot update immutable value without .set() method: " + collection);
            }
            return collection.set(key, value);
        }
        if (hasOwnProperty.call(collection, key) && value === collection[key]) {
            return collection;
        }
        var collectionCopy = shallowCopy(collection);
        collectionCopy[key] = value;
        return collectionCopy;
    }
    function updateIn$1(collection, keyPath, notSetValue, updater) {
        if (!updater) {
            updater = notSetValue;
            notSetValue = undefined;
        }
        var updatedValue = updateInDeeply(isImmutable(collection), collection, coerceKeyPath(keyPath), 0, notSetValue, updater);
        return updatedValue === NOT_SET ? notSetValue : updatedValue;
    }
    function updateInDeeply(inImmutable, existing, keyPath, i, notSetValue, updater) {
        var wasNotSet = existing === NOT_SET;
        if (i === keyPath.length) {
            var existingValue = wasNotSet ? notSetValue : existing;
            var newValue = updater(existingValue);
            return newValue === existingValue ? existing : newValue;
        }
        if (!wasNotSet && !isDataStructure(existing)) {
            throw new TypeError("Cannot update within non-data-structure value in path [" + keyPath.slice(0, i).map(quoteString) + "]: " + existing);
        }
        var key = keyPath[i];
        var nextExisting = wasNotSet ? NOT_SET : get(existing, key, NOT_SET);
        var nextUpdated = updateInDeeply(nextExisting === NOT_SET ? inImmutable : isImmutable(nextExisting), nextExisting, keyPath, i + 1, notSetValue, updater);
        return nextUpdated === nextExisting ? existing : nextUpdated === NOT_SET ? remove(existing, key) : set(wasNotSet ? inImmutable ? emptyMap() : {} : existing, key, nextUpdated);
    }
    function setIn$1(collection, keyPath, value) {
        return updateIn$1(collection, keyPath, NOT_SET, function() {
            return value;
        });
    }
    function setIn(keyPath, v) {
        return setIn$1(this, keyPath, v);
    }
    function removeIn(collection, keyPath) {
        return updateIn$1(collection, keyPath, function() {
            return NOT_SET;
        });
    }
    function deleteIn(keyPath) {
        return removeIn(this, keyPath);
    }
    function update$1(collection, key, notSetValue, updater) {
        return updateIn$1(collection, [
            key
        ], notSetValue, updater);
    }
    function update(key, notSetValue, updater) {
        return arguments.length === 1 ? key(this) : update$1(this, key, notSetValue, updater);
    }
    function updateIn(keyPath, notSetValue, updater) {
        return updateIn$1(this, keyPath, notSetValue, updater);
    }
    function merge$1() {
        var iters = [], len = arguments.length;
        while(len--)iters[len] = arguments[len];
        return mergeIntoKeyedWith(this, iters);
    }
    function mergeWith$1(merger) {
        var iters = [], len = arguments.length - 1;
        while(len-- > 0)iters[len] = arguments[len + 1];
        if (typeof merger !== "function") {
            throw new TypeError("Invalid merger function: " + merger);
        }
        return mergeIntoKeyedWith(this, iters, merger);
    }
    function mergeIntoKeyedWith(collection, collections, merger) {
        var iters = [];
        for(var ii = 0; ii < collections.length; ii++){
            var collection$1 = KeyedCollection(collections[ii]);
            if (collection$1.size !== 0) {
                iters.push(collection$1);
            }
        }
        if (iters.length === 0) {
            return collection;
        }
        if (collection.toSeq().size === 0 && !collection.__ownerID && iters.length === 1) {
            return collection.constructor(iters[0]);
        }
        return collection.withMutations(function(collection) {
            var mergeIntoCollection = merger ? function(value, key) {
                update$1(collection, key, NOT_SET, function(oldVal) {
                    return oldVal === NOT_SET ? value : merger(oldVal, value, key);
                });
            } : function(value, key) {
                collection.set(key, value);
            };
            for(var ii = 0; ii < iters.length; ii++){
                iters[ii].forEach(mergeIntoCollection);
            }
        });
    }
    function merge(collection) {
        var sources = [], len = arguments.length - 1;
        while(len-- > 0)sources[len] = arguments[len + 1];
        return mergeWithSources(collection, sources);
    }
    function mergeWith(merger, collection) {
        var sources = [], len = arguments.length - 2;
        while(len-- > 0)sources[len] = arguments[len + 2];
        return mergeWithSources(collection, sources, merger);
    }
    function mergeDeep$1(collection) {
        var sources = [], len = arguments.length - 1;
        while(len-- > 0)sources[len] = arguments[len + 1];
        return mergeDeepWithSources(collection, sources);
    }
    function mergeDeepWith$1(merger, collection) {
        var sources = [], len = arguments.length - 2;
        while(len-- > 0)sources[len] = arguments[len + 2];
        return mergeDeepWithSources(collection, sources, merger);
    }
    function mergeDeepWithSources(collection, sources, merger) {
        return mergeWithSources(collection, sources, deepMergerWith(merger));
    }
    function mergeWithSources(collection, sources, merger) {
        if (!isDataStructure(collection)) {
            throw new TypeError("Cannot merge into non-data-structure value: " + collection);
        }
        if (isImmutable(collection)) {
            return typeof merger === "function" && collection.mergeWith ? collection.mergeWith.apply(collection, [
                merger
            ].concat(sources)) : collection.merge ? collection.merge.apply(collection, sources) : collection.concat.apply(collection, sources);
        }
        var isArray = Array.isArray(collection);
        var merged = collection;
        var Collection = isArray ? IndexedCollection : KeyedCollection;
        var mergeItem = isArray ? function(value) {
            // Copy on write
            if (merged === collection) {
                merged = shallowCopy(merged);
            }
            merged.push(value);
        } : function(value, key) {
            var hasVal = hasOwnProperty.call(merged, key);
            var nextVal = hasVal && merger ? merger(merged[key], value, key) : value;
            if (!hasVal || nextVal !== merged[key]) {
                // Copy on write
                if (merged === collection) {
                    merged = shallowCopy(merged);
                }
                merged[key] = nextVal;
            }
        };
        for(var i = 0; i < sources.length; i++){
            Collection(sources[i]).forEach(mergeItem);
        }
        return merged;
    }
    function deepMergerWith(merger) {
        function deepMerger(oldValue, newValue, key) {
            return isDataStructure(oldValue) && isDataStructure(newValue) && areMergeable(oldValue, newValue) ? mergeWithSources(oldValue, [
                newValue
            ], deepMerger) : merger ? merger(oldValue, newValue, key) : newValue;
        }
        return deepMerger;
    }
    /**
   * It's unclear what the desired behavior is for merging two collections that
   * fall into separate categories between keyed, indexed, or set-like, so we only
   * consider them mergeable if they fall into the same category.
   */ function areMergeable(oldDataStructure, newDataStructure) {
        var oldSeq = Seq(oldDataStructure);
        var newSeq = Seq(newDataStructure);
        // This logic assumes that a sequence can only fall into one of the three
        // categories mentioned above (since there's no `isSetLike()` method).
        return isIndexed(oldSeq) === isIndexed(newSeq) && isKeyed(oldSeq) === isKeyed(newSeq);
    }
    function mergeDeep() {
        var iters = [], len = arguments.length;
        while(len--)iters[len] = arguments[len];
        return mergeDeepWithSources(this, iters);
    }
    function mergeDeepWith(merger) {
        var iters = [], len = arguments.length - 1;
        while(len-- > 0)iters[len] = arguments[len + 1];
        return mergeDeepWithSources(this, iters, merger);
    }
    function mergeIn(keyPath) {
        var iters = [], len = arguments.length - 1;
        while(len-- > 0)iters[len] = arguments[len + 1];
        return updateIn$1(this, keyPath, emptyMap(), function(m) {
            return mergeWithSources(m, iters);
        });
    }
    function mergeDeepIn(keyPath) {
        var iters = [], len = arguments.length - 1;
        while(len-- > 0)iters[len] = arguments[len + 1];
        return updateIn$1(this, keyPath, emptyMap(), function(m) {
            return mergeDeepWithSources(m, iters);
        });
    }
    function withMutations(fn) {
        var mutable = this.asMutable();
        fn(mutable);
        return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
    }
    function asMutable() {
        return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
    }
    function asImmutable() {
        return this.__ensureOwner();
    }
    function wasAltered() {
        return this.__altered;
    }
    var Map = /*@__PURE__*/ function(KeyedCollection) {
        function Map(value) {
            return value === undefined || value === null ? emptyMap() : isMap(value) && !isOrdered(value) ? value : emptyMap().withMutations(function(map) {
                var iter = KeyedCollection(value);
                assertNotInfinite(iter.size);
                iter.forEach(function(v, k) {
                    return map.set(k, v);
                });
            });
        }
        if (KeyedCollection) Map.__proto__ = KeyedCollection;
        Map.prototype = Object.create(KeyedCollection && KeyedCollection.prototype);
        Map.prototype.constructor = Map;
        Map.of = function of() {
            var keyValues = [], len = arguments.length;
            while(len--)keyValues[len] = arguments[len];
            return emptyMap().withMutations(function(map) {
                for(var i = 0; i < keyValues.length; i += 2){
                    if (i + 1 >= keyValues.length) {
                        throw new Error("Missing value for key: " + keyValues[i]);
                    }
                    map.set(keyValues[i], keyValues[i + 1]);
                }
            });
        };
        Map.prototype.toString = function toString() {
            return this.__toString("Map {", "}");
        };
        // @pragma Access
        Map.prototype.get = function get(k, notSetValue) {
            return this._root ? this._root.get(0, undefined, k, notSetValue) : notSetValue;
        };
        // @pragma Modification
        Map.prototype.set = function set(k, v) {
            return updateMap(this, k, v);
        };
        Map.prototype.remove = function remove(k) {
            return updateMap(this, k, NOT_SET);
        };
        Map.prototype.deleteAll = function deleteAll(keys) {
            var collection = Collection(keys);
            if (collection.size === 0) {
                return this;
            }
            return this.withMutations(function(map) {
                collection.forEach(function(key) {
                    return map.remove(key);
                });
            });
        };
        Map.prototype.clear = function clear() {
            if (this.size === 0) {
                return this;
            }
            if (this.__ownerID) {
                this.size = 0;
                this._root = null;
                this.__hash = undefined;
                this.__altered = true;
                return this;
            }
            return emptyMap();
        };
        // @pragma Composition
        Map.prototype.sort = function sort(comparator) {
            // Late binding
            return OrderedMap(sortFactory(this, comparator));
        };
        Map.prototype.sortBy = function sortBy(mapper, comparator) {
            // Late binding
            return OrderedMap(sortFactory(this, comparator, mapper));
        };
        Map.prototype.map = function map(mapper, context) {
            var this$1$1 = this;
            return this.withMutations(function(map) {
                map.forEach(function(value, key) {
                    map.set(key, mapper.call(context, value, key, this$1$1));
                });
            });
        };
        // @pragma Mutability
        Map.prototype.__iterator = function __iterator(type, reverse) {
            return new MapIterator(this, type, reverse);
        };
        Map.prototype.__iterate = function __iterate(fn, reverse) {
            var this$1$1 = this;
            var iterations = 0;
            this._root && this._root.iterate(function(entry) {
                iterations++;
                return fn(entry[1], entry[0], this$1$1);
            }, reverse);
            return iterations;
        };
        Map.prototype.__ensureOwner = function __ensureOwner(ownerID) {
            if (ownerID === this.__ownerID) {
                return this;
            }
            if (!ownerID) {
                if (this.size === 0) {
                    return emptyMap();
                }
                this.__ownerID = ownerID;
                this.__altered = false;
                return this;
            }
            return makeMap(this.size, this._root, ownerID, this.__hash);
        };
        return Map;
    }(KeyedCollection);
    Map.isMap = isMap;
    var MapPrototype = Map.prototype;
    MapPrototype[IS_MAP_SYMBOL] = true;
    MapPrototype[DELETE] = MapPrototype.remove;
    MapPrototype.removeAll = MapPrototype.deleteAll;
    MapPrototype.setIn = setIn;
    MapPrototype.removeIn = MapPrototype.deleteIn = deleteIn;
    MapPrototype.update = update;
    MapPrototype.updateIn = updateIn;
    MapPrototype.merge = MapPrototype.concat = merge$1;
    MapPrototype.mergeWith = mergeWith$1;
    MapPrototype.mergeDeep = mergeDeep;
    MapPrototype.mergeDeepWith = mergeDeepWith;
    MapPrototype.mergeIn = mergeIn;
    MapPrototype.mergeDeepIn = mergeDeepIn;
    MapPrototype.withMutations = withMutations;
    MapPrototype.wasAltered = wasAltered;
    MapPrototype.asImmutable = asImmutable;
    MapPrototype["@@transducer/init"] = MapPrototype.asMutable = asMutable;
    MapPrototype["@@transducer/step"] = function(result, arr) {
        return result.set(arr[0], arr[1]);
    };
    MapPrototype["@@transducer/result"] = function(obj) {
        return obj.asImmutable();
    };
    // #pragma Trie Nodes
    var ArrayMapNode = function ArrayMapNode(ownerID, entries) {
        this.ownerID = ownerID;
        this.entries = entries;
    };
    ArrayMapNode.prototype.get = function get(shift, keyHash, key, notSetValue) {
        var entries = this.entries;
        for(var ii = 0, len = entries.length; ii < len; ii++){
            if (is(key, entries[ii][0])) {
                return entries[ii][1];
            }
        }
        return notSetValue;
    };
    ArrayMapNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
        var removed = value === NOT_SET;
        var entries = this.entries;
        var idx = 0;
        var len = entries.length;
        for(; idx < len; idx++){
            if (is(key, entries[idx][0])) {
                break;
            }
        }
        var exists = idx < len;
        if (exists ? entries[idx][1] === value : removed) {
            return this;
        }
        SetRef(didAlter);
        (removed || !exists) && SetRef(didChangeSize);
        if (removed && entries.length === 1) {
            return; // undefined
        }
        if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {
            return createNodes(ownerID, entries, key, value);
        }
        var isEditable = ownerID && ownerID === this.ownerID;
        var newEntries = isEditable ? entries : arrCopy(entries);
        if (exists) {
            if (removed) {
                idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
            } else {
                newEntries[idx] = [
                    key,
                    value
                ];
            }
        } else {
            newEntries.push([
                key,
                value
            ]);
        }
        if (isEditable) {
            this.entries = newEntries;
            return this;
        }
        return new ArrayMapNode(ownerID, newEntries);
    };
    var BitmapIndexedNode = function BitmapIndexedNode(ownerID, bitmap, nodes) {
        this.ownerID = ownerID;
        this.bitmap = bitmap;
        this.nodes = nodes;
    };
    BitmapIndexedNode.prototype.get = function get(shift, keyHash, key, notSetValue) {
        if (keyHash === undefined) {
            keyHash = hash(key);
        }
        var bit = 1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK);
        var bitmap = this.bitmap;
        return (bitmap & bit) === 0 ? notSetValue : this.nodes[popCount(bitmap & bit - 1)].get(shift + SHIFT, keyHash, key, notSetValue);
    };
    BitmapIndexedNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
        if (keyHash === undefined) {
            keyHash = hash(key);
        }
        var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
        var bit = 1 << keyHashFrag;
        var bitmap = this.bitmap;
        var exists = (bitmap & bit) !== 0;
        if (!exists && value === NOT_SET) {
            return this;
        }
        var idx = popCount(bitmap & bit - 1);
        var nodes = this.nodes;
        var node = exists ? nodes[idx] : undefined;
        var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
        if (newNode === node) {
            return this;
        }
        if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
            return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
        }
        if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
            return nodes[idx ^ 1];
        }
        if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
            return newNode;
        }
        var isEditable = ownerID && ownerID === this.ownerID;
        var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
        var newNodes = exists ? newNode ? setAt(nodes, idx, newNode, isEditable) : spliceOut(nodes, idx, isEditable) : spliceIn(nodes, idx, newNode, isEditable);
        if (isEditable) {
            this.bitmap = newBitmap;
            this.nodes = newNodes;
            return this;
        }
        return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
    };
    var HashArrayMapNode = function HashArrayMapNode(ownerID, count, nodes) {
        this.ownerID = ownerID;
        this.count = count;
        this.nodes = nodes;
    };
    HashArrayMapNode.prototype.get = function get(shift, keyHash, key, notSetValue) {
        if (keyHash === undefined) {
            keyHash = hash(key);
        }
        var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
        var node = this.nodes[idx];
        return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;
    };
    HashArrayMapNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
        if (keyHash === undefined) {
            keyHash = hash(key);
        }
        var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
        var removed = value === NOT_SET;
        var nodes = this.nodes;
        var node = nodes[idx];
        if (removed && !node) {
            return this;
        }
        var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
        if (newNode === node) {
            return this;
        }
        var newCount = this.count;
        if (!node) {
            newCount++;
        } else if (!newNode) {
            newCount--;
            if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
                return packNodes(ownerID, nodes, newCount, idx);
            }
        }
        var isEditable = ownerID && ownerID === this.ownerID;
        var newNodes = setAt(nodes, idx, newNode, isEditable);
        if (isEditable) {
            this.count = newCount;
            this.nodes = newNodes;
            return this;
        }
        return new HashArrayMapNode(ownerID, newCount, newNodes);
    };
    var HashCollisionNode = function HashCollisionNode(ownerID, keyHash, entries) {
        this.ownerID = ownerID;
        this.keyHash = keyHash;
        this.entries = entries;
    };
    HashCollisionNode.prototype.get = function get(shift, keyHash, key, notSetValue) {
        var entries = this.entries;
        for(var ii = 0, len = entries.length; ii < len; ii++){
            if (is(key, entries[ii][0])) {
                return entries[ii][1];
            }
        }
        return notSetValue;
    };
    HashCollisionNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
        if (keyHash === undefined) {
            keyHash = hash(key);
        }
        var removed = value === NOT_SET;
        if (keyHash !== this.keyHash) {
            if (removed) {
                return this;
            }
            SetRef(didAlter);
            SetRef(didChangeSize);
            return mergeIntoNode(this, ownerID, shift, keyHash, [
                key,
                value
            ]);
        }
        var entries = this.entries;
        var idx = 0;
        var len = entries.length;
        for(; idx < len; idx++){
            if (is(key, entries[idx][0])) {
                break;
            }
        }
        var exists = idx < len;
        if (exists ? entries[idx][1] === value : removed) {
            return this;
        }
        SetRef(didAlter);
        (removed || !exists) && SetRef(didChangeSize);
        if (removed && len === 2) {
            return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);
        }
        var isEditable = ownerID && ownerID === this.ownerID;
        var newEntries = isEditable ? entries : arrCopy(entries);
        if (exists) {
            if (removed) {
                idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
            } else {
                newEntries[idx] = [
                    key,
                    value
                ];
            }
        } else {
            newEntries.push([
                key,
                value
            ]);
        }
        if (isEditable) {
            this.entries = newEntries;
            return this;
        }
        return new HashCollisionNode(ownerID, this.keyHash, newEntries);
    };
    var ValueNode = function ValueNode(ownerID, keyHash, entry) {
        this.ownerID = ownerID;
        this.keyHash = keyHash;
        this.entry = entry;
    };
    ValueNode.prototype.get = function get(shift, keyHash, key, notSetValue) {
        return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
    };
    ValueNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
        var removed = value === NOT_SET;
        var keyMatch = is(key, this.entry[0]);
        if (keyMatch ? value === this.entry[1] : removed) {
            return this;
        }
        SetRef(didAlter);
        if (removed) {
            SetRef(didChangeSize);
            return; // undefined
        }
        if (keyMatch) {
            if (ownerID && ownerID === this.ownerID) {
                this.entry[1] = value;
                return this;
            }
            return new ValueNode(ownerID, this.keyHash, [
                key,
                value
            ]);
        }
        SetRef(didChangeSize);
        return mergeIntoNode(this, ownerID, shift, hash(key), [
            key,
            value
        ]);
    };
    // #pragma Iterators
    ArrayMapNode.prototype.iterate = HashCollisionNode.prototype.iterate = function(fn, reverse) {
        var entries = this.entries;
        for(var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++){
            if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {
                return false;
            }
        }
    };
    BitmapIndexedNode.prototype.iterate = HashArrayMapNode.prototype.iterate = function(fn, reverse) {
        var nodes = this.nodes;
        for(var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++){
            var node = nodes[reverse ? maxIndex - ii : ii];
            if (node && node.iterate(fn, reverse) === false) {
                return false;
            }
        }
    };
    // eslint-disable-next-line no-unused-vars
    ValueNode.prototype.iterate = function(fn, reverse) {
        return fn(this.entry);
    };
    var MapIterator = /*@__PURE__*/ function(Iterator) {
        function MapIterator(map, type, reverse) {
            this._type = type;
            this._reverse = reverse;
            this._stack = map._root && mapIteratorFrame(map._root);
        }
        if (Iterator) MapIterator.__proto__ = Iterator;
        MapIterator.prototype = Object.create(Iterator && Iterator.prototype);
        MapIterator.prototype.constructor = MapIterator;
        MapIterator.prototype.next = function next() {
            var type = this._type;
            var stack = this._stack;
            while(stack){
                var node = stack.node;
                var index = stack.index++;
                var maxIndex = void 0;
                if (node.entry) {
                    if (index === 0) {
                        return mapIteratorValue(type, node.entry);
                    }
                } else if (node.entries) {
                    maxIndex = node.entries.length - 1;
                    if (index <= maxIndex) {
                        return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);
                    }
                } else {
                    maxIndex = node.nodes.length - 1;
                    if (index <= maxIndex) {
                        var subNode = node.nodes[this._reverse ? maxIndex - index : index];
                        if (subNode) {
                            if (subNode.entry) {
                                return mapIteratorValue(type, subNode.entry);
                            }
                            stack = this._stack = mapIteratorFrame(subNode, stack);
                        }
                        continue;
                    }
                }
                stack = this._stack = this._stack.__prev;
            }
            return iteratorDone();
        };
        return MapIterator;
    }(Iterator);
    function mapIteratorValue(type, entry) {
        return iteratorValue(type, entry[0], entry[1]);
    }
    function mapIteratorFrame(node, prev) {
        return {
            node: node,
            index: 0,
            __prev: prev
        };
    }
    function makeMap(size, root, ownerID, hash) {
        var map = Object.create(MapPrototype);
        map.size = size;
        map._root = root;
        map.__ownerID = ownerID;
        map.__hash = hash;
        map.__altered = false;
        return map;
    }
    var EMPTY_MAP;
    function emptyMap() {
        return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
    }
    function updateMap(map, k, v) {
        var newRoot;
        var newSize;
        if (!map._root) {
            if (v === NOT_SET) {
                return map;
            }
            newSize = 1;
            newRoot = new ArrayMapNode(map.__ownerID, [
                [
                    k,
                    v
                ]
            ]);
        } else {
            var didChangeSize = MakeRef();
            var didAlter = MakeRef();
            newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);
            if (!didAlter.value) {
                return map;
            }
            newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);
        }
        if (map.__ownerID) {
            map.size = newSize;
            map._root = newRoot;
            map.__hash = undefined;
            map.__altered = true;
            return map;
        }
        return newRoot ? makeMap(newSize, newRoot) : emptyMap();
    }
    function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
        if (!node) {
            if (value === NOT_SET) {
                return node;
            }
            SetRef(didAlter);
            SetRef(didChangeSize);
            return new ValueNode(ownerID, keyHash, [
                key,
                value
            ]);
        }
        return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);
    }
    function isLeafNode(node) {
        return node.constructor === ValueNode || node.constructor === HashCollisionNode;
    }
    function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
        if (node.keyHash === keyHash) {
            return new HashCollisionNode(ownerID, keyHash, [
                node.entry,
                entry
            ]);
        }
        var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
        var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
        var newNode;
        var nodes = idx1 === idx2 ? [
            mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)
        ] : (newNode = new ValueNode(ownerID, keyHash, entry), idx1 < idx2 ? [
            node,
            newNode
        ] : [
            newNode,
            node
        ]);
        return new BitmapIndexedNode(ownerID, 1 << idx1 | 1 << idx2, nodes);
    }
    function createNodes(ownerID, entries, key, value) {
        if (!ownerID) {
            ownerID = new OwnerID();
        }
        var node = new ValueNode(ownerID, hash(key), [
            key,
            value
        ]);
        for(var ii = 0; ii < entries.length; ii++){
            var entry = entries[ii];
            node = node.update(ownerID, 0, undefined, entry[0], entry[1]);
        }
        return node;
    }
    function packNodes(ownerID, nodes, count, excluding) {
        var bitmap = 0;
        var packedII = 0;
        var packedNodes = new Array(count);
        for(var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1){
            var node = nodes[ii];
            if (node !== undefined && ii !== excluding) {
                bitmap |= bit;
                packedNodes[packedII++] = node;
            }
        }
        return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
    }
    function expandNodes(ownerID, nodes, bitmap, including, node) {
        var count = 0;
        var expandedNodes = new Array(SIZE);
        for(var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1){
            expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;
        }
        expandedNodes[including] = node;
        return new HashArrayMapNode(ownerID, count + 1, expandedNodes);
    }
    function popCount(x) {
        x -= x >> 1 & 0x55555555;
        x = (x & 0x33333333) + (x >> 2 & 0x33333333);
        x = x + (x >> 4) & 0x0f0f0f0f;
        x += x >> 8;
        x += x >> 16;
        return x & 0x7f;
    }
    function setAt(array, idx, val, canEdit) {
        var newArray = canEdit ? array : arrCopy(array);
        newArray[idx] = val;
        return newArray;
    }
    function spliceIn(array, idx, val, canEdit) {
        var newLen = array.length + 1;
        if (canEdit && idx + 1 === newLen) {
            array[idx] = val;
            return array;
        }
        var newArray = new Array(newLen);
        var after = 0;
        for(var ii = 0; ii < newLen; ii++){
            if (ii === idx) {
                newArray[ii] = val;
                after = -1;
            } else {
                newArray[ii] = array[ii + after];
            }
        }
        return newArray;
    }
    function spliceOut(array, idx, canEdit) {
        var newLen = array.length - 1;
        if (canEdit && idx === newLen) {
            array.pop();
            return array;
        }
        var newArray = new Array(newLen);
        var after = 0;
        for(var ii = 0; ii < newLen; ii++){
            if (ii === idx) {
                after = 1;
            }
            newArray[ii] = array[ii + after];
        }
        return newArray;
    }
    var MAX_ARRAY_MAP_SIZE = SIZE / 4;
    var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
    var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;
    var IS_LIST_SYMBOL = "@@__IMMUTABLE_LIST__@@";
    function isList(maybeList) {
        return Boolean(maybeList && maybeList[IS_LIST_SYMBOL]);
    }
    var List = /*@__PURE__*/ function(IndexedCollection) {
        function List(value) {
            var empty = emptyList();
            if (value === undefined || value === null) {
                return empty;
            }
            if (isList(value)) {
                return value;
            }
            var iter = IndexedCollection(value);
            var size = iter.size;
            if (size === 0) {
                return empty;
            }
            assertNotInfinite(size);
            if (size > 0 && size < SIZE) {
                return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
            }
            return empty.withMutations(function(list) {
                list.setSize(size);
                iter.forEach(function(v, i) {
                    return list.set(i, v);
                });
            });
        }
        if (IndexedCollection) List.__proto__ = IndexedCollection;
        List.prototype = Object.create(IndexedCollection && IndexedCollection.prototype);
        List.prototype.constructor = List;
        List.of = function of() {
            return this(arguments);
        };
        List.prototype.toString = function toString() {
            return this.__toString("List [", "]");
        };
        // @pragma Access
        List.prototype.get = function get(index, notSetValue) {
            index = wrapIndex(this, index);
            if (index >= 0 && index < this.size) {
                index += this._origin;
                var node = listNodeFor(this, index);
                return node && node.array[index & MASK];
            }
            return notSetValue;
        };
        // @pragma Modification
        List.prototype.set = function set(index, value) {
            return updateList(this, index, value);
        };
        List.prototype.remove = function remove(index) {
            return !this.has(index) ? this : index === 0 ? this.shift() : index === this.size - 1 ? this.pop() : this.splice(index, 1);
        };
        List.prototype.insert = function insert(index, value) {
            return this.splice(index, 0, value);
        };
        List.prototype.clear = function clear() {
            if (this.size === 0) {
                return this;
            }
            if (this.__ownerID) {
                this.size = this._origin = this._capacity = 0;
                this._level = SHIFT;
                this._root = this._tail = this.__hash = undefined;
                this.__altered = true;
                return this;
            }
            return emptyList();
        };
        List.prototype.push = function push() {
            var values = arguments;
            var oldSize = this.size;
            return this.withMutations(function(list) {
                setListBounds(list, 0, oldSize + values.length);
                for(var ii = 0; ii < values.length; ii++){
                    list.set(oldSize + ii, values[ii]);
                }
            });
        };
        List.prototype.pop = function pop() {
            return setListBounds(this, 0, -1);
        };
        List.prototype.unshift = function unshift() {
            var values = arguments;
            return this.withMutations(function(list) {
                setListBounds(list, -values.length);
                for(var ii = 0; ii < values.length; ii++){
                    list.set(ii, values[ii]);
                }
            });
        };
        List.prototype.shift = function shift() {
            return setListBounds(this, 1);
        };
        // @pragma Composition
        List.prototype.concat = function concat() {
            var arguments$1 = arguments;
            var seqs = [];
            for(var i = 0; i < arguments.length; i++){
                var argument = arguments$1[i];
                var seq = IndexedCollection(typeof argument !== "string" && hasIterator(argument) ? argument : [
                    argument
                ]);
                if (seq.size !== 0) {
                    seqs.push(seq);
                }
            }
            if (seqs.length === 0) {
                return this;
            }
            if (this.size === 0 && !this.__ownerID && seqs.length === 1) {
                return this.constructor(seqs[0]);
            }
            return this.withMutations(function(list) {
                seqs.forEach(function(seq) {
                    return seq.forEach(function(value) {
                        return list.push(value);
                    });
                });
            });
        };
        List.prototype.setSize = function setSize(size) {
            return setListBounds(this, 0, size);
        };
        List.prototype.map = function map(mapper, context) {
            var this$1$1 = this;
            return this.withMutations(function(list) {
                for(var i = 0; i < this$1$1.size; i++){
                    list.set(i, mapper.call(context, list.get(i), i, this$1$1));
                }
            });
        };
        // @pragma Iteration
        List.prototype.slice = function slice(begin, end) {
            var size = this.size;
            if (wholeSlice(begin, end, size)) {
                return this;
            }
            return setListBounds(this, resolveBegin(begin, size), resolveEnd(end, size));
        };
        List.prototype.__iterator = function __iterator(type, reverse) {
            var index = reverse ? this.size : 0;
            var values = iterateList(this, reverse);
            return new Iterator(function() {
                var value = values();
                return value === DONE ? iteratorDone() : iteratorValue(type, reverse ? --index : index++, value);
            });
        };
        List.prototype.__iterate = function __iterate(fn, reverse) {
            var index = reverse ? this.size : 0;
            var values = iterateList(this, reverse);
            var value;
            while((value = values()) !== DONE){
                if (fn(value, reverse ? --index : index++, this) === false) {
                    break;
                }
            }
            return index;
        };
        List.prototype.__ensureOwner = function __ensureOwner(ownerID) {
            if (ownerID === this.__ownerID) {
                return this;
            }
            if (!ownerID) {
                if (this.size === 0) {
                    return emptyList();
                }
                this.__ownerID = ownerID;
                this.__altered = false;
                return this;
            }
            return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);
        };
        return List;
    }(IndexedCollection);
    List.isList = isList;
    var ListPrototype = List.prototype;
    ListPrototype[IS_LIST_SYMBOL] = true;
    ListPrototype[DELETE] = ListPrototype.remove;
    ListPrototype.merge = ListPrototype.concat;
    ListPrototype.setIn = setIn;
    ListPrototype.deleteIn = ListPrototype.removeIn = deleteIn;
    ListPrototype.update = update;
    ListPrototype.updateIn = updateIn;
    ListPrototype.mergeIn = mergeIn;
    ListPrototype.mergeDeepIn = mergeDeepIn;
    ListPrototype.withMutations = withMutations;
    ListPrototype.wasAltered = wasAltered;
    ListPrototype.asImmutable = asImmutable;
    ListPrototype["@@transducer/init"] = ListPrototype.asMutable = asMutable;
    ListPrototype["@@transducer/step"] = function(result, arr) {
        return result.push(arr);
    };
    ListPrototype["@@transducer/result"] = function(obj) {
        return obj.asImmutable();
    };
    var VNode = function VNode(array, ownerID) {
        this.array = array;
        this.ownerID = ownerID;
    };
    // TODO: seems like these methods are very similar
    VNode.prototype.removeBefore = function removeBefore(ownerID, level, index) {
        if (index === level ? 1 << level : this.array.length === 0) {
            return this;
        }
        var originIndex = index >>> level & MASK;
        if (originIndex >= this.array.length) {
            return new VNode([], ownerID);
        }
        var removingFirst = originIndex === 0;
        var newChild;
        if (level > 0) {
            var oldChild = this.array[originIndex];
            newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);
            if (newChild === oldChild && removingFirst) {
                return this;
            }
        }
        if (removingFirst && !newChild) {
            return this;
        }
        var editable = editableVNode(this, ownerID);
        if (!removingFirst) {
            for(var ii = 0; ii < originIndex; ii++){
                editable.array[ii] = undefined;
            }
        }
        if (newChild) {
            editable.array[originIndex] = newChild;
        }
        return editable;
    };
    VNode.prototype.removeAfter = function removeAfter(ownerID, level, index) {
        if (index === (level ? 1 << level : 0) || this.array.length === 0) {
            return this;
        }
        var sizeIndex = index - 1 >>> level & MASK;
        if (sizeIndex >= this.array.length) {
            return this;
        }
        var newChild;
        if (level > 0) {
            var oldChild = this.array[sizeIndex];
            newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);
            if (newChild === oldChild && sizeIndex === this.array.length - 1) {
                return this;
            }
        }
        var editable = editableVNode(this, ownerID);
        editable.array.splice(sizeIndex + 1);
        if (newChild) {
            editable.array[sizeIndex] = newChild;
        }
        return editable;
    };
    var DONE = {};
    function iterateList(list, reverse) {
        var left = list._origin;
        var right = list._capacity;
        var tailPos = getTailOffset(right);
        var tail = list._tail;
        return iterateNodeOrLeaf(list._root, list._level, 0);
        function iterateNodeOrLeaf(node, level, offset) {
            return level === 0 ? iterateLeaf(node, offset) : iterateNode(node, level, offset);
        }
        function iterateLeaf(node, offset) {
            var array = offset === tailPos ? tail && tail.array : node && node.array;
            var from = offset > left ? 0 : left - offset;
            var to = right - offset;
            if (to > SIZE) {
                to = SIZE;
            }
            return function() {
                if (from === to) {
                    return DONE;
                }
                var idx = reverse ? --to : from++;
                return array && array[idx];
            };
        }
        function iterateNode(node, level, offset) {
            var values;
            var array = node && node.array;
            var from = offset > left ? 0 : left - offset >> level;
            var to = (right - offset >> level) + 1;
            if (to > SIZE) {
                to = SIZE;
            }
            return function() {
                while(true){
                    if (values) {
                        var value = values();
                        if (value !== DONE) {
                            return value;
                        }
                        values = null;
                    }
                    if (from === to) {
                        return DONE;
                    }
                    var idx = reverse ? --to : from++;
                    values = iterateNodeOrLeaf(array && array[idx], level - SHIFT, offset + (idx << level));
                }
            };
        }
    }
    function makeList(origin, capacity, level, root, tail, ownerID, hash) {
        var list = Object.create(ListPrototype);
        list.size = capacity - origin;
        list._origin = origin;
        list._capacity = capacity;
        list._level = level;
        list._root = root;
        list._tail = tail;
        list.__ownerID = ownerID;
        list.__hash = hash;
        list.__altered = false;
        return list;
    }
    var EMPTY_LIST;
    function emptyList() {
        return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
    }
    function updateList(list, index, value) {
        index = wrapIndex(list, index);
        if (index !== index) {
            return list;
        }
        if (index >= list.size || index < 0) {
            return list.withMutations(function(list) {
                index < 0 ? setListBounds(list, index).set(0, value) : setListBounds(list, 0, index + 1).set(index, value);
            });
        }
        index += list._origin;
        var newTail = list._tail;
        var newRoot = list._root;
        var didAlter = MakeRef();
        if (index >= getTailOffset(list._capacity)) {
            newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);
        } else {
            newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);
        }
        if (!didAlter.value) {
            return list;
        }
        if (list.__ownerID) {
            list._root = newRoot;
            list._tail = newTail;
            list.__hash = undefined;
            list.__altered = true;
            return list;
        }
        return makeList(list._origin, list._capacity, list._level, newRoot, newTail);
    }
    function updateVNode(node, ownerID, level, index, value, didAlter) {
        var idx = index >>> level & MASK;
        var nodeHas = node && idx < node.array.length;
        if (!nodeHas && value === undefined) {
            return node;
        }
        var newNode;
        if (level > 0) {
            var lowerNode = node && node.array[idx];
            var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);
            if (newLowerNode === lowerNode) {
                return node;
            }
            newNode = editableVNode(node, ownerID);
            newNode.array[idx] = newLowerNode;
            return newNode;
        }
        if (nodeHas && node.array[idx] === value) {
            return node;
        }
        if (didAlter) {
            SetRef(didAlter);
        }
        newNode = editableVNode(node, ownerID);
        if (value === undefined && idx === newNode.array.length - 1) {
            newNode.array.pop();
        } else {
            newNode.array[idx] = value;
        }
        return newNode;
    }
    function editableVNode(node, ownerID) {
        if (ownerID && node && ownerID === node.ownerID) {
            return node;
        }
        return new VNode(node ? node.array.slice() : [], ownerID);
    }
    function listNodeFor(list, rawIndex) {
        if (rawIndex >= getTailOffset(list._capacity)) {
            return list._tail;
        }
        if (rawIndex < 1 << list._level + SHIFT) {
            var node = list._root;
            var level = list._level;
            while(node && level > 0){
                node = node.array[rawIndex >>> level & MASK];
                level -= SHIFT;
            }
            return node;
        }
    }
    function setListBounds(list, begin, end) {
        // Sanitize begin & end using this shorthand for ToInt32(argument)
        // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
        if (begin !== undefined) {
            begin |= 0;
        }
        if (end !== undefined) {
            end |= 0;
        }
        var owner = list.__ownerID || new OwnerID();
        var oldOrigin = list._origin;
        var oldCapacity = list._capacity;
        var newOrigin = oldOrigin + begin;
        var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;
        if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
            return list;
        }
        // If it's going to end after it starts, it's empty.
        if (newOrigin >= newCapacity) {
            return list.clear();
        }
        var newLevel = list._level;
        var newRoot = list._root;
        // New origin might need creating a higher root.
        var offsetShift = 0;
        while(newOrigin + offsetShift < 0){
            newRoot = new VNode(newRoot && newRoot.array.length ? [
                undefined,
                newRoot
            ] : [], owner);
            newLevel += SHIFT;
            offsetShift += 1 << newLevel;
        }
        if (offsetShift) {
            newOrigin += offsetShift;
            oldOrigin += offsetShift;
            newCapacity += offsetShift;
            oldCapacity += offsetShift;
        }
        var oldTailOffset = getTailOffset(oldCapacity);
        var newTailOffset = getTailOffset(newCapacity);
        // New size might need creating a higher root.
        while(newTailOffset >= 1 << newLevel + SHIFT){
            newRoot = new VNode(newRoot && newRoot.array.length ? [
                newRoot
            ] : [], owner);
            newLevel += SHIFT;
        }
        // Locate or create the new tail.
        var oldTail = list._tail;
        var newTail = newTailOffset < oldTailOffset ? listNodeFor(list, newCapacity - 1) : newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;
        // Merge Tail into tree.
        if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {
            newRoot = editableVNode(newRoot, owner);
            var node = newRoot;
            for(var level = newLevel; level > SHIFT; level -= SHIFT){
                var idx = oldTailOffset >>> level & MASK;
                node = node.array[idx] = editableVNode(node.array[idx], owner);
            }
            node.array[oldTailOffset >>> SHIFT & MASK] = oldTail;
        }
        // If the size has been reduced, there's a chance the tail needs to be trimmed.
        if (newCapacity < oldCapacity) {
            newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
        }
        // If the new origin is within the tail, then we do not need a root.
        if (newOrigin >= newTailOffset) {
            newOrigin -= newTailOffset;
            newCapacity -= newTailOffset;
            newLevel = SHIFT;
            newRoot = null;
            newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);
        // Otherwise, if the root has been trimmed, garbage collect.
        } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
            offsetShift = 0;
            // Identify the new top root node of the subtree of the old root.
            while(newRoot){
                var beginIndex = newOrigin >>> newLevel & MASK;
                if (beginIndex !== newTailOffset >>> newLevel & MASK) {
                    break;
                }
                if (beginIndex) {
                    offsetShift += (1 << newLevel) * beginIndex;
                }
                newLevel -= SHIFT;
                newRoot = newRoot.array[beginIndex];
            }
            // Trim the new sides of the new root.
            if (newRoot && newOrigin > oldOrigin) {
                newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
            }
            if (newRoot && newTailOffset < oldTailOffset) {
                newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);
            }
            if (offsetShift) {
                newOrigin -= offsetShift;
                newCapacity -= offsetShift;
            }
        }
        if (list.__ownerID) {
            list.size = newCapacity - newOrigin;
            list._origin = newOrigin;
            list._capacity = newCapacity;
            list._level = newLevel;
            list._root = newRoot;
            list._tail = newTail;
            list.__hash = undefined;
            list.__altered = true;
            return list;
        }
        return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
    }
    function getTailOffset(size) {
        return size < SIZE ? 0 : size - 1 >>> SHIFT << SHIFT;
    }
    var OrderedMap = /*@__PURE__*/ function(Map) {
        function OrderedMap(value) {
            return value === undefined || value === null ? emptyOrderedMap() : isOrderedMap(value) ? value : emptyOrderedMap().withMutations(function(map) {
                var iter = KeyedCollection(value);
                assertNotInfinite(iter.size);
                iter.forEach(function(v, k) {
                    return map.set(k, v);
                });
            });
        }
        if (Map) OrderedMap.__proto__ = Map;
        OrderedMap.prototype = Object.create(Map && Map.prototype);
        OrderedMap.prototype.constructor = OrderedMap;
        OrderedMap.of = function of() {
            return this(arguments);
        };
        OrderedMap.prototype.toString = function toString() {
            return this.__toString("OrderedMap {", "}");
        };
        // @pragma Access
        OrderedMap.prototype.get = function get(k, notSetValue) {
            var index = this._map.get(k);
            return index !== undefined ? this._list.get(index)[1] : notSetValue;
        };
        // @pragma Modification
        OrderedMap.prototype.clear = function clear() {
            if (this.size === 0) {
                return this;
            }
            if (this.__ownerID) {
                this.size = 0;
                this._map.clear();
                this._list.clear();
                this.__altered = true;
                return this;
            }
            return emptyOrderedMap();
        };
        OrderedMap.prototype.set = function set(k, v) {
            return updateOrderedMap(this, k, v);
        };
        OrderedMap.prototype.remove = function remove(k) {
            return updateOrderedMap(this, k, NOT_SET);
        };
        OrderedMap.prototype.__iterate = function __iterate(fn, reverse) {
            var this$1$1 = this;
            return this._list.__iterate(function(entry) {
                return entry && fn(entry[1], entry[0], this$1$1);
            }, reverse);
        };
        OrderedMap.prototype.__iterator = function __iterator(type, reverse) {
            return this._list.fromEntrySeq().__iterator(type, reverse);
        };
        OrderedMap.prototype.__ensureOwner = function __ensureOwner(ownerID) {
            if (ownerID === this.__ownerID) {
                return this;
            }
            var newMap = this._map.__ensureOwner(ownerID);
            var newList = this._list.__ensureOwner(ownerID);
            if (!ownerID) {
                if (this.size === 0) {
                    return emptyOrderedMap();
                }
                this.__ownerID = ownerID;
                this.__altered = false;
                this._map = newMap;
                this._list = newList;
                return this;
            }
            return makeOrderedMap(newMap, newList, ownerID, this.__hash);
        };
        return OrderedMap;
    }(Map);
    OrderedMap.isOrderedMap = isOrderedMap;
    OrderedMap.prototype[IS_ORDERED_SYMBOL] = true;
    OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;
    function makeOrderedMap(map, list, ownerID, hash) {
        var omap = Object.create(OrderedMap.prototype);
        omap.size = map ? map.size : 0;
        omap._map = map;
        omap._list = list;
        omap.__ownerID = ownerID;
        omap.__hash = hash;
        omap.__altered = false;
        return omap;
    }
    var EMPTY_ORDERED_MAP;
    function emptyOrderedMap() {
        return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));
    }
    function updateOrderedMap(omap, k, v) {
        var map = omap._map;
        var list = omap._list;
        var i = map.get(k);
        var has = i !== undefined;
        var newMap;
        var newList;
        if (v === NOT_SET) {
            // removed
            if (!has) {
                return omap;
            }
            if (list.size >= SIZE && list.size >= map.size * 2) {
                newList = list.filter(function(entry, idx) {
                    return entry !== undefined && i !== idx;
                });
                newMap = newList.toKeyedSeq().map(function(entry) {
                    return entry[0];
                }).flip().toMap();
                if (omap.__ownerID) {
                    newMap.__ownerID = newList.__ownerID = omap.__ownerID;
                }
            } else {
                newMap = map.remove(k);
                newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);
            }
        } else if (has) {
            if (v === list.get(i)[1]) {
                return omap;
            }
            newMap = map;
            newList = list.set(i, [
                k,
                v
            ]);
        } else {
            newMap = map.set(k, list.size);
            newList = list.set(list.size, [
                k,
                v
            ]);
        }
        if (omap.__ownerID) {
            omap.size = newMap.size;
            omap._map = newMap;
            omap._list = newList;
            omap.__hash = undefined;
            omap.__altered = true;
            return omap;
        }
        return makeOrderedMap(newMap, newList);
    }
    var IS_STACK_SYMBOL = "@@__IMMUTABLE_STACK__@@";
    function isStack(maybeStack) {
        return Boolean(maybeStack && maybeStack[IS_STACK_SYMBOL]);
    }
    var Stack = /*@__PURE__*/ function(IndexedCollection) {
        function Stack(value) {
            return value === undefined || value === null ? emptyStack() : isStack(value) ? value : emptyStack().pushAll(value);
        }
        if (IndexedCollection) Stack.__proto__ = IndexedCollection;
        Stack.prototype = Object.create(IndexedCollection && IndexedCollection.prototype);
        Stack.prototype.constructor = Stack;
        Stack.of = function of() {
            return this(arguments);
        };
        Stack.prototype.toString = function toString() {
            return this.__toString("Stack [", "]");
        };
        // @pragma Access
        Stack.prototype.get = function get(index, notSetValue) {
            var head = this._head;
            index = wrapIndex(this, index);
            while(head && index--){
                head = head.next;
            }
            return head ? head.value : notSetValue;
        };
        Stack.prototype.peek = function peek() {
            return this._head && this._head.value;
        };
        // @pragma Modification
        Stack.prototype.push = function push() {
            var arguments$1 = arguments;
            if (arguments.length === 0) {
                return this;
            }
            var newSize = this.size + arguments.length;
            var head = this._head;
            for(var ii = arguments.length - 1; ii >= 0; ii--){
                head = {
                    value: arguments$1[ii],
                    next: head
                };
            }
            if (this.__ownerID) {
                this.size = newSize;
                this._head = head;
                this.__hash = undefined;
                this.__altered = true;
                return this;
            }
            return makeStack(newSize, head);
        };
        Stack.prototype.pushAll = function pushAll(iter) {
            iter = IndexedCollection(iter);
            if (iter.size === 0) {
                return this;
            }
            if (this.size === 0 && isStack(iter)) {
                return iter;
            }
            assertNotInfinite(iter.size);
            var newSize = this.size;
            var head = this._head;
            iter.__iterate(function(value) {
                newSize++;
                head = {
                    value: value,
                    next: head
                };
            }, /* reverse */ true);
            if (this.__ownerID) {
                this.size = newSize;
                this._head = head;
                this.__hash = undefined;
                this.__altered = true;
                return this;
            }
            return makeStack(newSize, head);
        };
        Stack.prototype.pop = function pop() {
            return this.slice(1);
        };
        Stack.prototype.clear = function clear() {
            if (this.size === 0) {
                return this;
            }
            if (this.__ownerID) {
                this.size = 0;
                this._head = undefined;
                this.__hash = undefined;
                this.__altered = true;
                return this;
            }
            return emptyStack();
        };
        Stack.prototype.slice = function slice(begin, end) {
            if (wholeSlice(begin, end, this.size)) {
                return this;
            }
            var resolvedBegin = resolveBegin(begin, this.size);
            var resolvedEnd = resolveEnd(end, this.size);
            if (resolvedEnd !== this.size) {
                // super.slice(begin, end);
                return IndexedCollection.prototype.slice.call(this, begin, end);
            }
            var newSize = this.size - resolvedBegin;
            var head = this._head;
            while(resolvedBegin--){
                head = head.next;
            }
            if (this.__ownerID) {
                this.size = newSize;
                this._head = head;
                this.__hash = undefined;
                this.__altered = true;
                return this;
            }
            return makeStack(newSize, head);
        };
        // @pragma Mutability
        Stack.prototype.__ensureOwner = function __ensureOwner(ownerID) {
            if (ownerID === this.__ownerID) {
                return this;
            }
            if (!ownerID) {
                if (this.size === 0) {
                    return emptyStack();
                }
                this.__ownerID = ownerID;
                this.__altered = false;
                return this;
            }
            return makeStack(this.size, this._head, ownerID, this.__hash);
        };
        // @pragma Iteration
        Stack.prototype.__iterate = function __iterate(fn, reverse) {
            var this$1$1 = this;
            if (reverse) {
                return new ArraySeq(this.toArray()).__iterate(function(v, k) {
                    return fn(v, k, this$1$1);
                }, reverse);
            }
            var iterations = 0;
            var node = this._head;
            while(node){
                if (fn(node.value, iterations++, this) === false) {
                    break;
                }
                node = node.next;
            }
            return iterations;
        };
        Stack.prototype.__iterator = function __iterator(type, reverse) {
            if (reverse) {
                return new ArraySeq(this.toArray()).__iterator(type, reverse);
            }
            var iterations = 0;
            var node = this._head;
            return new Iterator(function() {
                if (node) {
                    var value = node.value;
                    node = node.next;
                    return iteratorValue(type, iterations++, value);
                }
                return iteratorDone();
            });
        };
        return Stack;
    }(IndexedCollection);
    Stack.isStack = isStack;
    var StackPrototype = Stack.prototype;
    StackPrototype[IS_STACK_SYMBOL] = true;
    StackPrototype.shift = StackPrototype.pop;
    StackPrototype.unshift = StackPrototype.push;
    StackPrototype.unshiftAll = StackPrototype.pushAll;
    StackPrototype.withMutations = withMutations;
    StackPrototype.wasAltered = wasAltered;
    StackPrototype.asImmutable = asImmutable;
    StackPrototype["@@transducer/init"] = StackPrototype.asMutable = asMutable;
    StackPrototype["@@transducer/step"] = function(result, arr) {
        return result.unshift(arr);
    };
    StackPrototype["@@transducer/result"] = function(obj) {
        return obj.asImmutable();
    };
    function makeStack(size, head, ownerID, hash) {
        var map = Object.create(StackPrototype);
        map.size = size;
        map._head = head;
        map.__ownerID = ownerID;
        map.__hash = hash;
        map.__altered = false;
        return map;
    }
    var EMPTY_STACK;
    function emptyStack() {
        return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
    }
    var IS_SET_SYMBOL = "@@__IMMUTABLE_SET__@@";
    function isSet(maybeSet) {
        return Boolean(maybeSet && maybeSet[IS_SET_SYMBOL]);
    }
    function isOrderedSet(maybeOrderedSet) {
        return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);
    }
    function deepEqual(a, b) {
        if (a === b) {
            return true;
        }
        if (!isCollection(b) || a.size !== undefined && b.size !== undefined && a.size !== b.size || a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash || isKeyed(a) !== isKeyed(b) || isIndexed(a) !== isIndexed(b) || isOrdered(a) !== isOrdered(b)) {
            return false;
        }
        if (a.size === 0 && b.size === 0) {
            return true;
        }
        var notAssociative = !isAssociative(a);
        if (isOrdered(a)) {
            var entries = a.entries();
            return b.every(function(v, k) {
                var entry = entries.next().value;
                return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));
            }) && entries.next().done;
        }
        var flipped = false;
        if (a.size === undefined) {
            if (b.size === undefined) {
                if (typeof a.cacheResult === "function") {
                    a.cacheResult();
                }
            } else {
                flipped = true;
                var _ = a;
                a = b;
                b = _;
            }
        }
        var allEqual = true;
        var bSize = b.__iterate(function(v, k) {
            if (notAssociative ? !a.has(v) : flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {
                allEqual = false;
                return false;
            }
        });
        return allEqual && a.size === bSize;
    }
    function mixin(ctor, methods) {
        var keyCopier = function(key) {
            ctor.prototype[key] = methods[key];
        };
        Object.keys(methods).forEach(keyCopier);
        Object.getOwnPropertySymbols && Object.getOwnPropertySymbols(methods).forEach(keyCopier);
        return ctor;
    }
    function toJS(value) {
        if (!value || typeof value !== "object") {
            return value;
        }
        if (!isCollection(value)) {
            if (!isDataStructure(value)) {
                return value;
            }
            value = Seq(value);
        }
        if (isKeyed(value)) {
            var result$1 = {};
            value.__iterate(function(v, k) {
                result$1[k] = toJS(v);
            });
            return result$1;
        }
        var result = [];
        value.__iterate(function(v) {
            result.push(toJS(v));
        });
        return result;
    }
    var Set = /*@__PURE__*/ function(SetCollection) {
        function Set(value) {
            return value === undefined || value === null ? emptySet() : isSet(value) && !isOrdered(value) ? value : emptySet().withMutations(function(set) {
                var iter = SetCollection(value);
                assertNotInfinite(iter.size);
                iter.forEach(function(v) {
                    return set.add(v);
                });
            });
        }
        if (SetCollection) Set.__proto__ = SetCollection;
        Set.prototype = Object.create(SetCollection && SetCollection.prototype);
        Set.prototype.constructor = Set;
        Set.of = function of() {
            return this(arguments);
        };
        Set.fromKeys = function fromKeys(value) {
            return this(KeyedCollection(value).keySeq());
        };
        Set.intersect = function intersect(sets) {
            sets = Collection(sets).toArray();
            return sets.length ? SetPrototype.intersect.apply(Set(sets.pop()), sets) : emptySet();
        };
        Set.union = function union(sets) {
            sets = Collection(sets).toArray();
            return sets.length ? SetPrototype.union.apply(Set(sets.pop()), sets) : emptySet();
        };
        Set.prototype.toString = function toString() {
            return this.__toString("Set {", "}");
        };
        // @pragma Access
        Set.prototype.has = function has(value) {
            return this._map.has(value);
        };
        // @pragma Modification
        Set.prototype.add = function add(value) {
            return updateSet(this, this._map.set(value, value));
        };
        Set.prototype.remove = function remove(value) {
            return updateSet(this, this._map.remove(value));
        };
        Set.prototype.clear = function clear() {
            return updateSet(this, this._map.clear());
        };
        // @pragma Composition
        Set.prototype.map = function map(mapper, context) {
            var this$1$1 = this;
            // keep track if the set is altered by the map function
            var didChanges = false;
            var newMap = updateSet(this, this._map.mapEntries(function(ref) {
                var v = ref[1];
                var mapped = mapper.call(context, v, v, this$1$1);
                if (mapped !== v) {
                    didChanges = true;
                }
                return [
                    mapped,
                    mapped
                ];
            }, context));
            return didChanges ? newMap : this;
        };
        Set.prototype.union = function union() {
            var iters = [], len = arguments.length;
            while(len--)iters[len] = arguments[len];
            iters = iters.filter(function(x) {
                return x.size !== 0;
            });
            if (iters.length === 0) {
                return this;
            }
            if (this.size === 0 && !this.__ownerID && iters.length === 1) {
                return this.constructor(iters[0]);
            }
            return this.withMutations(function(set) {
                for(var ii = 0; ii < iters.length; ii++){
                    if (typeof iters[ii] === "string") {
                        set.add(iters[ii]);
                    } else {
                        SetCollection(iters[ii]).forEach(function(value) {
                            return set.add(value);
                        });
                    }
                }
            });
        };
        Set.prototype.intersect = function intersect() {
            var iters = [], len = arguments.length;
            while(len--)iters[len] = arguments[len];
            if (iters.length === 0) {
                return this;
            }
            iters = iters.map(function(iter) {
                return SetCollection(iter);
            });
            var toRemove = [];
            this.forEach(function(value) {
                if (!iters.every(function(iter) {
                    return iter.includes(value);
                })) {
                    toRemove.push(value);
                }
            });
            return this.withMutations(function(set) {
                toRemove.forEach(function(value) {
                    set.remove(value);
                });
            });
        };
        Set.prototype.subtract = function subtract() {
            var iters = [], len = arguments.length;
            while(len--)iters[len] = arguments[len];
            if (iters.length === 0) {
                return this;
            }
            iters = iters.map(function(iter) {
                return SetCollection(iter);
            });
            var toRemove = [];
            this.forEach(function(value) {
                if (iters.some(function(iter) {
                    return iter.includes(value);
                })) {
                    toRemove.push(value);
                }
            });
            return this.withMutations(function(set) {
                toRemove.forEach(function(value) {
                    set.remove(value);
                });
            });
        };
        Set.prototype.sort = function sort(comparator) {
            // Late binding
            return OrderedSet(sortFactory(this, comparator));
        };
        Set.prototype.sortBy = function sortBy(mapper, comparator) {
            // Late binding
            return OrderedSet(sortFactory(this, comparator, mapper));
        };
        Set.prototype.wasAltered = function wasAltered() {
            return this._map.wasAltered();
        };
        Set.prototype.__iterate = function __iterate(fn, reverse) {
            var this$1$1 = this;
            return this._map.__iterate(function(k) {
                return fn(k, k, this$1$1);
            }, reverse);
        };
        Set.prototype.__iterator = function __iterator(type, reverse) {
            return this._map.__iterator(type, reverse);
        };
        Set.prototype.__ensureOwner = function __ensureOwner(ownerID) {
            if (ownerID === this.__ownerID) {
                return this;
            }
            var newMap = this._map.__ensureOwner(ownerID);
            if (!ownerID) {
                if (this.size === 0) {
                    return this.__empty();
                }
                this.__ownerID = ownerID;
                this._map = newMap;
                return this;
            }
            return this.__make(newMap, ownerID);
        };
        return Set;
    }(SetCollection);
    Set.isSet = isSet;
    var SetPrototype = Set.prototype;
    SetPrototype[IS_SET_SYMBOL] = true;
    SetPrototype[DELETE] = SetPrototype.remove;
    SetPrototype.merge = SetPrototype.concat = SetPrototype.union;
    SetPrototype.withMutations = withMutations;
    SetPrototype.asImmutable = asImmutable;
    SetPrototype["@@transducer/init"] = SetPrototype.asMutable = asMutable;
    SetPrototype["@@transducer/step"] = function(result, arr) {
        return result.add(arr);
    };
    SetPrototype["@@transducer/result"] = function(obj) {
        return obj.asImmutable();
    };
    SetPrototype.__empty = emptySet;
    SetPrototype.__make = makeSet;
    function updateSet(set, newMap) {
        if (set.__ownerID) {
            set.size = newMap.size;
            set._map = newMap;
            return set;
        }
        return newMap === set._map ? set : newMap.size === 0 ? set.__empty() : set.__make(newMap);
    }
    function makeSet(map, ownerID) {
        var set = Object.create(SetPrototype);
        set.size = map ? map.size : 0;
        set._map = map;
        set.__ownerID = ownerID;
        return set;
    }
    var EMPTY_SET;
    function emptySet() {
        return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
    }
    /**
   * Returns a lazy seq of nums from start (inclusive) to end
   * (exclusive), by step, where start defaults to 0, step to 1, and end to
   * infinity. When start is equal to end, returns empty list.
   */ var Range = /*@__PURE__*/ function(IndexedSeq) {
        function Range(start, end, step) {
            if (!(this instanceof Range)) {
                return new Range(start, end, step);
            }
            invariant(step !== 0, "Cannot step a Range by 0");
            start = start || 0;
            if (end === undefined) {
                end = Infinity;
            }
            step = step === undefined ? 1 : Math.abs(step);
            if (end < start) {
                step = -step;
            }
            this._start = start;
            this._end = end;
            this._step = step;
            this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
            if (this.size === 0) {
                if (EMPTY_RANGE) {
                    return EMPTY_RANGE;
                }
                EMPTY_RANGE = this;
            }
        }
        if (IndexedSeq) Range.__proto__ = IndexedSeq;
        Range.prototype = Object.create(IndexedSeq && IndexedSeq.prototype);
        Range.prototype.constructor = Range;
        Range.prototype.toString = function toString() {
            if (this.size === 0) {
                return "Range []";
            }
            return "Range [ " + this._start + "..." + this._end + (this._step !== 1 ? " by " + this._step : "") + " ]";
        };
        Range.prototype.get = function get(index, notSetValue) {
            return this.has(index) ? this._start + wrapIndex(this, index) * this._step : notSetValue;
        };
        Range.prototype.includes = function includes(searchValue) {
            var possibleIndex = (searchValue - this._start) / this._step;
            return possibleIndex >= 0 && possibleIndex < this.size && possibleIndex === Math.floor(possibleIndex);
        };
        Range.prototype.slice = function slice(begin, end) {
            if (wholeSlice(begin, end, this.size)) {
                return this;
            }
            begin = resolveBegin(begin, this.size);
            end = resolveEnd(end, this.size);
            if (end <= begin) {
                return new Range(0, 0);
            }
            return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);
        };
        Range.prototype.indexOf = function indexOf(searchValue) {
            var offsetValue = searchValue - this._start;
            if (offsetValue % this._step === 0) {
                var index = offsetValue / this._step;
                if (index >= 0 && index < this.size) {
                    return index;
                }
            }
            return -1;
        };
        Range.prototype.lastIndexOf = function lastIndexOf(searchValue) {
            return this.indexOf(searchValue);
        };
        Range.prototype.__iterate = function __iterate(fn, reverse) {
            var size = this.size;
            var step = this._step;
            var value = reverse ? this._start + (size - 1) * step : this._start;
            var i = 0;
            while(i !== size){
                if (fn(value, reverse ? size - ++i : i++, this) === false) {
                    break;
                }
                value += reverse ? -step : step;
            }
            return i;
        };
        Range.prototype.__iterator = function __iterator(type, reverse) {
            var size = this.size;
            var step = this._step;
            var value = reverse ? this._start + (size - 1) * step : this._start;
            var i = 0;
            return new Iterator(function() {
                if (i === size) {
                    return iteratorDone();
                }
                var v = value;
                value += reverse ? -step : step;
                return iteratorValue(type, reverse ? size - ++i : i++, v);
            });
        };
        Range.prototype.equals = function equals(other) {
            return other instanceof Range ? this._start === other._start && this._end === other._end && this._step === other._step : deepEqual(this, other);
        };
        return Range;
    }(IndexedSeq);
    var EMPTY_RANGE;
    function getIn$1(collection, searchKeyPath, notSetValue) {
        var keyPath = coerceKeyPath(searchKeyPath);
        var i = 0;
        while(i !== keyPath.length){
            collection = get(collection, keyPath[i++], NOT_SET);
            if (collection === NOT_SET) {
                return notSetValue;
            }
        }
        return collection;
    }
    function getIn(searchKeyPath, notSetValue) {
        return getIn$1(this, searchKeyPath, notSetValue);
    }
    function hasIn$1(collection, keyPath) {
        return getIn$1(collection, keyPath, NOT_SET) !== NOT_SET;
    }
    function hasIn(searchKeyPath) {
        return hasIn$1(this, searchKeyPath);
    }
    function toObject() {
        assertNotInfinite(this.size);
        var object = {};
        this.__iterate(function(v, k) {
            object[k] = v;
        });
        return object;
    }
    // Note: all of these methods are deprecated.
    Collection.isIterable = isCollection;
    Collection.isKeyed = isKeyed;
    Collection.isIndexed = isIndexed;
    Collection.isAssociative = isAssociative;
    Collection.isOrdered = isOrdered;
    Collection.Iterator = Iterator;
    mixin(Collection, {
        // ### Conversion to other types
        toArray: function toArray() {
            assertNotInfinite(this.size);
            var array = new Array(this.size || 0);
            var useTuples = isKeyed(this);
            var i = 0;
            this.__iterate(function(v, k) {
                // Keyed collections produce an array of tuples.
                array[i++] = useTuples ? [
                    k,
                    v
                ] : v;
            });
            return array;
        },
        toIndexedSeq: function toIndexedSeq() {
            return new ToIndexedSequence(this);
        },
        toJS: function toJS$1() {
            return toJS(this);
        },
        toKeyedSeq: function toKeyedSeq() {
            return new ToKeyedSequence(this, true);
        },
        toMap: function toMap() {
            // Use Late Binding here to solve the circular dependency.
            return Map(this.toKeyedSeq());
        },
        toObject: toObject,
        toOrderedMap: function toOrderedMap() {
            // Use Late Binding here to solve the circular dependency.
            return OrderedMap(this.toKeyedSeq());
        },
        toOrderedSet: function toOrderedSet() {
            // Use Late Binding here to solve the circular dependency.
            return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
        },
        toSet: function toSet() {
            // Use Late Binding here to solve the circular dependency.
            return Set(isKeyed(this) ? this.valueSeq() : this);
        },
        toSetSeq: function toSetSeq() {
            return new ToSetSequence(this);
        },
        toSeq: function toSeq() {
            return isIndexed(this) ? this.toIndexedSeq() : isKeyed(this) ? this.toKeyedSeq() : this.toSetSeq();
        },
        toStack: function toStack() {
            // Use Late Binding here to solve the circular dependency.
            return Stack(isKeyed(this) ? this.valueSeq() : this);
        },
        toList: function toList() {
            // Use Late Binding here to solve the circular dependency.
            return List(isKeyed(this) ? this.valueSeq() : this);
        },
        // ### Common JavaScript methods and properties
        toString: function toString() {
            return "[Collection]";
        },
        __toString: function __toString(head, tail) {
            if (this.size === 0) {
                return head + tail;
            }
            return head + " " + this.toSeq().map(this.__toStringMapper).join(", ") + " " + tail;
        },
        // ### ES6 Collection methods (ES6 Array and Map)
        concat: function concat() {
            var values = [], len = arguments.length;
            while(len--)values[len] = arguments[len];
            return reify(this, concatFactory(this, values));
        },
        includes: function includes(searchValue) {
            return this.some(function(value) {
                return is(value, searchValue);
            });
        },
        entries: function entries() {
            return this.__iterator(ITERATE_ENTRIES);
        },
        every: function every(predicate, context) {
            assertNotInfinite(this.size);
            var returnValue = true;
            this.__iterate(function(v, k, c) {
                if (!predicate.call(context, v, k, c)) {
                    returnValue = false;
                    return false;
                }
            });
            return returnValue;
        },
        filter: function filter(predicate, context) {
            return reify(this, filterFactory(this, predicate, context, true));
        },
        partition: function partition(predicate, context) {
            return partitionFactory(this, predicate, context);
        },
        find: function find(predicate, context, notSetValue) {
            var entry = this.findEntry(predicate, context);
            return entry ? entry[1] : notSetValue;
        },
        forEach: function forEach(sideEffect, context) {
            assertNotInfinite(this.size);
            return this.__iterate(context ? sideEffect.bind(context) : sideEffect);
        },
        join: function join(separator) {
            assertNotInfinite(this.size);
            separator = separator !== undefined ? "" + separator : ",";
            var joined = "";
            var isFirst = true;
            this.__iterate(function(v) {
                isFirst ? isFirst = false : joined += separator;
                joined += v !== null && v !== undefined ? v.toString() : "";
            });
            return joined;
        },
        keys: function keys() {
            return this.__iterator(ITERATE_KEYS);
        },
        map: function map(mapper, context) {
            return reify(this, mapFactory(this, mapper, context));
        },
        reduce: function reduce$1(reducer, initialReduction, context) {
            return reduce(this, reducer, initialReduction, context, arguments.length < 2, false);
        },
        reduceRight: function reduceRight(reducer, initialReduction, context) {
            return reduce(this, reducer, initialReduction, context, arguments.length < 2, true);
        },
        reverse: function reverse() {
            return reify(this, reverseFactory(this, true));
        },
        slice: function slice(begin, end) {
            return reify(this, sliceFactory(this, begin, end, true));
        },
        some: function some(predicate, context) {
            return !this.every(not(predicate), context);
        },
        sort: function sort(comparator) {
            return reify(this, sortFactory(this, comparator));
        },
        values: function values() {
            return this.__iterator(ITERATE_VALUES);
        },
        // ### More sequential methods
        butLast: function butLast() {
            return this.slice(0, -1);
        },
        isEmpty: function isEmpty() {
            return this.size !== undefined ? this.size === 0 : !this.some(function() {
                return true;
            });
        },
        count: function count(predicate, context) {
            return ensureSize(predicate ? this.toSeq().filter(predicate, context) : this);
        },
        countBy: function countBy(grouper, context) {
            return countByFactory(this, grouper, context);
        },
        equals: function equals(other) {
            return deepEqual(this, other);
        },
        entrySeq: function entrySeq() {
            var collection = this;
            if (collection._cache) {
                // We cache as an entries array, so we can just return the cache!
                return new ArraySeq(collection._cache);
            }
            var entriesSequence = collection.toSeq().map(entryMapper).toIndexedSeq();
            entriesSequence.fromEntrySeq = function() {
                return collection.toSeq();
            };
            return entriesSequence;
        },
        filterNot: function filterNot(predicate, context) {
            return this.filter(not(predicate), context);
        },
        findEntry: function findEntry(predicate, context, notSetValue) {
            var found = notSetValue;
            this.__iterate(function(v, k, c) {
                if (predicate.call(context, v, k, c)) {
                    found = [
                        k,
                        v
                    ];
                    return false;
                }
            });
            return found;
        },
        findKey: function findKey(predicate, context) {
            var entry = this.findEntry(predicate, context);
            return entry && entry[0];
        },
        findLast: function findLast(predicate, context, notSetValue) {
            return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);
        },
        findLastEntry: function findLastEntry(predicate, context, notSetValue) {
            return this.toKeyedSeq().reverse().findEntry(predicate, context, notSetValue);
        },
        findLastKey: function findLastKey(predicate, context) {
            return this.toKeyedSeq().reverse().findKey(predicate, context);
        },
        first: function first(notSetValue) {
            return this.find(returnTrue, null, notSetValue);
        },
        flatMap: function flatMap(mapper, context) {
            return reify(this, flatMapFactory(this, mapper, context));
        },
        flatten: function flatten(depth) {
            return reify(this, flattenFactory(this, depth, true));
        },
        fromEntrySeq: function fromEntrySeq() {
            return new FromEntriesSequence(this);
        },
        get: function get(searchKey, notSetValue) {
            return this.find(function(_, key) {
                return is(key, searchKey);
            }, undefined, notSetValue);
        },
        getIn: getIn,
        groupBy: function groupBy(grouper, context) {
            return groupByFactory(this, grouper, context);
        },
        has: function has(searchKey) {
            return this.get(searchKey, NOT_SET) !== NOT_SET;
        },
        hasIn: hasIn,
        isSubset: function isSubset(iter) {
            iter = typeof iter.includes === "function" ? iter : Collection(iter);
            return this.every(function(value) {
                return iter.includes(value);
            });
        },
        isSuperset: function isSuperset(iter) {
            iter = typeof iter.isSubset === "function" ? iter : Collection(iter);
            return iter.isSubset(this);
        },
        keyOf: function keyOf(searchValue) {
            return this.findKey(function(value) {
                return is(value, searchValue);
            });
        },
        keySeq: function keySeq() {
            return this.toSeq().map(keyMapper).toIndexedSeq();
        },
        last: function last(notSetValue) {
            return this.toSeq().reverse().first(notSetValue);
        },
        lastKeyOf: function lastKeyOf(searchValue) {
            return this.toKeyedSeq().reverse().keyOf(searchValue);
        },
        max: function max(comparator) {
            return maxFactory(this, comparator);
        },
        maxBy: function maxBy(mapper, comparator) {
            return maxFactory(this, comparator, mapper);
        },
        min: function min(comparator) {
            return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);
        },
        minBy: function minBy(mapper, comparator) {
            return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);
        },
        rest: function rest() {
            return this.slice(1);
        },
        skip: function skip(amount) {
            return amount === 0 ? this : this.slice(Math.max(0, amount));
        },
        skipLast: function skipLast(amount) {
            return amount === 0 ? this : this.slice(0, -Math.max(0, amount));
        },
        skipWhile: function skipWhile(predicate, context) {
            return reify(this, skipWhileFactory(this, predicate, context, true));
        },
        skipUntil: function skipUntil(predicate, context) {
            return this.skipWhile(not(predicate), context);
        },
        sortBy: function sortBy(mapper, comparator) {
            return reify(this, sortFactory(this, comparator, mapper));
        },
        take: function take(amount) {
            return this.slice(0, Math.max(0, amount));
        },
        takeLast: function takeLast(amount) {
            return this.slice(-Math.max(0, amount));
        },
        takeWhile: function takeWhile(predicate, context) {
            return reify(this, takeWhileFactory(this, predicate, context));
        },
        takeUntil: function takeUntil(predicate, context) {
            return this.takeWhile(not(predicate), context);
        },
        update: function update(fn) {
            return fn(this);
        },
        valueSeq: function valueSeq() {
            return this.toIndexedSeq();
        },
        // ### Hashable Object
        hashCode: function hashCode() {
            return this.__hash || (this.__hash = hashCollection(this));
        }
    });
    var CollectionPrototype = Collection.prototype;
    CollectionPrototype[IS_COLLECTION_SYMBOL] = true;
    CollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.values;
    CollectionPrototype.toJSON = CollectionPrototype.toArray;
    CollectionPrototype.__toStringMapper = quoteString;
    CollectionPrototype.inspect = CollectionPrototype.toSource = function() {
        return this.toString();
    };
    CollectionPrototype.chain = CollectionPrototype.flatMap;
    CollectionPrototype.contains = CollectionPrototype.includes;
    mixin(KeyedCollection, {
        // ### More sequential methods
        flip: function flip() {
            return reify(this, flipFactory(this));
        },
        mapEntries: function mapEntries(mapper, context) {
            var this$1$1 = this;
            var iterations = 0;
            return reify(this, this.toSeq().map(function(v, k) {
                return mapper.call(context, [
                    k,
                    v
                ], iterations++, this$1$1);
            }).fromEntrySeq());
        },
        mapKeys: function mapKeys(mapper, context) {
            var this$1$1 = this;
            return reify(this, this.toSeq().flip().map(function(k, v) {
                return mapper.call(context, k, v, this$1$1);
            }).flip());
        }
    });
    var KeyedCollectionPrototype = KeyedCollection.prototype;
    KeyedCollectionPrototype[IS_KEYED_SYMBOL] = true;
    KeyedCollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.entries;
    KeyedCollectionPrototype.toJSON = toObject;
    KeyedCollectionPrototype.__toStringMapper = function(v, k) {
        return quoteString(k) + ": " + quoteString(v);
    };
    mixin(IndexedCollection, {
        // ### Conversion to other types
        toKeyedSeq: function toKeyedSeq() {
            return new ToKeyedSequence(this, false);
        },
        // ### ES6 Collection methods (ES6 Array and Map)
        filter: function filter(predicate, context) {
            return reify(this, filterFactory(this, predicate, context, false));
        },
        findIndex: function findIndex(predicate, context) {
            var entry = this.findEntry(predicate, context);
            return entry ? entry[0] : -1;
        },
        indexOf: function indexOf(searchValue) {
            var key = this.keyOf(searchValue);
            return key === undefined ? -1 : key;
        },
        lastIndexOf: function lastIndexOf(searchValue) {
            var key = this.lastKeyOf(searchValue);
            return key === undefined ? -1 : key;
        },
        reverse: function reverse() {
            return reify(this, reverseFactory(this, false));
        },
        slice: function slice(begin, end) {
            return reify(this, sliceFactory(this, begin, end, false));
        },
        splice: function splice(index, removeNum /*, ...values*/ ) {
            var numArgs = arguments.length;
            removeNum = Math.max(removeNum || 0, 0);
            if (numArgs === 0 || numArgs === 2 && !removeNum) {
                return this;
            }
            // If index is negative, it should resolve relative to the size of the
            // collection. However size may be expensive to compute if not cached, so
            // only call count() if the number is in fact negative.
            index = resolveBegin(index, index < 0 ? this.count() : this.size);
            var spliced = this.slice(0, index);
            return reify(this, numArgs === 1 ? spliced : spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum)));
        },
        // ### More collection methods
        findLastIndex: function findLastIndex(predicate, context) {
            var entry = this.findLastEntry(predicate, context);
            return entry ? entry[0] : -1;
        },
        first: function first(notSetValue) {
            return this.get(0, notSetValue);
        },
        flatten: function flatten(depth) {
            return reify(this, flattenFactory(this, depth, false));
        },
        get: function get(index, notSetValue) {
            index = wrapIndex(this, index);
            return index < 0 || this.size === Infinity || this.size !== undefined && index > this.size ? notSetValue : this.find(function(_, key) {
                return key === index;
            }, undefined, notSetValue);
        },
        has: function has(index) {
            index = wrapIndex(this, index);
            return index >= 0 && (this.size !== undefined ? this.size === Infinity || index < this.size : this.indexOf(index) !== -1);
        },
        interpose: function interpose(separator) {
            return reify(this, interposeFactory(this, separator));
        },
        interleave: function interleave() {
            var collections = [
                this
            ].concat(arrCopy(arguments));
            var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, collections);
            var interleaved = zipped.flatten(true);
            if (zipped.size) {
                interleaved.size = zipped.size * collections.length;
            }
            return reify(this, interleaved);
        },
        keySeq: function keySeq() {
            return Range(0, this.size);
        },
        last: function last(notSetValue) {
            return this.get(-1, notSetValue);
        },
        skipWhile: function skipWhile(predicate, context) {
            return reify(this, skipWhileFactory(this, predicate, context, false));
        },
        zip: function zip() {
            var collections = [
                this
            ].concat(arrCopy(arguments));
            return reify(this, zipWithFactory(this, defaultZipper, collections));
        },
        zipAll: function zipAll() {
            var collections = [
                this
            ].concat(arrCopy(arguments));
            return reify(this, zipWithFactory(this, defaultZipper, collections, true));
        },
        zipWith: function zipWith(zipper /*, ...collections */ ) {
            var collections = arrCopy(arguments);
            collections[0] = this;
            return reify(this, zipWithFactory(this, zipper, collections));
        }
    });
    var IndexedCollectionPrototype = IndexedCollection.prototype;
    IndexedCollectionPrototype[IS_INDEXED_SYMBOL] = true;
    IndexedCollectionPrototype[IS_ORDERED_SYMBOL] = true;
    mixin(SetCollection, {
        // ### ES6 Collection methods (ES6 Array and Map)
        get: function get(value, notSetValue) {
            return this.has(value) ? value : notSetValue;
        },
        includes: function includes(value) {
            return this.has(value);
        },
        // ### More sequential methods
        keySeq: function keySeq() {
            return this.valueSeq();
        }
    });
    var SetCollectionPrototype = SetCollection.prototype;
    SetCollectionPrototype.has = CollectionPrototype.includes;
    SetCollectionPrototype.contains = SetCollectionPrototype.includes;
    SetCollectionPrototype.keys = SetCollectionPrototype.values;
    // Mixin subclasses
    mixin(KeyedSeq, KeyedCollectionPrototype);
    mixin(IndexedSeq, IndexedCollectionPrototype);
    mixin(SetSeq, SetCollectionPrototype);
    // #pragma Helper functions
    function reduce(collection, reducer, reduction, context, useFirst, reverse) {
        assertNotInfinite(collection.size);
        collection.__iterate(function(v, k, c) {
            if (useFirst) {
                useFirst = false;
                reduction = v;
            } else {
                reduction = reducer.call(context, reduction, v, k, c);
            }
        }, reverse);
        return reduction;
    }
    function keyMapper(v, k) {
        return k;
    }
    function entryMapper(v, k) {
        return [
            k,
            v
        ];
    }
    function not(predicate) {
        return function() {
            return !predicate.apply(this, arguments);
        };
    }
    function neg(predicate) {
        return function() {
            return -predicate.apply(this, arguments);
        };
    }
    function defaultZipper() {
        return arrCopy(arguments);
    }
    function defaultNegComparator(a, b) {
        return a < b ? 1 : a > b ? -1 : 0;
    }
    function hashCollection(collection) {
        if (collection.size === Infinity) {
            return 0;
        }
        var ordered = isOrdered(collection);
        var keyed = isKeyed(collection);
        var h = ordered ? 1 : 0;
        var size = collection.__iterate(keyed ? ordered ? function(v, k) {
            h = 31 * h + hashMerge(hash(v), hash(k)) | 0;
        } : function(v, k) {
            h = h + hashMerge(hash(v), hash(k)) | 0;
        } : ordered ? function(v) {
            h = 31 * h + hash(v) | 0;
        } : function(v) {
            h = h + hash(v) | 0;
        });
        return murmurHashOfSize(size, h);
    }
    function murmurHashOfSize(size, h) {
        h = imul(h, 0xcc9e2d51);
        h = imul(h << 15 | h >>> -15, 0x1b873593);
        h = imul(h << 13 | h >>> -13, 5);
        h = (h + 0xe6546b64 | 0) ^ size;
        h = imul(h ^ h >>> 16, 0x85ebca6b);
        h = imul(h ^ h >>> 13, 0xc2b2ae35);
        h = smi(h ^ h >>> 16);
        return h;
    }
    function hashMerge(a, b) {
        return a ^ b + 0x9e3779b9 + (a << 6) + (a >> 2) | 0; // int
    }
    var OrderedSet = /*@__PURE__*/ function(Set) {
        function OrderedSet(value) {
            return value === undefined || value === null ? emptyOrderedSet() : isOrderedSet(value) ? value : emptyOrderedSet().withMutations(function(set) {
                var iter = SetCollection(value);
                assertNotInfinite(iter.size);
                iter.forEach(function(v) {
                    return set.add(v);
                });
            });
        }
        if (Set) OrderedSet.__proto__ = Set;
        OrderedSet.prototype = Object.create(Set && Set.prototype);
        OrderedSet.prototype.constructor = OrderedSet;
        OrderedSet.of = function of() {
            return this(arguments);
        };
        OrderedSet.fromKeys = function fromKeys(value) {
            return this(KeyedCollection(value).keySeq());
        };
        OrderedSet.prototype.toString = function toString() {
            return this.__toString("OrderedSet {", "}");
        };
        return OrderedSet;
    }(Set);
    OrderedSet.isOrderedSet = isOrderedSet;
    var OrderedSetPrototype = OrderedSet.prototype;
    OrderedSetPrototype[IS_ORDERED_SYMBOL] = true;
    OrderedSetPrototype.zip = IndexedCollectionPrototype.zip;
    OrderedSetPrototype.zipWith = IndexedCollectionPrototype.zipWith;
    OrderedSetPrototype.zipAll = IndexedCollectionPrototype.zipAll;
    OrderedSetPrototype.__empty = emptyOrderedSet;
    OrderedSetPrototype.__make = makeOrderedSet;
    function makeOrderedSet(map, ownerID) {
        var set = Object.create(OrderedSetPrototype);
        set.size = map ? map.size : 0;
        set._map = map;
        set.__ownerID = ownerID;
        return set;
    }
    var EMPTY_ORDERED_SET;
    function emptyOrderedSet() {
        return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));
    }
    var PairSorting = {
        LeftThenRight: -1,
        RightThenLeft: +1
    };
    function throwOnInvalidDefaultValues(defaultValues) {
        if (isRecord(defaultValues)) {
            throw new Error("Can not call `Record` with an immutable Record as default values. Use a plain javascript object instead.");
        }
        if (isImmutable(defaultValues)) {
            throw new Error("Can not call `Record` with an immutable Collection as default values. Use a plain javascript object instead.");
        }
        if (defaultValues === null || typeof defaultValues !== "object") {
            throw new Error("Can not call `Record` with a non-object as default values. Use a plain javascript object instead.");
        }
    }
    var Record = function Record(defaultValues, name) {
        var hasInitialized;
        throwOnInvalidDefaultValues(defaultValues);
        var RecordType = function Record(values) {
            var this$1$1 = this;
            if (values instanceof RecordType) {
                return values;
            }
            if (!(this instanceof RecordType)) {
                return new RecordType(values);
            }
            if (!hasInitialized) {
                hasInitialized = true;
                var keys = Object.keys(defaultValues);
                var indices = RecordTypePrototype._indices = {};
                // Deprecated: left to attempt not to break any external code which
                // relies on a ._name property existing on record instances.
                // Use Record.getDescriptiveName() instead
                RecordTypePrototype._name = name;
                RecordTypePrototype._keys = keys;
                RecordTypePrototype._defaultValues = defaultValues;
                for(var i = 0; i < keys.length; i++){
                    var propName = keys[i];
                    indices[propName] = i;
                    if (RecordTypePrototype[propName]) {
                        /* eslint-disable no-console */ typeof console === "object" && console.warn && console.warn("Cannot define " + recordName(this) + ' with property "' + propName + '" since that property name is part of the Record API.');
                    /* eslint-enable no-console */ } else {
                        setProp(RecordTypePrototype, propName);
                    }
                }
            }
            this.__ownerID = undefined;
            this._values = List().withMutations(function(l) {
                l.setSize(this$1$1._keys.length);
                KeyedCollection(values).forEach(function(v, k) {
                    l.set(this$1$1._indices[k], v === this$1$1._defaultValues[k] ? undefined : v);
                });
            });
            return this;
        };
        var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
        RecordTypePrototype.constructor = RecordType;
        if (name) {
            RecordType.displayName = name;
        }
        return RecordType;
    };
    Record.prototype.toString = function toString() {
        var str = recordName(this) + " { ";
        var keys = this._keys;
        var k;
        for(var i = 0, l = keys.length; i !== l; i++){
            k = keys[i];
            str += (i ? ", " : "") + k + ": " + quoteString(this.get(k));
        }
        return str + " }";
    };
    Record.prototype.equals = function equals(other) {
        return this === other || isRecord(other) && recordSeq(this).equals(recordSeq(other));
    };
    Record.prototype.hashCode = function hashCode() {
        return recordSeq(this).hashCode();
    };
    // @pragma Access
    Record.prototype.has = function has(k) {
        return this._indices.hasOwnProperty(k);
    };
    Record.prototype.get = function get(k, notSetValue) {
        if (!this.has(k)) {
            return notSetValue;
        }
        var index = this._indices[k];
        var value = this._values.get(index);
        return value === undefined ? this._defaultValues[k] : value;
    };
    // @pragma Modification
    Record.prototype.set = function set(k, v) {
        if (this.has(k)) {
            var newValues = this._values.set(this._indices[k], v === this._defaultValues[k] ? undefined : v);
            if (newValues !== this._values && !this.__ownerID) {
                return makeRecord(this, newValues);
            }
        }
        return this;
    };
    Record.prototype.remove = function remove(k) {
        return this.set(k);
    };
    Record.prototype.clear = function clear() {
        var newValues = this._values.clear().setSize(this._keys.length);
        return this.__ownerID ? this : makeRecord(this, newValues);
    };
    Record.prototype.wasAltered = function wasAltered() {
        return this._values.wasAltered();
    };
    Record.prototype.toSeq = function toSeq() {
        return recordSeq(this);
    };
    Record.prototype.toJS = function toJS$1() {
        return toJS(this);
    };
    Record.prototype.entries = function entries() {
        return this.__iterator(ITERATE_ENTRIES);
    };
    Record.prototype.__iterator = function __iterator(type, reverse) {
        return recordSeq(this).__iterator(type, reverse);
    };
    Record.prototype.__iterate = function __iterate(fn, reverse) {
        return recordSeq(this).__iterate(fn, reverse);
    };
    Record.prototype.__ensureOwner = function __ensureOwner(ownerID) {
        if (ownerID === this.__ownerID) {
            return this;
        }
        var newValues = this._values.__ensureOwner(ownerID);
        if (!ownerID) {
            this.__ownerID = ownerID;
            this._values = newValues;
            return this;
        }
        return makeRecord(this, newValues, ownerID);
    };
    Record.isRecord = isRecord;
    Record.getDescriptiveName = recordName;
    var RecordPrototype = Record.prototype;
    RecordPrototype[IS_RECORD_SYMBOL] = true;
    RecordPrototype[DELETE] = RecordPrototype.remove;
    RecordPrototype.deleteIn = RecordPrototype.removeIn = deleteIn;
    RecordPrototype.getIn = getIn;
    RecordPrototype.hasIn = CollectionPrototype.hasIn;
    RecordPrototype.merge = merge$1;
    RecordPrototype.mergeWith = mergeWith$1;
    RecordPrototype.mergeIn = mergeIn;
    RecordPrototype.mergeDeep = mergeDeep;
    RecordPrototype.mergeDeepWith = mergeDeepWith;
    RecordPrototype.mergeDeepIn = mergeDeepIn;
    RecordPrototype.setIn = setIn;
    RecordPrototype.update = update;
    RecordPrototype.updateIn = updateIn;
    RecordPrototype.withMutations = withMutations;
    RecordPrototype.asMutable = asMutable;
    RecordPrototype.asImmutable = asImmutable;
    RecordPrototype[ITERATOR_SYMBOL] = RecordPrototype.entries;
    RecordPrototype.toJSON = RecordPrototype.toObject = CollectionPrototype.toObject;
    RecordPrototype.inspect = RecordPrototype.toSource = function() {
        return this.toString();
    };
    function makeRecord(likeRecord, values, ownerID) {
        var record = Object.create(Object.getPrototypeOf(likeRecord));
        record._values = values;
        record.__ownerID = ownerID;
        return record;
    }
    function recordName(record) {
        return record.constructor.displayName || record.constructor.name || "Record";
    }
    function recordSeq(record) {
        return keyedSeqFromValue(record._keys.map(function(k) {
            return [
                k,
                record.get(k)
            ];
        }));
    }
    function setProp(prototype, name) {
        try {
            Object.defineProperty(prototype, name, {
                get: function() {
                    return this.get(name);
                },
                set: function(value) {
                    invariant(this.__ownerID, "Cannot set on an immutable record.");
                    this.set(name, value);
                }
            });
        } catch (error) {
        // Object.defineProperty failed. Probably IE8.
        }
    }
    /**
   * Returns a lazy Seq of `value` repeated `times` times. When `times` is
   * undefined, returns an infinite sequence of `value`.
   */ var Repeat = /*@__PURE__*/ function(IndexedSeq) {
        function Repeat(value, times) {
            if (!(this instanceof Repeat)) {
                return new Repeat(value, times);
            }
            this._value = value;
            this.size = times === undefined ? Infinity : Math.max(0, times);
            if (this.size === 0) {
                if (EMPTY_REPEAT) {
                    return EMPTY_REPEAT;
                }
                EMPTY_REPEAT = this;
            }
        }
        if (IndexedSeq) Repeat.__proto__ = IndexedSeq;
        Repeat.prototype = Object.create(IndexedSeq && IndexedSeq.prototype);
        Repeat.prototype.constructor = Repeat;
        Repeat.prototype.toString = function toString() {
            if (this.size === 0) {
                return "Repeat []";
            }
            return "Repeat [ " + this._value + " " + this.size + " times ]";
        };
        Repeat.prototype.get = function get(index, notSetValue) {
            return this.has(index) ? this._value : notSetValue;
        };
        Repeat.prototype.includes = function includes(searchValue) {
            return is(this._value, searchValue);
        };
        Repeat.prototype.slice = function slice(begin, end) {
            var size = this.size;
            return wholeSlice(begin, end, size) ? this : new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));
        };
        Repeat.prototype.reverse = function reverse() {
            return this;
        };
        Repeat.prototype.indexOf = function indexOf(searchValue) {
            if (is(this._value, searchValue)) {
                return 0;
            }
            return -1;
        };
        Repeat.prototype.lastIndexOf = function lastIndexOf(searchValue) {
            if (is(this._value, searchValue)) {
                return this.size;
            }
            return -1;
        };
        Repeat.prototype.__iterate = function __iterate(fn, reverse) {
            var size = this.size;
            var i = 0;
            while(i !== size){
                if (fn(this._value, reverse ? size - ++i : i++, this) === false) {
                    break;
                }
            }
            return i;
        };
        Repeat.prototype.__iterator = function __iterator(type, reverse) {
            var this$1$1 = this;
            var size = this.size;
            var i = 0;
            return new Iterator(function() {
                return i === size ? iteratorDone() : iteratorValue(type, reverse ? size - ++i : i++, this$1$1._value);
            });
        };
        Repeat.prototype.equals = function equals(other) {
            return other instanceof Repeat ? is(this._value, other._value) : deepEqual(other);
        };
        return Repeat;
    }(IndexedSeq);
    var EMPTY_REPEAT;
    function fromJS(value, converter) {
        return fromJSWith([], converter || defaultConverter, value, "", converter && converter.length > 2 ? [] : undefined, {
            "": value
        });
    }
    function fromJSWith(stack, converter, value, key, keyPath, parentValue) {
        if (typeof value !== "string" && !isImmutable(value) && (isArrayLike(value) || hasIterator(value) || isPlainObject(value))) {
            if (~stack.indexOf(value)) {
                throw new TypeError("Cannot convert circular structure to Immutable");
            }
            stack.push(value);
            keyPath && key !== "" && keyPath.push(key);
            var converted = converter.call(parentValue, key, Seq(value).map(function(v, k) {
                return fromJSWith(stack, converter, v, k, keyPath, value);
            }), keyPath && keyPath.slice());
            stack.pop();
            keyPath && keyPath.pop();
            return converted;
        }
        return value;
    }
    function defaultConverter(k, v) {
        // Effectively the opposite of "Collection.toSeq()"
        return isIndexed(v) ? v.toList() : isKeyed(v) ? v.toMap() : v.toSet();
    }
    var version = "4.3.0";
    var Immutable = {
        version: version,
        Collection: Collection,
        // Note: Iterable is deprecated
        Iterable: Collection,
        Seq: Seq,
        Map: Map,
        OrderedMap: OrderedMap,
        List: List,
        Stack: Stack,
        Set: Set,
        OrderedSet: OrderedSet,
        PairSorting: PairSorting,
        Record: Record,
        Range: Range,
        Repeat: Repeat,
        is: is,
        fromJS: fromJS,
        hash: hash,
        isImmutable: isImmutable,
        isCollection: isCollection,
        isKeyed: isKeyed,
        isIndexed: isIndexed,
        isAssociative: isAssociative,
        isOrdered: isOrdered,
        isValueObject: isValueObject,
        isPlainObject: isPlainObject,
        isSeq: isSeq,
        isList: isList,
        isMap: isMap,
        isOrderedMap: isOrderedMap,
        isStack: isStack,
        isSet: isSet,
        isOrderedSet: isOrderedSet,
        isRecord: isRecord,
        get: get,
        getIn: getIn$1,
        has: has,
        hasIn: hasIn$1,
        merge: merge,
        mergeDeep: mergeDeep$1,
        mergeWith: mergeWith,
        mergeDeepWith: mergeDeepWith$1,
        remove: remove,
        removeIn: removeIn,
        set: set,
        setIn: setIn$1,
        update: update$1,
        updateIn: updateIn$1
    };
    // Note: Iterable is deprecated
    var Iterable = Collection;
    exports1.Collection = Collection;
    exports1.Iterable = Iterable;
    exports1.List = List;
    exports1.Map = Map;
    exports1.OrderedMap = OrderedMap;
    exports1.OrderedSet = OrderedSet;
    exports1.PairSorting = PairSorting;
    exports1.Range = Range;
    exports1.Record = Record;
    exports1.Repeat = Repeat;
    exports1.Seq = Seq;
    exports1.Set = Set;
    exports1.Stack = Stack;
    exports1.default = Immutable;
    exports1.fromJS = fromJS;
    exports1.get = get;
    exports1.getIn = getIn$1;
    exports1.has = has;
    exports1.hasIn = hasIn$1;
    exports1.hash = hash;
    exports1.is = is;
    exports1.isAssociative = isAssociative;
    exports1.isCollection = isCollection;
    exports1.isImmutable = isImmutable;
    exports1.isIndexed = isIndexed;
    exports1.isKeyed = isKeyed;
    exports1.isList = isList;
    exports1.isMap = isMap;
    exports1.isOrdered = isOrdered;
    exports1.isOrderedMap = isOrderedMap;
    exports1.isOrderedSet = isOrderedSet;
    exports1.isPlainObject = isPlainObject;
    exports1.isRecord = isRecord;
    exports1.isSeq = isSeq;
    exports1.isSet = isSet;
    exports1.isStack = isStack;
    exports1.isValueObject = isValueObject;
    exports1.merge = merge;
    exports1.mergeDeep = mergeDeep$1;
    exports1.mergeDeepWith = mergeDeepWith$1;
    exports1.mergeWith = mergeWith;
    exports1.remove = remove;
    exports1.removeIn = removeIn;
    exports1.set = set;
    exports1.setIn = setIn$1;
    exports1.update = update$1;
    exports1.updateIn = updateIn$1;
    exports1.version = version;
    Object.defineProperty(exports1, "__esModule", {
        value: true
    });
});


/***/ }),

/***/ 54:
/***/ ((module) => {

"use strict";

(function(window, factory) {
    if (true) {
        module.exports = factory();
    } else {}
})(void 0, function() {
    var jStat = function(Math1, undefined1) {
        // For quick reference.
        var concat = Array.prototype.concat;
        var slice = Array.prototype.slice;
        var toString = Object.prototype.toString;
        // Calculate correction for IEEE error
        // TODO: This calculation can be improved.
        function calcRdx(n, m) {
            var val = n > m ? n : m;
            return Math1.pow(10, 17 - ~~(Math1.log(val > 0 ? val : -val) * Math1.LOG10E));
        }
        var isArray = Array.isArray || function isArray(arg) {
            return toString.call(arg) === "[object Array]";
        };
        function isFunction(arg) {
            return toString.call(arg) === "[object Function]";
        }
        function isNumber(num) {
            return typeof num === "number" ? num - num === 0 : false;
        }
        // Converts the jStat matrix to vector.
        function toVector(arr) {
            return concat.apply([], arr);
        }
        // The one and only jStat constructor.
        function jStat() {
            return new jStat._init(arguments);
        }
        // TODO: Remove after all references in src files have been removed.
        jStat.fn = jStat.prototype;
        // By separating the initializer from the constructor it's easier to handle
        // always returning a new instance whether "new" was used or not.
        jStat._init = function _init(args) {
            // If first argument is an array, must be vector or matrix.
            if (isArray(args[0])) {
                // Check if matrix.
                if (isArray(args[0][0])) {
                    // See if a mapping function was also passed.
                    if (isFunction(args[1])) args[0] = jStat.map(args[0], args[1]);
                    // Iterate over each is faster than this.push.apply(this, args[0].
                    for(var i = 0; i < args[0].length; i++)this[i] = args[0][i];
                    this.length = args[0].length;
                // Otherwise must be a vector.
                } else {
                    this[0] = isFunction(args[1]) ? jStat.map(args[0], args[1]) : args[0];
                    this.length = 1;
                }
            // If first argument is number, assume creation of sequence.
            } else if (isNumber(args[0])) {
                this[0] = jStat.seq.apply(null, args);
                this.length = 1;
            // Handle case when jStat object is passed to jStat.
            } else if (args[0] instanceof jStat) {
                // Duplicate the object and pass it back.
                return jStat(args[0].toArray());
            // Unexpected argument value, return empty jStat object.
            // TODO: This is strange behavior. Shouldn't this throw or some such to let
            // the user know they had bad arguments?
            } else {
                this[0] = [];
                this.length = 1;
            }
            return this;
        };
        jStat._init.prototype = jStat.prototype;
        jStat._init.constructor = jStat;
        // Utility functions.
        // TODO: for internal use only?
        jStat.utils = {
            calcRdx: calcRdx,
            isArray: isArray,
            isFunction: isFunction,
            isNumber: isNumber,
            toVector: toVector
        };
        jStat._random_fn = Math1.random;
        jStat.setRandom = function setRandom(fn) {
            if (typeof fn !== "function") throw new TypeError("fn is not a function");
            jStat._random_fn = fn;
        };
        // Easily extend the jStat object.
        // TODO: is this seriously necessary?
        jStat.extend = function extend(obj) {
            var i, j;
            if (arguments.length === 1) {
                for(j in obj)jStat[j] = obj[j];
                return this;
            }
            for(i = 1; i < arguments.length; i++){
                for(j in arguments[i])obj[j] = arguments[i][j];
            }
            return obj;
        };
        // Returns the number of rows in the matrix.
        jStat.rows = function rows(arr) {
            return arr.length || 1;
        };
        // Returns the number of columns in the matrix.
        jStat.cols = function cols(arr) {
            return arr[0].length || 1;
        };
        // Returns the dimensions of the object { rows: i, cols: j }
        jStat.dimensions = function dimensions(arr) {
            return {
                rows: jStat.rows(arr),
                cols: jStat.cols(arr)
            };
        };
        // Returns a specified row as a vector or return a sub matrix by pick some rows
        jStat.row = function row(arr, index) {
            if (isArray(index)) {
                return index.map(function(i) {
                    return jStat.row(arr, i);
                });
            }
            return arr[index];
        };
        // return row as array
        // rowa([[1,2],[3,4]],0) -> [1,2]
        jStat.rowa = function rowa(arr, i) {
            return jStat.row(arr, i);
        };
        // Returns the specified column as a vector or return a sub matrix by pick some
        // columns
        jStat.col = function col(arr, index) {
            if (isArray(index)) {
                var submat = jStat.arange(arr.length).map(function() {
                    return new Array(index.length);
                });
                index.forEach(function(ind, i) {
                    jStat.arange(arr.length).forEach(function(j) {
                        submat[j][i] = arr[j][ind];
                    });
                });
                return submat;
            }
            var column = new Array(arr.length);
            for(var i = 0; i < arr.length; i++)column[i] = [
                arr[i][index]
            ];
            return column;
        };
        // return column as array
        // cola([[1,2],[3,4]],0) -> [1,3]
        jStat.cola = function cola(arr, i) {
            return jStat.col(arr, i).map(function(a) {
                return a[0];
            });
        };
        // Returns the diagonal of the matrix
        jStat.diag = function diag(arr) {
            var nrow = jStat.rows(arr);
            var res = new Array(nrow);
            for(var row = 0; row < nrow; row++)res[row] = [
                arr[row][row]
            ];
            return res;
        };
        // Returns the anti-diagonal of the matrix
        jStat.antidiag = function antidiag(arr) {
            var nrow = jStat.rows(arr) - 1;
            var res = new Array(nrow);
            for(var i = 0; nrow >= 0; nrow--, i++)res[i] = [
                arr[i][nrow]
            ];
            return res;
        };
        // Transpose a matrix or array.
        jStat.transpose = function transpose(arr) {
            var obj = [];
            var objArr, rows, cols, j, i;
            // Make sure arr is in matrix format.
            if (!isArray(arr[0])) arr = [
                arr
            ];
            rows = arr.length;
            cols = arr[0].length;
            for(i = 0; i < cols; i++){
                objArr = new Array(rows);
                for(j = 0; j < rows; j++)objArr[j] = arr[j][i];
                obj.push(objArr);
            }
            // If obj is vector, return only single array.
            return obj.length === 1 ? obj[0] : obj;
        };
        // Map a function to an array or array of arrays.
        // "toAlter" is an internal variable.
        jStat.map = function map(arr, func, toAlter) {
            var row, nrow, ncol, res, col;
            if (!isArray(arr[0])) arr = [
                arr
            ];
            nrow = arr.length;
            ncol = arr[0].length;
            res = toAlter ? arr : new Array(nrow);
            for(row = 0; row < nrow; row++){
                // if the row doesn't exist, create it
                if (!res[row]) res[row] = new Array(ncol);
                for(col = 0; col < ncol; col++)res[row][col] = func(arr[row][col], row, col);
            }
            return res.length === 1 ? res[0] : res;
        };
        // Cumulatively combine the elements of an array or array of arrays using a function.
        jStat.cumreduce = function cumreduce(arr, func, toAlter) {
            var row, nrow, ncol, res, col;
            if (!isArray(arr[0])) arr = [
                arr
            ];
            nrow = arr.length;
            ncol = arr[0].length;
            res = toAlter ? arr : new Array(nrow);
            for(row = 0; row < nrow; row++){
                // if the row doesn't exist, create it
                if (!res[row]) res[row] = new Array(ncol);
                if (ncol > 0) res[row][0] = arr[row][0];
                for(col = 1; col < ncol; col++)res[row][col] = func(res[row][col - 1], arr[row][col]);
            }
            return res.length === 1 ? res[0] : res;
        };
        // Destructively alter an array.
        jStat.alter = function alter(arr, func) {
            return jStat.map(arr, func, true);
        };
        // Generate a rows x cols matrix according to the supplied function.
        jStat.create = function create(rows, cols, func) {
            var res = new Array(rows);
            var i, j;
            if (isFunction(cols)) {
                func = cols;
                cols = rows;
            }
            for(i = 0; i < rows; i++){
                res[i] = new Array(cols);
                for(j = 0; j < cols; j++)res[i][j] = func(i, j);
            }
            return res;
        };
        function retZero() {
            return 0;
        }
        // Generate a rows x cols matrix of zeros.
        jStat.zeros = function zeros(rows, cols) {
            if (!isNumber(cols)) cols = rows;
            return jStat.create(rows, cols, retZero);
        };
        function retOne() {
            return 1;
        }
        // Generate a rows x cols matrix of ones.
        jStat.ones = function ones(rows, cols) {
            if (!isNumber(cols)) cols = rows;
            return jStat.create(rows, cols, retOne);
        };
        // Generate a rows x cols matrix of uniformly random numbers.
        jStat.rand = function rand(rows, cols) {
            if (!isNumber(cols)) cols = rows;
            return jStat.create(rows, cols, jStat._random_fn);
        };
        function retIdent(i, j) {
            return i === j ? 1 : 0;
        }
        // Generate an identity matrix of size row x cols.
        jStat.identity = function identity(rows, cols) {
            if (!isNumber(cols)) cols = rows;
            return jStat.create(rows, cols, retIdent);
        };
        // Tests whether a matrix is symmetric
        jStat.symmetric = function symmetric(arr) {
            var size = arr.length;
            var row, col;
            if (arr.length !== arr[0].length) return false;
            for(row = 0; row < size; row++){
                for(col = 0; col < size; col++)if (arr[col][row] !== arr[row][col]) return false;
            }
            return true;
        };
        // Set all values to zero.
        jStat.clear = function clear(arr) {
            return jStat.alter(arr, retZero);
        };
        // Generate sequence.
        jStat.seq = function seq(min, max, length, func) {
            if (!isFunction(func)) func = false;
            var arr = [];
            var hival = calcRdx(min, max);
            var step = (max * hival - min * hival) / ((length - 1) * hival);
            var current = min;
            var cnt;
            // Current is assigned using a technique to compensate for IEEE error.
            // TODO: Needs better implementation.
            for(cnt = 0; current <= max && cnt < length; cnt++, current = (min * hival + step * hival * cnt) / hival){
                arr.push(func ? func(current, cnt) : current);
            }
            return arr;
        };
        // arange(5) -> [0,1,2,3,4]
        // arange(1,5) -> [1,2,3,4]
        // arange(5,1,-1) -> [5,4,3,2]
        jStat.arange = function arange(start, end, step) {
            var rl = [];
            var i;
            step = step || 1;
            if (end === undefined1) {
                end = start;
                start = 0;
            }
            if (start === end || step === 0) {
                return [];
            }
            if (start < end && step < 0) {
                return [];
            }
            if (start > end && step > 0) {
                return [];
            }
            if (step > 0) {
                for(i = start; i < end; i += step){
                    rl.push(i);
                }
            } else {
                for(i = start; i > end; i += step){
                    rl.push(i);
                }
            }
            return rl;
        };
        // A=[[1,2,3],[4,5,6],[7,8,9]]
        // slice(A,{row:{end:2},col:{start:1}}) -> [[2,3],[5,6]]
        // slice(A,1,{start:1}) -> [5,6]
        // as numpy code A[:2,1:]
        jStat.slice = function() {
            function _slice(list, start, end, step) {
                // note it's not equal to range.map mode it's a bug
                var i;
                var rl = [];
                var length = list.length;
                if (start === undefined1 && end === undefined1 && step === undefined1) {
                    return jStat.copy(list);
                }
                start = start || 0;
                end = end || list.length;
                start = start >= 0 ? start : length + start;
                end = end >= 0 ? end : length + end;
                step = step || 1;
                if (start === end || step === 0) {
                    return [];
                }
                if (start < end && step < 0) {
                    return [];
                }
                if (start > end && step > 0) {
                    return [];
                }
                if (step > 0) {
                    for(i = start; i < end; i += step){
                        rl.push(list[i]);
                    }
                } else {
                    for(i = start; i > end; i += step){
                        rl.push(list[i]);
                    }
                }
                return rl;
            }
            function slice(list, rcSlice) {
                var colSlice, rowSlice;
                rcSlice = rcSlice || {};
                if (isNumber(rcSlice.row)) {
                    if (isNumber(rcSlice.col)) return list[rcSlice.row][rcSlice.col];
                    var row = jStat.rowa(list, rcSlice.row);
                    colSlice = rcSlice.col || {};
                    return _slice(row, colSlice.start, colSlice.end, colSlice.step);
                }
                if (isNumber(rcSlice.col)) {
                    var col = jStat.cola(list, rcSlice.col);
                    rowSlice = rcSlice.row || {};
                    return _slice(col, rowSlice.start, rowSlice.end, rowSlice.step);
                }
                rowSlice = rcSlice.row || {};
                colSlice = rcSlice.col || {};
                var rows = _slice(list, rowSlice.start, rowSlice.end, rowSlice.step);
                return rows.map(function(row) {
                    return _slice(row, colSlice.start, colSlice.end, colSlice.step);
                });
            }
            return slice;
        }();
        // A=[[1,2,3],[4,5,6],[7,8,9]]
        // sliceAssign(A,{row:{start:1},col:{start:1}},[[0,0],[0,0]])
        // A=[[1,2,3],[4,0,0],[7,0,0]]
        jStat.sliceAssign = function sliceAssign(A, rcSlice, B) {
            var nl, ml;
            if (isNumber(rcSlice.row)) {
                if (isNumber(rcSlice.col)) return A[rcSlice.row][rcSlice.col] = B;
                rcSlice.col = rcSlice.col || {};
                rcSlice.col.start = rcSlice.col.start || 0;
                rcSlice.col.end = rcSlice.col.end || A[0].length;
                rcSlice.col.step = rcSlice.col.step || 1;
                nl = jStat.arange(rcSlice.col.start, Math1.min(A.length, rcSlice.col.end), rcSlice.col.step);
                var m = rcSlice.row;
                nl.forEach(function(n, i) {
                    A[m][n] = B[i];
                });
                return A;
            }
            if (isNumber(rcSlice.col)) {
                rcSlice.row = rcSlice.row || {};
                rcSlice.row.start = rcSlice.row.start || 0;
                rcSlice.row.end = rcSlice.row.end || A.length;
                rcSlice.row.step = rcSlice.row.step || 1;
                ml = jStat.arange(rcSlice.row.start, Math1.min(A[0].length, rcSlice.row.end), rcSlice.row.step);
                var n = rcSlice.col;
                ml.forEach(function(m, j) {
                    A[m][n] = B[j];
                });
                return A;
            }
            if (B[0].length === undefined1) {
                B = [
                    B
                ];
            }
            rcSlice.row.start = rcSlice.row.start || 0;
            rcSlice.row.end = rcSlice.row.end || A.length;
            rcSlice.row.step = rcSlice.row.step || 1;
            rcSlice.col.start = rcSlice.col.start || 0;
            rcSlice.col.end = rcSlice.col.end || A[0].length;
            rcSlice.col.step = rcSlice.col.step || 1;
            ml = jStat.arange(rcSlice.row.start, Math1.min(A.length, rcSlice.row.end), rcSlice.row.step);
            nl = jStat.arange(rcSlice.col.start, Math1.min(A[0].length, rcSlice.col.end), rcSlice.col.step);
            ml.forEach(function(m, i) {
                nl.forEach(function(n, j) {
                    A[m][n] = B[i][j];
                });
            });
            return A;
        };
        // [1,2,3] ->
        // [[1,0,0],[0,2,0],[0,0,3]]
        jStat.diagonal = function diagonal(diagArray) {
            var mat = jStat.zeros(diagArray.length, diagArray.length);
            diagArray.forEach(function(t, i) {
                mat[i][i] = t;
            });
            return mat;
        };
        // return copy of A
        jStat.copy = function copy(A) {
            return A.map(function(row) {
                if (isNumber(row)) return row;
                return row.map(function(t) {
                    return t;
                });
            });
        };
        // TODO: Go over this entire implementation. Seems a tragic waste of resources
        // doing all this work. Instead, and while ugly, use new Function() to generate
        // a custom function for each static method.
        // Quick reference.
        var jProto = jStat.prototype;
        // Default length.
        jProto.length = 0;
        // For internal use only.
        // TODO: Check if they're actually used, and if they are then rename them
        // to _*
        jProto.push = Array.prototype.push;
        jProto.sort = Array.prototype.sort;
        jProto.splice = Array.prototype.splice;
        jProto.slice = Array.prototype.slice;
        // Return a clean array.
        jProto.toArray = function toArray() {
            return this.length > 1 ? slice.call(this) : slice.call(this)[0];
        };
        // Map a function to a matrix or vector.
        jProto.map = function map(func, toAlter) {
            return jStat(jStat.map(this, func, toAlter));
        };
        // Cumulatively combine the elements of a matrix or vector using a function.
        jProto.cumreduce = function cumreduce(func, toAlter) {
            return jStat(jStat.cumreduce(this, func, toAlter));
        };
        // Destructively alter an array.
        jProto.alter = function alter(func) {
            jStat.alter(this, func);
            return this;
        };
        // Extend prototype with methods that have no argument.
        (function(funcs) {
            for(var i = 0; i < funcs.length; i++)(function(passfunc) {
                jProto[passfunc] = function(func) {
                    var self = this, results;
                    // Check for callback.
                    if (func) {
                        setTimeout(function() {
                            func.call(self, jProto[passfunc].call(self));
                        });
                        return this;
                    }
                    results = jStat[passfunc](this);
                    return isArray(results) ? jStat(results) : results;
                };
            })(funcs[i]);
        })("transpose clear symmetric rows cols dimensions diag antidiag".split(" "));
        // Extend prototype with methods that have one argument.
        (function(funcs) {
            for(var i = 0; i < funcs.length; i++)(function(passfunc) {
                jProto[passfunc] = function(index, func) {
                    var self = this;
                    // check for callback
                    if (func) {
                        setTimeout(function() {
                            func.call(self, jProto[passfunc].call(self, index));
                        });
                        return this;
                    }
                    return jStat(jStat[passfunc](this, index));
                };
            })(funcs[i]);
        })("row col".split(" "));
        // Extend prototype with simple shortcut methods.
        (function(funcs) {
            for(var i = 0; i < funcs.length; i++)(function(passfunc) {
                jProto[passfunc] = function() {
                    return jStat(jStat[passfunc].apply(null, arguments));
                };
            })(funcs[i]);
        })("create zeros ones rand identity".split(" "));
        // Exposing jStat.
        return jStat;
    }(Math);
    (function(jStat, Math1) {
        var isFunction = jStat.utils.isFunction;
        // Ascending functions for sort
        function ascNum(a, b) {
            return a - b;
        }
        function clip(arg, min, max) {
            return Math1.max(min, Math1.min(arg, max));
        }
        // sum of an array
        jStat.sum = function sum(arr) {
            var sum = 0;
            var i = arr.length;
            while(--i >= 0)sum += arr[i];
            return sum;
        };
        // sum squared
        jStat.sumsqrd = function sumsqrd(arr) {
            var sum = 0;
            var i = arr.length;
            while(--i >= 0)sum += arr[i] * arr[i];
            return sum;
        };
        // sum of squared errors of prediction (SSE)
        jStat.sumsqerr = function sumsqerr(arr) {
            var mean = jStat.mean(arr);
            var sum = 0;
            var i = arr.length;
            var tmp;
            while(--i >= 0){
                tmp = arr[i] - mean;
                sum += tmp * tmp;
            }
            return sum;
        };
        // sum of an array in each row
        jStat.sumrow = function sumrow(arr) {
            var sum = 0;
            var i = arr.length;
            while(--i >= 0)sum += arr[i];
            return sum;
        };
        // product of an array
        jStat.product = function product(arr) {
            var prod = 1;
            var i = arr.length;
            while(--i >= 0)prod *= arr[i];
            return prod;
        };
        // minimum value of an array
        jStat.min = function min(arr) {
            var low = arr[0];
            var i = 0;
            while(++i < arr.length)if (arr[i] < low) low = arr[i];
            return low;
        };
        // maximum value of an array
        jStat.max = function max(arr) {
            var high = arr[0];
            var i = 0;
            while(++i < arr.length)if (arr[i] > high) high = arr[i];
            return high;
        };
        // unique values of an array
        jStat.unique = function unique(arr) {
            var hash = {}, _arr = [];
            for(var i = 0; i < arr.length; i++){
                if (!hash[arr[i]]) {
                    hash[arr[i]] = true;
                    _arr.push(arr[i]);
                }
            }
            return _arr;
        };
        // mean value of an array
        jStat.mean = function mean(arr) {
            return jStat.sum(arr) / arr.length;
        };
        // mean squared error (MSE)
        jStat.meansqerr = function meansqerr(arr) {
            return jStat.sumsqerr(arr) / arr.length;
        };
        // geometric mean of an array
        jStat.geomean = function geomean(arr) {
            var logs = arr.map(Math1.log);
            var meanOfLogs = jStat.mean(logs);
            return Math1.exp(meanOfLogs);
        };
        // median of an array
        jStat.median = function median(arr) {
            var arrlen = arr.length;
            var _arr = arr.slice().sort(ascNum);
            // check if array is even or odd, then return the appropriate
            return !(arrlen & 1) ? (_arr[arrlen / 2 - 1] + _arr[arrlen / 2]) / 2 : _arr[arrlen / 2 | 0];
        };
        // cumulative sum of an array
        jStat.cumsum = function cumsum(arr) {
            return jStat.cumreduce(arr, function(a, b) {
                return a + b;
            });
        };
        // cumulative product of an array
        jStat.cumprod = function cumprod(arr) {
            return jStat.cumreduce(arr, function(a, b) {
                return a * b;
            });
        };
        // successive differences of a sequence
        jStat.diff = function diff(arr) {
            var diffs = [];
            var arrLen = arr.length;
            var i;
            for(i = 1; i < arrLen; i++)diffs.push(arr[i] - arr[i - 1]);
            return diffs;
        };
        // ranks of an array
        jStat.rank = function(arr) {
            var i;
            var distinctNumbers = [];
            var numberCounts = {};
            for(i = 0; i < arr.length; i++){
                var number = arr[i];
                if (numberCounts[number]) {
                    numberCounts[number]++;
                } else {
                    numberCounts[number] = 1;
                    distinctNumbers.push(number);
                }
            }
            var sortedDistinctNumbers = distinctNumbers.sort(ascNum);
            var numberRanks = {};
            var currentRank = 1;
            for(i = 0; i < sortedDistinctNumbers.length; i++){
                var number = sortedDistinctNumbers[i];
                var count = numberCounts[number];
                var first = currentRank;
                var last = currentRank + count - 1;
                var rank = (first + last) / 2;
                numberRanks[number] = rank;
                currentRank += count;
            }
            return arr.map(function(number) {
                return numberRanks[number];
            });
        };
        // mode of an array
        // if there are multiple modes of an array, return all of them
        // is this the appropriate way of handling it?
        jStat.mode = function mode(arr) {
            var arrLen = arr.length;
            var _arr = arr.slice().sort(ascNum);
            var count = 1;
            var maxCount = 0;
            var numMaxCount = 0;
            var mode_arr = [];
            var i;
            for(i = 0; i < arrLen; i++){
                if (_arr[i] === _arr[i + 1]) {
                    count++;
                } else {
                    if (count > maxCount) {
                        mode_arr = [
                            _arr[i]
                        ];
                        maxCount = count;
                        numMaxCount = 0;
                    } else if (count === maxCount) {
                        mode_arr.push(_arr[i]);
                        numMaxCount++;
                    }
                    // resetting count for new value in array
                    count = 1;
                }
            }
            return numMaxCount === 0 ? mode_arr[0] : mode_arr;
        };
        // range of an array
        jStat.range = function range(arr) {
            return jStat.max(arr) - jStat.min(arr);
        };
        // variance of an array
        // flag = true indicates sample instead of population
        jStat.variance = function variance(arr, flag) {
            return jStat.sumsqerr(arr) / (arr.length - (flag ? 1 : 0));
        };
        // pooled variance of an array of arrays
        jStat.pooledvariance = function pooledvariance(arr) {
            var sumsqerr = arr.reduce(function(a, samples) {
                return a + jStat.sumsqerr(samples);
            }, 0);
            var count = arr.reduce(function(a, samples) {
                return a + samples.length;
            }, 0);
            return sumsqerr / (count - arr.length);
        };
        // deviation of an array
        jStat.deviation = function(arr) {
            var mean = jStat.mean(arr);
            var arrlen = arr.length;
            var dev = new Array(arrlen);
            for(var i = 0; i < arrlen; i++){
                dev[i] = arr[i] - mean;
            }
            return dev;
        };
        // standard deviation of an array
        // flag = true indicates sample instead of population
        jStat.stdev = function stdev(arr, flag) {
            return Math1.sqrt(jStat.variance(arr, flag));
        };
        // pooled standard deviation of an array of arrays
        jStat.pooledstdev = function pooledstdev(arr) {
            return Math1.sqrt(jStat.pooledvariance(arr));
        };
        // mean deviation (mean absolute deviation) of an array
        jStat.meandev = function meandev(arr) {
            var mean = jStat.mean(arr);
            var a = [];
            for(var i = arr.length - 1; i >= 0; i--){
                a.push(Math1.abs(arr[i] - mean));
            }
            return jStat.mean(a);
        };
        // median deviation (median absolute deviation) of an array
        jStat.meddev = function meddev(arr) {
            var median = jStat.median(arr);
            var a = [];
            for(var i = arr.length - 1; i >= 0; i--){
                a.push(Math1.abs(arr[i] - median));
            }
            return jStat.median(a);
        };
        // coefficient of variation
        jStat.coeffvar = function coeffvar(arr) {
            return jStat.stdev(arr) / jStat.mean(arr);
        };
        // quartiles of an array
        jStat.quartiles = function quartiles(arr) {
            var arrlen = arr.length;
            var _arr = arr.slice().sort(ascNum);
            return [
                _arr[Math1.round(arrlen / 4) - 1],
                _arr[Math1.round(arrlen / 2) - 1],
                _arr[Math1.round(arrlen * 3 / 4) - 1]
            ];
        };
        // Arbitary quantiles of an array. Direct port of the scipy.stats
        // implementation by Pierre GF Gerard-Marchant.
        jStat.quantiles = function quantiles(arr, quantilesArray, alphap, betap) {
            var sortedArray = arr.slice().sort(ascNum);
            var quantileVals = [
                quantilesArray.length
            ];
            var n = arr.length;
            var i, p, m, aleph, k, gamma;
            if (typeof alphap === "undefined") alphap = 3 / 8;
            if (typeof betap === "undefined") betap = 3 / 8;
            for(i = 0; i < quantilesArray.length; i++){
                p = quantilesArray[i];
                m = alphap + p * (1 - alphap - betap);
                aleph = n * p + m;
                k = Math1.floor(clip(aleph, 1, n - 1));
                gamma = clip(aleph - k, 0, 1);
                quantileVals[i] = (1 - gamma) * sortedArray[k - 1] + gamma * sortedArray[k];
            }
            return quantileVals;
        };
        // Return the k-th percentile of values in a range, where k is in the range 0..1, inclusive.
        // Passing true for the exclusive parameter excludes both endpoints of the range.
        jStat.percentile = function percentile(arr, k, exclusive) {
            var _arr = arr.slice().sort(ascNum);
            var realIndex = k * (_arr.length + (exclusive ? 1 : -1)) + (exclusive ? 0 : 1);
            var index = parseInt(realIndex);
            var frac = realIndex - index;
            if (index + 1 < _arr.length) {
                return _arr[index - 1] + frac * (_arr[index] - _arr[index - 1]);
            } else {
                return _arr[index - 1];
            }
        };
        // The percentile rank of score in a given array. Returns the percentage
        // of all values in the input array that are less than (kind='strict') or
        // less or equal than (kind='weak') score. Default is weak.
        jStat.percentileOfScore = function percentileOfScore(arr, score, kind) {
            var counter = 0;
            var len = arr.length;
            var strict = false;
            var value, i;
            if (kind === "strict") strict = true;
            for(i = 0; i < len; i++){
                value = arr[i];
                if (strict && value < score || !strict && value <= score) {
                    counter++;
                }
            }
            return counter / len;
        };
        // Histogram (bin count) data
        jStat.histogram = function histogram(arr, binCnt) {
            binCnt = binCnt || 4;
            var first = jStat.min(arr);
            var binWidth = (jStat.max(arr) - first) / binCnt;
            var len = arr.length;
            var bins = [];
            var i;
            for(i = 0; i < binCnt; i++)bins[i] = 0;
            for(i = 0; i < len; i++)bins[Math1.min(Math1.floor((arr[i] - first) / binWidth), binCnt - 1)] += 1;
            return bins;
        };
        // covariance of two arrays
        jStat.covariance = function covariance(arr1, arr2) {
            var u = jStat.mean(arr1);
            var v = jStat.mean(arr2);
            var arr1Len = arr1.length;
            var sq_dev = new Array(arr1Len);
            var i;
            for(i = 0; i < arr1Len; i++)sq_dev[i] = (arr1[i] - u) * (arr2[i] - v);
            return jStat.sum(sq_dev) / (arr1Len - 1);
        };
        // (pearson's) population correlation coefficient, rho
        jStat.corrcoeff = function corrcoeff(arr1, arr2) {
            return jStat.covariance(arr1, arr2) / jStat.stdev(arr1, 1) / jStat.stdev(arr2, 1);
        };
        // (spearman's) rank correlation coefficient, sp
        jStat.spearmancoeff = function(arr1, arr2) {
            arr1 = jStat.rank(arr1);
            arr2 = jStat.rank(arr2);
            //return pearson's correlation of the ranks:
            return jStat.corrcoeff(arr1, arr2);
        };
        // statistical standardized moments (general form of skew/kurt)
        jStat.stanMoment = function stanMoment(arr, n) {
            var mu = jStat.mean(arr);
            var sigma = jStat.stdev(arr);
            var len = arr.length;
            var skewSum = 0;
            for(var i = 0; i < len; i++)skewSum += Math1.pow((arr[i] - mu) / sigma, n);
            return skewSum / arr.length;
        };
        // (pearson's) moment coefficient of skewness
        jStat.skewness = function skewness(arr) {
            return jStat.stanMoment(arr, 3);
        };
        // (pearson's) (excess) kurtosis
        jStat.kurtosis = function kurtosis(arr) {
            return jStat.stanMoment(arr, 4) - 3;
        };
        var jProto = jStat.prototype;
        // Extend jProto with method for calculating cumulative sums and products.
        // This differs from the similar extension below as cumsum and cumprod should
        // not be run again in the case fullbool === true.
        // If a matrix is passed, automatically assume operation should be done on the
        // columns.
        (function(funcs) {
            for(var i = 0; i < funcs.length; i++)(function(passfunc) {
                // If a matrix is passed, automatically assume operation should be done on
                // the columns.
                jProto[passfunc] = function(fullbool, func) {
                    var arr = [];
                    var i = 0;
                    var tmpthis = this;
                    // Assignment reassignation depending on how parameters were passed in.
                    if (isFunction(fullbool)) {
                        func = fullbool;
                        fullbool = false;
                    }
                    // Check if a callback was passed with the function.
                    if (func) {
                        setTimeout(function() {
                            func.call(tmpthis, jProto[passfunc].call(tmpthis, fullbool));
                        });
                        return this;
                    }
                    // Check if matrix and run calculations.
                    if (this.length > 1) {
                        tmpthis = fullbool === true ? this : this.transpose();
                        for(; i < tmpthis.length; i++)arr[i] = jStat[passfunc](tmpthis[i]);
                        return arr;
                    }
                    // Pass fullbool if only vector, not a matrix. for variance and stdev.
                    return jStat[passfunc](this[0], fullbool);
                };
            })(funcs[i]);
        })("cumsum cumprod".split(" "));
        // Extend jProto with methods which don't require arguments and work on columns.
        (function(funcs) {
            for(var i = 0; i < funcs.length; i++)(function(passfunc) {
                // If a matrix is passed, automatically assume operation should be done on
                // the columns.
                jProto[passfunc] = function(fullbool, func) {
                    var arr = [];
                    var i = 0;
                    var tmpthis = this;
                    // Assignment reassignation depending on how parameters were passed in.
                    if (isFunction(fullbool)) {
                        func = fullbool;
                        fullbool = false;
                    }
                    // Check if a callback was passed with the function.
                    if (func) {
                        setTimeout(function() {
                            func.call(tmpthis, jProto[passfunc].call(tmpthis, fullbool));
                        });
                        return this;
                    }
                    // Check if matrix and run calculations.
                    if (this.length > 1) {
                        if (passfunc !== "sumrow") tmpthis = fullbool === true ? this : this.transpose();
                        for(; i < tmpthis.length; i++)arr[i] = jStat[passfunc](tmpthis[i]);
                        return fullbool === true ? jStat[passfunc](jStat.utils.toVector(arr)) : arr;
                    }
                    // Pass fullbool if only vector, not a matrix. for variance and stdev.
                    return jStat[passfunc](this[0], fullbool);
                };
            })(funcs[i]);
        })(("sum sumsqrd sumsqerr sumrow product min max unique mean meansqerr " + "geomean median diff rank mode range variance deviation stdev meandev " + "meddev coeffvar quartiles histogram skewness kurtosis").split(" "));
        // Extend jProto with functions that take arguments. Operations on matrices are
        // done on columns.
        (function(funcs) {
            for(var i = 0; i < funcs.length; i++)(function(passfunc) {
                jProto[passfunc] = function() {
                    var arr = [];
                    var i = 0;
                    var tmpthis = this;
                    var args = Array.prototype.slice.call(arguments);
                    var callbackFunction;
                    // If the last argument is a function, we assume it's a callback; we
                    // strip the callback out and call the function again.
                    if (isFunction(args[args.length - 1])) {
                        callbackFunction = args[args.length - 1];
                        var argsToPass = args.slice(0, args.length - 1);
                        setTimeout(function() {
                            callbackFunction.call(tmpthis, jProto[passfunc].apply(tmpthis, argsToPass));
                        });
                        return this;
                    // Otherwise we curry the function args and call normally.
                    } else {
                        callbackFunction = undefined;
                        var curriedFunction = function curriedFunction(vector) {
                            return jStat[passfunc].apply(tmpthis, [
                                vector
                            ].concat(args));
                        };
                    }
                    // If this is a matrix, run column-by-column.
                    if (this.length > 1) {
                        tmpthis = tmpthis.transpose();
                        for(; i < tmpthis.length; i++)arr[i] = curriedFunction(tmpthis[i]);
                        return arr;
                    }
                    // Otherwise run on the vector.
                    return curriedFunction(this[0]);
                };
            })(funcs[i]);
        })("quantiles percentileOfScore".split(" "));
    })(jStat, Math);
    // Special functions //
    (function(jStat, Math1) {
        // Log-gamma function
        jStat.gammaln = function gammaln(x) {
            var j = 0;
            var cof = [
                76.18009172947146,
                -86.50532032941677,
                24.01409824083091,
                -1.231739572450155,
                0.1208650973866179e-2,
                -0.5395239384953e-5
            ];
            var ser = 1.000000000190015;
            var xx, y, tmp;
            tmp = (y = xx = x) + 5.5;
            tmp -= (xx + 0.5) * Math1.log(tmp);
            for(; j < 6; j++)ser += cof[j] / ++y;
            return Math1.log(2.5066282746310005 * ser / xx) - tmp;
        };
        /*
 * log-gamma function to support poisson distribution sampling. The
 * algorithm comes from SPECFUN by Shanjie Zhang and Jianming Jin and their
 * book "Computation of Special Functions", 1996, John Wiley & Sons, Inc.
 */ jStat.loggam = function loggam(x) {
            var x0, x2, xp, gl, gl0;
            var k, n;
            var a = [
                8.333333333333333e-02,
                -2.777777777777778e-03,
                7.936507936507937e-04,
                -5.952380952380952e-04,
                8.417508417508418e-04,
                -1.917526917526918e-03,
                6.410256410256410e-03,
                -2.955065359477124e-02,
                1.796443723688307e-01,
                -1.39243221690590e+00
            ];
            x0 = x;
            n = 0;
            if (x == 1.0 || x == 2.0) {
                return 0.0;
            }
            if (x <= 7.0) {
                n = Math1.floor(7 - x);
                x0 = x + n;
            }
            x2 = 1.0 / (x0 * x0);
            xp = 2 * Math1.PI;
            gl0 = a[9];
            for(k = 8; k >= 0; k--){
                gl0 *= x2;
                gl0 += a[k];
            }
            gl = gl0 / x0 + 0.5 * Math1.log(xp) + (x0 - 0.5) * Math1.log(x0) - x0;
            if (x <= 7.0) {
                for(k = 1; k <= n; k++){
                    gl -= Math1.log(x0 - 1.0);
                    x0 -= 1.0;
                }
            }
            return gl;
        };
        // gamma of x
        jStat.gammafn = function gammafn(x) {
            var p = [
                -1.716185138865495,
                24.76565080557592,
                -379.80425647094563,
                629.3311553128184,
                866.9662027904133,
                -31451.272968848367,
                -36144.413418691176,
                66456.14382024054
            ];
            var q = [
                -30.8402300119739,
                315.35062697960416,
                -1015.1563674902192,
                -3107.771671572311,
                22538.118420980151,
                4755.8462775278811,
                -134659.9598649693,
                -115132.2596755535
            ];
            var fact = false;
            var n = 0;
            var xden = 0;
            var xnum = 0;
            var y = x;
            var i, z, yi, res;
            if (x > 171.6243769536076) {
                return Infinity;
            }
            if (y <= 0) {
                res = y % 1 + 3.6e-16;
                if (res) {
                    fact = (!(y & 1) ? 1 : -1) * Math1.PI / Math1.sin(Math1.PI * res);
                    y = 1 - y;
                } else {
                    return Infinity;
                }
            }
            yi = y;
            if (y < 1) {
                z = y++;
            } else {
                z = (y -= n = (y | 0) - 1) - 1;
            }
            for(i = 0; i < 8; ++i){
                xnum = (xnum + p[i]) * z;
                xden = xden * z + q[i];
            }
            res = xnum / xden + 1;
            if (yi < y) {
                res /= yi;
            } else if (yi > y) {
                for(i = 0; i < n; ++i){
                    res *= y;
                    y++;
                }
            }
            if (fact) {
                res = fact / res;
            }
            return res;
        };
        // lower incomplete gamma function, which is usually typeset with a
        // lower-case greek gamma as the function symbol
        jStat.gammap = function gammap(a, x) {
            return jStat.lowRegGamma(a, x) * jStat.gammafn(a);
        };
        // The lower regularized incomplete gamma function, usually written P(a,x)
        jStat.lowRegGamma = function lowRegGamma(a, x) {
            var aln = jStat.gammaln(a);
            var ap = a;
            var sum = 1 / a;
            var del = sum;
            var b = x + 1 - a;
            var c = 1 / 1.0e-30;
            var d = 1 / b;
            var h = d;
            var i = 1;
            // calculate maximum number of itterations required for a
            var ITMAX = -~(Math1.log(a >= 1 ? a : 1 / a) * 8.5 + a * 0.4 + 17);
            var an;
            if (x < 0 || a <= 0) {
                return NaN;
            } else if (x < a + 1) {
                for(; i <= ITMAX; i++){
                    sum += del *= x / ++ap;
                }
                return sum * Math1.exp(-x + a * Math1.log(x) - aln);
            }
            for(; i <= ITMAX; i++){
                an = -i * (i - a);
                b += 2;
                d = an * d + b;
                c = b + an / c;
                d = 1 / d;
                h *= d * c;
            }
            return 1 - h * Math1.exp(-x + a * Math1.log(x) - aln);
        };
        // natural log factorial of n
        jStat.factorialln = function factorialln(n) {
            return n < 0 ? NaN : jStat.gammaln(n + 1);
        };
        // factorial of n
        jStat.factorial = function factorial(n) {
            return n < 0 ? NaN : jStat.gammafn(n + 1);
        };
        // combinations of n, m
        jStat.combination = function combination(n, m) {
            // make sure n or m don't exceed the upper limit of usable values
            return n > 170 || m > 170 ? Math1.exp(jStat.combinationln(n, m)) : jStat.factorial(n) / jStat.factorial(m) / jStat.factorial(n - m);
        };
        jStat.combinationln = function combinationln(n, m) {
            return jStat.factorialln(n) - jStat.factorialln(m) - jStat.factorialln(n - m);
        };
        // permutations of n, m
        jStat.permutation = function permutation(n, m) {
            return jStat.factorial(n) / jStat.factorial(n - m);
        };
        // beta function
        jStat.betafn = function betafn(x, y) {
            // ensure arguments are positive
            if (x <= 0 || y <= 0) return undefined;
            // make sure x + y doesn't exceed the upper limit of usable values
            return x + y > 170 ? Math1.exp(jStat.betaln(x, y)) : jStat.gammafn(x) * jStat.gammafn(y) / jStat.gammafn(x + y);
        };
        // natural logarithm of beta function
        jStat.betaln = function betaln(x, y) {
            return jStat.gammaln(x) + jStat.gammaln(y) - jStat.gammaln(x + y);
        };
        // Evaluates the continued fraction for incomplete beta function by modified
        // Lentz's method.
        jStat.betacf = function betacf(x, a, b) {
            var fpmin = 1e-30;
            var m = 1;
            var qab = a + b;
            var qap = a + 1;
            var qam = a - 1;
            var c = 1;
            var d = 1 - qab * x / qap;
            var m2, aa, del, h;
            // These q's will be used in factors that occur in the coefficients
            if (Math1.abs(d) < fpmin) d = fpmin;
            d = 1 / d;
            h = d;
            for(; m <= 100; m++){
                m2 = 2 * m;
                aa = m * (b - m) * x / ((qam + m2) * (a + m2));
                // One step (the even one) of the recurrence
                d = 1 + aa * d;
                if (Math1.abs(d) < fpmin) d = fpmin;
                c = 1 + aa / c;
                if (Math1.abs(c) < fpmin) c = fpmin;
                d = 1 / d;
                h *= d * c;
                aa = -(a + m) * (qab + m) * x / ((a + m2) * (qap + m2));
                // Next step of the recurrence (the odd one)
                d = 1 + aa * d;
                if (Math1.abs(d) < fpmin) d = fpmin;
                c = 1 + aa / c;
                if (Math1.abs(c) < fpmin) c = fpmin;
                d = 1 / d;
                del = d * c;
                h *= del;
                if (Math1.abs(del - 1.0) < 3e-7) break;
            }
            return h;
        };
        // Returns the inverse of the lower regularized inomplete gamma function
        jStat.gammapinv = function gammapinv(p, a) {
            var j = 0;
            var a1 = a - 1;
            var EPS = 1e-8;
            var gln = jStat.gammaln(a);
            var x, err, t, u, pp, lna1, afac;
            if (p >= 1) return Math1.max(100, a + 100 * Math1.sqrt(a));
            if (p <= 0) return 0;
            if (a > 1) {
                lna1 = Math1.log(a1);
                afac = Math1.exp(a1 * (lna1 - 1) - gln);
                pp = p < 0.5 ? p : 1 - p;
                t = Math1.sqrt(-2 * Math1.log(pp));
                x = (2.30753 + t * 0.27061) / (1 + t * (0.99229 + t * 0.04481)) - t;
                if (p < 0.5) x = -x;
                x = Math1.max(1e-3, a * Math1.pow(1 - 1 / (9 * a) - x / (3 * Math1.sqrt(a)), 3));
            } else {
                t = 1 - a * (0.253 + a * 0.12);
                if (p < t) x = Math1.pow(p / t, 1 / a);
                else x = 1 - Math1.log(1 - (p - t) / (1 - t));
            }
            for(; j < 12; j++){
                if (x <= 0) return 0;
                err = jStat.lowRegGamma(a, x) - p;
                if (a > 1) t = afac * Math1.exp(-(x - a1) + a1 * (Math1.log(x) - lna1));
                else t = Math1.exp(-x + a1 * Math1.log(x) - gln);
                u = err / t;
                x -= t = u / (1 - 0.5 * Math1.min(1, u * ((a - 1) / x - 1)));
                if (x <= 0) x = 0.5 * (x + t);
                if (Math1.abs(t) < EPS * x) break;
            }
            return x;
        };
        // Returns the error function erf(x)
        jStat.erf = function erf(x) {
            var cof = [
                -1.3026537197817094,
                6.4196979235649026e-1,
                1.9476473204185836e-2,
                -9.561514786808631e-3,
                -9.46595344482036e-4,
                3.66839497852761e-4,
                4.2523324806907e-5,
                -2.0278578112534e-5,
                -1.624290004647e-6,
                1.303655835580e-6,
                1.5626441722e-8,
                -8.5238095915e-8,
                6.529054439e-9,
                5.059343495e-9,
                -9.91364156e-10,
                -2.27365122e-10,
                9.6467911e-11,
                2.394038e-12,
                -6.886027e-12,
                8.94487e-13,
                3.13092e-13,
                -1.12708e-13,
                3.81e-16,
                7.106e-15,
                -1.523e-15,
                -9.4e-17,
                1.21e-16,
                -2.8e-17
            ];
            var j = cof.length - 1;
            var isneg = false;
            var d = 0;
            var dd = 0;
            var t, ty, tmp, res;
            if (x < 0) {
                x = -x;
                isneg = true;
            }
            t = 2 / (2 + x);
            ty = 4 * t - 2;
            for(; j > 0; j--){
                tmp = d;
                d = ty * d - dd + cof[j];
                dd = tmp;
            }
            res = t * Math1.exp(-x * x + 0.5 * (cof[0] + ty * d) - dd);
            return isneg ? res - 1 : 1 - res;
        };
        // Returns the complmentary error function erfc(x)
        jStat.erfc = function erfc(x) {
            return 1 - jStat.erf(x);
        };
        // Returns the inverse of the complementary error function
        jStat.erfcinv = function erfcinv(p) {
            var j = 0;
            var x, err, t, pp;
            if (p >= 2) return -100;
            if (p <= 0) return 100;
            pp = p < 1 ? p : 2 - p;
            t = Math1.sqrt(-2 * Math1.log(pp / 2));
            x = -0.70711 * ((2.30753 + t * 0.27061) / (1 + t * (0.99229 + t * 0.04481)) - t);
            for(; j < 2; j++){
                err = jStat.erfc(x) - pp;
                x += err / (1.12837916709551257 * Math1.exp(-x * x) - x * err);
            }
            return p < 1 ? x : -x;
        };
        // Returns the inverse of the incomplete beta function
        jStat.ibetainv = function ibetainv(p, a, b) {
            var EPS = 1e-8;
            var a1 = a - 1;
            var b1 = b - 1;
            var j = 0;
            var lna, lnb, pp, t, u, err, x, al, h, w, afac;
            if (p <= 0) return 0;
            if (p >= 1) return 1;
            if (a >= 1 && b >= 1) {
                pp = p < 0.5 ? p : 1 - p;
                t = Math1.sqrt(-2 * Math1.log(pp));
                x = (2.30753 + t * 0.27061) / (1 + t * (0.99229 + t * 0.04481)) - t;
                if (p < 0.5) x = -x;
                al = (x * x - 3) / 6;
                h = 2 / (1 / (2 * a - 1) + 1 / (2 * b - 1));
                w = x * Math1.sqrt(al + h) / h - (1 / (2 * b - 1) - 1 / (2 * a - 1)) * (al + 5 / 6 - 2 / (3 * h));
                x = a / (a + b * Math1.exp(2 * w));
            } else {
                lna = Math1.log(a / (a + b));
                lnb = Math1.log(b / (a + b));
                t = Math1.exp(a * lna) / a;
                u = Math1.exp(b * lnb) / b;
                w = t + u;
                if (p < t / w) x = Math1.pow(a * w * p, 1 / a);
                else x = 1 - Math1.pow(b * w * (1 - p), 1 / b);
            }
            afac = -jStat.gammaln(a) - jStat.gammaln(b) + jStat.gammaln(a + b);
            for(; j < 10; j++){
                if (x === 0 || x === 1) return x;
                err = jStat.ibeta(x, a, b) - p;
                t = Math1.exp(a1 * Math1.log(x) + b1 * Math1.log(1 - x) + afac);
                u = err / t;
                x -= t = u / (1 - 0.5 * Math1.min(1, u * (a1 / x - b1 / (1 - x))));
                if (x <= 0) x = 0.5 * (x + t);
                if (x >= 1) x = 0.5 * (x + t + 1);
                if (Math1.abs(t) < EPS * x && j > 0) break;
            }
            return x;
        };
        // Returns the incomplete beta function I_x(a,b)
        jStat.ibeta = function ibeta(x, a, b) {
            // Factors in front of the continued fraction.
            var bt = x === 0 || x === 1 ? 0 : Math1.exp(jStat.gammaln(a + b) - jStat.gammaln(a) - jStat.gammaln(b) + a * Math1.log(x) + b * Math1.log(1 - x));
            if (x < 0 || x > 1) return false;
            if (x < (a + 1) / (a + b + 2)) // Use continued fraction directly.
            return bt * jStat.betacf(x, a, b) / a;
            // else use continued fraction after making the symmetry transformation.
            return 1 - bt * jStat.betacf(1 - x, b, a) / b;
        };
        // Returns a normal deviate (mu=0, sigma=1).
        // If n and m are specified it returns a object of normal deviates.
        jStat.randn = function randn(n, m) {
            var u, v, x, y, q;
            if (!m) m = n;
            if (n) return jStat.create(n, m, function() {
                return jStat.randn();
            });
            do {
                u = jStat._random_fn();
                v = 1.7156 * (jStat._random_fn() - 0.5);
                x = u - 0.449871;
                y = Math1.abs(v) + 0.386595;
                q = x * x + y * (0.19600 * y - 0.25472 * x);
            }while (q > 0.27597 && (q > 0.27846 || v * v > -4 * Math1.log(u) * u * u));
            return v / u;
        };
        // Returns a gamma deviate by the method of Marsaglia and Tsang.
        jStat.randg = function randg(shape, n, m) {
            var oalph = shape;
            var a1, a2, u, v, x, mat;
            if (!m) m = n;
            if (!shape) shape = 1;
            if (n) {
                mat = jStat.zeros(n, m);
                mat.alter(function() {
                    return jStat.randg(shape);
                });
                return mat;
            }
            if (shape < 1) shape += 1;
            a1 = shape - 1 / 3;
            a2 = 1 / Math1.sqrt(9 * a1);
            do {
                do {
                    x = jStat.randn();
                    v = 1 + a2 * x;
                }while (v <= 0);
                v = v * v * v;
                u = jStat._random_fn();
            }while (u > 1 - 0.331 * Math1.pow(x, 4) && Math1.log(u) > 0.5 * x * x + a1 * (1 - v + Math1.log(v)));
            // alpha > 1
            if (shape == oalph) return a1 * v;
            // alpha < 1
            do {
                u = jStat._random_fn();
            }while (u === 0);
            return Math1.pow(u, 1 / oalph) * a1 * v;
        };
        // making use of static methods on the instance
        (function(funcs) {
            for(var i = 0; i < funcs.length; i++)(function(passfunc) {
                jStat.fn[passfunc] = function() {
                    return jStat(jStat.map(this, function(value) {
                        return jStat[passfunc](value);
                    }));
                };
            })(funcs[i]);
        })("gammaln gammafn factorial factorialln".split(" "));
        (function(funcs) {
            for(var i = 0; i < funcs.length; i++)(function(passfunc) {
                jStat.fn[passfunc] = function() {
                    return jStat(jStat[passfunc].apply(null, arguments));
                };
            })(funcs[i]);
        })("randn".split(" "));
    })(jStat, Math);
    (function(jStat, Math1) {
        // generate all distribution instance methods
        (function(list) {
            for(var i = 0; i < list.length; i++)(function(func) {
                // distribution instance method
                jStat[func] = function f(a, b, c) {
                    if (!(this instanceof f)) return new f(a, b, c);
                    this._a = a;
                    this._b = b;
                    this._c = c;
                    return this;
                };
                // distribution method to be used on a jStat instance
                jStat.fn[func] = function(a, b, c) {
                    var newthis = jStat[func](a, b, c);
                    newthis.data = this;
                    return newthis;
                };
                // sample instance method
                jStat[func].prototype.sample = function(arr) {
                    var a = this._a;
                    var b = this._b;
                    var c = this._c;
                    if (arr) return jStat.alter(arr, function() {
                        return jStat[func].sample(a, b, c);
                    });
                    else return jStat[func].sample(a, b, c);
                };
                // generate the pdf, cdf and inv instance methods
                (function(vals) {
                    for(var i = 0; i < vals.length; i++)(function(fnfunc) {
                        jStat[func].prototype[fnfunc] = function(x) {
                            var a = this._a;
                            var b = this._b;
                            var c = this._c;
                            if (!x && x !== 0) x = this.data;
                            if (typeof x !== "number") {
                                return jStat.fn.map.call(x, function(x) {
                                    return jStat[func][fnfunc](x, a, b, c);
                                });
                            }
                            return jStat[func][fnfunc](x, a, b, c);
                        };
                    })(vals[i]);
                })("pdf cdf inv".split(" "));
                // generate the mean, median, mode and variance instance methods
                (function(vals) {
                    for(var i = 0; i < vals.length; i++)(function(fnfunc) {
                        jStat[func].prototype[fnfunc] = function() {
                            return jStat[func][fnfunc](this._a, this._b, this._c);
                        };
                    })(vals[i]);
                })("mean median mode variance".split(" "));
            })(list[i]);
        })(("beta centralF cauchy chisquare exponential gamma invgamma kumaraswamy " + "laplace lognormal noncentralt normal pareto studentt weibull uniform " + "binomial negbin hypgeom poisson triangular tukey arcsine").split(" "));
        // extend beta function with static methods
        jStat.extend(jStat.beta, {
            pdf: function pdf(x, alpha, beta) {
                // PDF is zero outside the support
                if (x > 1 || x < 0) return 0;
                // PDF is one for the uniform case
                if (alpha == 1 && beta == 1) return 1;
                if (alpha < 512 && beta < 512) {
                    return Math1.pow(x, alpha - 1) * Math1.pow(1 - x, beta - 1) / jStat.betafn(alpha, beta);
                } else {
                    return Math1.exp((alpha - 1) * Math1.log(x) + (beta - 1) * Math1.log(1 - x) - jStat.betaln(alpha, beta));
                }
            },
            cdf: function cdf(x, alpha, beta) {
                return x > 1 || x < 0 ? (x > 1) * 1 : jStat.ibeta(x, alpha, beta);
            },
            inv: function inv(x, alpha, beta) {
                return jStat.ibetainv(x, alpha, beta);
            },
            mean: function mean(alpha, beta) {
                return alpha / (alpha + beta);
            },
            median: function median(alpha, beta) {
                return jStat.ibetainv(0.5, alpha, beta);
            },
            mode: function mode(alpha, beta) {
                return (alpha - 1) / (alpha + beta - 2);
            },
            // return a random sample
            sample: function sample(alpha, beta) {
                var u = jStat.randg(alpha);
                return u / (u + jStat.randg(beta));
            },
            variance: function variance(alpha, beta) {
                return alpha * beta / (Math1.pow(alpha + beta, 2) * (alpha + beta + 1));
            }
        });
        // extend F function with static methods
        jStat.extend(jStat.centralF, {
            // This implementation of the pdf function avoids float overflow
            // See the way that R calculates this value:
            // https://svn.r-project.org/R/trunk/src/nmath/df.c
            pdf: function pdf(x, df1, df2) {
                var p, q, f;
                if (x < 0) return 0;
                if (df1 <= 2) {
                    if (x === 0 && df1 < 2) {
                        return Infinity;
                    }
                    if (x === 0 && df1 === 2) {
                        return 1;
                    }
                    return 1 / jStat.betafn(df1 / 2, df2 / 2) * Math1.pow(df1 / df2, df1 / 2) * Math1.pow(x, df1 / 2 - 1) * Math1.pow(1 + df1 / df2 * x, -(df1 + df2) / 2);
                }
                p = df1 * x / (df2 + x * df1);
                q = df2 / (df2 + x * df1);
                f = df1 * q / 2.0;
                return f * jStat.binomial.pdf((df1 - 2) / 2, (df1 + df2 - 2) / 2, p);
            },
            cdf: function cdf(x, df1, df2) {
                if (x < 0) return 0;
                return jStat.ibeta(df1 * x / (df1 * x + df2), df1 / 2, df2 / 2);
            },
            inv: function inv(x, df1, df2) {
                return df2 / (df1 * (1 / jStat.ibetainv(x, df1 / 2, df2 / 2) - 1));
            },
            mean: function mean(df1, df2) {
                return df2 > 2 ? df2 / (df2 - 2) : undefined;
            },
            mode: function mode(df1, df2) {
                return df1 > 2 ? df2 * (df1 - 2) / (df1 * (df2 + 2)) : undefined;
            },
            // return a random sample
            sample: function sample(df1, df2) {
                var x1 = jStat.randg(df1 / 2) * 2;
                var x2 = jStat.randg(df2 / 2) * 2;
                return x1 / df1 / (x2 / df2);
            },
            variance: function variance(df1, df2) {
                if (df2 <= 4) return undefined;
                return 2 * df2 * df2 * (df1 + df2 - 2) / (df1 * (df2 - 2) * (df2 - 2) * (df2 - 4));
            }
        });
        // extend cauchy function with static methods
        jStat.extend(jStat.cauchy, {
            pdf: function pdf(x, local, scale) {
                if (scale < 0) {
                    return 0;
                }
                return scale / (Math1.pow(x - local, 2) + Math1.pow(scale, 2)) / Math1.PI;
            },
            cdf: function cdf(x, local, scale) {
                return Math1.atan((x - local) / scale) / Math1.PI + 0.5;
            },
            inv: function(p, local, scale) {
                return local + scale * Math1.tan(Math1.PI * (p - 0.5));
            },
            median: function median(local /*, scale*/ ) {
                return local;
            },
            mode: function mode(local /*, scale*/ ) {
                return local;
            },
            sample: function sample(local, scale) {
                return jStat.randn() * Math1.sqrt(1 / (2 * jStat.randg(0.5))) * scale + local;
            }
        });
        // extend chisquare function with static methods
        jStat.extend(jStat.chisquare, {
            pdf: function pdf(x, dof) {
                if (x < 0) return 0;
                return x === 0 && dof === 2 ? 0.5 : Math1.exp((dof / 2 - 1) * Math1.log(x) - x / 2 - dof / 2 * Math1.log(2) - jStat.gammaln(dof / 2));
            },
            cdf: function cdf(x, dof) {
                if (x < 0) return 0;
                return jStat.lowRegGamma(dof / 2, x / 2);
            },
            inv: function(p, dof) {
                return 2 * jStat.gammapinv(p, 0.5 * dof);
            },
            mean: function(dof) {
                return dof;
            },
            // TODO: this is an approximation (is there a better way?)
            median: function median(dof) {
                return dof * Math1.pow(1 - 2 / (9 * dof), 3);
            },
            mode: function mode(dof) {
                return dof - 2 > 0 ? dof - 2 : 0;
            },
            sample: function sample(dof) {
                return jStat.randg(dof / 2) * 2;
            },
            variance: function variance(dof) {
                return 2 * dof;
            }
        });
        // extend exponential function with static methods
        jStat.extend(jStat.exponential, {
            pdf: function pdf(x, rate) {
                return x < 0 ? 0 : rate * Math1.exp(-rate * x);
            },
            cdf: function cdf(x, rate) {
                return x < 0 ? 0 : 1 - Math1.exp(-rate * x);
            },
            inv: function(p, rate) {
                return -Math1.log(1 - p) / rate;
            },
            mean: function(rate) {
                return 1 / rate;
            },
            median: function(rate) {
                return 1 / rate * Math1.log(2);
            },
            mode: function mode() {
                return 0;
            },
            sample: function sample(rate) {
                return -1 / rate * Math1.log(jStat._random_fn());
            },
            variance: function(rate) {
                return Math1.pow(rate, -2);
            }
        });
        // extend gamma function with static methods
        jStat.extend(jStat.gamma, {
            pdf: function pdf(x, shape, scale) {
                if (x < 0) return 0;
                return x === 0 && shape === 1 ? 1 / scale : Math1.exp((shape - 1) * Math1.log(x) - x / scale - jStat.gammaln(shape) - shape * Math1.log(scale));
            },
            cdf: function cdf(x, shape, scale) {
                if (x < 0) return 0;
                return jStat.lowRegGamma(shape, x / scale);
            },
            inv: function(p, shape, scale) {
                return jStat.gammapinv(p, shape) * scale;
            },
            mean: function(shape, scale) {
                return shape * scale;
            },
            mode: function mode(shape, scale) {
                if (shape > 1) return (shape - 1) * scale;
                return undefined;
            },
            sample: function sample(shape, scale) {
                return jStat.randg(shape) * scale;
            },
            variance: function variance(shape, scale) {
                return shape * scale * scale;
            }
        });
        // extend inverse gamma function with static methods
        jStat.extend(jStat.invgamma, {
            pdf: function pdf(x, shape, scale) {
                if (x <= 0) return 0;
                return Math1.exp(-(shape + 1) * Math1.log(x) - scale / x - jStat.gammaln(shape) + shape * Math1.log(scale));
            },
            cdf: function cdf(x, shape, scale) {
                if (x <= 0) return 0;
                return 1 - jStat.lowRegGamma(shape, scale / x);
            },
            inv: function(p, shape, scale) {
                return scale / jStat.gammapinv(1 - p, shape);
            },
            mean: function(shape, scale) {
                return shape > 1 ? scale / (shape - 1) : undefined;
            },
            mode: function mode(shape, scale) {
                return scale / (shape + 1);
            },
            sample: function sample(shape, scale) {
                return scale / jStat.randg(shape);
            },
            variance: function variance(shape, scale) {
                if (shape <= 2) return undefined;
                return scale * scale / ((shape - 1) * (shape - 1) * (shape - 2));
            }
        });
        // extend kumaraswamy function with static methods
        jStat.extend(jStat.kumaraswamy, {
            pdf: function pdf(x, alpha, beta) {
                if (x === 0 && alpha === 1) return beta;
                else if (x === 1 && beta === 1) return alpha;
                return Math1.exp(Math1.log(alpha) + Math1.log(beta) + (alpha - 1) * Math1.log(x) + (beta - 1) * Math1.log(1 - Math1.pow(x, alpha)));
            },
            cdf: function cdf(x, alpha, beta) {
                if (x < 0) return 0;
                else if (x > 1) return 1;
                return 1 - Math1.pow(1 - Math1.pow(x, alpha), beta);
            },
            inv: function inv(p, alpha, beta) {
                return Math1.pow(1 - Math1.pow(1 - p, 1 / beta), 1 / alpha);
            },
            mean: function(alpha, beta) {
                return beta * jStat.gammafn(1 + 1 / alpha) * jStat.gammafn(beta) / jStat.gammafn(1 + 1 / alpha + beta);
            },
            median: function median(alpha, beta) {
                return Math1.pow(1 - Math1.pow(2, -1 / beta), 1 / alpha);
            },
            mode: function mode(alpha, beta) {
                if (!(alpha >= 1 && beta >= 1 && alpha !== 1 && beta !== 1)) return undefined;
                return Math1.pow((alpha - 1) / (alpha * beta - 1), 1 / alpha);
            },
            variance: function variance() {
                throw new Error("variance not yet implemented");
            // TODO: complete this
            }
        });
        // extend lognormal function with static methods
        jStat.extend(jStat.lognormal, {
            pdf: function pdf(x, mu, sigma) {
                if (x <= 0) return 0;
                return Math1.exp(-Math1.log(x) - 0.5 * Math1.log(2 * Math1.PI) - Math1.log(sigma) - Math1.pow(Math1.log(x) - mu, 2) / (2 * sigma * sigma));
            },
            cdf: function cdf(x, mu, sigma) {
                if (x < 0) return 0;
                return 0.5 + 0.5 * jStat.erf((Math1.log(x) - mu) / Math1.sqrt(2 * sigma * sigma));
            },
            inv: function(p, mu, sigma) {
                return Math1.exp(-1.41421356237309505 * sigma * jStat.erfcinv(2 * p) + mu);
            },
            mean: function mean(mu, sigma) {
                return Math1.exp(mu + sigma * sigma / 2);
            },
            median: function median(mu /*, sigma*/ ) {
                return Math1.exp(mu);
            },
            mode: function mode(mu, sigma) {
                return Math1.exp(mu - sigma * sigma);
            },
            sample: function sample(mu, sigma) {
                return Math1.exp(jStat.randn() * sigma + mu);
            },
            variance: function variance(mu, sigma) {
                return (Math1.exp(sigma * sigma) - 1) * Math1.exp(2 * mu + sigma * sigma);
            }
        });
        // extend noncentralt function with static methods
        jStat.extend(jStat.noncentralt, {
            pdf: function pdf(x, dof, ncp) {
                var tol = 1e-14;
                if (Math1.abs(ncp) < tol) return jStat.studentt.pdf(x, dof);
                if (Math1.abs(x) < tol) {
                    return Math1.exp(jStat.gammaln((dof + 1) / 2) - ncp * ncp / 2 - 0.5 * Math1.log(Math1.PI * dof) - jStat.gammaln(dof / 2));
                }
                // formula for x != 0
                return dof / x * (jStat.noncentralt.cdf(x * Math1.sqrt(1 + 2 / dof), dof + 2, ncp) - jStat.noncentralt.cdf(x, dof, ncp));
            },
            cdf: function cdf(x, dof, ncp) {
                var tol = 1e-14;
                var min_iterations = 200;
                if (Math1.abs(ncp) < tol) return jStat.studentt.cdf(x, dof);
                // turn negative x into positive and flip result afterwards
                var flip = false;
                if (x < 0) {
                    flip = true;
                    ncp = -ncp;
                }
                var prob = jStat.normal.cdf(-ncp, 0, 1);
                var value = tol + 1;
                // use value at last two steps to determine convergence
                var lastvalue = value;
                var y = x * x / (x * x + dof);
                var j = 0;
                var p = Math1.exp(-ncp * ncp / 2);
                var q = Math1.exp(-ncp * ncp / 2 - 0.5 * Math1.log(2) - jStat.gammaln(3 / 2)) * ncp;
                while(j < min_iterations || lastvalue > tol || value > tol){
                    lastvalue = value;
                    if (j > 0) {
                        p *= ncp * ncp / (2 * j);
                        q *= ncp * ncp / (2 * (j + 1 / 2));
                    }
                    value = p * jStat.beta.cdf(y, j + 0.5, dof / 2) + q * jStat.beta.cdf(y, j + 1, dof / 2);
                    prob += 0.5 * value;
                    j++;
                }
                return flip ? 1 - prob : prob;
            }
        });
        // extend normal function with static methods
        jStat.extend(jStat.normal, {
            pdf: function pdf(x, mean, std) {
                return Math1.exp(-0.5 * Math1.log(2 * Math1.PI) - Math1.log(std) - Math1.pow(x - mean, 2) / (2 * std * std));
            },
            cdf: function cdf(x, mean, std) {
                return 0.5 * (1 + jStat.erf((x - mean) / Math1.sqrt(2 * std * std)));
            },
            inv: function(p, mean, std) {
                return -1.41421356237309505 * std * jStat.erfcinv(2 * p) + mean;
            },
            mean: function(mean /*, std*/ ) {
                return mean;
            },
            median: function median(mean /*, std*/ ) {
                return mean;
            },
            mode: function(mean /*, std*/ ) {
                return mean;
            },
            sample: function sample(mean, std) {
                return jStat.randn() * std + mean;
            },
            variance: function(mean, std) {
                return std * std;
            }
        });
        // extend pareto function with static methods
        jStat.extend(jStat.pareto, {
            pdf: function pdf(x, scale, shape) {
                if (x < scale) return 0;
                return shape * Math1.pow(scale, shape) / Math1.pow(x, shape + 1);
            },
            cdf: function cdf(x, scale, shape) {
                if (x < scale) return 0;
                return 1 - Math1.pow(scale / x, shape);
            },
            inv: function inv(p, scale, shape) {
                return scale / Math1.pow(1 - p, 1 / shape);
            },
            mean: function mean(scale, shape) {
                if (shape <= 1) return undefined;
                return shape * Math1.pow(scale, shape) / (shape - 1);
            },
            median: function median(scale, shape) {
                return scale * (shape * Math1.SQRT2);
            },
            mode: function mode(scale /*, shape*/ ) {
                return scale;
            },
            variance: function(scale, shape) {
                if (shape <= 2) return undefined;
                return scale * scale * shape / (Math1.pow(shape - 1, 2) * (shape - 2));
            }
        });
        // extend studentt function with static methods
        jStat.extend(jStat.studentt, {
            pdf: function pdf(x, dof) {
                dof = dof > 1e100 ? 1e100 : dof;
                return 1 / (Math1.sqrt(dof) * jStat.betafn(0.5, dof / 2)) * Math1.pow(1 + x * x / dof, -((dof + 1) / 2));
            },
            cdf: function cdf(x, dof) {
                var dof2 = dof / 2;
                return jStat.ibeta((x + Math1.sqrt(x * x + dof)) / (2 * Math1.sqrt(x * x + dof)), dof2, dof2);
            },
            inv: function(p, dof) {
                var x = jStat.ibetainv(2 * Math1.min(p, 1 - p), 0.5 * dof, 0.5);
                x = Math1.sqrt(dof * (1 - x) / x);
                return p > 0.5 ? x : -x;
            },
            mean: function mean(dof) {
                return dof > 1 ? 0 : undefined;
            },
            median: function median() {
                return 0;
            },
            mode: function mode() {
                return 0;
            },
            sample: function sample(dof) {
                return jStat.randn() * Math1.sqrt(dof / (2 * jStat.randg(dof / 2)));
            },
            variance: function variance(dof) {
                return dof > 2 ? dof / (dof - 2) : dof > 1 ? Infinity : undefined;
            }
        });
        // extend weibull function with static methods
        jStat.extend(jStat.weibull, {
            pdf: function pdf(x, scale, shape) {
                if (x < 0 || scale < 0 || shape < 0) return 0;
                return shape / scale * Math1.pow(x / scale, shape - 1) * Math1.exp(-Math1.pow(x / scale, shape));
            },
            cdf: function cdf(x, scale, shape) {
                return x < 0 ? 0 : 1 - Math1.exp(-Math1.pow(x / scale, shape));
            },
            inv: function(p, scale, shape) {
                return scale * Math1.pow(-Math1.log(1 - p), 1 / shape);
            },
            mean: function(scale, shape) {
                return scale * jStat.gammafn(1 + 1 / shape);
            },
            median: function median(scale, shape) {
                return scale * Math1.pow(Math1.log(2), 1 / shape);
            },
            mode: function mode(scale, shape) {
                if (shape <= 1) return 0;
                return scale * Math1.pow((shape - 1) / shape, 1 / shape);
            },
            sample: function sample(scale, shape) {
                return scale * Math1.pow(-Math1.log(jStat._random_fn()), 1 / shape);
            },
            variance: function variance(scale, shape) {
                return scale * scale * jStat.gammafn(1 + 2 / shape) - Math1.pow(jStat.weibull.mean(scale, shape), 2);
            }
        });
        // extend uniform function with static methods
        jStat.extend(jStat.uniform, {
            pdf: function pdf(x, a, b) {
                return x < a || x > b ? 0 : 1 / (b - a);
            },
            cdf: function cdf(x, a, b) {
                if (x < a) return 0;
                else if (x < b) return (x - a) / (b - a);
                return 1;
            },
            inv: function(p, a, b) {
                return a + p * (b - a);
            },
            mean: function mean(a, b) {
                return 0.5 * (a + b);
            },
            median: function median(a, b) {
                return jStat.mean(a, b);
            },
            mode: function mode() {
                throw new Error("mode is not yet implemented");
            },
            sample: function sample(a, b) {
                return a / 2 + b / 2 + (b / 2 - a / 2) * (2 * jStat._random_fn() - 1);
            },
            variance: function variance(a, b) {
                return Math1.pow(b - a, 2) / 12;
            }
        });
        // Got this from http://www.math.ucla.edu/~tom/distributions/binomial.html
        function betinc(x, a, b, eps) {
            var a0 = 0;
            var b0 = 1;
            var a1 = 1;
            var b1 = 1;
            var m9 = 0;
            var a2 = 0;
            var c9;
            while(Math1.abs((a1 - a2) / a1) > eps){
                a2 = a1;
                c9 = -(a + m9) * (a + b + m9) * x / (a + 2 * m9) / (a + 2 * m9 + 1);
                a0 = a1 + c9 * a0;
                b0 = b1 + c9 * b0;
                m9 = m9 + 1;
                c9 = m9 * (b - m9) * x / (a + 2 * m9 - 1) / (a + 2 * m9);
                a1 = a0 + c9 * a1;
                b1 = b0 + c9 * b1;
                a0 = a0 / b1;
                b0 = b0 / b1;
                a1 = a1 / b1;
                b1 = 1;
            }
            return a1 / a;
        }
        // extend uniform function with static methods
        jStat.extend(jStat.binomial, {
            pdf: function pdf(k, n, p) {
                return p === 0 || p === 1 ? n * p === k ? 1 : 0 : jStat.combination(n, k) * Math1.pow(p, k) * Math1.pow(1 - p, n - k);
            },
            cdf: function cdf(x, n, p) {
                var betacdf;
                var eps = 1e-10;
                if (x < 0) return 0;
                if (x >= n) return 1;
                if (p < 0 || p > 1 || n <= 0) return NaN;
                x = Math1.floor(x);
                var z = p;
                var a = x + 1;
                var b = n - x;
                var s = a + b;
                var bt = Math1.exp(jStat.gammaln(s) - jStat.gammaln(b) - jStat.gammaln(a) + a * Math1.log(z) + b * Math1.log(1 - z));
                if (z < (a + 1) / (s + 2)) betacdf = bt * betinc(z, a, b, eps);
                else betacdf = 1 - bt * betinc(1 - z, b, a, eps);
                return Math1.round((1 - betacdf) * (1 / eps)) / (1 / eps);
            }
        });
        // extend uniform function with static methods
        jStat.extend(jStat.negbin, {
            pdf: function pdf(k, r, p) {
                if (k !== k >>> 0) return false;
                if (k < 0) return 0;
                return jStat.combination(k + r - 1, r - 1) * Math1.pow(1 - p, k) * Math1.pow(p, r);
            },
            cdf: function cdf(x, r, p) {
                var sum = 0, k = 0;
                if (x < 0) return 0;
                for(; k <= x; k++){
                    sum += jStat.negbin.pdf(k, r, p);
                }
                return sum;
            }
        });
        // extend uniform function with static methods
        jStat.extend(jStat.hypgeom, {
            pdf: function pdf(k, N, m, n) {
                // Hypergeometric PDF.
                // A simplification of the CDF algorithm below.
                // k = number of successes drawn
                // N = population size
                // m = number of successes in population
                // n = number of items drawn from population
                if (k !== k | 0) {
                    return false;
                } else if (k < 0 || k < m - (N - n)) {
                    // It's impossible to have this few successes drawn.
                    return 0;
                } else if (k > n || k > m) {
                    // It's impossible to have this many successes drawn.
                    return 0;
                } else if (m * 2 > N) {
                    // More than half the population is successes.
                    if (n * 2 > N) {
                        // More than half the population is sampled.
                        return jStat.hypgeom.pdf(N - m - n + k, N, N - m, N - n);
                    } else {
                        // Half or less of the population is sampled.
                        return jStat.hypgeom.pdf(n - k, N, N - m, n);
                    }
                } else if (n * 2 > N) {
                    // Half or less is successes.
                    return jStat.hypgeom.pdf(m - k, N, m, N - n);
                } else if (m < n) {
                    // We want to have the number of things sampled to be less than the
                    // successes available. So swap the definitions of successful and sampled.
                    return jStat.hypgeom.pdf(k, N, n, m);
                } else {
                    // If we get here, half or less of the population was sampled, half or
                    // less of it was successes, and we had fewer sampled things than
                    // successes. Now we can do this complicated iterative algorithm in an
                    // efficient way.
                    // The basic premise of the algorithm is that we partially normalize our
                    // intermediate product to keep it in a numerically good region, and then
                    // finish the normalization at the end.
                    // This variable holds the scaled probability of the current number of
                    // successes.
                    var scaledPDF = 1;
                    // This keeps track of how much we have normalized.
                    var samplesDone = 0;
                    for(var i = 0; i < k; i++){
                        // For every possible number of successes up to that observed...
                        while(scaledPDF > 1 && samplesDone < n){
                            // Intermediate result is growing too big. Apply some of the
                            // normalization to shrink everything.
                            scaledPDF *= 1 - m / (N - samplesDone);
                            // Say we've normalized by this sample already.
                            samplesDone++;
                        }
                        // Work out the partially-normalized hypergeometric PDF for the next
                        // number of successes
                        scaledPDF *= (n - i) * (m - i) / ((i + 1) * (N - m - n + i + 1));
                    }
                    for(; samplesDone < n; samplesDone++){
                        // Apply all the rest of the normalization
                        scaledPDF *= 1 - m / (N - samplesDone);
                    }
                    // Bound answer sanely before returning.
                    return Math1.min(1, Math1.max(0, scaledPDF));
                }
            },
            cdf: function cdf(x, N, m, n) {
                // Hypergeometric CDF.
                // This algorithm is due to Prof. Thomas S. Ferguson, <tom@math.ucla.edu>,
                // and comes from his hypergeometric test calculator at
                // <http://www.math.ucla.edu/~tom/distributions/Hypergeometric.html>.
                // x = number of successes drawn
                // N = population size
                // m = number of successes in population
                // n = number of items drawn from population
                if (x < 0 || x < m - (N - n)) {
                    // It's impossible to have this few successes drawn or fewer.
                    return 0;
                } else if (x >= n || x >= m) {
                    // We will always have this many successes or fewer.
                    return 1;
                } else if (m * 2 > N) {
                    // More than half the population is successes.
                    if (n * 2 > N) {
                        // More than half the population is sampled.
                        return jStat.hypgeom.cdf(N - m - n + x, N, N - m, N - n);
                    } else {
                        // Half or less of the population is sampled.
                        return 1 - jStat.hypgeom.cdf(n - x - 1, N, N - m, n);
                    }
                } else if (n * 2 > N) {
                    // Half or less is successes.
                    return 1 - jStat.hypgeom.cdf(m - x - 1, N, m, N - n);
                } else if (m < n) {
                    // We want to have the number of things sampled to be less than the
                    // successes available. So swap the definitions of successful and sampled.
                    return jStat.hypgeom.cdf(x, N, n, m);
                } else {
                    // If we get here, half or less of the population was sampled, half or
                    // less of it was successes, and we had fewer sampled things than
                    // successes. Now we can do this complicated iterative algorithm in an
                    // efficient way.
                    // The basic premise of the algorithm is that we partially normalize our
                    // intermediate sum to keep it in a numerically good region, and then
                    // finish the normalization at the end.
                    // Holds the intermediate, scaled total CDF.
                    var scaledCDF = 1;
                    // This variable holds the scaled probability of the current number of
                    // successes.
                    var scaledPDF = 1;
                    // This keeps track of how much we have normalized.
                    var samplesDone = 0;
                    for(var i = 0; i < x; i++){
                        // For every possible number of successes up to that observed...
                        while(scaledCDF > 1 && samplesDone < n){
                            // Intermediate result is growing too big. Apply some of the
                            // normalization to shrink everything.
                            var factor = 1 - m / (N - samplesDone);
                            scaledPDF *= factor;
                            scaledCDF *= factor;
                            // Say we've normalized by this sample already.
                            samplesDone++;
                        }
                        // Work out the partially-normalized hypergeometric PDF for the next
                        // number of successes
                        scaledPDF *= (n - i) * (m - i) / ((i + 1) * (N - m - n + i + 1));
                        // Add to the CDF answer.
                        scaledCDF += scaledPDF;
                    }
                    for(; samplesDone < n; samplesDone++){
                        // Apply all the rest of the normalization
                        scaledCDF *= 1 - m / (N - samplesDone);
                    }
                    // Bound answer sanely before returning.
                    return Math1.min(1, Math1.max(0, scaledCDF));
                }
            }
        });
        // extend uniform function with static methods
        jStat.extend(jStat.poisson, {
            pdf: function pdf(k, l) {
                if (l < 0 || k % 1 !== 0 || k < 0) {
                    return 0;
                }
                return Math1.pow(l, k) * Math1.exp(-l) / jStat.factorial(k);
            },
            cdf: function cdf(x, l) {
                var sumarr = [], k = 0;
                if (x < 0) return 0;
                for(; k <= x; k++){
                    sumarr.push(jStat.poisson.pdf(k, l));
                }
                return jStat.sum(sumarr);
            },
            mean: function(l) {
                return l;
            },
            variance: function(l) {
                return l;
            },
            sampleSmall: function sampleSmall(l) {
                var p = 1, k = 0, L = Math1.exp(-l);
                do {
                    k++;
                    p *= jStat._random_fn();
                }while (p > L);
                return k - 1;
            },
            sampleLarge: function sampleLarge(l) {
                var lam = l;
                var k;
                var U, V, slam, loglam, a, b, invalpha, vr, us;
                slam = Math1.sqrt(lam);
                loglam = Math1.log(lam);
                b = 0.931 + 2.53 * slam;
                a = -0.059 + 0.02483 * b;
                invalpha = 1.1239 + 1.1328 / (b - 3.4);
                vr = 0.9277 - 3.6224 / (b - 2);
                while(1){
                    U = Math1.random() - 0.5;
                    V = Math1.random();
                    us = 0.5 - Math1.abs(U);
                    k = Math1.floor((2 * a / us + b) * U + lam + 0.43);
                    if (us >= 0.07 && V <= vr) {
                        return k;
                    }
                    if (k < 0 || us < 0.013 && V > us) {
                        continue;
                    }
                    /* log(V) == log(0.0) ok here */ /* if U==0.0 so that us==0.0, log is ok since always returns */ if (Math1.log(V) + Math1.log(invalpha) - Math1.log(a / (us * us) + b) <= -lam + k * loglam - jStat.loggam(k + 1)) {
                        return k;
                    }
                }
            },
            sample: function sample(l) {
                if (l < 10) return this.sampleSmall(l);
                else return this.sampleLarge(l);
            }
        });
        // extend triangular function with static methods
        jStat.extend(jStat.triangular, {
            pdf: function pdf(x, a, b, c) {
                if (b <= a || c < a || c > b) {
                    return NaN;
                } else {
                    if (x < a || x > b) {
                        return 0;
                    } else if (x < c) {
                        return 2 * (x - a) / ((b - a) * (c - a));
                    } else if (x === c) {
                        return 2 / (b - a);
                    } else {
                        return 2 * (b - x) / ((b - a) * (b - c));
                    }
                }
            },
            cdf: function cdf(x, a, b, c) {
                if (b <= a || c < a || c > b) return NaN;
                if (x <= a) return 0;
                else if (x >= b) return 1;
                if (x <= c) return Math1.pow(x - a, 2) / ((b - a) * (c - a));
                else return 1 - Math1.pow(b - x, 2) / ((b - a) * (b - c));
            },
            inv: function inv(p, a, b, c) {
                if (b <= a || c < a || c > b) {
                    return NaN;
                } else {
                    if (p <= (c - a) / (b - a)) {
                        return a + (b - a) * Math1.sqrt(p * ((c - a) / (b - a)));
                    } else {
                        return a + (b - a) * (1 - Math1.sqrt((1 - p) * (1 - (c - a) / (b - a))));
                    }
                }
            },
            mean: function mean(a, b, c) {
                return (a + b + c) / 3;
            },
            median: function median(a, b, c) {
                if (c <= (a + b) / 2) {
                    return b - Math1.sqrt((b - a) * (b - c)) / Math1.sqrt(2);
                } else if (c > (a + b) / 2) {
                    return a + Math1.sqrt((b - a) * (c - a)) / Math1.sqrt(2);
                }
            },
            mode: function mode(a, b, c) {
                return c;
            },
            sample: function sample(a, b, c) {
                var u = jStat._random_fn();
                if (u < (c - a) / (b - a)) return a + Math1.sqrt(u * (b - a) * (c - a));
                return b - Math1.sqrt((1 - u) * (b - a) * (b - c));
            },
            variance: function variance(a, b, c) {
                return (a * a + b * b + c * c - a * b - a * c - b * c) / 18;
            }
        });
        // extend arcsine function with static methods
        jStat.extend(jStat.arcsine, {
            pdf: function pdf(x, a, b) {
                if (b <= a) return NaN;
                return x <= a || x >= b ? 0 : 2 / Math1.PI * Math1.pow(Math1.pow(b - a, 2) - Math1.pow(2 * x - a - b, 2), -0.5);
            },
            cdf: function cdf(x, a, b) {
                if (x < a) return 0;
                else if (x < b) return 2 / Math1.PI * Math1.asin(Math1.sqrt((x - a) / (b - a)));
                return 1;
            },
            inv: function(p, a, b) {
                return a + (0.5 - 0.5 * Math1.cos(Math1.PI * p)) * (b - a);
            },
            mean: function mean(a, b) {
                if (b <= a) return NaN;
                return (a + b) / 2;
            },
            median: function median(a, b) {
                if (b <= a) return NaN;
                return (a + b) / 2;
            },
            mode: function mode() {
                throw new Error("mode is not yet implemented");
            },
            sample: function sample(a, b) {
                return (a + b) / 2 + (b - a) / 2 * Math1.sin(2 * Math1.PI * jStat.uniform.sample(0, 1));
            },
            variance: function variance(a, b) {
                if (b <= a) return NaN;
                return Math1.pow(b - a, 2) / 8;
            }
        });
        function laplaceSign(x) {
            return x / Math1.abs(x);
        }
        jStat.extend(jStat.laplace, {
            pdf: function pdf(x, mu, b) {
                return b <= 0 ? 0 : Math1.exp(-Math1.abs(x - mu) / b) / (2 * b);
            },
            cdf: function cdf(x, mu, b) {
                if (b <= 0) {
                    return 0;
                }
                if (x < mu) {
                    return 0.5 * Math1.exp((x - mu) / b);
                } else {
                    return 1 - 0.5 * Math1.exp(-(x - mu) / b);
                }
            },
            mean: function(mu /*, b*/ ) {
                return mu;
            },
            median: function(mu /*, b*/ ) {
                return mu;
            },
            mode: function(mu /*, b*/ ) {
                return mu;
            },
            variance: function(mu, b) {
                return 2 * b * b;
            },
            sample: function sample(mu, b) {
                var u = jStat._random_fn() - 0.5;
                return mu - b * laplaceSign(u) * Math1.log(1 - 2 * Math1.abs(u));
            }
        });
        function tukeyWprob(w, rr, cc) {
            var nleg = 12;
            var ihalf = 6;
            var C1 = -30;
            var C2 = -50;
            var C3 = 60;
            var bb = 8;
            var wlar = 3;
            var wincr1 = 2;
            var wincr2 = 3;
            var xleg = [
                0.981560634246719250690549090149,
                0.904117256370474856678465866119,
                0.769902674194304687036893833213,
                0.587317954286617447296702418941,
                0.367831498998180193752691536644,
                0.125233408511468915472441369464
            ];
            var aleg = [
                0.047175336386511827194615961485,
                0.106939325995318430960254718194,
                0.160078328543346226334652529543,
                0.203167426723065921749064455810,
                0.233492536538354808760849898925,
                0.249147045813402785000562436043
            ];
            var qsqz = w * 0.5;
            // if w >= 16 then the integral lower bound (occurs for c=20)
            // is 0.99999999999995 so return a value of 1.
            if (qsqz >= bb) return 1.0;
            // find (f(w/2) - 1) ^ cc
            // (first term in integral of hartley's form).
            var pr_w = 2 * jStat.normal.cdf(qsqz, 0, 1, 1, 0) - 1; // erf(qsqz / M_SQRT2)
            // if pr_w ^ cc < 2e-22 then set pr_w = 0
            if (pr_w >= Math1.exp(C2 / cc)) pr_w = Math1.pow(pr_w, cc);
            else pr_w = 0.0;
            // if w is large then the second component of the
            // integral is small, so fewer intervals are needed.
            var wincr;
            if (w > wlar) wincr = wincr1;
            else wincr = wincr2;
            // find the integral of second term of hartley's form
            // for the integral of the range for equal-length
            // intervals using legendre quadrature.  limits of
            // integration are from (w/2, 8).  two or three
            // equal-length intervals are used.
            // blb and bub are lower and upper limits of integration.
            var blb = qsqz;
            var binc = (bb - qsqz) / wincr;
            var bub = blb + binc;
            var einsum = 0.0;
            // integrate over each interval
            var cc1 = cc - 1.0;
            for(var wi = 1; wi <= wincr; wi++){
                var elsum = 0.0;
                var a = 0.5 * (bub + blb);
                // legendre quadrature with order = nleg
                var b = 0.5 * (bub - blb);
                for(var jj = 1; jj <= nleg; jj++){
                    var j, xx;
                    if (ihalf < jj) {
                        j = nleg - jj + 1;
                        xx = xleg[j - 1];
                    } else {
                        j = jj;
                        xx = -xleg[j - 1];
                    }
                    var c = b * xx;
                    var ac = a + c;
                    // if exp(-qexpo/2) < 9e-14,
                    // then doesn't contribute to integral
                    var qexpo = ac * ac;
                    if (qexpo > C3) break;
                    var pplus = 2 * jStat.normal.cdf(ac, 0, 1, 1, 0);
                    var pminus = 2 * jStat.normal.cdf(ac, w, 1, 1, 0);
                    // if rinsum ^ (cc-1) < 9e-14,
                    // then doesn't contribute to integral
                    var rinsum = pplus * 0.5 - pminus * 0.5;
                    if (rinsum >= Math1.exp(C1 / cc1)) {
                        rinsum = aleg[j - 1] * Math1.exp(-(0.5 * qexpo)) * Math1.pow(rinsum, cc1);
                        elsum += rinsum;
                    }
                }
                elsum *= 2.0 * b * cc / Math1.sqrt(2 * Math1.PI);
                einsum += elsum;
                blb = bub;
                bub += binc;
            }
            // if pr_w ^ rr < 9e-14, then return 0
            pr_w += einsum;
            if (pr_w <= Math1.exp(C1 / rr)) return 0;
            pr_w = Math1.pow(pr_w, rr);
            if (pr_w >= 1) return 1;
            return pr_w;
        }
        function tukeyQinv(p, c, v) {
            var p0 = 0.322232421088;
            var q0 = 0.993484626060e-01;
            var p1 = -1.0;
            var q1 = 0.588581570495;
            var p2 = -0.342242088547;
            var q2 = 0.531103462366;
            var p3 = -0.204231210125;
            var q3 = 0.103537752850;
            var p4 = -0.453642210148e-04;
            var q4 = 0.38560700634e-02;
            var c1 = 0.8832;
            var c2 = 0.2368;
            var c3 = 1.214;
            var c4 = 1.208;
            var c5 = 1.4142;
            var vmax = 120.0;
            var ps = 0.5 - 0.5 * p;
            var yi = Math1.sqrt(Math1.log(1.0 / (ps * ps)));
            var t = yi + ((((yi * p4 + p3) * yi + p2) * yi + p1) * yi + p0) / ((((yi * q4 + q3) * yi + q2) * yi + q1) * yi + q0);
            if (v < vmax) t += (t * t * t + t) / v / 4.0;
            var q = c1 - c2 * t;
            if (v < vmax) q += -c3 / v + c4 * t / v;
            return t * (q * Math1.log(c - 1.0) + c5);
        }
        jStat.extend(jStat.tukey, {
            cdf: function cdf(q, nmeans, df) {
                // Identical implementation as the R ptukey() function as of commit 68947
                var rr = 1;
                var cc = nmeans;
                var nlegq = 16;
                var ihalfq = 8;
                var eps1 = -30.0;
                var eps2 = 1.0e-14;
                var dhaf = 100.0;
                var dquar = 800.0;
                var deigh = 5000.0;
                var dlarg = 25000.0;
                var ulen1 = 1.0;
                var ulen2 = 0.5;
                var ulen3 = 0.25;
                var ulen4 = 0.125;
                var xlegq = [
                    0.989400934991649932596154173450,
                    0.944575023073232576077988415535,
                    0.865631202387831743880467897712,
                    0.755404408355003033895101194847,
                    0.617876244402643748446671764049,
                    0.458016777657227386342419442984,
                    0.281603550779258913230460501460,
                    0.950125098376374401853193354250e-1
                ];
                var alegq = [
                    0.271524594117540948517805724560e-1,
                    0.622535239386478928628438369944e-1,
                    0.951585116824927848099251076022e-1,
                    0.124628971255533872052476282192,
                    0.149595988816576732081501730547,
                    0.169156519395002538189312079030,
                    0.182603415044923588866763667969,
                    0.189450610455068496285396723208
                ];
                if (q <= 0) return 0;
                // df must be > 1
                // there must be at least two values
                if (df < 2 || rr < 1 || cc < 2) return NaN;
                if (!Number.isFinite(q)) return 1;
                if (df > dlarg) return tukeyWprob(q, rr, cc);
                // calculate leading constant
                var f2 = df * 0.5;
                var f2lf = f2 * Math1.log(df) - df * Math1.log(2) - jStat.gammaln(f2);
                var f21 = f2 - 1.0;
                // integral is divided into unit, half-unit, quarter-unit, or
                // eighth-unit length intervals depending on the value of the
                // degrees of freedom.
                var ff4 = df * 0.25;
                var ulen;
                if (df <= dhaf) ulen = ulen1;
                else if (df <= dquar) ulen = ulen2;
                else if (df <= deigh) ulen = ulen3;
                else ulen = ulen4;
                f2lf += Math1.log(ulen);
                // integrate over each subinterval
                var ans = 0.0;
                for(var i = 1; i <= 50; i++){
                    var otsum = 0.0;
                    // legendre quadrature with order = nlegq
                    // nodes (stored in xlegq) are symmetric around zero.
                    var twa1 = (2 * i - 1) * ulen;
                    for(var jj = 1; jj <= nlegq; jj++){
                        var j, t1;
                        if (ihalfq < jj) {
                            j = jj - ihalfq - 1;
                            t1 = f2lf + f21 * Math1.log(twa1 + xlegq[j] * ulen) - (xlegq[j] * ulen + twa1) * ff4;
                        } else {
                            j = jj - 1;
                            t1 = f2lf + f21 * Math1.log(twa1 - xlegq[j] * ulen) + (xlegq[j] * ulen - twa1) * ff4;
                        }
                        // if exp(t1) < 9e-14, then doesn't contribute to integral
                        var qsqz;
                        if (t1 >= eps1) {
                            if (ihalfq < jj) {
                                qsqz = q * Math1.sqrt((xlegq[j] * ulen + twa1) * 0.5);
                            } else {
                                qsqz = q * Math1.sqrt((-(xlegq[j] * ulen) + twa1) * 0.5);
                            }
                            // call wprob to find integral of range portion
                            var wprb = tukeyWprob(qsqz, rr, cc);
                            var rotsum = wprb * alegq[j] * Math1.exp(t1);
                            otsum += rotsum;
                        }
                    // end legendre integral for interval i
                    // L200:
                    }
                    // if integral for interval i < 1e-14, then stop.
                    // However, in order to avoid small area under left tail,
                    // at least  1 / ulen  intervals are calculated.
                    if (i * ulen >= 1.0 && otsum <= eps2) break;
                    // end of interval i
                    // L330:
                    ans += otsum;
                }
                if (otsum > eps2) {
                    throw new Error("tukey.cdf failed to converge");
                }
                if (ans > 1) ans = 1;
                return ans;
            },
            inv: function(p, nmeans, df) {
                // Identical implementation as the R qtukey() function as of commit 68947
                var rr = 1;
                var cc = nmeans;
                var eps = 0.0001;
                var maxiter = 50;
                // df must be > 1 ; there must be at least two values
                if (df < 2 || rr < 1 || cc < 2) return NaN;
                if (p < 0 || p > 1) return NaN;
                if (p === 0) return 0;
                if (p === 1) return Infinity;
                // Initial value
                var x0 = tukeyQinv(p, cc, df);
                // Find prob(value < x0)
                var valx0 = jStat.tukey.cdf(x0, nmeans, df) - p;
                // Find the second iterate and prob(value < x1).
                // If the first iterate has probability value
                // exceeding p then second iterate is 1 less than
                // first iterate; otherwise it is 1 greater.
                var x1;
                if (valx0 > 0.0) x1 = Math1.max(0.0, x0 - 1.0);
                else x1 = x0 + 1.0;
                var valx1 = jStat.tukey.cdf(x1, nmeans, df) - p;
                // Find new iterate
                var ans;
                for(var iter = 1; iter < maxiter; iter++){
                    ans = x1 - valx1 * (x1 - x0) / (valx1 - valx0);
                    valx0 = valx1;
                    // New iterate must be >= 0
                    x0 = x1;
                    if (ans < 0.0) {
                        ans = 0.0;
                        valx1 = -p;
                    }
                    // Find prob(value < new iterate)
                    valx1 = jStat.tukey.cdf(ans, nmeans, df) - p;
                    x1 = ans;
                    // If the difference between two successive
                    // iterates is less than eps, stop
                    var xabs = Math1.abs(x1 - x0);
                    if (xabs < eps) return ans;
                }
                throw new Error("tukey.inv failed to converge");
            }
        });
    })(jStat, Math);
    /* Provides functions for the solution of linear system of equations, integration, extrapolation,
 * interpolation, eigenvalue problems, differential equations and PCA analysis. */ (function(jStat, Math1) {
        var push = Array.prototype.push;
        var isArray = jStat.utils.isArray;
        function isUsable(arg) {
            return isArray(arg) || arg instanceof jStat;
        }
        jStat.extend({
            // add a vector/matrix to a vector/matrix or scalar
            add: function add(arr, arg) {
                // check if arg is a vector or scalar
                if (isUsable(arg)) {
                    if (!isUsable(arg[0])) arg = [
                        arg
                    ];
                    return jStat.map(arr, function(value, row, col) {
                        return value + arg[row][col];
                    });
                }
                return jStat.map(arr, function(value) {
                    return value + arg;
                });
            },
            // subtract a vector or scalar from the vector
            subtract: function subtract(arr, arg) {
                // check if arg is a vector or scalar
                if (isUsable(arg)) {
                    if (!isUsable(arg[0])) arg = [
                        arg
                    ];
                    return jStat.map(arr, function(value, row, col) {
                        return value - arg[row][col] || 0;
                    });
                }
                return jStat.map(arr, function(value) {
                    return value - arg;
                });
            },
            // matrix division
            divide: function divide(arr, arg) {
                if (isUsable(arg)) {
                    if (!isUsable(arg[0])) arg = [
                        arg
                    ];
                    return jStat.multiply(arr, jStat.inv(arg));
                }
                return jStat.map(arr, function(value) {
                    return value / arg;
                });
            },
            // matrix multiplication
            multiply: function multiply(arr, arg) {
                var row, col, nrescols, sum, nrow, ncol, res, rescols;
                // eg: arr = 2 arg = 3 -> 6 for res[0][0] statement closure
                if (arr.length === undefined && arg.length === undefined) {
                    return arr * arg;
                }
                nrow = arr.length, ncol = arr[0].length, res = jStat.zeros(nrow, nrescols = isUsable(arg) ? arg[0].length : ncol), rescols = 0;
                if (isUsable(arg)) {
                    for(; rescols < nrescols; rescols++){
                        for(row = 0; row < nrow; row++){
                            sum = 0;
                            for(col = 0; col < ncol; col++)sum += arr[row][col] * arg[col][rescols];
                            res[row][rescols] = sum;
                        }
                    }
                    return nrow === 1 && rescols === 1 ? res[0][0] : res;
                }
                return jStat.map(arr, function(value) {
                    return value * arg;
                });
            },
            // outer([1,2,3],[4,5,6])
            // ===
            // [[1],[2],[3]] times [[4,5,6]]
            // ->
            // [[4,5,6],[8,10,12],[12,15,18]]
            outer: function outer(A, B) {
                return jStat.multiply(A.map(function(t) {
                    return [
                        t
                    ];
                }), [
                    B
                ]);
            },
            // Returns the dot product of two matricies
            dot: function dot(arr, arg) {
                if (!isUsable(arr[0])) arr = [
                    arr
                ];
                if (!isUsable(arg[0])) arg = [
                    arg
                ];
                // convert column to row vector
                var left = arr[0].length === 1 && arr.length !== 1 ? jStat.transpose(arr) : arr, right = arg[0].length === 1 && arg.length !== 1 ? jStat.transpose(arg) : arg, res = [], row = 0, nrow = left.length, ncol = left[0].length, sum, col;
                for(; row < nrow; row++){
                    res[row] = [];
                    sum = 0;
                    for(col = 0; col < ncol; col++)sum += left[row][col] * right[row][col];
                    res[row] = sum;
                }
                return res.length === 1 ? res[0] : res;
            },
            // raise every element by a scalar
            pow: function pow(arr, arg) {
                return jStat.map(arr, function(value) {
                    return Math1.pow(value, arg);
                });
            },
            // exponentiate every element
            exp: function exp(arr) {
                return jStat.map(arr, function(value) {
                    return Math1.exp(value);
                });
            },
            // generate the natural log of every element
            log: function exp(arr) {
                return jStat.map(arr, function(value) {
                    return Math1.log(value);
                });
            },
            // generate the absolute values of the vector
            abs: function abs(arr) {
                return jStat.map(arr, function(value) {
                    return Math1.abs(value);
                });
            },
            // computes the p-norm of the vector
            // In the case that a matrix is passed, uses the first row as the vector
            norm: function norm(arr, p) {
                var nnorm = 0, i = 0;
                // check the p-value of the norm, and set for most common case
                if (isNaN(p)) p = 2;
                // check if multi-dimensional array, and make vector correction
                if (isUsable(arr[0])) arr = arr[0];
                // vector norm
                for(; i < arr.length; i++){
                    nnorm += Math1.pow(Math1.abs(arr[i]), p);
                }
                return Math1.pow(nnorm, 1 / p);
            },
            // computes the angle between two vectors in rads
            // In case a matrix is passed, this uses the first row as the vector
            angle: function angle(arr, arg) {
                return Math1.acos(jStat.dot(arr, arg) / (jStat.norm(arr) * jStat.norm(arg)));
            },
            // augment one matrix by another
            // Note: this function returns a matrix, not a jStat object
            aug: function aug(a, b) {
                var newarr = [];
                var i;
                for(i = 0; i < a.length; i++){
                    newarr.push(a[i].slice());
                }
                for(i = 0; i < newarr.length; i++){
                    push.apply(newarr[i], b[i]);
                }
                return newarr;
            },
            // The inv() function calculates the inverse of a matrix
            // Create the inverse by augmenting the matrix by the identity matrix of the
            // appropriate size, and then use G-J elimination on the augmented matrix.
            inv: function inv(a) {
                var rows = a.length;
                var cols = a[0].length;
                var b = jStat.identity(rows, cols);
                var c = jStat.gauss_jordan(a, b);
                var result = [];
                var i = 0;
                var j;
                //We need to copy the inverse portion to a new matrix to rid G-J artifacts
                for(; i < rows; i++){
                    result[i] = [];
                    for(j = cols; j < c[0].length; j++)result[i][j - cols] = c[i][j];
                }
                return result;
            },
            // calculate the determinant of a matrix
            det: function det(a) {
                if (a.length === 2) {
                    return a[0][0] * a[1][1] - a[0][1] * a[1][0];
                }
                var determinant = 0;
                for(var i = 0; i < a.length; i++){
                    // build a sub matrix without column `i`
                    var submatrix = [];
                    for(var row = 1; row < a.length; row++){
                        submatrix[row - 1] = [];
                        for(var col = 0; col < a.length; col++){
                            if (col < i) {
                                submatrix[row - 1][col] = a[row][col];
                            } else if (col > i) {
                                submatrix[row - 1][col - 1] = a[row][col];
                            }
                        }
                    }
                    // alternate between + and - between determinants
                    var sign = i % 2 ? -1 : 1;
                    determinant += det(submatrix) * a[0][i] * sign;
                }
                return determinant;
            },
            gauss_elimination: function gauss_elimination(a, b) {
                var i = 0, j = 0, n = a.length, m = a[0].length, factor = 1, sum = 0, x = [], maug, pivot, temp, k;
                a = jStat.aug(a, b);
                maug = a[0].length;
                for(i = 0; i < n; i++){
                    pivot = a[i][i];
                    j = i;
                    for(k = i + 1; k < m; k++){
                        if (pivot < Math1.abs(a[k][i])) {
                            pivot = a[k][i];
                            j = k;
                        }
                    }
                    if (j != i) {
                        for(k = 0; k < maug; k++){
                            temp = a[i][k];
                            a[i][k] = a[j][k];
                            a[j][k] = temp;
                        }
                    }
                    for(j = i + 1; j < n; j++){
                        factor = a[j][i] / a[i][i];
                        for(k = i; k < maug; k++){
                            a[j][k] = a[j][k] - factor * a[i][k];
                        }
                    }
                }
                for(i = n - 1; i >= 0; i--){
                    sum = 0;
                    for(j = i + 1; j <= n - 1; j++){
                        sum = sum + x[j] * a[i][j];
                    }
                    x[i] = (a[i][maug - 1] - sum) / a[i][i];
                }
                return x;
            },
            gauss_jordan: function gauss_jordan(a, b) {
                var m = jStat.aug(a, b);
                var h = m.length;
                var w = m[0].length;
                var c = 0;
                var x, y, y2;
                // find max pivot
                for(y = 0; y < h; y++){
                    var maxrow = y;
                    for(y2 = y + 1; y2 < h; y2++){
                        if (Math1.abs(m[y2][y]) > Math1.abs(m[maxrow][y])) maxrow = y2;
                    }
                    var tmp = m[y];
                    m[y] = m[maxrow];
                    m[maxrow] = tmp;
                    for(y2 = y + 1; y2 < h; y2++){
                        c = m[y2][y] / m[y][y];
                        for(x = y; x < w; x++){
                            m[y2][x] -= m[y][x] * c;
                        }
                    }
                }
                // backsubstitute
                for(y = h - 1; y >= 0; y--){
                    c = m[y][y];
                    for(y2 = 0; y2 < y; y2++){
                        for(x = w - 1; x > y - 1; x--){
                            m[y2][x] -= m[y][x] * m[y2][y] / c;
                        }
                    }
                    m[y][y] /= c;
                    for(x = h; x < w; x++){
                        m[y][x] /= c;
                    }
                }
                return m;
            },
            // solve equation
            // Ax=b
            // A is upper triangular matrix
            // A=[[1,2,3],[0,4,5],[0,6,7]]
            // b=[1,2,3]
            // triaUpSolve(A,b) // -> [2.666,0.1666,1.666]
            // if you use matrix style
            // A=[[1,2,3],[0,4,5],[0,6,7]]
            // b=[[1],[2],[3]]
            // will return [[2.666],[0.1666],[1.666]]
            triaUpSolve: function triaUpSolve(A, b) {
                var size = A[0].length;
                var x = jStat.zeros(1, size)[0];
                var parts;
                var matrix_mode = false;
                if (b[0].length != undefined) {
                    b = b.map(function(i) {
                        return i[0];
                    });
                    matrix_mode = true;
                }
                jStat.arange(size - 1, -1, -1).forEach(function(i) {
                    parts = jStat.arange(i + 1, size).map(function(j) {
                        return x[j] * A[i][j];
                    });
                    x[i] = (b[i] - jStat.sum(parts)) / A[i][i];
                });
                if (matrix_mode) return x.map(function(i) {
                    return [
                        i
                    ];
                });
                return x;
            },
            triaLowSolve: function triaLowSolve(A, b) {
                // like to triaUpSolve but A is lower triangular matrix
                var size = A[0].length;
                var x = jStat.zeros(1, size)[0];
                var parts;
                var matrix_mode = false;
                if (b[0].length != undefined) {
                    b = b.map(function(i) {
                        return i[0];
                    });
                    matrix_mode = true;
                }
                jStat.arange(size).forEach(function(i) {
                    parts = jStat.arange(i).map(function(j) {
                        return A[i][j] * x[j];
                    });
                    x[i] = (b[i] - jStat.sum(parts)) / A[i][i];
                });
                if (matrix_mode) return x.map(function(i) {
                    return [
                        i
                    ];
                });
                return x;
            },
            // A -> [L,U]
            // A=LU
            // L is lower triangular matrix
            // U is upper triangular matrix
            lu: function lu(A) {
                var size = A.length;
                //var L=jStat.diagonal(jStat.ones(1,size)[0]);
                var L = jStat.identity(size);
                var R = jStat.zeros(A.length, A[0].length);
                var parts;
                jStat.arange(size).forEach(function(t) {
                    R[0][t] = A[0][t];
                });
                jStat.arange(1, size).forEach(function(l) {
                    jStat.arange(l).forEach(function(i) {
                        parts = jStat.arange(i).map(function(jj) {
                            return L[l][jj] * R[jj][i];
                        });
                        L[l][i] = (A[l][i] - jStat.sum(parts)) / R[i][i];
                    });
                    jStat.arange(l, size).forEach(function(j) {
                        parts = jStat.arange(l).map(function(jj) {
                            return L[l][jj] * R[jj][j];
                        });
                        R[l][j] = A[parts.length][j] - jStat.sum(parts);
                    });
                });
                return [
                    L,
                    R
                ];
            },
            // A -> T
            // A=TT'
            // T is lower triangular matrix
            cholesky: function cholesky(A) {
                var size = A.length;
                var T = jStat.zeros(A.length, A[0].length);
                var parts;
                jStat.arange(size).forEach(function(i) {
                    parts = jStat.arange(i).map(function(t) {
                        return Math1.pow(T[i][t], 2);
                    });
                    T[i][i] = Math1.sqrt(A[i][i] - jStat.sum(parts));
                    jStat.arange(i + 1, size).forEach(function(j) {
                        parts = jStat.arange(i).map(function(t) {
                            return T[i][t] * T[j][t];
                        });
                        T[j][i] = (A[i][j] - jStat.sum(parts)) / T[i][i];
                    });
                });
                return T;
            },
            gauss_jacobi: function gauss_jacobi(a, b, x, r) {
                var i = 0;
                var j = 0;
                var n = a.length;
                var l = [];
                var u = [];
                var d = [];
                var xv, c, h, xk;
                for(; i < n; i++){
                    l[i] = [];
                    u[i] = [];
                    d[i] = [];
                    for(j = 0; j < n; j++){
                        if (i > j) {
                            l[i][j] = a[i][j];
                            u[i][j] = d[i][j] = 0;
                        } else if (i < j) {
                            u[i][j] = a[i][j];
                            l[i][j] = d[i][j] = 0;
                        } else {
                            d[i][j] = a[i][j];
                            l[i][j] = u[i][j] = 0;
                        }
                    }
                }
                h = jStat.multiply(jStat.multiply(jStat.inv(d), jStat.add(l, u)), -1);
                c = jStat.multiply(jStat.inv(d), b);
                xv = x;
                xk = jStat.add(jStat.multiply(h, x), c);
                i = 2;
                while(Math1.abs(jStat.norm(jStat.subtract(xk, xv))) > r){
                    xv = xk;
                    xk = jStat.add(jStat.multiply(h, xv), c);
                    i++;
                }
                return xk;
            },
            gauss_seidel: function gauss_seidel(a, b, x, r) {
                var i = 0;
                var n = a.length;
                var l = [];
                var u = [];
                var d = [];
                var j, xv, c, h, xk;
                for(; i < n; i++){
                    l[i] = [];
                    u[i] = [];
                    d[i] = [];
                    for(j = 0; j < n; j++){
                        if (i > j) {
                            l[i][j] = a[i][j];
                            u[i][j] = d[i][j] = 0;
                        } else if (i < j) {
                            u[i][j] = a[i][j];
                            l[i][j] = d[i][j] = 0;
                        } else {
                            d[i][j] = a[i][j];
                            l[i][j] = u[i][j] = 0;
                        }
                    }
                }
                h = jStat.multiply(jStat.multiply(jStat.inv(jStat.add(d, l)), u), -1);
                c = jStat.multiply(jStat.inv(jStat.add(d, l)), b);
                xv = x;
                xk = jStat.add(jStat.multiply(h, x), c);
                i = 2;
                while(Math1.abs(jStat.norm(jStat.subtract(xk, xv))) > r){
                    xv = xk;
                    xk = jStat.add(jStat.multiply(h, xv), c);
                    i = i + 1;
                }
                return xk;
            },
            SOR: function SOR(a, b, x, r, w) {
                var i = 0;
                var n = a.length;
                var l = [];
                var u = [];
                var d = [];
                var j, xv, c, h, xk;
                for(; i < n; i++){
                    l[i] = [];
                    u[i] = [];
                    d[i] = [];
                    for(j = 0; j < n; j++){
                        if (i > j) {
                            l[i][j] = a[i][j];
                            u[i][j] = d[i][j] = 0;
                        } else if (i < j) {
                            u[i][j] = a[i][j];
                            l[i][j] = d[i][j] = 0;
                        } else {
                            d[i][j] = a[i][j];
                            l[i][j] = u[i][j] = 0;
                        }
                    }
                }
                h = jStat.multiply(jStat.inv(jStat.add(d, jStat.multiply(l, w))), jStat.subtract(jStat.multiply(d, 1 - w), jStat.multiply(u, w)));
                c = jStat.multiply(jStat.multiply(jStat.inv(jStat.add(d, jStat.multiply(l, w))), b), w);
                xv = x;
                xk = jStat.add(jStat.multiply(h, x), c);
                i = 2;
                while(Math1.abs(jStat.norm(jStat.subtract(xk, xv))) > r){
                    xv = xk;
                    xk = jStat.add(jStat.multiply(h, xv), c);
                    i++;
                }
                return xk;
            },
            householder: function householder(a) {
                var m = a.length;
                var n = a[0].length;
                var i = 0;
                var w = [];
                var p = [];
                var alpha, r, k, j, factor;
                for(; i < m - 1; i++){
                    alpha = 0;
                    for(j = i + 1; j < n; j++)alpha += a[j][i] * a[j][i];
                    factor = a[i + 1][i] > 0 ? -1 : 1;
                    alpha = factor * Math1.sqrt(alpha);
                    r = Math1.sqrt((alpha * alpha - a[i + 1][i] * alpha) / 2);
                    w = jStat.zeros(m, 1);
                    w[i + 1][0] = (a[i + 1][i] - alpha) / (2 * r);
                    for(k = i + 2; k < m; k++)w[k][0] = a[k][i] / (2 * r);
                    p = jStat.subtract(jStat.identity(m, n), jStat.multiply(jStat.multiply(w, jStat.transpose(w)), 2));
                    a = jStat.multiply(p, jStat.multiply(a, p));
                }
                return a;
            },
            // A -> [Q,R]
            // Q is orthogonal matrix
            // R is upper triangular
            QR: function() {
                // x -> Q
                // find a orthogonal matrix Q st.
                // Qx=y
                // y is [||x||,0,0,...]
                // quick ref
                var sum = jStat.sum;
                var range = jStat.arange;
                function qr2(x) {
                    // quick impletation
                    // https://www.stat.wisc.edu/~larget/math496/qr.html
                    var n = x.length;
                    var p = x[0].length;
                    var r = jStat.zeros(p, p);
                    x = jStat.copy(x);
                    var i, j, k;
                    for(j = 0; j < p; j++){
                        r[j][j] = Math1.sqrt(sum(range(n).map(function(i) {
                            return x[i][j] * x[i][j];
                        })));
                        for(i = 0; i < n; i++){
                            x[i][j] = x[i][j] / r[j][j];
                        }
                        for(k = j + 1; k < p; k++){
                            r[j][k] = sum(range(n).map(function(i) {
                                return x[i][j] * x[i][k];
                            }));
                            for(i = 0; i < n; i++){
                                x[i][k] = x[i][k] - x[i][j] * r[j][k];
                            }
                        }
                    }
                    return [
                        x,
                        r
                    ];
                }
                return qr2;
            }(),
            lstsq: function() {
                // solve least squard problem for Ax=b as QR decomposition way if b is
                // [[b1],[b2],[b3]] form will return [[x1],[x2],[x3]] array form solution
                // else b is [b1,b2,b3] form will return [x1,x2,x3] array form solution
                function R_I(A) {
                    A = jStat.copy(A);
                    var size = A.length;
                    var I = jStat.identity(size);
                    jStat.arange(size - 1, -1, -1).forEach(function(i) {
                        jStat.sliceAssign(I, {
                            row: i
                        }, jStat.divide(jStat.slice(I, {
                            row: i
                        }), A[i][i]));
                        jStat.sliceAssign(A, {
                            row: i
                        }, jStat.divide(jStat.slice(A, {
                            row: i
                        }), A[i][i]));
                        jStat.arange(i).forEach(function(j) {
                            var c = jStat.multiply(A[j][i], -1);
                            var Aj = jStat.slice(A, {
                                row: j
                            });
                            var cAi = jStat.multiply(jStat.slice(A, {
                                row: i
                            }), c);
                            jStat.sliceAssign(A, {
                                row: j
                            }, jStat.add(Aj, cAi));
                            var Ij = jStat.slice(I, {
                                row: j
                            });
                            var cIi = jStat.multiply(jStat.slice(I, {
                                row: i
                            }), c);
                            jStat.sliceAssign(I, {
                                row: j
                            }, jStat.add(Ij, cIi));
                        });
                    });
                    return I;
                }
                function qr_solve(A, b) {
                    var array_mode = false;
                    if (b[0].length === undefined) {
                        // [c1,c2,c3] mode
                        b = b.map(function(x) {
                            return [
                                x
                            ];
                        });
                        array_mode = true;
                    }
                    var QR = jStat.QR(A);
                    var Q = QR[0];
                    var R = QR[1];
                    var attrs = A[0].length;
                    var Q1 = jStat.slice(Q, {
                        col: {
                            end: attrs
                        }
                    });
                    var R1 = jStat.slice(R, {
                        row: {
                            end: attrs
                        }
                    });
                    var RI = R_I(R1);
                    var Q2 = jStat.transpose(Q1);
                    if (Q2[0].length === undefined) {
                        Q2 = [
                            Q2
                        ]; // The confusing jStat.multifly implementation threat nature process again.
                    }
                    var x = jStat.multiply(jStat.multiply(RI, Q2), b);
                    if (x.length === undefined) {
                        x = [
                            [
                                x
                            ]
                        ]; // The confusing jStat.multifly implementation threat nature process again.
                    }
                    if (array_mode) return x.map(function(i) {
                        return i[0];
                    });
                    return x;
                }
                return qr_solve;
            }(),
            jacobi: function jacobi(a) {
                var condition = 1;
                var n = a.length;
                var e = jStat.identity(n, n);
                var ev = [];
                var b, i, j, p, q, maxim, theta, s;
                // condition === 1 only if tolerance is not reached
                while(condition === 1){
                    maxim = a[0][1];
                    p = 0;
                    q = 1;
                    for(i = 0; i < n; i++){
                        for(j = 0; j < n; j++){
                            if (i != j) {
                                if (maxim < Math1.abs(a[i][j])) {
                                    maxim = Math1.abs(a[i][j]);
                                    p = i;
                                    q = j;
                                }
                            }
                        }
                    }
                    if (a[p][p] === a[q][q]) theta = a[p][q] > 0 ? Math1.PI / 4 : -Math1.PI / 4;
                    else theta = Math1.atan(2 * a[p][q] / (a[p][p] - a[q][q])) / 2;
                    s = jStat.identity(n, n);
                    s[p][p] = Math1.cos(theta);
                    s[p][q] = -Math1.sin(theta);
                    s[q][p] = Math1.sin(theta);
                    s[q][q] = Math1.cos(theta);
                    // eigen vector matrix
                    e = jStat.multiply(e, s);
                    b = jStat.multiply(jStat.multiply(jStat.inv(s), a), s);
                    a = b;
                    condition = 0;
                    for(i = 1; i < n; i++){
                        for(j = 1; j < n; j++){
                            if (i != j && Math1.abs(a[i][j]) > 0.001) {
                                condition = 1;
                            }
                        }
                    }
                }
                for(i = 0; i < n; i++)ev.push(a[i][i]);
                //returns both the eigenvalue and eigenmatrix
                return [
                    e,
                    ev
                ];
            },
            rungekutta: function rungekutta(f, h, p, t_j, u_j, order) {
                var k1, k2, u_j1, k3, k4;
                if (order === 2) {
                    while(t_j <= p){
                        k1 = h * f(t_j, u_j);
                        k2 = h * f(t_j + h, u_j + k1);
                        u_j1 = u_j + (k1 + k2) / 2;
                        u_j = u_j1;
                        t_j = t_j + h;
                    }
                }
                if (order === 4) {
                    while(t_j <= p){
                        k1 = h * f(t_j, u_j);
                        k2 = h * f(t_j + h / 2, u_j + k1 / 2);
                        k3 = h * f(t_j + h / 2, u_j + k2 / 2);
                        k4 = h * f(t_j + h, u_j + k3);
                        u_j1 = u_j + (k1 + 2 * k2 + 2 * k3 + k4) / 6;
                        u_j = u_j1;
                        t_j = t_j + h;
                    }
                }
                return u_j;
            },
            romberg: function romberg(f, a, b, order) {
                var i = 0;
                var h = (b - a) / 2;
                var x = [];
                var h1 = [];
                var g = [];
                var m, a1, j, k, I;
                while(i < order / 2){
                    I = f(a);
                    for(j = a, k = 0; j <= b; j = j + h, k++)x[k] = j;
                    m = x.length;
                    for(j = 1; j < m - 1; j++){
                        I += (j % 2 !== 0 ? 4 : 2) * f(x[j]);
                    }
                    I = h / 3 * (I + f(b));
                    g[i] = I;
                    h /= 2;
                    i++;
                }
                a1 = g.length;
                m = 1;
                while(a1 !== 1){
                    for(j = 0; j < a1 - 1; j++)h1[j] = (Math1.pow(4, m) * g[j + 1] - g[j]) / (Math1.pow(4, m) - 1);
                    a1 = h1.length;
                    g = h1;
                    h1 = [];
                    m++;
                }
                return g;
            },
            richardson: function richardson(X, f, x, h) {
                function pos(X, x) {
                    var i = 0;
                    var n = X.length;
                    var p;
                    for(; i < n; i++)if (X[i] === x) p = i;
                    return p;
                }
                var h_min = Math1.abs(x - X[pos(X, x) + 1]);
                var i = 0;
                var g = [];
                var h1 = [];
                var y1, y2, m, a, j;
                while(h >= h_min){
                    y1 = pos(X, x + h);
                    y2 = pos(X, x);
                    g[i] = (f[y1] - 2 * f[y2] + f[2 * y2 - y1]) / (h * h);
                    h /= 2;
                    i++;
                }
                a = g.length;
                m = 1;
                while(a != 1){
                    for(j = 0; j < a - 1; j++)h1[j] = (Math1.pow(4, m) * g[j + 1] - g[j]) / (Math1.pow(4, m) - 1);
                    a = h1.length;
                    g = h1;
                    h1 = [];
                    m++;
                }
                return g;
            },
            simpson: function simpson(f, a, b, n) {
                var h = (b - a) / n;
                var I = f(a);
                var x = [];
                var j = a;
                var k = 0;
                var i = 1;
                var m;
                for(; j <= b; j = j + h, k++)x[k] = j;
                m = x.length;
                for(; i < m - 1; i++){
                    I += (i % 2 !== 0 ? 4 : 2) * f(x[i]);
                }
                return h / 3 * (I + f(b));
            },
            hermite: function hermite(X, F, dF, value) {
                var n = X.length;
                var p = 0;
                var i = 0;
                var l = [];
                var dl = [];
                var A = [];
                var B = [];
                var j;
                for(; i < n; i++){
                    l[i] = 1;
                    for(j = 0; j < n; j++){
                        if (i != j) l[i] *= (value - X[j]) / (X[i] - X[j]);
                    }
                    dl[i] = 0;
                    for(j = 0; j < n; j++){
                        if (i != j) dl[i] += 1 / (X[i] - X[j]);
                    }
                    A[i] = (1 - 2 * (value - X[i]) * dl[i]) * (l[i] * l[i]);
                    B[i] = (value - X[i]) * (l[i] * l[i]);
                    p += A[i] * F[i] + B[i] * dF[i];
                }
                return p;
            },
            lagrange: function lagrange(X, F, value) {
                var p = 0;
                var i = 0;
                var j, l;
                var n = X.length;
                for(; i < n; i++){
                    l = F[i];
                    for(j = 0; j < n; j++){
                        // calculating the lagrange polynomial L_i
                        if (i != j) l *= (value - X[j]) / (X[i] - X[j]);
                    }
                    // adding the lagrange polynomials found above
                    p += l;
                }
                return p;
            },
            cubic_spline: function cubic_spline(X, F, value) {
                var n = X.length;
                var i = 0, j;
                var A = [];
                var B = [];
                var alpha = [];
                var c = [];
                var h = [];
                var b = [];
                var d = [];
                for(; i < n - 1; i++)h[i] = X[i + 1] - X[i];
                alpha[0] = 0;
                for(i = 1; i < n - 1; i++){
                    alpha[i] = 3 / h[i] * (F[i + 1] - F[i]) - 3 / h[i - 1] * (F[i] - F[i - 1]);
                }
                for(i = 1; i < n - 1; i++){
                    A[i] = [];
                    B[i] = [];
                    A[i][i - 1] = h[i - 1];
                    A[i][i] = 2 * (h[i - 1] + h[i]);
                    A[i][i + 1] = h[i];
                    B[i][0] = alpha[i];
                }
                c = jStat.multiply(jStat.inv(A), B);
                for(j = 0; j < n - 1; j++){
                    b[j] = (F[j + 1] - F[j]) / h[j] - h[j] * (c[j + 1][0] + 2 * c[j][0]) / 3;
                    d[j] = (c[j + 1][0] - c[j][0]) / (3 * h[j]);
                }
                for(j = 0; j < n; j++){
                    if (X[j] > value) break;
                }
                j -= 1;
                return F[j] + (value - X[j]) * b[j] + jStat.sq(value - X[j]) * c[j] + (value - X[j]) * jStat.sq(value - X[j]) * d[j];
            },
            gauss_quadrature: function gauss_quadrature() {
                throw new Error("gauss_quadrature not yet implemented");
            },
            PCA: function PCA(X) {
                var m = X.length;
                var n = X[0].length;
                var i = 0;
                var j, temp1;
                var u = [];
                var D = [];
                var result = [];
                var temp2 = [];
                var Y = [];
                var Bt = [];
                var B = [];
                var C = [];
                var V = [];
                var Vt = [];
                for(i = 0; i < m; i++){
                    u[i] = jStat.sum(X[i]) / n;
                }
                for(i = 0; i < n; i++){
                    B[i] = [];
                    for(j = 0; j < m; j++){
                        B[i][j] = X[j][i] - u[j];
                    }
                }
                B = jStat.transpose(B);
                for(i = 0; i < m; i++){
                    C[i] = [];
                    for(j = 0; j < m; j++){
                        C[i][j] = jStat.dot([
                            B[i]
                        ], [
                            B[j]
                        ]) / (n - 1);
                    }
                }
                result = jStat.jacobi(C);
                V = result[0];
                D = result[1];
                Vt = jStat.transpose(V);
                for(i = 0; i < D.length; i++){
                    for(j = i; j < D.length; j++){
                        if (D[i] < D[j]) {
                            temp1 = D[i];
                            D[i] = D[j];
                            D[j] = temp1;
                            temp2 = Vt[i];
                            Vt[i] = Vt[j];
                            Vt[j] = temp2;
                        }
                    }
                }
                Bt = jStat.transpose(B);
                for(i = 0; i < m; i++){
                    Y[i] = [];
                    for(j = 0; j < Bt.length; j++){
                        Y[i][j] = jStat.dot([
                            Vt[i]
                        ], [
                            Bt[j]
                        ]);
                    }
                }
                return [
                    X,
                    D,
                    Vt,
                    Y
                ];
            }
        });
        // extend jStat.fn with methods that require one argument
        (function(funcs) {
            for(var i = 0; i < funcs.length; i++)(function(passfunc) {
                jStat.fn[passfunc] = function(arg, func) {
                    var tmpthis = this;
                    // check for callback
                    if (func) {
                        setTimeout(function() {
                            func.call(tmpthis, jStat.fn[passfunc].call(tmpthis, arg));
                        }, 15);
                        return this;
                    }
                    if (typeof jStat[passfunc](this, arg) === "number") return jStat[passfunc](this, arg);
                    else return jStat(jStat[passfunc](this, arg));
                };
            })(funcs[i]);
        })("add divide multiply subtract dot pow exp log abs norm angle".split(" "));
    })(jStat, Math);
    (function(jStat, Math1) {
        var slice = [].slice;
        var isNumber = jStat.utils.isNumber;
        var isArray = jStat.utils.isArray;
        // flag==true denotes use of sample standard deviation
        // Z Statistics
        jStat.extend({
            // 2 different parameter lists:
            // (value, mean, sd)
            // (value, array, flag)
            zscore: function zscore() {
                var args = slice.call(arguments);
                if (isNumber(args[1])) {
                    return (args[0] - args[1]) / args[2];
                }
                return (args[0] - jStat.mean(args[1])) / jStat.stdev(args[1], args[2]);
            },
            // 3 different paramter lists:
            // (value, mean, sd, sides)
            // (zscore, sides)
            // (value, array, sides, flag)
            ztest: function ztest() {
                var args = slice.call(arguments);
                var z;
                if (isArray(args[1])) {
                    // (value, array, sides, flag)
                    z = jStat.zscore(args[0], args[1], args[3]);
                    return args[2] === 1 ? jStat.normal.cdf(-Math1.abs(z), 0, 1) : jStat.normal.cdf(-Math1.abs(z), 0, 1) * 2;
                } else {
                    if (args.length > 2) {
                        // (value, mean, sd, sides)
                        z = jStat.zscore(args[0], args[1], args[2]);
                        return args[3] === 1 ? jStat.normal.cdf(-Math1.abs(z), 0, 1) : jStat.normal.cdf(-Math1.abs(z), 0, 1) * 2;
                    } else {
                        // (zscore, sides)
                        z = args[0];
                        return args[1] === 1 ? jStat.normal.cdf(-Math1.abs(z), 0, 1) : jStat.normal.cdf(-Math1.abs(z), 0, 1) * 2;
                    }
                }
            }
        });
        jStat.extend(jStat.fn, {
            zscore: function zscore(value, flag) {
                return (value - this.mean()) / this.stdev(flag);
            },
            ztest: function ztest(value, sides, flag) {
                var zscore = Math1.abs(this.zscore(value, flag));
                return sides === 1 ? jStat.normal.cdf(-zscore, 0, 1) : jStat.normal.cdf(-zscore, 0, 1) * 2;
            }
        });
        // T Statistics
        jStat.extend({
            // 2 parameter lists
            // (value, mean, sd, n)
            // (value, array)
            tscore: function tscore() {
                var args = slice.call(arguments);
                return args.length === 4 ? (args[0] - args[1]) / (args[2] / Math1.sqrt(args[3])) : (args[0] - jStat.mean(args[1])) / (jStat.stdev(args[1], true) / Math1.sqrt(args[1].length));
            },
            // 3 different paramter lists:
            // (value, mean, sd, n, sides)
            // (tscore, n, sides)
            // (value, array, sides)
            ttest: function ttest() {
                var args = slice.call(arguments);
                var tscore;
                if (args.length === 5) {
                    tscore = Math1.abs(jStat.tscore(args[0], args[1], args[2], args[3]));
                    return args[4] === 1 ? jStat.studentt.cdf(-tscore, args[3] - 1) : jStat.studentt.cdf(-tscore, args[3] - 1) * 2;
                }
                if (isNumber(args[1])) {
                    tscore = Math1.abs(args[0]);
                    return args[2] == 1 ? jStat.studentt.cdf(-tscore, args[1] - 1) : jStat.studentt.cdf(-tscore, args[1] - 1) * 2;
                }
                tscore = Math1.abs(jStat.tscore(args[0], args[1]));
                return args[2] == 1 ? jStat.studentt.cdf(-tscore, args[1].length - 1) : jStat.studentt.cdf(-tscore, args[1].length - 1) * 2;
            }
        });
        jStat.extend(jStat.fn, {
            tscore: function tscore(value) {
                return (value - this.mean()) / (this.stdev(true) / Math1.sqrt(this.cols()));
            },
            ttest: function ttest(value, sides) {
                return sides === 1 ? 1 - jStat.studentt.cdf(Math1.abs(this.tscore(value)), this.cols() - 1) : jStat.studentt.cdf(-Math1.abs(this.tscore(value)), this.cols() - 1) * 2;
            }
        });
        // F Statistics
        jStat.extend({
            // Paramter list is as follows:
            // (array1, array2, array3, ...)
            // or it is an array of arrays
            // array of arrays conversion
            anovafscore: function anovafscore() {
                var args = slice.call(arguments), expVar, sample, sampMean, sampSampMean, tmpargs, unexpVar, i, j;
                if (args.length === 1) {
                    tmpargs = new Array(args[0].length);
                    for(i = 0; i < args[0].length; i++){
                        tmpargs[i] = args[0][i];
                    }
                    args = tmpargs;
                }
                // Builds sample array
                sample = new Array();
                for(i = 0; i < args.length; i++){
                    sample = sample.concat(args[i]);
                }
                sampMean = jStat.mean(sample);
                // Computes the explained variance
                expVar = 0;
                for(i = 0; i < args.length; i++){
                    expVar = expVar + args[i].length * Math1.pow(jStat.mean(args[i]) - sampMean, 2);
                }
                expVar /= args.length - 1;
                // Computes unexplained variance
                unexpVar = 0;
                for(i = 0; i < args.length; i++){
                    sampSampMean = jStat.mean(args[i]);
                    for(j = 0; j < args[i].length; j++){
                        unexpVar += Math1.pow(args[i][j] - sampSampMean, 2);
                    }
                }
                unexpVar /= sample.length - args.length;
                return expVar / unexpVar;
            },
            // 2 different paramter setups
            // (array1, array2, array3, ...)
            // (anovafscore, df1, df2)
            anovaftest: function anovaftest() {
                var args = slice.call(arguments), df1, df2, n, i;
                if (isNumber(args[0])) {
                    return 1 - jStat.centralF.cdf(args[0], args[1], args[2]);
                }
                var anovafscore = jStat.anovafscore(args);
                df1 = args.length - 1;
                n = 0;
                for(i = 0; i < args.length; i++){
                    n = n + args[i].length;
                }
                df2 = n - df1 - 1;
                return 1 - jStat.centralF.cdf(anovafscore, df1, df2);
            },
            ftest: function ftest(fscore, df1, df2) {
                return 1 - jStat.centralF.cdf(fscore, df1, df2);
            }
        });
        jStat.extend(jStat.fn, {
            anovafscore: function anovafscore() {
                return jStat.anovafscore(this.toArray());
            },
            anovaftes: function anovaftes() {
                var n = 0;
                var i;
                for(i = 0; i < this.length; i++){
                    n = n + this[i].length;
                }
                return jStat.ftest(this.anovafscore(), this.length - 1, n - this.length);
            }
        });
        // Tukey's range test
        jStat.extend({
            // 2 parameter lists
            // (mean1, mean2, n1, n2, sd)
            // (array1, array2, sd)
            qscore: function qscore() {
                var args = slice.call(arguments);
                var mean1, mean2, n1, n2, sd;
                if (isNumber(args[0])) {
                    mean1 = args[0];
                    mean2 = args[1];
                    n1 = args[2];
                    n2 = args[3];
                    sd = args[4];
                } else {
                    mean1 = jStat.mean(args[0]);
                    mean2 = jStat.mean(args[1]);
                    n1 = args[0].length;
                    n2 = args[1].length;
                    sd = args[2];
                }
                return Math1.abs(mean1 - mean2) / (sd * Math1.sqrt((1 / n1 + 1 / n2) / 2));
            },
            // 3 different parameter lists:
            // (qscore, n, k)
            // (mean1, mean2, n1, n2, sd, n, k)
            // (array1, array2, sd, n, k)
            qtest: function qtest() {
                var args = slice.call(arguments);
                var qscore;
                if (args.length === 3) {
                    qscore = args[0];
                    args = args.slice(1);
                } else if (args.length === 7) {
                    qscore = jStat.qscore(args[0], args[1], args[2], args[3], args[4]);
                    args = args.slice(5);
                } else {
                    qscore = jStat.qscore(args[0], args[1], args[2]);
                    args = args.slice(3);
                }
                var n = args[0];
                var k = args[1];
                return 1 - jStat.tukey.cdf(qscore, k, n - k);
            },
            tukeyhsd: function tukeyhsd(arrays) {
                var sd = jStat.pooledstdev(arrays);
                var means = arrays.map(function(arr) {
                    return jStat.mean(arr);
                });
                var n = arrays.reduce(function(n, arr) {
                    return n + arr.length;
                }, 0);
                var results = [];
                for(var i = 0; i < arrays.length; ++i){
                    for(var j = i + 1; j < arrays.length; ++j){
                        var p = jStat.qtest(means[i], means[j], arrays[i].length, arrays[j].length, sd, n, arrays.length);
                        results.push([
                            [
                                i,
                                j
                            ],
                            p
                        ]);
                    }
                }
                return results;
            }
        });
        // Error Bounds
        jStat.extend({
            // 2 different parameter setups
            // (value, alpha, sd, n)
            // (value, alpha, array)
            normalci: function normalci() {
                var args = slice.call(arguments), ans = new Array(2), change;
                if (args.length === 4) {
                    change = Math1.abs(jStat.normal.inv(args[1] / 2, 0, 1) * args[2] / Math1.sqrt(args[3]));
                } else {
                    change = Math1.abs(jStat.normal.inv(args[1] / 2, 0, 1) * jStat.stdev(args[2]) / Math1.sqrt(args[2].length));
                }
                ans[0] = args[0] - change;
                ans[1] = args[0] + change;
                return ans;
            },
            // 2 different parameter setups
            // (value, alpha, sd, n)
            // (value, alpha, array)
            tci: function tci() {
                var args = slice.call(arguments), ans = new Array(2), change;
                if (args.length === 4) {
                    change = Math1.abs(jStat.studentt.inv(args[1] / 2, args[3] - 1) * args[2] / Math1.sqrt(args[3]));
                } else {
                    change = Math1.abs(jStat.studentt.inv(args[1] / 2, args[2].length - 1) * jStat.stdev(args[2], true) / Math1.sqrt(args[2].length));
                }
                ans[0] = args[0] - change;
                ans[1] = args[0] + change;
                return ans;
            },
            significant: function significant(pvalue, alpha) {
                return pvalue < alpha;
            }
        });
        jStat.extend(jStat.fn, {
            normalci: function normalci(value, alpha) {
                return jStat.normalci(value, alpha, this.toArray());
            },
            tci: function tci(value, alpha) {
                return jStat.tci(value, alpha, this.toArray());
            }
        });
        // internal method for calculating the z-score for a difference of proportions test
        function differenceOfProportions(p1, n1, p2, n2) {
            if (p1 > 1 || p2 > 1 || p1 <= 0 || p2 <= 0) {
                throw new Error("Proportions should be greater than 0 and less than 1");
            }
            var pooled = (p1 * n1 + p2 * n2) / (n1 + n2);
            var se = Math1.sqrt(pooled * (1 - pooled) * (1 / n1 + 1 / n2));
            return (p1 - p2) / se;
        }
        // Difference of Proportions
        jStat.extend(jStat.fn, {
            oneSidedDifferenceOfProportions: function oneSidedDifferenceOfProportions(p1, n1, p2, n2) {
                var z = differenceOfProportions(p1, n1, p2, n2);
                return jStat.ztest(z, 1);
            },
            twoSidedDifferenceOfProportions: function twoSidedDifferenceOfProportions(p1, n1, p2, n2) {
                var z = differenceOfProportions(p1, n1, p2, n2);
                return jStat.ztest(z, 2);
            }
        });
    })(jStat, Math);
    jStat.models = function() {
        function sub_regress(exog) {
            var var_count = exog[0].length;
            var modelList = jStat.arange(var_count).map(function(endog_index) {
                var exog_index = jStat.arange(var_count).filter(function(i) {
                    return i !== endog_index;
                });
                return ols(jStat.col(exog, endog_index).map(function(x) {
                    return x[0];
                }), jStat.col(exog, exog_index));
            });
            return modelList;
        }
        // do OLS model regress
        // exog have include const columns ,it will not generate it .In fact, exog is
        // "design matrix" look at
        //https://en.wikipedia.org/wiki/Design_matrix
        function ols(endog, exog) {
            var nobs = endog.length;
            var df_model = exog[0].length - 1;
            var df_resid = nobs - df_model - 1;
            var coef = jStat.lstsq(exog, endog);
            var predict = jStat.multiply(exog, coef.map(function(x) {
                return [
                    x
                ];
            })).map(function(p) {
                return p[0];
            });
            var resid = jStat.subtract(endog, predict);
            var ybar = jStat.mean(endog);
            // constant cause problem
            // var SST = jStat.sum(endog.map(function(y) {
            //   return Math.pow(y-ybar,2);
            // }));
            var SSE = jStat.sum(predict.map(function(f) {
                return Math.pow(f - ybar, 2);
            }));
            var SSR = jStat.sum(endog.map(function(y, i) {
                return Math.pow(y - predict[i], 2);
            }));
            var SST = SSE + SSR;
            var R2 = SSE / SST;
            return {
                exog: exog,
                endog: endog,
                nobs: nobs,
                df_model: df_model,
                df_resid: df_resid,
                coef: coef,
                predict: predict,
                resid: resid,
                ybar: ybar,
                SST: SST,
                SSE: SSE,
                SSR: SSR,
                R2: R2
            };
        }
        // H0: b_I=0
        // H1: b_I!=0
        function t_test(model) {
            var subModelList = sub_regress(model.exog);
            //var sigmaHat=jStat.stdev(model.resid);
            var sigmaHat = Math.sqrt(model.SSR / model.df_resid);
            var seBetaHat = subModelList.map(function(mod) {
                var SST = mod.SST;
                var R2 = mod.R2;
                return sigmaHat / Math.sqrt(SST * (1 - R2));
            });
            var tStatistic = model.coef.map(function(coef, i) {
                return (coef - 0) / seBetaHat[i];
            });
            var pValue = tStatistic.map(function(t) {
                var leftppf = jStat.studentt.cdf(t, model.df_resid);
                return (leftppf > 0.5 ? 1 - leftppf : leftppf) * 2;
            });
            var c = jStat.studentt.inv(0.975, model.df_resid);
            var interval95 = model.coef.map(function(coef, i) {
                var d = c * seBetaHat[i];
                return [
                    coef - d,
                    coef + d
                ];
            });
            return {
                se: seBetaHat,
                t: tStatistic,
                p: pValue,
                sigmaHat: sigmaHat,
                interval95: interval95
            };
        }
        function F_test(model) {
            var F_statistic = model.R2 / model.df_model / ((1 - model.R2) / model.df_resid);
            var fcdf = function(x, n1, n2) {
                return jStat.beta.cdf(x / (n2 / n1 + x), n1 / 2, n2 / 2);
            };
            var pvalue = 1 - fcdf(F_statistic, model.df_model, model.df_resid);
            return {
                F_statistic: F_statistic,
                pvalue: pvalue
            };
        }
        function ols_wrap(endog, exog) {
            var model = ols(endog, exog);
            var ttest = t_test(model);
            var ftest = F_test(model);
            // Provide the Wherry / Ezekiel / McNemar / Cohen Adjusted R^2
            // Which matches the 'adjusted R^2' provided by R's lm package
            var adjust_R2 = 1 - (1 - model.R2) * ((model.nobs - 1) / model.df_resid);
            model.t = ttest;
            model.f = ftest;
            model.adjust_R2 = adjust_R2;
            return model;
        }
        return {
            ols: ols_wrap
        };
    }();
    //To regress, simply build X matrix
    //(append column of 1's) using
    //buildxmatrix and build the Y
    //matrix using buildymatrix
    //(simply the transpose)
    //and run regress.
    //Regressions
    jStat.extend({
        buildxmatrix: function buildxmatrix() {
            //Parameters will be passed in as such
            //(array1,array2,array3,...)
            //as (x1,x2,x3,...)
            //needs to be (1,x1,x2,x3,...)
            var matrixRows = new Array(arguments.length);
            for(var i = 0; i < arguments.length; i++){
                var array = [
                    1
                ];
                matrixRows[i] = array.concat(arguments[i]);
            }
            return jStat(matrixRows);
        },
        builddxmatrix: function builddxmatrix() {
            //Paramters will be passed in as such
            //([array1,array2,...]
            var matrixRows = new Array(arguments[0].length);
            for(var i = 0; i < arguments[0].length; i++){
                var array = [
                    1
                ];
                matrixRows[i] = array.concat(arguments[0][i]);
            }
            return jStat(matrixRows);
        },
        buildjxmatrix: function buildjxmatrix(jMat) {
            //Builds from jStat Matrix
            var pass = new Array(jMat.length);
            for(var i = 0; i < jMat.length; i++){
                pass[i] = jMat[i];
            }
            return jStat.builddxmatrix(pass);
        },
        buildymatrix: function buildymatrix(array) {
            return jStat(array).transpose();
        },
        buildjymatrix: function buildjymatrix(jMat) {
            return jMat.transpose();
        },
        matrixmult: function matrixmult(A, B) {
            var i, j, k, result, sum;
            if (A.cols() == B.rows()) {
                if (B.rows() > 1) {
                    result = [];
                    for(i = 0; i < A.rows(); i++){
                        result[i] = [];
                        for(j = 0; j < B.cols(); j++){
                            sum = 0;
                            for(k = 0; k < A.cols(); k++){
                                sum += A.toArray()[i][k] * B.toArray()[k][j];
                            }
                            result[i][j] = sum;
                        }
                    }
                    return jStat(result);
                }
                result = [];
                for(i = 0; i < A.rows(); i++){
                    result[i] = [];
                    for(j = 0; j < B.cols(); j++){
                        sum = 0;
                        for(k = 0; k < A.cols(); k++){
                            sum += A.toArray()[i][k] * B.toArray()[j];
                        }
                        result[i][j] = sum;
                    }
                }
                return jStat(result);
            }
        },
        //regress and regresst to be fixed
        regress: function regress(jMatX, jMatY) {
            //print("regressin!");
            //print(jMatX.toArray());
            var innerinv = jStat.xtranspxinv(jMatX);
            //print(innerinv);
            var xtransp = jMatX.transpose();
            var next = jStat.matrixmult(jStat(innerinv), xtransp);
            return jStat.matrixmult(next, jMatY);
        },
        regresst: function regresst(jMatX, jMatY, sides) {
            var beta = jStat.regress(jMatX, jMatY);
            var compile = {};
            compile.anova = {};
            var jMatYBar = jStat.jMatYBar(jMatX, beta);
            compile.yBar = jMatYBar;
            var yAverage = jMatY.mean();
            compile.anova.residuals = jStat.residuals(jMatY, jMatYBar);
            compile.anova.ssr = jStat.ssr(jMatYBar, yAverage);
            compile.anova.msr = compile.anova.ssr / (jMatX[0].length - 1);
            compile.anova.sse = jStat.sse(jMatY, jMatYBar);
            compile.anova.mse = compile.anova.sse / (jMatY.length - (jMatX[0].length - 1) - 1);
            compile.anova.sst = jStat.sst(jMatY, yAverage);
            compile.anova.mst = compile.anova.sst / (jMatY.length - 1);
            compile.anova.r2 = 1 - compile.anova.sse / compile.anova.sst;
            if (compile.anova.r2 < 0) compile.anova.r2 = 0;
            compile.anova.fratio = compile.anova.msr / compile.anova.mse;
            compile.anova.pvalue = jStat.anovaftest(compile.anova.fratio, jMatX[0].length - 1, jMatY.length - (jMatX[0].length - 1) - 1);
            compile.anova.rmse = Math.sqrt(compile.anova.mse);
            compile.anova.r2adj = 1 - compile.anova.mse / compile.anova.mst;
            if (compile.anova.r2adj < 0) compile.anova.r2adj = 0;
            compile.stats = new Array(jMatX[0].length);
            var covar = jStat.xtranspxinv(jMatX);
            var sds, ts, ps;
            for(var i = 0; i < beta.length; i++){
                sds = Math.sqrt(compile.anova.mse * Math.abs(covar[i][i]));
                ts = Math.abs(beta[i] / sds);
                ps = jStat.ttest(ts, jMatY.length - jMatX[0].length - 1, sides);
                compile.stats[i] = [
                    beta[i],
                    sds,
                    ts,
                    ps
                ];
            }
            compile.regress = beta;
            return compile;
        },
        xtranspx: function xtranspx(jMatX) {
            return jStat.matrixmult(jMatX.transpose(), jMatX);
        },
        xtranspxinv: function xtranspxinv(jMatX) {
            var inner = jStat.matrixmult(jMatX.transpose(), jMatX);
            var innerinv = jStat.inv(inner);
            return innerinv;
        },
        jMatYBar: function jMatYBar(jMatX, beta) {
            var yBar = jStat.matrixmult(jMatX, beta);
            return new jStat(yBar);
        },
        residuals: function residuals(jMatY, jMatYBar) {
            return jStat.matrixsubtract(jMatY, jMatYBar);
        },
        ssr: function ssr(jMatYBar, yAverage) {
            var ssr = 0;
            for(var i = 0; i < jMatYBar.length; i++){
                ssr += Math.pow(jMatYBar[i] - yAverage, 2);
            }
            return ssr;
        },
        sse: function sse(jMatY, jMatYBar) {
            var sse = 0;
            for(var i = 0; i < jMatY.length; i++){
                sse += Math.pow(jMatY[i] - jMatYBar[i], 2);
            }
            return sse;
        },
        sst: function sst(jMatY, yAverage) {
            var sst = 0;
            for(var i = 0; i < jMatY.length; i++){
                sst += Math.pow(jMatY[i] - yAverage, 2);
            }
            return sst;
        },
        matrixsubtract: function matrixsubtract(A, B) {
            var ans = new Array(A.length);
            for(var i = 0; i < A.length; i++){
                ans[i] = new Array(A[i].length);
                for(var j = 0; j < A[i].length; j++){
                    ans[i][j] = A[i][j] - B[i][j];
                }
            }
            return jStat(ans);
        }
    });
    // Make it compatible with previous version.
    jStat.jStat = jStat;
    return jStat;
});


/***/ }),

/***/ 7771:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// A linked list to keep track of recently-used-ness
const Yallist = __webpack_require__(9606);
const MAX = Symbol("max");
const LENGTH = Symbol("length");
const LENGTH_CALCULATOR = Symbol("lengthCalculator");
const ALLOW_STALE = Symbol("allowStale");
const MAX_AGE = Symbol("maxAge");
const DISPOSE = Symbol("dispose");
const NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
const LRU_LIST = Symbol("lruList");
const CACHE = Symbol("cache");
const UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
const naiveLength = ()=>1;
// lruList is a yallist where the head is the youngest
// item, and the tail is the oldest.  the list contains the Hit
// objects as the entries.
// Each Hit object has a reference to its Yallist.Node.  This
// never changes.
//
// cache is a Map (or PseudoMap) that matches the keys to
// the Yallist.Node object.
class LRUCache {
    constructor(options){
        if (typeof options === "number") options = {
            max: options
        };
        if (!options) options = {};
        if (options.max && (typeof options.max !== "number" || options.max < 0)) throw new TypeError("max must be a non-negative number");
        // Kind of weird to have a default max of Infinity, but oh well.
        const max = this[MAX] = options.max || Infinity;
        const lc = options.length || naiveLength;
        this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
        this[ALLOW_STALE] = options.stale || false;
        if (options.maxAge && typeof options.maxAge !== "number") throw new TypeError("maxAge must be a number");
        this[MAX_AGE] = options.maxAge || 0;
        this[DISPOSE] = options.dispose;
        this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
        this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
        this.reset();
    }
    // resize the cache when the max changes.
    set max(mL) {
        if (typeof mL !== "number" || mL < 0) throw new TypeError("max must be a non-negative number");
        this[MAX] = mL || Infinity;
        trim(this);
    }
    get max() {
        return this[MAX];
    }
    set allowStale(allowStale) {
        this[ALLOW_STALE] = !!allowStale;
    }
    get allowStale() {
        return this[ALLOW_STALE];
    }
    set maxAge(mA) {
        if (typeof mA !== "number") throw new TypeError("maxAge must be a non-negative number");
        this[MAX_AGE] = mA;
        trim(this);
    }
    get maxAge() {
        return this[MAX_AGE];
    }
    // resize the cache when the lengthCalculator changes.
    set lengthCalculator(lC) {
        if (typeof lC !== "function") lC = naiveLength;
        if (lC !== this[LENGTH_CALCULATOR]) {
            this[LENGTH_CALCULATOR] = lC;
            this[LENGTH] = 0;
            this[LRU_LIST].forEach((hit)=>{
                hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
                this[LENGTH] += hit.length;
            });
        }
        trim(this);
    }
    get lengthCalculator() {
        return this[LENGTH_CALCULATOR];
    }
    get length() {
        return this[LENGTH];
    }
    get itemCount() {
        return this[LRU_LIST].length;
    }
    rforEach(fn, thisp) {
        thisp = thisp || this;
        for(let walker = this[LRU_LIST].tail; walker !== null;){
            const prev = walker.prev;
            forEachStep(this, fn, walker, thisp);
            walker = prev;
        }
    }
    forEach(fn, thisp) {
        thisp = thisp || this;
        for(let walker = this[LRU_LIST].head; walker !== null;){
            const next = walker.next;
            forEachStep(this, fn, walker, thisp);
            walker = next;
        }
    }
    keys() {
        return this[LRU_LIST].toArray().map((k)=>k.key);
    }
    values() {
        return this[LRU_LIST].toArray().map((k)=>k.value);
    }
    reset() {
        if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
            this[LRU_LIST].forEach((hit)=>this[DISPOSE](hit.key, hit.value));
        }
        this[CACHE] = new Map() // hash of items by key
        ;
        this[LRU_LIST] = new Yallist() // list of items in order of use recency
        ;
        this[LENGTH] = 0 // length of items in the list
        ;
    }
    dump() {
        return this[LRU_LIST].map((hit)=>isStale(this, hit) ? false : {
                k: hit.key,
                v: hit.value,
                e: hit.now + (hit.maxAge || 0)
            }).toArray().filter((h)=>h);
    }
    dumpLru() {
        return this[LRU_LIST];
    }
    set(key, value, maxAge) {
        maxAge = maxAge || this[MAX_AGE];
        if (maxAge && typeof maxAge !== "number") throw new TypeError("maxAge must be a number");
        const now = maxAge ? Date.now() : 0;
        const len = this[LENGTH_CALCULATOR](value, key);
        if (this[CACHE].has(key)) {
            if (len > this[MAX]) {
                del(this, this[CACHE].get(key));
                return false;
            }
            const node = this[CACHE].get(key);
            const item = node.value;
            // dispose of the old one before overwriting
            // split out into 2 ifs for better coverage tracking
            if (this[DISPOSE]) {
                if (!this[NO_DISPOSE_ON_SET]) this[DISPOSE](key, item.value);
            }
            item.now = now;
            item.maxAge = maxAge;
            item.value = value;
            this[LENGTH] += len - item.length;
            item.length = len;
            this.get(key);
            trim(this);
            return true;
        }
        const hit = new Entry(key, value, len, now, maxAge);
        // oversized objects fall out of cache automatically.
        if (hit.length > this[MAX]) {
            if (this[DISPOSE]) this[DISPOSE](key, value);
            return false;
        }
        this[LENGTH] += hit.length;
        this[LRU_LIST].unshift(hit);
        this[CACHE].set(key, this[LRU_LIST].head);
        trim(this);
        return true;
    }
    has(key) {
        if (!this[CACHE].has(key)) return false;
        const hit = this[CACHE].get(key).value;
        return !isStale(this, hit);
    }
    get(key) {
        return get(this, key, true);
    }
    peek(key) {
        return get(this, key, false);
    }
    pop() {
        const node = this[LRU_LIST].tail;
        if (!node) return null;
        del(this, node);
        return node.value;
    }
    del(key) {
        del(this, this[CACHE].get(key));
    }
    load(arr) {
        // reset the cache
        this.reset();
        const now = Date.now();
        // A previous serialized cache has the most recent items first
        for(let l = arr.length - 1; l >= 0; l--){
            const hit = arr[l];
            const expiresAt = hit.e || 0;
            if (expiresAt === 0) // the item was created without expiration in a non aged cache
            this.set(hit.k, hit.v);
            else {
                const maxAge = expiresAt - now;
                // dont add already expired items
                if (maxAge > 0) {
                    this.set(hit.k, hit.v, maxAge);
                }
            }
        }
    }
    prune() {
        this[CACHE].forEach((value, key)=>get(this, key, false));
    }
}
const get = (self, key, doUse)=>{
    const node = self[CACHE].get(key);
    if (node) {
        const hit = node.value;
        if (isStale(self, hit)) {
            del(self, node);
            if (!self[ALLOW_STALE]) return undefined;
        } else {
            if (doUse) {
                if (self[UPDATE_AGE_ON_GET]) node.value.now = Date.now();
                self[LRU_LIST].unshiftNode(node);
            }
        }
        return hit.value;
    }
};
const isStale = (self, hit)=>{
    if (!hit || !hit.maxAge && !self[MAX_AGE]) return false;
    const diff = Date.now() - hit.now;
    return hit.maxAge ? diff > hit.maxAge : self[MAX_AGE] && diff > self[MAX_AGE];
};
const trim = (self)=>{
    if (self[LENGTH] > self[MAX]) {
        for(let walker = self[LRU_LIST].tail; self[LENGTH] > self[MAX] && walker !== null;){
            // We know that we're about to delete this one, and also
            // what the next least recently used key will be, so just
            // go ahead and set it now.
            const prev = walker.prev;
            del(self, walker);
            walker = prev;
        }
    }
};
const del = (self, node)=>{
    if (node) {
        const hit = node.value;
        if (self[DISPOSE]) self[DISPOSE](hit.key, hit.value);
        self[LENGTH] -= hit.length;
        self[CACHE].delete(hit.key);
        self[LRU_LIST].removeNode(node);
    }
};
class Entry {
    constructor(key, value, length, now, maxAge){
        this.key = key;
        this.value = value;
        this.length = length;
        this.now = now;
        this.maxAge = maxAge || 0;
    }
}
const forEachStep = (self, fn, node, thisp)=>{
    let hit = node.value;
    if (isStale(self, hit)) {
        del(self, node);
        if (!self[ALLOW_STALE]) hit = undefined;
    }
    if (hit) fn.call(thisp, hit.value, hit.key, self);
};
module.exports = LRUCache;


/***/ }),

/***/ 6337:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
0 && (0);
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    prefixes: function() {
        return prefixes;
    },
    wait: function() {
        return wait;
    },
    error: function() {
        return error;
    },
    warn: function() {
        return warn;
    },
    ready: function() {
        return ready;
    },
    info: function() {
        return info;
    },
    event: function() {
        return event;
    },
    trace: function() {
        return trace;
    },
    warnOnce: function() {
        return warnOnce;
    }
});
const _chalk = /*#__PURE__*/ _interop_require_default(__webpack_require__(6444));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const prefixes = {
    wait: _chalk.default.cyan("wait") + "  -",
    error: _chalk.default.red("error") + " -",
    warn: _chalk.default.yellow("warn") + "  -",
    ready: _chalk.default.green("ready") + " -",
    info: _chalk.default.cyan("info") + "  -",
    event: _chalk.default.magenta("event") + " -",
    trace: _chalk.default.magenta("trace") + " -"
};
function wait(...message) {
    console.log(prefixes.wait, ...message);
}
function error(...message) {
    console.error(prefixes.error, ...message);
}
function warn(...message) {
    console.warn(prefixes.warn, ...message);
}
function ready(...message) {
    console.log(prefixes.ready, ...message);
}
function info(...message) {
    console.log(prefixes.info, ...message);
}
function event(...message) {
    console.log(prefixes.event, ...message);
}
function trace(...message) {
    console.log(prefixes.trace, ...message);
}
const warnOnceMessages = new Set();
function warnOnce(...message) {
    if (!warnOnceMessages.has(message[0])) {
        warnOnceMessages.add(message.join(" "));
        warn(...message);
    }
} //# sourceMappingURL=log.js.map


/***/ }),

/***/ 4887:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "actionAsyncStorage", ({
    enumerable: true,
    get: function() {
        return actionAsyncStorage;
    }
}));
const _asynclocalstorage = __webpack_require__(8629);
const actionAsyncStorage = (0, _asynclocalstorage.createAsyncLocalStorage)();
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=action-async-storage.js.map


/***/ }),

/***/ 4940:
/***/ ((module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
0 && (0);
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    RSC: function() {
        return RSC;
    },
    ACTION: function() {
        return ACTION;
    },
    NEXT_ROUTER_STATE_TREE: function() {
        return NEXT_ROUTER_STATE_TREE;
    },
    NEXT_ROUTER_PREFETCH: function() {
        return NEXT_ROUTER_PREFETCH;
    },
    NEXT_URL: function() {
        return NEXT_URL;
    },
    FETCH_CACHE_HEADER: function() {
        return FETCH_CACHE_HEADER;
    },
    RSC_CONTENT_TYPE_HEADER: function() {
        return RSC_CONTENT_TYPE_HEADER;
    },
    RSC_VARY_HEADER: function() {
        return RSC_VARY_HEADER;
    },
    FLIGHT_PARAMETERS: function() {
        return FLIGHT_PARAMETERS;
    }
});
const RSC = "RSC";
const ACTION = "Next-Action";
const NEXT_ROUTER_STATE_TREE = "Next-Router-State-Tree";
const NEXT_ROUTER_PREFETCH = "Next-Router-Prefetch";
const NEXT_URL = "Next-Url";
const FETCH_CACHE_HEADER = "x-vercel-sc-headers";
const RSC_CONTENT_TYPE_HEADER = "text/x-component";
const RSC_VARY_HEADER = RSC + ", " + NEXT_ROUTER_STATE_TREE + ", " + NEXT_ROUTER_PREFETCH;
const FLIGHT_PARAMETERS = [
    [
        RSC
    ],
    [
        NEXT_ROUTER_STATE_TREE
    ],
    [
        NEXT_ROUTER_PREFETCH
    ]
];
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=app-router-headers.js.map


/***/ }),

/***/ 8629:
/***/ ((module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "createAsyncLocalStorage", ({
    enumerable: true,
    get: function() {
        return createAsyncLocalStorage;
    }
}));
class FakeAsyncLocalStorage {
    disable() {
        throw new Error("Invariant: AsyncLocalStorage accessed in runtime where it is not available");
    }
    getStore() {
        // This fake implementation of AsyncLocalStorage always returns `undefined`.
        return undefined;
    }
    run() {
        throw new Error("Invariant: AsyncLocalStorage accessed in runtime where it is not available");
    }
    exit() {
        throw new Error("Invariant: AsyncLocalStorage accessed in runtime where it is not available");
    }
    enterWith() {
        throw new Error("Invariant: AsyncLocalStorage accessed in runtime where it is not available");
    }
}
function createAsyncLocalStorage() {
    if (globalThis.AsyncLocalStorage) {
        return new globalThis.AsyncLocalStorage();
    }
    return new FakeAsyncLocalStorage();
}
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=async-local-storage.js.map


/***/ }),

/***/ 4534:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
0 && (0);
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    headers: function() {
        return headers;
    },
    previewData: function() {
        return previewData;
    },
    cookies: function() {
        return cookies;
    }
});
const _requestcookies = __webpack_require__(5697);
const _headers = __webpack_require__(104);
const _cookies = __webpack_require__(5153);
const _requestasyncstorage = __webpack_require__(6128);
const _actionasyncstorage = __webpack_require__(4887);
const _staticgenerationbailout = __webpack_require__(5151);
function headers() {
    if ((0, _staticgenerationbailout.staticGenerationBailout)("headers")) {
        return _headers.HeadersAdapter.seal(new Headers({}));
    }
    const requestStore = _requestasyncstorage.requestAsyncStorage.getStore();
    if (!requestStore) {
        throw new Error("Invariant: Method expects to have requestAsyncStorage, none available");
    }
    return requestStore.headers;
}
function previewData() {
    const requestStore = _requestasyncstorage.requestAsyncStorage.getStore();
    if (!requestStore) {
        throw new Error("Invariant: Method expects to have requestAsyncStorage, none available");
    }
    return requestStore.previewData;
}
function cookies() {
    if ((0, _staticgenerationbailout.staticGenerationBailout)("cookies")) {
        return _requestcookies.RequestCookiesAdapter.seal(new _cookies.RequestCookies(new Headers({})));
    }
    const requestStore = _requestasyncstorage.requestAsyncStorage.getStore();
    if (!requestStore) {
        throw new Error("Invariant: Method expects to have requestAsyncStorage, none available");
    }
    const asyncActionStore = _actionasyncstorage.actionAsyncStorage.getStore();
    if (asyncActionStore && (asyncActionStore.isAction || asyncActionStore.isAppRoute)) {
        // We can't conditionally return different types here based on the context.
        // To avoid confusion, we always return the readonly type here.
        return requestStore.mutableCookies;
    }
    return requestStore.cookies;
}
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=headers.js.map


/***/ }),

/***/ 8339:
/***/ ((module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
0 && (0);
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    DYNAMIC_ERROR_CODE: function() {
        return DYNAMIC_ERROR_CODE;
    },
    DynamicServerError: function() {
        return DynamicServerError;
    }
});
const DYNAMIC_ERROR_CODE = "DYNAMIC_SERVER_USAGE";
class DynamicServerError extends Error {
    constructor(type){
        super("Dynamic server usage: " + type);
        this.digest = DYNAMIC_ERROR_CODE;
    }
}
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=hooks-server-context.js.map


/***/ }),

/***/ 6925:
/***/ ((module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
0 && (0);
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    notFound: function() {
        return notFound;
    },
    isNotFoundError: function() {
        return isNotFoundError;
    }
});
const NOT_FOUND_ERROR_CODE = "NEXT_NOT_FOUND";
function notFound() {
    // eslint-disable-next-line no-throw-literal
    const error = new Error(NOT_FOUND_ERROR_CODE);
    error.digest = NOT_FOUND_ERROR_CODE;
    throw error;
}
function isNotFoundError(error) {
    return (error == null ? void 0 : error.digest) === NOT_FOUND_ERROR_CODE;
}
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=not-found.js.map


/***/ }),

/***/ 9498:
/***/ ((module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
0 && (0);
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    redirect: function() {
        return redirect;
    },
    isRedirectError: function() {
        return isRedirectError;
    },
    getURLFromRedirectError: function() {
        return getURLFromRedirectError;
    }
});
const REDIRECT_ERROR_CODE = "NEXT_REDIRECT";
function redirect(url) {
    // eslint-disable-next-line no-throw-literal
    const error = new Error(REDIRECT_ERROR_CODE);
    error.digest = REDIRECT_ERROR_CODE + ";" + url;
    throw error;
}
function isRedirectError(error) {
    return typeof (error == null ? void 0 : error.digest) === "string" && error.digest.startsWith(REDIRECT_ERROR_CODE + ";") && error.digest.length > REDIRECT_ERROR_CODE.length + 1;
}
function getURLFromRedirectError(error) {
    if (!isRedirectError(error)) return null;
    // Slices off the beginning of the digest that contains the code and the
    // separating ';'.
    return error.digest.slice(REDIRECT_ERROR_CODE.length + 1);
}
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=redirect.js.map


/***/ }),

/***/ 6128:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "requestAsyncStorage", ({
    enumerable: true,
    get: function() {
        return requestAsyncStorage;
    }
}));
const _asynclocalstorage = __webpack_require__(8629);
const requestAsyncStorage = (0, _asynclocalstorage.createAsyncLocalStorage)();
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=request-async-storage.js.map


/***/ }),

/***/ 5151:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "staticGenerationBailout", ({
    enumerable: true,
    get: function() {
        return staticGenerationBailout;
    }
}));
const _hooksservercontext = __webpack_require__(8339);
const _staticgenerationasyncstorage = __webpack_require__(7358);
class StaticGenBailoutError extends Error {
    constructor(...args){
        super(...args);
        this.code = "NEXT_STATIC_GEN_BAILOUT";
    }
}
const staticGenerationBailout = (reason, opts)=>{
    const staticGenerationStore = _staticgenerationasyncstorage.staticGenerationAsyncStorage.getStore();
    if (staticGenerationStore == null ? void 0 : staticGenerationStore.forceStatic) {
        return true;
    }
    if (staticGenerationStore == null ? void 0 : staticGenerationStore.dynamicShouldError) {
        const { dynamic ="error" , link  } = opts || {};
        const suffix = link ? " See more info here: " + link : "";
        throw new StaticGenBailoutError('Page with `dynamic = "' + dynamic + "\"` couldn't be rendered statically because it used `" + reason + "`." + suffix);
    }
    if (staticGenerationStore) {
        staticGenerationStore.revalidate = 0;
    }
    if (staticGenerationStore == null ? void 0 : staticGenerationStore.isStaticGeneration) {
        const err = new _hooksservercontext.DynamicServerError(reason);
        staticGenerationStore.dynamicUsageDescription = reason;
        staticGenerationStore.dynamicUsageStack = err.stack;
        throw err;
    }
    return false;
};
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=static-generation-bailout.js.map


/***/ }),

/***/ 2468:
/***/ ((module) => {

"use strict";

(()=>{
    "use strict";
    var e = {
        339: (e, t, r)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.ContextAPI = void 0;
            const n = r(44);
            const a = r(38);
            const o = r(741);
            const i = "context";
            const c = new n.NoopContextManager;
            class ContextAPI {
                constructor(){}
                static getInstance() {
                    if (!this._instance) {
                        this._instance = new ContextAPI;
                    }
                    return this._instance;
                }
                setGlobalContextManager(e) {
                    return (0, a.registerGlobal)(i, e, o.DiagAPI.instance());
                }
                active() {
                    return this._getContextManager().active();
                }
                with(e, t, r, ...n) {
                    return this._getContextManager().with(e, t, r, ...n);
                }
                bind(e, t) {
                    return this._getContextManager().bind(e, t);
                }
                _getContextManager() {
                    return (0, a.getGlobal)(i) || c;
                }
                disable() {
                    this._getContextManager().disable();
                    (0, a.unregisterGlobal)(i, o.DiagAPI.instance());
                }
            }
            t.ContextAPI = ContextAPI;
        },
        741: (e, t, r)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.DiagAPI = void 0;
            const n = r(144);
            const a = r(871);
            const o = r(133);
            const i = r(38);
            const c = "diag";
            class DiagAPI {
                constructor(){
                    function _logProxy(e) {
                        return function(...t) {
                            const r = (0, i.getGlobal)("diag");
                            if (!r) return;
                            return r[e](...t);
                        };
                    }
                    const e = this;
                    const setLogger = (t, r = {
                        logLevel: o.DiagLogLevel.INFO
                    })=>{
                        var n, c, s;
                        if (t === e) {
                            const t = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
                            e.error((n = t.stack) !== null && n !== void 0 ? n : t.message);
                            return false;
                        }
                        if (typeof r === "number") {
                            r = {
                                logLevel: r
                            };
                        }
                        const u = (0, i.getGlobal)("diag");
                        const l = (0, a.createLogLevelDiagLogger)((c = r.logLevel) !== null && c !== void 0 ? c : o.DiagLogLevel.INFO, t);
                        if (u && !r.suppressOverrideMessage) {
                            const e = (s = (new Error).stack) !== null && s !== void 0 ? s : "<failed to generate stacktrace>";
                            u.warn(`Current logger will be overwritten from ${e}`);
                            l.warn(`Current logger will overwrite one already registered from ${e}`);
                        }
                        return (0, i.registerGlobal)("diag", l, e, true);
                    };
                    e.setLogger = setLogger;
                    e.disable = ()=>{
                        (0, i.unregisterGlobal)(c, e);
                    };
                    e.createComponentLogger = (e)=>new n.DiagComponentLogger(e);
                    e.verbose = _logProxy("verbose");
                    e.debug = _logProxy("debug");
                    e.info = _logProxy("info");
                    e.warn = _logProxy("warn");
                    e.error = _logProxy("error");
                }
                static instance() {
                    if (!this._instance) {
                        this._instance = new DiagAPI;
                    }
                    return this._instance;
                }
            }
            t.DiagAPI = DiagAPI;
        },
        128: (e, t, r)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.MetricsAPI = void 0;
            const n = r(333);
            const a = r(38);
            const o = r(741);
            const i = "metrics";
            class MetricsAPI {
                constructor(){}
                static getInstance() {
                    if (!this._instance) {
                        this._instance = new MetricsAPI;
                    }
                    return this._instance;
                }
                setGlobalMeterProvider(e) {
                    return (0, a.registerGlobal)(i, e, o.DiagAPI.instance());
                }
                getMeterProvider() {
                    return (0, a.getGlobal)(i) || n.NOOP_METER_PROVIDER;
                }
                getMeter(e, t, r) {
                    return this.getMeterProvider().getMeter(e, t, r);
                }
                disable() {
                    (0, a.unregisterGlobal)(i, o.DiagAPI.instance());
                }
            }
            t.MetricsAPI = MetricsAPI;
        },
        930: (e, t, r)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.PropagationAPI = void 0;
            const n = r(38);
            const a = r(600);
            const o = r(625);
            const i = r(377);
            const c = r(701);
            const s = r(741);
            const u = "propagation";
            const l = new a.NoopTextMapPropagator;
            class PropagationAPI {
                constructor(){
                    this.createBaggage = c.createBaggage;
                    this.getBaggage = i.getBaggage;
                    this.getActiveBaggage = i.getActiveBaggage;
                    this.setBaggage = i.setBaggage;
                    this.deleteBaggage = i.deleteBaggage;
                }
                static getInstance() {
                    if (!this._instance) {
                        this._instance = new PropagationAPI;
                    }
                    return this._instance;
                }
                setGlobalPropagator(e) {
                    return (0, n.registerGlobal)(u, e, s.DiagAPI.instance());
                }
                inject(e, t, r = o.defaultTextMapSetter) {
                    return this._getGlobalPropagator().inject(e, t, r);
                }
                extract(e, t, r = o.defaultTextMapGetter) {
                    return this._getGlobalPropagator().extract(e, t, r);
                }
                fields() {
                    return this._getGlobalPropagator().fields();
                }
                disable() {
                    (0, n.unregisterGlobal)(u, s.DiagAPI.instance());
                }
                _getGlobalPropagator() {
                    return (0, n.getGlobal)(u) || l;
                }
            }
            t.PropagationAPI = PropagationAPI;
        },
        967: (e, t, r)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.TraceAPI = void 0;
            const n = r(38);
            const a = r(414);
            const o = r(994);
            const i = r(542);
            const c = r(741);
            const s = "trace";
            class TraceAPI {
                constructor(){
                    this._proxyTracerProvider = new a.ProxyTracerProvider;
                    this.wrapSpanContext = o.wrapSpanContext;
                    this.isSpanContextValid = o.isSpanContextValid;
                    this.deleteSpan = i.deleteSpan;
                    this.getSpan = i.getSpan;
                    this.getActiveSpan = i.getActiveSpan;
                    this.getSpanContext = i.getSpanContext;
                    this.setSpan = i.setSpan;
                    this.setSpanContext = i.setSpanContext;
                }
                static getInstance() {
                    if (!this._instance) {
                        this._instance = new TraceAPI;
                    }
                    return this._instance;
                }
                setGlobalTracerProvider(e) {
                    const t = (0, n.registerGlobal)(s, this._proxyTracerProvider, c.DiagAPI.instance());
                    if (t) {
                        this._proxyTracerProvider.setDelegate(e);
                    }
                    return t;
                }
                getTracerProvider() {
                    return (0, n.getGlobal)(s) || this._proxyTracerProvider;
                }
                getTracer(e, t) {
                    return this.getTracerProvider().getTracer(e, t);
                }
                disable() {
                    (0, n.unregisterGlobal)(s, c.DiagAPI.instance());
                    this._proxyTracerProvider = new a.ProxyTracerProvider;
                }
            }
            t.TraceAPI = TraceAPI;
        },
        377: (e, t, r)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.deleteBaggage = t.setBaggage = t.getActiveBaggage = t.getBaggage = void 0;
            const n = r(339);
            const a = r(421);
            const o = (0, a.createContextKey)("OpenTelemetry Baggage Key");
            function getBaggage(e) {
                return e.getValue(o) || undefined;
            }
            t.getBaggage = getBaggage;
            function getActiveBaggage() {
                return getBaggage(n.ContextAPI.getInstance().active());
            }
            t.getActiveBaggage = getActiveBaggage;
            function setBaggage(e, t) {
                return e.setValue(o, t);
            }
            t.setBaggage = setBaggage;
            function deleteBaggage(e) {
                return e.deleteValue(o);
            }
            t.deleteBaggage = deleteBaggage;
        },
        496: (e, t)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.BaggageImpl = void 0;
            class BaggageImpl {
                constructor(e){
                    this._entries = e ? new Map(e) : new Map;
                }
                getEntry(e) {
                    const t = this._entries.get(e);
                    if (!t) {
                        return undefined;
                    }
                    return Object.assign({}, t);
                }
                getAllEntries() {
                    return Array.from(this._entries.entries()).map(([e, t])=>[
                            e,
                            t
                        ]);
                }
                setEntry(e, t) {
                    const r = new BaggageImpl(this._entries);
                    r._entries.set(e, t);
                    return r;
                }
                removeEntry(e) {
                    const t = new BaggageImpl(this._entries);
                    t._entries.delete(e);
                    return t;
                }
                removeEntries(...e) {
                    const t = new BaggageImpl(this._entries);
                    for (const r of e){
                        t._entries.delete(r);
                    }
                    return t;
                }
                clear() {
                    return new BaggageImpl;
                }
            }
            t.BaggageImpl = BaggageImpl;
        },
        817: (e, t)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.baggageEntryMetadataSymbol = void 0;
            t.baggageEntryMetadataSymbol = Symbol("BaggageEntryMetadata");
        },
        701: (e, t, r)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.baggageEntryMetadataFromString = t.createBaggage = void 0;
            const n = r(741);
            const a = r(496);
            const o = r(817);
            const i = n.DiagAPI.instance();
            function createBaggage(e = {}) {
                return new a.BaggageImpl(new Map(Object.entries(e)));
            }
            t.createBaggage = createBaggage;
            function baggageEntryMetadataFromString(e) {
                if (typeof e !== "string") {
                    i.error(`Cannot create baggage metadata from unknown type: ${typeof e}`);
                    e = "";
                }
                return {
                    __TYPE__: o.baggageEntryMetadataSymbol,
                    toString () {
                        return e;
                    }
                };
            }
            t.baggageEntryMetadataFromString = baggageEntryMetadataFromString;
        },
        388: (e, t, r)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.context = void 0;
            const n = r(339);
            t.context = n.ContextAPI.getInstance();
        },
        44: (e, t, r)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.NoopContextManager = void 0;
            const n = r(421);
            class NoopContextManager {
                active() {
                    return n.ROOT_CONTEXT;
                }
                with(e, t, r, ...n) {
                    return t.call(r, ...n);
                }
                bind(e, t) {
                    return t;
                }
                enable() {
                    return this;
                }
                disable() {
                    return this;
                }
            }
            t.NoopContextManager = NoopContextManager;
        },
        421: (e, t)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.ROOT_CONTEXT = t.createContextKey = void 0;
            function createContextKey(e) {
                return Symbol.for(e);
            }
            t.createContextKey = createContextKey;
            class BaseContext {
                constructor(e){
                    const t = this;
                    t._currentContext = e ? new Map(e) : new Map;
                    t.getValue = (e)=>t._currentContext.get(e);
                    t.setValue = (e, r)=>{
                        const n = new BaseContext(t._currentContext);
                        n._currentContext.set(e, r);
                        return n;
                    };
                    t.deleteValue = (e)=>{
                        const r = new BaseContext(t._currentContext);
                        r._currentContext.delete(e);
                        return r;
                    };
                }
            }
            t.ROOT_CONTEXT = new BaseContext;
        },
        920: (e, t, r)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.diag = void 0;
            const n = r(741);
            t.diag = n.DiagAPI.instance();
        },
        144: (e, t, r)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.DiagComponentLogger = void 0;
            const n = r(38);
            class DiagComponentLogger {
                constructor(e){
                    this._namespace = e.namespace || "DiagComponentLogger";
                }
                debug(...e) {
                    return logProxy("debug", this._namespace, e);
                }
                error(...e) {
                    return logProxy("error", this._namespace, e);
                }
                info(...e) {
                    return logProxy("info", this._namespace, e);
                }
                warn(...e) {
                    return logProxy("warn", this._namespace, e);
                }
                verbose(...e) {
                    return logProxy("verbose", this._namespace, e);
                }
            }
            t.DiagComponentLogger = DiagComponentLogger;
            function logProxy(e, t, r) {
                const a = (0, n.getGlobal)("diag");
                if (!a) {
                    return;
                }
                r.unshift(t);
                return a[e](...r);
            }
        },
        689: (e, t)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.DiagConsoleLogger = void 0;
            const r = [
                {
                    n: "error",
                    c: "error"
                },
                {
                    n: "warn",
                    c: "warn"
                },
                {
                    n: "info",
                    c: "info"
                },
                {
                    n: "debug",
                    c: "debug"
                },
                {
                    n: "verbose",
                    c: "trace"
                }
            ];
            class DiagConsoleLogger {
                constructor(){
                    function _consoleFunc(e) {
                        return function(...t) {
                            if (console) {
                                let r = console[e];
                                if (typeof r !== "function") {
                                    r = console.log;
                                }
                                if (typeof r === "function") {
                                    return r.apply(console, t);
                                }
                            }
                        };
                    }
                    for(let e = 0; e < r.length; e++){
                        this[r[e].n] = _consoleFunc(r[e].c);
                    }
                }
            }
            t.DiagConsoleLogger = DiagConsoleLogger;
        },
        871: (e, t, r)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.createLogLevelDiagLogger = void 0;
            const n = r(133);
            function createLogLevelDiagLogger(e, t) {
                if (e < n.DiagLogLevel.NONE) {
                    e = n.DiagLogLevel.NONE;
                } else if (e > n.DiagLogLevel.ALL) {
                    e = n.DiagLogLevel.ALL;
                }
                t = t || {};
                function _filterFunc(r, n) {
                    const a = t[r];
                    if (typeof a === "function" && e >= n) {
                        return a.bind(t);
                    }
                    return function() {};
                }
                return {
                    error: _filterFunc("error", n.DiagLogLevel.ERROR),
                    warn: _filterFunc("warn", n.DiagLogLevel.WARN),
                    info: _filterFunc("info", n.DiagLogLevel.INFO),
                    debug: _filterFunc("debug", n.DiagLogLevel.DEBUG),
                    verbose: _filterFunc("verbose", n.DiagLogLevel.VERBOSE)
                };
            }
            t.createLogLevelDiagLogger = createLogLevelDiagLogger;
        },
        133: (e, t)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.DiagLogLevel = void 0;
            var r;
            (function(e) {
                e[e["NONE"] = 0] = "NONE";
                e[e["ERROR"] = 30] = "ERROR";
                e[e["WARN"] = 50] = "WARN";
                e[e["INFO"] = 60] = "INFO";
                e[e["DEBUG"] = 70] = "DEBUG";
                e[e["VERBOSE"] = 80] = "VERBOSE";
                e[e["ALL"] = 9999] = "ALL";
            })(r = t.DiagLogLevel || (t.DiagLogLevel = {}));
        },
        38: (e, t, r)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.unregisterGlobal = t.getGlobal = t.registerGlobal = void 0;
            const n = r(966);
            const a = r(520);
            const o = r(565);
            const i = a.VERSION.split(".")[0];
            const c = Symbol.for(`opentelemetry.js.api.${i}`);
            const s = n._globalThis;
            function registerGlobal(e, t, r, n = false) {
                var o;
                const i = s[c] = (o = s[c]) !== null && o !== void 0 ? o : {
                    version: a.VERSION
                };
                if (!n && i[e]) {
                    const t = new Error(`@opentelemetry/api: Attempted duplicate registration of API: ${e}`);
                    r.error(t.stack || t.message);
                    return false;
                }
                if (i.version !== a.VERSION) {
                    const t = new Error(`@opentelemetry/api: Registration of version v${i.version} for ${e} does not match previously registered API v${a.VERSION}`);
                    r.error(t.stack || t.message);
                    return false;
                }
                i[e] = t;
                r.debug(`@opentelemetry/api: Registered a global for ${e} v${a.VERSION}.`);
                return true;
            }
            t.registerGlobal = registerGlobal;
            function getGlobal(e) {
                var t, r;
                const n = (t = s[c]) === null || t === void 0 ? void 0 : t.version;
                if (!n || !(0, o.isCompatible)(n)) {
                    return;
                }
                return (r = s[c]) === null || r === void 0 ? void 0 : r[e];
            }
            t.getGlobal = getGlobal;
            function unregisterGlobal(e, t) {
                t.debug(`@opentelemetry/api: Unregistering a global for ${e} v${a.VERSION}.`);
                const r = s[c];
                if (r) {
                    delete r[e];
                }
            }
            t.unregisterGlobal = unregisterGlobal;
        },
        565: (e, t, r)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.isCompatible = t._makeCompatibilityCheck = void 0;
            const n = r(520);
            const a = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
            function _makeCompatibilityCheck(e) {
                const t = new Set([
                    e
                ]);
                const r = new Set;
                const n = e.match(a);
                if (!n) {
                    return ()=>false;
                }
                const o = {
                    major: +n[1],
                    minor: +n[2],
                    patch: +n[3],
                    prerelease: n[4]
                };
                if (o.prerelease != null) {
                    return function isExactmatch(t) {
                        return t === e;
                    };
                }
                function _reject(e) {
                    r.add(e);
                    return false;
                }
                function _accept(e) {
                    t.add(e);
                    return true;
                }
                return function isCompatible(e) {
                    if (t.has(e)) {
                        return true;
                    }
                    if (r.has(e)) {
                        return false;
                    }
                    const n = e.match(a);
                    if (!n) {
                        return _reject(e);
                    }
                    const i = {
                        major: +n[1],
                        minor: +n[2],
                        patch: +n[3],
                        prerelease: n[4]
                    };
                    if (i.prerelease != null) {
                        return _reject(e);
                    }
                    if (o.major !== i.major) {
                        return _reject(e);
                    }
                    if (o.major === 0) {
                        if (o.minor === i.minor && o.patch <= i.patch) {
                            return _accept(e);
                        }
                        return _reject(e);
                    }
                    if (o.minor <= i.minor) {
                        return _accept(e);
                    }
                    return _reject(e);
                };
            }
            t._makeCompatibilityCheck = _makeCompatibilityCheck;
            t.isCompatible = _makeCompatibilityCheck(n.VERSION);
        },
        934: (e, t, r)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.metrics = void 0;
            const n = r(128);
            t.metrics = n.MetricsAPI.getInstance();
        },
        28: (e, t)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.ValueType = void 0;
            var r;
            (function(e) {
                e[e["INT"] = 0] = "INT";
                e[e["DOUBLE"] = 1] = "DOUBLE";
            })(r = t.ValueType || (t.ValueType = {}));
        },
        962: (e, t)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.createNoopMeter = t.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = t.NOOP_OBSERVABLE_GAUGE_METRIC = t.NOOP_OBSERVABLE_COUNTER_METRIC = t.NOOP_UP_DOWN_COUNTER_METRIC = t.NOOP_HISTOGRAM_METRIC = t.NOOP_COUNTER_METRIC = t.NOOP_METER = t.NoopObservableUpDownCounterMetric = t.NoopObservableGaugeMetric = t.NoopObservableCounterMetric = t.NoopObservableMetric = t.NoopHistogramMetric = t.NoopUpDownCounterMetric = t.NoopCounterMetric = t.NoopMetric = t.NoopMeter = void 0;
            class NoopMeter {
                constructor(){}
                createHistogram(e, r) {
                    return t.NOOP_HISTOGRAM_METRIC;
                }
                createCounter(e, r) {
                    return t.NOOP_COUNTER_METRIC;
                }
                createUpDownCounter(e, r) {
                    return t.NOOP_UP_DOWN_COUNTER_METRIC;
                }
                createObservableGauge(e, r) {
                    return t.NOOP_OBSERVABLE_GAUGE_METRIC;
                }
                createObservableCounter(e, r) {
                    return t.NOOP_OBSERVABLE_COUNTER_METRIC;
                }
                createObservableUpDownCounter(e, r) {
                    return t.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;
                }
                addBatchObservableCallback(e, t) {}
                removeBatchObservableCallback(e) {}
            }
            t.NoopMeter = NoopMeter;
            class NoopMetric {
            }
            t.NoopMetric = NoopMetric;
            class NoopCounterMetric extends NoopMetric {
                add(e, t) {}
            }
            t.NoopCounterMetric = NoopCounterMetric;
            class NoopUpDownCounterMetric extends NoopMetric {
                add(e, t) {}
            }
            t.NoopUpDownCounterMetric = NoopUpDownCounterMetric;
            class NoopHistogramMetric extends NoopMetric {
                record(e, t) {}
            }
            t.NoopHistogramMetric = NoopHistogramMetric;
            class NoopObservableMetric {
                addCallback(e) {}
                removeCallback(e) {}
            }
            t.NoopObservableMetric = NoopObservableMetric;
            class NoopObservableCounterMetric extends NoopObservableMetric {
            }
            t.NoopObservableCounterMetric = NoopObservableCounterMetric;
            class NoopObservableGaugeMetric extends NoopObservableMetric {
            }
            t.NoopObservableGaugeMetric = NoopObservableGaugeMetric;
            class NoopObservableUpDownCounterMetric extends NoopObservableMetric {
            }
            t.NoopObservableUpDownCounterMetric = NoopObservableUpDownCounterMetric;
            t.NOOP_METER = new NoopMeter;
            t.NOOP_COUNTER_METRIC = new NoopCounterMetric;
            t.NOOP_HISTOGRAM_METRIC = new NoopHistogramMetric;
            t.NOOP_UP_DOWN_COUNTER_METRIC = new NoopUpDownCounterMetric;
            t.NOOP_OBSERVABLE_COUNTER_METRIC = new NoopObservableCounterMetric;
            t.NOOP_OBSERVABLE_GAUGE_METRIC = new NoopObservableGaugeMetric;
            t.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = new NoopObservableUpDownCounterMetric;
            function createNoopMeter() {
                return t.NOOP_METER;
            }
            t.createNoopMeter = createNoopMeter;
        },
        333: (e, t, r)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.NOOP_METER_PROVIDER = t.NoopMeterProvider = void 0;
            const n = r(962);
            class NoopMeterProvider {
                getMeter(e, t, r) {
                    return n.NOOP_METER;
                }
            }
            t.NoopMeterProvider = NoopMeterProvider;
            t.NOOP_METER_PROVIDER = new NoopMeterProvider;
        },
        966: function(e, t, r) {
            var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
                if (n === undefined) n = r;
                Object.defineProperty(e, n, {
                    enumerable: true,
                    get: function() {
                        return t[r];
                    }
                });
            } : function(e, t, r, n) {
                if (n === undefined) n = r;
                e[n] = t[r];
            });
            var a = this && this.__exportStar || function(e, t) {
                for(var r in e)if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            a(r(652), t);
        },
        385: (e, t)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t._globalThis = void 0;
            t._globalThis = typeof globalThis === "object" ? globalThis : global;
        },
        652: function(e, t, r) {
            var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
                if (n === undefined) n = r;
                Object.defineProperty(e, n, {
                    enumerable: true,
                    get: function() {
                        return t[r];
                    }
                });
            } : function(e, t, r, n) {
                if (n === undefined) n = r;
                e[n] = t[r];
            });
            var a = this && this.__exportStar || function(e, t) {
                for(var r in e)if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            a(r(385), t);
        },
        251: (e, t, r)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.propagation = void 0;
            const n = r(930);
            t.propagation = n.PropagationAPI.getInstance();
        },
        600: (e, t)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.NoopTextMapPropagator = void 0;
            class NoopTextMapPropagator {
                inject(e, t) {}
                extract(e, t) {
                    return e;
                }
                fields() {
                    return [];
                }
            }
            t.NoopTextMapPropagator = NoopTextMapPropagator;
        },
        625: (e, t)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.defaultTextMapSetter = t.defaultTextMapGetter = void 0;
            t.defaultTextMapGetter = {
                get (e, t) {
                    if (e == null) {
                        return undefined;
                    }
                    return e[t];
                },
                keys (e) {
                    if (e == null) {
                        return [];
                    }
                    return Object.keys(e);
                }
            };
            t.defaultTextMapSetter = {
                set (e, t, r) {
                    if (e == null) {
                        return;
                    }
                    e[t] = r;
                }
            };
        },
        978: (e, t, r)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.trace = void 0;
            const n = r(967);
            t.trace = n.TraceAPI.getInstance();
        },
        76: (e, t, r)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.NonRecordingSpan = void 0;
            const n = r(304);
            class NonRecordingSpan {
                constructor(e = n.INVALID_SPAN_CONTEXT){
                    this._spanContext = e;
                }
                spanContext() {
                    return this._spanContext;
                }
                setAttribute(e, t) {
                    return this;
                }
                setAttributes(e) {
                    return this;
                }
                addEvent(e, t) {
                    return this;
                }
                setStatus(e) {
                    return this;
                }
                updateName(e) {
                    return this;
                }
                end(e) {}
                isRecording() {
                    return false;
                }
                recordException(e, t) {}
            }
            t.NonRecordingSpan = NonRecordingSpan;
        },
        527: (e, t, r)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.NoopTracer = void 0;
            const n = r(339);
            const a = r(542);
            const o = r(76);
            const i = r(994);
            const c = n.ContextAPI.getInstance();
            class NoopTracer {
                startSpan(e, t, r = c.active()) {
                    const n = Boolean(t === null || t === void 0 ? void 0 : t.root);
                    if (n) {
                        return new o.NonRecordingSpan;
                    }
                    const s = r && (0, a.getSpanContext)(r);
                    if (isSpanContext(s) && (0, i.isSpanContextValid)(s)) {
                        return new o.NonRecordingSpan(s);
                    } else {
                        return new o.NonRecordingSpan;
                    }
                }
                startActiveSpan(e, t, r, n) {
                    let o;
                    let i;
                    let s;
                    if (arguments.length < 2) {
                        return;
                    } else if (arguments.length === 2) {
                        s = t;
                    } else if (arguments.length === 3) {
                        o = t;
                        s = r;
                    } else {
                        o = t;
                        i = r;
                        s = n;
                    }
                    const u = i !== null && i !== void 0 ? i : c.active();
                    const l = this.startSpan(e, o, u);
                    const g = (0, a.setSpan)(u, l);
                    return c.with(g, s, undefined, l);
                }
            }
            t.NoopTracer = NoopTracer;
            function isSpanContext(e) {
                return typeof e === "object" && typeof e["spanId"] === "string" && typeof e["traceId"] === "string" && typeof e["traceFlags"] === "number";
            }
        },
        228: (e, t, r)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.NoopTracerProvider = void 0;
            const n = r(527);
            class NoopTracerProvider {
                getTracer(e, t, r) {
                    return new n.NoopTracer;
                }
            }
            t.NoopTracerProvider = NoopTracerProvider;
        },
        387: (e, t, r)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.ProxyTracer = void 0;
            const n = r(527);
            const a = new n.NoopTracer;
            class ProxyTracer {
                constructor(e, t, r, n){
                    this._provider = e;
                    this.name = t;
                    this.version = r;
                    this.options = n;
                }
                startSpan(e, t, r) {
                    return this._getTracer().startSpan(e, t, r);
                }
                startActiveSpan(e, t, r, n) {
                    const a = this._getTracer();
                    return Reflect.apply(a.startActiveSpan, a, arguments);
                }
                _getTracer() {
                    if (this._delegate) {
                        return this._delegate;
                    }
                    const e = this._provider.getDelegateTracer(this.name, this.version, this.options);
                    if (!e) {
                        return a;
                    }
                    this._delegate = e;
                    return this._delegate;
                }
            }
            t.ProxyTracer = ProxyTracer;
        },
        414: (e, t, r)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.ProxyTracerProvider = void 0;
            const n = r(387);
            const a = r(228);
            const o = new a.NoopTracerProvider;
            class ProxyTracerProvider {
                getTracer(e, t, r) {
                    var a;
                    return (a = this.getDelegateTracer(e, t, r)) !== null && a !== void 0 ? a : new n.ProxyTracer(this, e, t, r);
                }
                getDelegate() {
                    var e;
                    return (e = this._delegate) !== null && e !== void 0 ? e : o;
                }
                setDelegate(e) {
                    this._delegate = e;
                }
                getDelegateTracer(e, t, r) {
                    var n;
                    return (n = this._delegate) === null || n === void 0 ? void 0 : n.getTracer(e, t, r);
                }
            }
            t.ProxyTracerProvider = ProxyTracerProvider;
        },
        505: (e, t)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.SamplingDecision = void 0;
            var r;
            (function(e) {
                e[e["NOT_RECORD"] = 0] = "NOT_RECORD";
                e[e["RECORD"] = 1] = "RECORD";
                e[e["RECORD_AND_SAMPLED"] = 2] = "RECORD_AND_SAMPLED";
            })(r = t.SamplingDecision || (t.SamplingDecision = {}));
        },
        542: (e, t, r)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.getSpanContext = t.setSpanContext = t.deleteSpan = t.setSpan = t.getActiveSpan = t.getSpan = void 0;
            const n = r(421);
            const a = r(76);
            const o = r(339);
            const i = (0, n.createContextKey)("OpenTelemetry Context Key SPAN");
            function getSpan(e) {
                return e.getValue(i) || undefined;
            }
            t.getSpan = getSpan;
            function getActiveSpan() {
                return getSpan(o.ContextAPI.getInstance().active());
            }
            t.getActiveSpan = getActiveSpan;
            function setSpan(e, t) {
                return e.setValue(i, t);
            }
            t.setSpan = setSpan;
            function deleteSpan(e) {
                return e.deleteValue(i);
            }
            t.deleteSpan = deleteSpan;
            function setSpanContext(e, t) {
                return setSpan(e, new a.NonRecordingSpan(t));
            }
            t.setSpanContext = setSpanContext;
            function getSpanContext(e) {
                var t;
                return (t = getSpan(e)) === null || t === void 0 ? void 0 : t.spanContext();
            }
            t.getSpanContext = getSpanContext;
        },
        430: (e, t, r)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.TraceStateImpl = void 0;
            const n = r(450);
            const a = 32;
            const o = 512;
            const i = ",";
            const c = "=";
            class TraceStateImpl {
                constructor(e){
                    this._internalState = new Map;
                    if (e) this._parse(e);
                }
                set(e, t) {
                    const r = this._clone();
                    if (r._internalState.has(e)) {
                        r._internalState.delete(e);
                    }
                    r._internalState.set(e, t);
                    return r;
                }
                unset(e) {
                    const t = this._clone();
                    t._internalState.delete(e);
                    return t;
                }
                get(e) {
                    return this._internalState.get(e);
                }
                serialize() {
                    return this._keys().reduce((e, t)=>{
                        e.push(t + c + this.get(t));
                        return e;
                    }, []).join(i);
                }
                _parse(e) {
                    if (e.length > o) return;
                    this._internalState = e.split(i).reverse().reduce((e, t)=>{
                        const r = t.trim();
                        const a = r.indexOf(c);
                        if (a !== -1) {
                            const o = r.slice(0, a);
                            const i = r.slice(a + 1, t.length);
                            if ((0, n.validateKey)(o) && (0, n.validateValue)(i)) {
                                e.set(o, i);
                            } else {}
                        }
                        return e;
                    }, new Map);
                    if (this._internalState.size > a) {
                        this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, a));
                    }
                }
                _keys() {
                    return Array.from(this._internalState.keys()).reverse();
                }
                _clone() {
                    const e = new TraceStateImpl;
                    e._internalState = new Map(this._internalState);
                    return e;
                }
            }
            t.TraceStateImpl = TraceStateImpl;
        },
        450: (e, t)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.validateValue = t.validateKey = void 0;
            const r = "[_0-9a-z-*/]";
            const n = `[a-z]${r}{0,255}`;
            const a = `[a-z0-9]${r}{0,240}@[a-z]${r}{0,13}`;
            const o = new RegExp(`^(?:${n}|${a})$`);
            const i = /^[ -~]{0,255}[!-~]$/;
            const c = /,|=/;
            function validateKey(e) {
                return o.test(e);
            }
            t.validateKey = validateKey;
            function validateValue(e) {
                return i.test(e) && !c.test(e);
            }
            t.validateValue = validateValue;
        },
        757: (e, t, r)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.createTraceState = void 0;
            const n = r(430);
            function createTraceState(e) {
                return new n.TraceStateImpl(e);
            }
            t.createTraceState = createTraceState;
        },
        304: (e, t, r)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.INVALID_SPAN_CONTEXT = t.INVALID_TRACEID = t.INVALID_SPANID = void 0;
            const n = r(762);
            t.INVALID_SPANID = "0000000000000000";
            t.INVALID_TRACEID = "00000000000000000000000000000000";
            t.INVALID_SPAN_CONTEXT = {
                traceId: t.INVALID_TRACEID,
                spanId: t.INVALID_SPANID,
                traceFlags: n.TraceFlags.NONE
            };
        },
        902: (e, t)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.SpanKind = void 0;
            var r;
            (function(e) {
                e[e["INTERNAL"] = 0] = "INTERNAL";
                e[e["SERVER"] = 1] = "SERVER";
                e[e["CLIENT"] = 2] = "CLIENT";
                e[e["PRODUCER"] = 3] = "PRODUCER";
                e[e["CONSUMER"] = 4] = "CONSUMER";
            })(r = t.SpanKind || (t.SpanKind = {}));
        },
        994: (e, t, r)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.wrapSpanContext = t.isSpanContextValid = t.isValidSpanId = t.isValidTraceId = void 0;
            const n = r(304);
            const a = r(76);
            const o = /^([0-9a-f]{32})$/i;
            const i = /^[0-9a-f]{16}$/i;
            function isValidTraceId(e) {
                return o.test(e) && e !== n.INVALID_TRACEID;
            }
            t.isValidTraceId = isValidTraceId;
            function isValidSpanId(e) {
                return i.test(e) && e !== n.INVALID_SPANID;
            }
            t.isValidSpanId = isValidSpanId;
            function isSpanContextValid(e) {
                return isValidTraceId(e.traceId) && isValidSpanId(e.spanId);
            }
            t.isSpanContextValid = isSpanContextValid;
            function wrapSpanContext(e) {
                return new a.NonRecordingSpan(e);
            }
            t.wrapSpanContext = wrapSpanContext;
        },
        832: (e, t)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.SpanStatusCode = void 0;
            var r;
            (function(e) {
                e[e["UNSET"] = 0] = "UNSET";
                e[e["OK"] = 1] = "OK";
                e[e["ERROR"] = 2] = "ERROR";
            })(r = t.SpanStatusCode || (t.SpanStatusCode = {}));
        },
        762: (e, t)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.TraceFlags = void 0;
            var r;
            (function(e) {
                e[e["NONE"] = 0] = "NONE";
                e[e["SAMPLED"] = 1] = "SAMPLED";
            })(r = t.TraceFlags || (t.TraceFlags = {}));
        },
        520: (e, t)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.VERSION = void 0;
            t.VERSION = "1.4.1";
        }
    };
    var t = {};
    function __nccwpck_require__(r) {
        var n = t[r];
        if (n !== undefined) {
            return n.exports;
        }
        var a = t[r] = {
            exports: {}
        };
        var o = true;
        try {
            e[r].call(a.exports, a, a.exports, __nccwpck_require__);
            o = false;
        } finally{
            if (o) delete t[r];
        }
        return a.exports;
    }
    if (typeof __nccwpck_require__ !== "undefined") __nccwpck_require__.ab = __dirname + "/";
    var r = {};
    (()=>{
        var e = r;
        Object.defineProperty(e, "__esModule", {
            value: true
        });
        e.trace = e.propagation = e.metrics = e.diag = e.context = e.INVALID_SPAN_CONTEXT = e.INVALID_TRACEID = e.INVALID_SPANID = e.isValidSpanId = e.isValidTraceId = e.isSpanContextValid = e.createTraceState = e.TraceFlags = e.SpanStatusCode = e.SpanKind = e.SamplingDecision = e.ProxyTracerProvider = e.ProxyTracer = e.defaultTextMapSetter = e.defaultTextMapGetter = e.ValueType = e.createNoopMeter = e.DiagLogLevel = e.DiagConsoleLogger = e.ROOT_CONTEXT = e.createContextKey = e.baggageEntryMetadataFromString = void 0;
        var t = __nccwpck_require__(701);
        Object.defineProperty(e, "baggageEntryMetadataFromString", {
            enumerable: true,
            get: function() {
                return t.baggageEntryMetadataFromString;
            }
        });
        var n = __nccwpck_require__(421);
        Object.defineProperty(e, "createContextKey", {
            enumerable: true,
            get: function() {
                return n.createContextKey;
            }
        });
        Object.defineProperty(e, "ROOT_CONTEXT", {
            enumerable: true,
            get: function() {
                return n.ROOT_CONTEXT;
            }
        });
        var a = __nccwpck_require__(689);
        Object.defineProperty(e, "DiagConsoleLogger", {
            enumerable: true,
            get: function() {
                return a.DiagConsoleLogger;
            }
        });
        var o = __nccwpck_require__(133);
        Object.defineProperty(e, "DiagLogLevel", {
            enumerable: true,
            get: function() {
                return o.DiagLogLevel;
            }
        });
        var i = __nccwpck_require__(962);
        Object.defineProperty(e, "createNoopMeter", {
            enumerable: true,
            get: function() {
                return i.createNoopMeter;
            }
        });
        var c = __nccwpck_require__(28);
        Object.defineProperty(e, "ValueType", {
            enumerable: true,
            get: function() {
                return c.ValueType;
            }
        });
        var s = __nccwpck_require__(625);
        Object.defineProperty(e, "defaultTextMapGetter", {
            enumerable: true,
            get: function() {
                return s.defaultTextMapGetter;
            }
        });
        Object.defineProperty(e, "defaultTextMapSetter", {
            enumerable: true,
            get: function() {
                return s.defaultTextMapSetter;
            }
        });
        var u = __nccwpck_require__(387);
        Object.defineProperty(e, "ProxyTracer", {
            enumerable: true,
            get: function() {
                return u.ProxyTracer;
            }
        });
        var l = __nccwpck_require__(414);
        Object.defineProperty(e, "ProxyTracerProvider", {
            enumerable: true,
            get: function() {
                return l.ProxyTracerProvider;
            }
        });
        var g = __nccwpck_require__(505);
        Object.defineProperty(e, "SamplingDecision", {
            enumerable: true,
            get: function() {
                return g.SamplingDecision;
            }
        });
        var p = __nccwpck_require__(902);
        Object.defineProperty(e, "SpanKind", {
            enumerable: true,
            get: function() {
                return p.SpanKind;
            }
        });
        var d = __nccwpck_require__(832);
        Object.defineProperty(e, "SpanStatusCode", {
            enumerable: true,
            get: function() {
                return d.SpanStatusCode;
            }
        });
        var _ = __nccwpck_require__(762);
        Object.defineProperty(e, "TraceFlags", {
            enumerable: true,
            get: function() {
                return _.TraceFlags;
            }
        });
        var f = __nccwpck_require__(757);
        Object.defineProperty(e, "createTraceState", {
            enumerable: true,
            get: function() {
                return f.createTraceState;
            }
        });
        var b = __nccwpck_require__(994);
        Object.defineProperty(e, "isSpanContextValid", {
            enumerable: true,
            get: function() {
                return b.isSpanContextValid;
            }
        });
        Object.defineProperty(e, "isValidTraceId", {
            enumerable: true,
            get: function() {
                return b.isValidTraceId;
            }
        });
        Object.defineProperty(e, "isValidSpanId", {
            enumerable: true,
            get: function() {
                return b.isValidSpanId;
            }
        });
        var v = __nccwpck_require__(304);
        Object.defineProperty(e, "INVALID_SPANID", {
            enumerable: true,
            get: function() {
                return v.INVALID_SPANID;
            }
        });
        Object.defineProperty(e, "INVALID_TRACEID", {
            enumerable: true,
            get: function() {
                return v.INVALID_TRACEID;
            }
        });
        Object.defineProperty(e, "INVALID_SPAN_CONTEXT", {
            enumerable: true,
            get: function() {
                return v.INVALID_SPAN_CONTEXT;
            }
        });
        const O = __nccwpck_require__(388);
        Object.defineProperty(e, "context", {
            enumerable: true,
            get: function() {
                return O.context;
            }
        });
        const P = __nccwpck_require__(920);
        Object.defineProperty(e, "diag", {
            enumerable: true,
            get: function() {
                return P.diag;
            }
        });
        const N = __nccwpck_require__(934);
        Object.defineProperty(e, "metrics", {
            enumerable: true,
            get: function() {
                return N.metrics;
            }
        });
        const S = __nccwpck_require__(251);
        Object.defineProperty(e, "propagation", {
            enumerable: true,
            get: function() {
                return S.propagation;
            }
        });
        const C = __nccwpck_require__(978);
        Object.defineProperty(e, "trace", {
            enumerable: true,
            get: function() {
                return C.trace;
            }
        });
        e["default"] = {
            context: O.context,
            diag: P.diag,
            metrics: N.metrics,
            propagation: S.propagation,
            trace: C.trace
        };
    })();
    module.exports = r;
})();


/***/ }),

/***/ 6444:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return _default;
    }
}));
let chalk;
if (false) {} else {
    chalk = __webpack_require__(4426);
}
const _default = chalk; //# sourceMappingURL=chalk.js.map


/***/ }),

/***/ 2878:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
0 && (0);
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    NEXT_QUERY_PARAM_PREFIX: function() {
        return NEXT_QUERY_PARAM_PREFIX;
    },
    PRERENDER_REVALIDATE_HEADER: function() {
        return PRERENDER_REVALIDATE_HEADER;
    },
    PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER: function() {
        return PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER;
    },
    CACHE_ONE_YEAR: function() {
        return CACHE_ONE_YEAR;
    },
    MIDDLEWARE_FILENAME: function() {
        return MIDDLEWARE_FILENAME;
    },
    MIDDLEWARE_LOCATION_REGEXP: function() {
        return MIDDLEWARE_LOCATION_REGEXP;
    },
    INSTRUMENTATION_HOOK_FILENAME: function() {
        return INSTRUMENTATION_HOOK_FILENAME;
    },
    INSTRUMENTATION_HOOKS_LOCATION_REGEXP: function() {
        return INSTRUMENTATION_HOOKS_LOCATION_REGEXP;
    },
    PAGES_DIR_ALIAS: function() {
        return PAGES_DIR_ALIAS;
    },
    DOT_NEXT_ALIAS: function() {
        return DOT_NEXT_ALIAS;
    },
    ROOT_DIR_ALIAS: function() {
        return ROOT_DIR_ALIAS;
    },
    APP_DIR_ALIAS: function() {
        return APP_DIR_ALIAS;
    },
    RSC_MOD_REF_PROXY_ALIAS: function() {
        return RSC_MOD_REF_PROXY_ALIAS;
    },
    RSC_ACTION_PROXY_ALIAS: function() {
        return RSC_ACTION_PROXY_ALIAS;
    },
    RSC_ACTION_CLIENT_WRAPPER_ALIAS: function() {
        return RSC_ACTION_CLIENT_WRAPPER_ALIAS;
    },
    PUBLIC_DIR_MIDDLEWARE_CONFLICT: function() {
        return PUBLIC_DIR_MIDDLEWARE_CONFLICT;
    },
    SSG_GET_INITIAL_PROPS_CONFLICT: function() {
        return SSG_GET_INITIAL_PROPS_CONFLICT;
    },
    SERVER_PROPS_GET_INIT_PROPS_CONFLICT: function() {
        return SERVER_PROPS_GET_INIT_PROPS_CONFLICT;
    },
    SERVER_PROPS_SSG_CONFLICT: function() {
        return SERVER_PROPS_SSG_CONFLICT;
    },
    STATIC_STATUS_PAGE_GET_INITIAL_PROPS_ERROR: function() {
        return STATIC_STATUS_PAGE_GET_INITIAL_PROPS_ERROR;
    },
    SERVER_PROPS_EXPORT_ERROR: function() {
        return SERVER_PROPS_EXPORT_ERROR;
    },
    GSP_NO_RETURNED_VALUE: function() {
        return GSP_NO_RETURNED_VALUE;
    },
    GSSP_NO_RETURNED_VALUE: function() {
        return GSSP_NO_RETURNED_VALUE;
    },
    UNSTABLE_REVALIDATE_RENAME_ERROR: function() {
        return UNSTABLE_REVALIDATE_RENAME_ERROR;
    },
    GSSP_COMPONENT_MEMBER_ERROR: function() {
        return GSSP_COMPONENT_MEMBER_ERROR;
    },
    NON_STANDARD_NODE_ENV: function() {
        return NON_STANDARD_NODE_ENV;
    },
    SSG_FALLBACK_EXPORT_ERROR: function() {
        return SSG_FALLBACK_EXPORT_ERROR;
    },
    ESLINT_DEFAULT_DIRS: function() {
        return ESLINT_DEFAULT_DIRS;
    },
    ESLINT_DEFAULT_DIRS_WITH_APP: function() {
        return ESLINT_DEFAULT_DIRS_WITH_APP;
    },
    ESLINT_PROMPT_VALUES: function() {
        return ESLINT_PROMPT_VALUES;
    },
    SERVER_RUNTIME: function() {
        return SERVER_RUNTIME;
    },
    WEBPACK_LAYERS: function() {
        return WEBPACK_LAYERS;
    }
});
const NEXT_QUERY_PARAM_PREFIX = "nxtP";
const PRERENDER_REVALIDATE_HEADER = "x-prerender-revalidate";
const PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER = "x-prerender-revalidate-if-generated";
const CACHE_ONE_YEAR = 31536000;
const MIDDLEWARE_FILENAME = "middleware";
const MIDDLEWARE_LOCATION_REGEXP = `(?:src/)?${MIDDLEWARE_FILENAME}`;
const INSTRUMENTATION_HOOK_FILENAME = "instrumentation";
const INSTRUMENTATION_HOOKS_LOCATION_REGEXP = `(?:src/)?${INSTRUMENTATION_HOOK_FILENAME}`;
const PAGES_DIR_ALIAS = "private-next-pages";
const DOT_NEXT_ALIAS = "private-dot-next";
const ROOT_DIR_ALIAS = "private-next-root-dir";
const APP_DIR_ALIAS = "private-next-app-dir";
const RSC_MOD_REF_PROXY_ALIAS = "next/dist/build/webpack/loaders/next-flight-loader/module-proxy";
const RSC_ACTION_PROXY_ALIAS = "private-next-rsc-action-proxy";
const RSC_ACTION_CLIENT_WRAPPER_ALIAS = "private-next-rsc-action-client-wrapper";
const PUBLIC_DIR_MIDDLEWARE_CONFLICT = `You can not have a '_next' folder inside of your public folder. This conflicts with the internal '/_next' route. https://nextjs.org/docs/messages/public-next-folder-conflict`;
const SSG_GET_INITIAL_PROPS_CONFLICT = `You can not use getInitialProps with getStaticProps. To use SSG, please remove your getInitialProps`;
const SERVER_PROPS_GET_INIT_PROPS_CONFLICT = `You can not use getInitialProps with getServerSideProps. Please remove getInitialProps.`;
const SERVER_PROPS_SSG_CONFLICT = `You can not use getStaticProps or getStaticPaths with getServerSideProps. To use SSG, please remove getServerSideProps`;
const STATIC_STATUS_PAGE_GET_INITIAL_PROPS_ERROR = `can not have getInitialProps/getServerSideProps, https://nextjs.org/docs/messages/404-get-initial-props`;
const SERVER_PROPS_EXPORT_ERROR = `pages with \`getServerSideProps\` can not be exported. See more info here: https://nextjs.org/docs/messages/gssp-export`;
const GSP_NO_RETURNED_VALUE = "Your `getStaticProps` function did not return an object. Did you forget to add a `return`?";
const GSSP_NO_RETURNED_VALUE = "Your `getServerSideProps` function did not return an object. Did you forget to add a `return`?";
const UNSTABLE_REVALIDATE_RENAME_ERROR = "The `unstable_revalidate` property is available for general use.\n" + "Please use `revalidate` instead.";
const GSSP_COMPONENT_MEMBER_ERROR = `can not be attached to a page's component and must be exported from the page. See more info here: https://nextjs.org/docs/messages/gssp-component-member`;
const NON_STANDARD_NODE_ENV = `You are using a non-standard "NODE_ENV" value in your environment. This creates inconsistencies in the project and is strongly advised against. Read more: https://nextjs.org/docs/messages/non-standard-node-env`;
const SSG_FALLBACK_EXPORT_ERROR = `Pages with \`fallback\` enabled in \`getStaticPaths\` can not be exported. See more info here: https://nextjs.org/docs/messages/ssg-fallback-true-export`;
const ESLINT_DEFAULT_DIRS = [
    "pages",
    "components",
    "lib",
    "src"
];
const ESLINT_DEFAULT_DIRS_WITH_APP = [
    "app",
    ...ESLINT_DEFAULT_DIRS
];
const ESLINT_PROMPT_VALUES = [
    {
        title: "Strict",
        recommended: true,
        config: {
            extends: "next/core-web-vitals"
        }
    },
    {
        title: "Base",
        config: {
            extends: "next"
        }
    },
    {
        title: "Cancel",
        config: null
    }
];
const SERVER_RUNTIME = {
    edge: "edge",
    experimentalEdge: "experimental-edge",
    nodejs: "nodejs"
};
const WEBPACK_LAYERS = {
    shared: "sc_shared",
    server: "sc_server",
    client: "sc_client",
    action: "sc_action",
    api: "api",
    middleware: "middleware",
    edgeAsset: "edge-asset",
    appClient: "app-client"
}; //# sourceMappingURL=constants.js.map


/***/ }),

/***/ 8043:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "interopDefault", ({
    enumerable: true,
    get: function() {
        return interopDefault;
    }
}));
function interopDefault(mod) {
    return mod.default || mod;
} //# sourceMappingURL=interop-default.js.map


/***/ }),

/***/ 6496:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
0 && (0);
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    default: function() {
        return isError;
    },
    getProperError: function() {
        return getProperError;
    }
});
const _isplainobject = __webpack_require__(9864);
function isError(err) {
    return typeof err === "object" && err !== null && "name" in err && "message" in err;
}
function getProperError(err) {
    if (isError(err)) {
        return err;
    }
    if (false) {}
    return new Error((0, _isplainobject.isPlainObject)(err) ? JSON.stringify(err) : err + "");
} //# sourceMappingURL=is-error.js.map


/***/ }),

/***/ 1549:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
0 && (0);
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    getCookieParser: function() {
        return getCookieParser;
    },
    sendStatusCode: function() {
        return sendStatusCode;
    },
    redirect: function() {
        return redirect;
    },
    checkIsOnDemandRevalidate: function() {
        return checkIsOnDemandRevalidate;
    },
    COOKIE_NAME_PRERENDER_BYPASS: function() {
        return COOKIE_NAME_PRERENDER_BYPASS;
    },
    COOKIE_NAME_PRERENDER_DATA: function() {
        return COOKIE_NAME_PRERENDER_DATA;
    },
    RESPONSE_LIMIT_DEFAULT: function() {
        return RESPONSE_LIMIT_DEFAULT;
    },
    SYMBOL_PREVIEW_DATA: function() {
        return SYMBOL_PREVIEW_DATA;
    },
    SYMBOL_CLEARED_COOKIES: function() {
        return SYMBOL_CLEARED_COOKIES;
    },
    clearPreviewData: function() {
        return clearPreviewData;
    },
    ApiError: function() {
        return ApiError;
    },
    sendError: function() {
        return sendError;
    },
    setLazyProp: function() {
        return setLazyProp;
    }
});
const _headers = __webpack_require__(104);
const _constants = __webpack_require__(2878);
function getCookieParser(headers) {
    return function parseCookie() {
        const { cookie  } = headers;
        if (!cookie) {
            return {};
        }
        const { parse: parseCookieFn  } = __webpack_require__(252);
        return parseCookieFn(Array.isArray(cookie) ? cookie.join("; ") : cookie);
    };
}
function sendStatusCode(res, statusCode) {
    res.statusCode = statusCode;
    return res;
}
function redirect(res, statusOrUrl, url) {
    if (typeof statusOrUrl === "string") {
        url = statusOrUrl;
        statusOrUrl = 307;
    }
    if (typeof statusOrUrl !== "number" || typeof url !== "string") {
        throw new Error(`Invalid redirect arguments. Please use a single argument URL, e.g. res.redirect('/destination') or use a status code and URL, e.g. res.redirect(307, '/destination').`);
    }
    res.writeHead(statusOrUrl, {
        Location: url
    });
    res.write(url);
    res.end();
    return res;
}
function checkIsOnDemandRevalidate(req, previewProps) {
    const headers = _headers.HeadersAdapter.from(req.headers);
    const previewModeId = headers.get(_constants.PRERENDER_REVALIDATE_HEADER);
    const isOnDemandRevalidate = previewModeId === previewProps.previewModeId;
    const revalidateOnlyGenerated = headers.has(_constants.PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER);
    return {
        isOnDemandRevalidate,
        revalidateOnlyGenerated
    };
}
const COOKIE_NAME_PRERENDER_BYPASS = `__prerender_bypass`;
const COOKIE_NAME_PRERENDER_DATA = `__next_preview_data`;
const RESPONSE_LIMIT_DEFAULT = 4 * 1024 * 1024;
const SYMBOL_PREVIEW_DATA = Symbol(COOKIE_NAME_PRERENDER_DATA);
const SYMBOL_CLEARED_COOKIES = Symbol(COOKIE_NAME_PRERENDER_BYPASS);
function clearPreviewData(res, options = {}) {
    if (SYMBOL_CLEARED_COOKIES in res) {
        return res;
    }
    const { serialize  } = __webpack_require__(252);
    const previous = res.getHeader("Set-Cookie");
    res.setHeader(`Set-Cookie`, [
        ...typeof previous === "string" ? [
            previous
        ] : Array.isArray(previous) ? previous : [],
        serialize(COOKIE_NAME_PRERENDER_BYPASS, "", {
            // To delete a cookie, set `expires` to a date in the past:
            // https://tools.ietf.org/html/rfc6265#section-4.1.1
            // `Max-Age: 0` is not valid, thus ignored, and the cookie is persisted.
            expires: new Date(0),
            httpOnly: true,
            sameSite:  true ? "none" : 0,
            secure: "production" !== "development",
            path: "/",
            ...options.path !== undefined ? {
                path: options.path
            } : undefined
        }),
        serialize(COOKIE_NAME_PRERENDER_DATA, "", {
            // To delete a cookie, set `expires` to a date in the past:
            // https://tools.ietf.org/html/rfc6265#section-4.1.1
            // `Max-Age: 0` is not valid, thus ignored, and the cookie is persisted.
            expires: new Date(0),
            httpOnly: true,
            sameSite:  true ? "none" : 0,
            secure: "production" !== "development",
            path: "/",
            ...options.path !== undefined ? {
                path: options.path
            } : undefined
        })
    ]);
    Object.defineProperty(res, SYMBOL_CLEARED_COOKIES, {
        value: true,
        enumerable: false
    });
    return res;
}
class ApiError extends Error {
    constructor(statusCode, message){
        super(message);
        this.statusCode = statusCode;
    }
}
function sendError(res, statusCode, message) {
    res.statusCode = statusCode;
    res.statusMessage = message;
    res.end(message);
}
function setLazyProp({ req  }, prop, getter) {
    const opts = {
        configurable: true,
        enumerable: true
    };
    const optsReset = {
        ...opts,
        writable: true
    };
    Object.defineProperty(req, prop, {
        ...opts,
        get: ()=>{
            const value = getter();
            // we set the property on the object to avoid recalculating it
            Object.defineProperty(req, prop, {
                ...optsReset,
                value
            });
            return value;
        },
        set: (value)=>{
            Object.defineProperty(req, prop, {
                ...optsReset,
                value
            });
        }
    });
} //# sourceMappingURL=index.js.map


/***/ }),

/***/ 8664:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
0 && (0);
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    tryGetPreviewData: function() {
        return tryGetPreviewData;
    },
    parseBody: function() {
        return parseBody;
    },
    apiResolver: function() {
        return apiResolver;
    }
});
const _ = __webpack_require__(1549);
const _bytes = /*#__PURE__*/ _interop_require_default(__webpack_require__(5547));
const _etag = __webpack_require__(1175);
const _sendpayload = __webpack_require__(5122);
const _stream = __webpack_require__(2781);
const _contenttype = __webpack_require__(4929);
const _iserror = /*#__PURE__*/ _interop_require_default(__webpack_require__(6496));
const _utils = __webpack_require__(6199);
const _interopdefault = __webpack_require__(8043);
const _index = __webpack_require__(1549);
const _mockrequest = __webpack_require__(9310);
const _tracer = __webpack_require__(2224);
const _constants = __webpack_require__(9707);
const _cookies = __webpack_require__(5153);
const _headers = __webpack_require__(104);
const _constants1 = __webpack_require__(2878);
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function tryGetPreviewData(req, res, options) {
    var _cookies_get, _cookies_get1;
    // if an On-Demand revalidation is being done preview mode
    // is disabled
    if (options && (0, _.checkIsOnDemandRevalidate)(req, options).isOnDemandRevalidate) {
        return false;
    }
    // Read cached preview data if present
    // TODO: use request metadata instead of a symbol
    if (_index.SYMBOL_PREVIEW_DATA in req) {
        return req[_index.SYMBOL_PREVIEW_DATA];
    }
    const headers = _headers.HeadersAdapter.from(req.headers);
    const cookies = new _cookies.RequestCookies(headers);
    const previewModeId = (_cookies_get = cookies.get(_index.COOKIE_NAME_PRERENDER_BYPASS)) == null ? void 0 : _cookies_get.value;
    const tokenPreviewData = (_cookies_get1 = cookies.get(_index.COOKIE_NAME_PRERENDER_DATA)) == null ? void 0 : _cookies_get1.value;
    // Case: preview mode cookie set but data cookie is not set
    if (previewModeId && !tokenPreviewData && previewModeId === options.previewModeId) {
        // This is "Draft Mode" which doesn't use
        // previewData, so we return an empty object
        // for backwards compat with "Preview Mode".
        const data = {};
        Object.defineProperty(req, _index.SYMBOL_PREVIEW_DATA, {
            value: data,
            enumerable: false
        });
        return data;
    }
    // Case: neither cookie is set.
    if (!previewModeId && !tokenPreviewData) {
        return false;
    }
    // Case: one cookie is set, but not the other.
    if (!previewModeId || !tokenPreviewData) {
        (0, _index.clearPreviewData)(res);
        return false;
    }
    // Case: preview session is for an old build.
    if (previewModeId !== options.previewModeId) {
        (0, _index.clearPreviewData)(res);
        return false;
    }
    let encryptedPreviewData;
    try {
        const jsonwebtoken = __webpack_require__(5644);
        encryptedPreviewData = jsonwebtoken.verify(tokenPreviewData, options.previewModeSigningKey);
    } catch  {
        // TODO: warn
        (0, _index.clearPreviewData)(res);
        return false;
    }
    const { decryptWithSecret  } = __webpack_require__(6110);
    const decryptedPreviewData = decryptWithSecret(Buffer.from(options.previewModeEncryptionKey), encryptedPreviewData.data);
    try {
        // TODO: strict runtime type checking
        const data = JSON.parse(decryptedPreviewData);
        // Cache lookup
        Object.defineProperty(req, _index.SYMBOL_PREVIEW_DATA, {
            value: data,
            enumerable: false
        });
        return data;
    } catch  {
        return false;
    }
}
/**
 * Parse `JSON` and handles invalid `JSON` strings
 * @param str `JSON` string
 */ function parseJson(str) {
    if (str.length === 0) {
        // special-case empty json body, as it's a common client-side mistake
        return {};
    }
    try {
        return JSON.parse(str);
    } catch (e) {
        throw new _index.ApiError(400, "Invalid JSON");
    }
}
async function parseBody(req, limit) {
    let contentType;
    try {
        contentType = (0, _contenttype.parse)(req.headers["content-type"] || "text/plain");
    } catch  {
        contentType = (0, _contenttype.parse)("text/plain");
    }
    const { type , parameters  } = contentType;
    const encoding = parameters.charset || "utf-8";
    let buffer;
    try {
        const getRawBody = __webpack_require__(7798);
        buffer = await getRawBody(req, {
            encoding,
            limit
        });
    } catch (e) {
        if ((0, _iserror.default)(e) && e.type === "entity.too.large") {
            throw new _index.ApiError(413, `Body exceeded ${limit} limit`);
        } else {
            throw new _index.ApiError(400, "Invalid body");
        }
    }
    const body = buffer.toString();
    if (type === "application/json" || type === "application/ld+json") {
        return parseJson(body);
    } else if (type === "application/x-www-form-urlencoded") {
        const qs = __webpack_require__(3477);
        return qs.decode(body);
    } else {
        return body;
    }
}
function getMaxContentLength(responseLimit) {
    if (responseLimit && typeof responseLimit !== "boolean") {
        return _bytes.default.parse(responseLimit);
    }
    return _index.RESPONSE_LIMIT_DEFAULT;
}
/**
 * Send `any` body to response
 * @param req request object
 * @param res response object
 * @param body of response
 */ function sendData(req, res, body) {
    if (body === null || body === undefined) {
        res.end();
        return;
    }
    // strip irrelevant headers/body
    if (res.statusCode === 204 || res.statusCode === 304) {
        res.removeHeader("Content-Type");
        res.removeHeader("Content-Length");
        res.removeHeader("Transfer-Encoding");
        if (false) {}
        res.end();
        return;
    }
    const contentType = res.getHeader("Content-Type");
    if (body instanceof _stream.Stream) {
        if (!contentType) {
            res.setHeader("Content-Type", "application/octet-stream");
        }
        body.pipe(res);
        return;
    }
    const isJSONLike = [
        "object",
        "number",
        "boolean"
    ].includes(typeof body);
    const stringifiedBody = isJSONLike ? JSON.stringify(body) : body;
    const etag = (0, _etag.generateETag)(stringifiedBody);
    if ((0, _sendpayload.sendEtagResponse)(req, res, etag)) {
        return;
    }
    if (Buffer.isBuffer(body)) {
        if (!contentType) {
            res.setHeader("Content-Type", "application/octet-stream");
        }
        res.setHeader("Content-Length", body.length);
        res.end(body);
        return;
    }
    if (isJSONLike) {
        res.setHeader("Content-Type", "application/json; charset=utf-8");
    }
    res.setHeader("Content-Length", Buffer.byteLength(stringifiedBody));
    res.end(stringifiedBody);
}
/**
 * Send `JSON` object
 * @param res response object
 * @param jsonBody of data
 */ function sendJson(res, jsonBody) {
    // Set header to application/json
    res.setHeader("Content-Type", "application/json; charset=utf-8");
    // Use send to handle request
    res.send(JSON.stringify(jsonBody));
}
function isValidData(str) {
    return typeof str === "string" && str.length >= 16;
}
function setDraftMode(res, options) {
    if (!isValidData(options.previewModeId)) {
        throw new Error("invariant: invalid previewModeId");
    }
    const expires = options.enable ? undefined : new Date(0);
    // To delete a cookie, set `expires` to a date in the past:
    // https://tools.ietf.org/html/rfc6265#section-4.1.1
    // `Max-Age: 0` is not valid, thus ignored, and the cookie is persisted.
    const { serialize  } = __webpack_require__(252);
    const previous = res.getHeader("Set-Cookie");
    res.setHeader(`Set-Cookie`, [
        ...typeof previous === "string" ? [
            previous
        ] : Array.isArray(previous) ? previous : [],
        serialize(_index.COOKIE_NAME_PRERENDER_BYPASS, options.previewModeId, {
            httpOnly: true,
            sameSite:  true ? "none" : 0,
            secure: "production" !== "development",
            path: "/",
            expires
        })
    ]);
    return res;
}
function setPreviewData(res, data, options) {
    if (!isValidData(options.previewModeId)) {
        throw new Error("invariant: invalid previewModeId");
    }
    if (!isValidData(options.previewModeEncryptionKey)) {
        throw new Error("invariant: invalid previewModeEncryptionKey");
    }
    if (!isValidData(options.previewModeSigningKey)) {
        throw new Error("invariant: invalid previewModeSigningKey");
    }
    const jsonwebtoken = __webpack_require__(5644);
    const { encryptWithSecret  } = __webpack_require__(6110);
    const payload = jsonwebtoken.sign({
        data: encryptWithSecret(Buffer.from(options.previewModeEncryptionKey), JSON.stringify(data))
    }, options.previewModeSigningKey, {
        algorithm: "HS256",
        ...options.maxAge !== undefined ? {
            expiresIn: options.maxAge
        } : undefined
    });
    // limit preview mode cookie to 2KB since we shouldn't store too much
    // data here and browsers drop cookies over 4KB
    if (payload.length > 2048) {
        throw new Error(`Preview data is limited to 2KB currently, reduce how much data you are storing as preview data to continue`);
    }
    const { serialize  } = __webpack_require__(252);
    const previous = res.getHeader("Set-Cookie");
    res.setHeader(`Set-Cookie`, [
        ...typeof previous === "string" ? [
            previous
        ] : Array.isArray(previous) ? previous : [],
        serialize(_index.COOKIE_NAME_PRERENDER_BYPASS, options.previewModeId, {
            httpOnly: true,
            sameSite:  true ? "none" : 0,
            secure: "production" !== "development",
            path: "/",
            ...options.maxAge !== undefined ? {
                maxAge: options.maxAge
            } : undefined,
            ...options.path !== undefined ? {
                path: options.path
            } : undefined
        }),
        serialize(_index.COOKIE_NAME_PRERENDER_DATA, payload, {
            httpOnly: true,
            sameSite:  true ? "none" : 0,
            secure: "production" !== "development",
            path: "/",
            ...options.maxAge !== undefined ? {
                maxAge: options.maxAge
            } : undefined,
            ...options.path !== undefined ? {
                path: options.path
            } : undefined
        })
    ]);
    return res;
}
async function revalidate(urlPath, opts, req, context) {
    if (typeof urlPath !== "string" || !urlPath.startsWith("/")) {
        throw new Error(`Invalid urlPath provided to revalidate(), must be a path e.g. /blog/post-1, received ${urlPath}`);
    }
    const revalidateHeaders = {
        [_constants1.PRERENDER_REVALIDATE_HEADER]: context.previewModeId,
        ...opts.unstable_onlyGenerated ? {
            [_constants1.PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER]: "1"
        } : {}
    };
    const allowedRevalidateHeaderKeys = [
        ...context.allowedRevalidateHeaderKeys || [],
        ...context.trustHostHeader ? [
            "cookie",
            "x-vercel-protection-bypass"
        ] : []
    ];
    for (const key of Object.keys(req.headers)){
        if (allowedRevalidateHeaderKeys.includes(key)) {
            revalidateHeaders[key] = req.headers[key];
        }
    }
    try {
        if (context.trustHostHeader) {
            const res = await fetch(`https://${req.headers.host}${urlPath}`, {
                method: "HEAD",
                headers: revalidateHeaders
            });
            // we use the cache header to determine successful revalidate as
            // a non-200 status code can be returned from a successful revalidate
            // e.g. notFound: true returns 404 status code but is successful
            const cacheHeader = res.headers.get("x-vercel-cache") || res.headers.get("x-nextjs-cache");
            if ((cacheHeader == null ? void 0 : cacheHeader.toUpperCase()) !== "REVALIDATED" && !(res.status === 404 && opts.unstable_onlyGenerated)) {
                throw new Error(`Invalid response ${res.status}`);
            }
        } else if (context.revalidate) {
            const mocked = (0, _mockrequest.createRequestResponseMocks)({
                url: urlPath,
                headers: revalidateHeaders
            });
            await context.revalidate(mocked.req, mocked.res);
            await mocked.res.hasStreamed;
            if (mocked.res.getHeader("x-nextjs-cache") !== "REVALIDATED" && !(mocked.res.statusCode === 404 && opts.unstable_onlyGenerated)) {
                throw new Error(`Invalid response ${mocked.res.statusCode}`);
            }
        } else {
            throw new Error(`Invariant: required internal revalidate method not passed to api-utils`);
        }
    } catch (err) {
        throw new Error(`Failed to revalidate ${urlPath}: ${(0, _iserror.default)(err) ? err.message : err}`);
    }
}
async function apiResolver(req, res, query, resolverModule, apiContext, propagateError, dev, page) {
    const apiReq = req;
    const apiRes = res;
    try {
        var _config_api, _config_api1, _config_api2, _getTracer_getRootSpanAttributes;
        if (!resolverModule) {
            res.statusCode = 404;
            res.end("Not Found");
            return;
        }
        const config = resolverModule.config || {};
        const bodyParser = ((_config_api = config.api) == null ? void 0 : _config_api.bodyParser) !== false;
        const responseLimit = ((_config_api1 = config.api) == null ? void 0 : _config_api1.responseLimit) ?? true;
        const externalResolver = ((_config_api2 = config.api) == null ? void 0 : _config_api2.externalResolver) || false;
        // Parsing of cookies
        (0, _index.setLazyProp)({
            req: apiReq
        }, "cookies", (0, _index.getCookieParser)(req.headers));
        // Parsing query string
        apiReq.query = query;
        // Parsing preview data
        (0, _index.setLazyProp)({
            req: apiReq
        }, "previewData", ()=>tryGetPreviewData(req, res, apiContext));
        // Checking if preview mode is enabled
        (0, _index.setLazyProp)({
            req: apiReq
        }, "preview", ()=>apiReq.previewData !== false ? true : undefined);
        // Set draftMode to the same value as preview
        (0, _index.setLazyProp)({
            req: apiReq
        }, "draftMode", ()=>apiReq.preview);
        // Parsing of body
        if (bodyParser && !apiReq.body) {
            apiReq.body = await parseBody(apiReq, config.api && config.api.bodyParser && config.api.bodyParser.sizeLimit ? config.api.bodyParser.sizeLimit : "1mb");
        }
        let contentLength = 0;
        const maxContentLength = getMaxContentLength(responseLimit);
        const writeData = apiRes.write;
        const endResponse = apiRes.end;
        apiRes.write = (...args)=>{
            contentLength += Buffer.byteLength(args[0] || "");
            return writeData.apply(apiRes, args);
        };
        apiRes.end = (...args)=>{
            if (args.length && typeof args[0] !== "function") {
                contentLength += Buffer.byteLength(args[0] || "");
            }
            if (responseLimit && contentLength >= maxContentLength) {
                console.warn(`API response for ${req.url} exceeds ${_bytes.default.format(maxContentLength)}. API Routes are meant to respond quickly. https://nextjs.org/docs/messages/api-routes-response-size-limit`);
            }
            endResponse.apply(apiRes, args);
        };
        apiRes.status = (statusCode)=>(0, _index.sendStatusCode)(apiRes, statusCode);
        apiRes.send = (data)=>sendData(apiReq, apiRes, data);
        apiRes.json = (data)=>sendJson(apiRes, data);
        apiRes.redirect = (statusOrUrl, url)=>(0, _index.redirect)(apiRes, statusOrUrl, url);
        apiRes.setDraftMode = (options = {
            enable: true
        })=>setDraftMode(apiRes, Object.assign({}, apiContext, options));
        apiRes.setPreviewData = (data, options = {})=>setPreviewData(apiRes, data, Object.assign({}, apiContext, options));
        apiRes.clearPreviewData = (options = {})=>(0, _index.clearPreviewData)(apiRes, options);
        apiRes.revalidate = (urlPath, opts)=>revalidate(urlPath, opts || {}, req, apiContext);
        const resolver = (0, _interopdefault.interopDefault)(resolverModule);
        let wasPiped = false;
        if (false) {}
        (_getTracer_getRootSpanAttributes = (0, _tracer.getTracer)().getRootSpanAttributes()) == null ? void 0 : _getTracer_getRootSpanAttributes.set("next.route", page);
        // Call API route method
        const apiRouteResult = await (0, _tracer.getTracer)().trace(_constants.NodeSpan.runHandler, {
            spanName: `executing api route (pages) ${page}`
        }, ()=>resolver(req, res));
        if (false) {}
    } catch (err) {
        if (err instanceof _index.ApiError) {
            (0, _index.sendError)(apiRes, err.statusCode, err.message);
        } else {
            if (dev) {
                if ((0, _iserror.default)(err)) {
                    err.page = page;
                }
                throw err;
            }
            console.error(err);
            if (propagateError) {
                throw err;
            }
            (0, _index.sendError)(apiRes, 500, "Internal Server Error");
        }
    }
} //# sourceMappingURL=node.js.map


/***/ }),

/***/ 2415:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "RequestAsyncStorageWrapper", ({
    enumerable: true,
    get: function() {
        return RequestAsyncStorageWrapper;
    }
}));
const _approuterheaders = __webpack_require__(4940);
const _headers = __webpack_require__(104);
const _requestcookies = __webpack_require__(5697);
const _cookies = __webpack_require__(5153);
function getHeaders(headers) {
    const cleaned = _headers.HeadersAdapter.from(headers);
    for (const param of _approuterheaders.FLIGHT_PARAMETERS){
        cleaned.delete(param.toString().toLowerCase());
    }
    return _headers.HeadersAdapter.seal(cleaned);
}
function getCookies(headers) {
    const cookies = new _cookies.RequestCookies(_headers.HeadersAdapter.from(headers));
    return _requestcookies.RequestCookiesAdapter.seal(cookies);
}
function getMutableCookies(headers, res) {
    const cookies = new _cookies.RequestCookies(_headers.HeadersAdapter.from(headers));
    return _requestcookies.MutableRequestCookiesAdapter.seal(cookies, res);
}
/**
 * Tries to get the preview data on the request for the given route. This
 * isn't enabled in the edge runtime yet.
 */ const tryGetPreviewData =  true ? (__webpack_require__(8664).tryGetPreviewData) : 0;
const RequestAsyncStorageWrapper = {
    /**
   * Wrap the callback with the given store so it can access the underlying
   * store using hooks.
   *
   * @param storage underlying storage object returned by the module
   * @param context context to seed the store
   * @param callback function to call within the scope of the context
   * @returns the result returned by the callback
   */ wrap (storage, { req , res , renderOpts  }, callback) {
        // Reads of this are cached on the `req` object, so this should resolve
        // instantly. There's no need to pass this data down from a previous
        // invoke.
        const previewData = renderOpts && tryGetPreviewData && res ? tryGetPreviewData(req, res, renderOpts.previewProps) : false;
        const cache = {};
        const store = {
            get headers () {
                if (!cache.headers) {
                    // Seal the headers object that'll freeze out any methods that could
                    // mutate the underlying data.
                    cache.headers = getHeaders(req.headers);
                }
                return cache.headers;
            },
            get cookies () {
                if (!cache.cookies) {
                    // Seal the cookies object that'll freeze out any methods that could
                    // mutate the underlying data.
                    cache.cookies = getCookies(req.headers);
                }
                return cache.cookies;
            },
            get mutableCookies () {
                if (!cache.mutableCookies) {
                    cache.mutableCookies = getMutableCookies(req.headers, res);
                }
                return cache.mutableCookies;
            },
            previewData
        };
        return storage.run(store, callback, store);
    }
}; //# sourceMappingURL=request-async-storage-wrapper.js.map


/***/ }),

/***/ 9185:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "StaticGenerationAsyncStorageWrapper", ({
    enumerable: true,
    get: function() {
        return StaticGenerationAsyncStorageWrapper;
    }
}));
const StaticGenerationAsyncStorageWrapper = {
    wrap (storage, { pathname , renderOpts  }, callback) {
        /**
     * Rules of Static & Dynamic HTML:
     *
     *    1.) We must generate static HTML unless the caller explicitly opts
     *        in to dynamic HTML support.
     *
     *    2.) If dynamic HTML support is requested, we must honor that request
     *        or throw an error. It is the sole responsibility of the caller to
     *        ensure they aren't e.g. requesting dynamic HTML for an AMP page.
     *
     * These rules help ensure that other existing features like request caching,
     * coalescing, and ISR continue working as intended.
     */ const isStaticGeneration = !renderOpts.supportsDynamicHTML && !renderOpts.isBot;
        const store = {
            isStaticGeneration,
            pathname,
            incrementalCache: // so that it can access the fs cache without mocks
            renderOpts.incrementalCache || globalThis.__incrementalCache,
            isRevalidate: renderOpts.isRevalidate,
            isPrerendering: renderOpts.nextExport,
            fetchCache: renderOpts.fetchCache,
            isOnDemandRevalidate: renderOpts.isOnDemandRevalidate
        };
        // TODO: remove this when we resolve accessing the store outside the execution context
        renderOpts.store = store;
        return storage.run(store, callback, store);
    }
}; //# sourceMappingURL=static-generation-async-storage-wrapper.js.map


/***/ }),

/***/ 6110:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
0 && (0);
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    encryptWithSecret: function() {
        return encryptWithSecret;
    },
    decryptWithSecret: function() {
        return decryptWithSecret;
    }
});
const _crypto = /*#__PURE__*/ _interop_require_default(__webpack_require__(6113));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
// Background:
// https://security.stackexchange.com/questions/184305/why-would-i-ever-use-aes-256-cbc-if-aes-256-gcm-is-more-secure
const CIPHER_ALGORITHM = `aes-256-gcm`, CIPHER_KEY_LENGTH = 32, CIPHER_IV_LENGTH = 16, CIPHER_TAG_LENGTH = 16, CIPHER_SALT_LENGTH = 64;
const PBKDF2_ITERATIONS = 100000 // https://support.1password.com/pbkdf2/
;
function encryptWithSecret(secret, data) {
    const iv = _crypto.default.randomBytes(CIPHER_IV_LENGTH);
    const salt = _crypto.default.randomBytes(CIPHER_SALT_LENGTH);
    // https://nodejs.org/api/crypto.html#crypto_crypto_pbkdf2sync_password_salt_iterations_keylen_digest
    const key = _crypto.default.pbkdf2Sync(secret, salt, PBKDF2_ITERATIONS, CIPHER_KEY_LENGTH, `sha512`);
    const cipher = _crypto.default.createCipheriv(CIPHER_ALGORITHM, key, iv);
    const encrypted = Buffer.concat([
        cipher.update(data, `utf8`),
        cipher.final()
    ]);
    // https://nodejs.org/api/crypto.html#crypto_cipher_getauthtag
    const tag = cipher.getAuthTag();
    return Buffer.concat([
        // Data as required by:
        // Salt for Key: https://nodejs.org/api/crypto.html#crypto_crypto_pbkdf2sync_password_salt_iterations_keylen_digest
        // IV: https://nodejs.org/api/crypto.html#crypto_class_decipher
        // Tag: https://nodejs.org/api/crypto.html#crypto_decipher_setauthtag_buffer
        salt,
        iv,
        tag,
        encrypted
    ]).toString(`hex`);
}
function decryptWithSecret(secret, encryptedData) {
    const buffer = Buffer.from(encryptedData, `hex`);
    const salt = buffer.slice(0, CIPHER_SALT_LENGTH);
    const iv = buffer.slice(CIPHER_SALT_LENGTH, CIPHER_SALT_LENGTH + CIPHER_IV_LENGTH);
    const tag = buffer.slice(CIPHER_SALT_LENGTH + CIPHER_IV_LENGTH, CIPHER_SALT_LENGTH + CIPHER_IV_LENGTH + CIPHER_TAG_LENGTH);
    const encrypted = buffer.slice(CIPHER_SALT_LENGTH + CIPHER_IV_LENGTH + CIPHER_TAG_LENGTH);
    // https://nodejs.org/api/crypto.html#crypto_crypto_pbkdf2sync_password_salt_iterations_keylen_digest
    const key = _crypto.default.pbkdf2Sync(secret, salt, PBKDF2_ITERATIONS, CIPHER_KEY_LENGTH, `sha512`);
    const decipher = _crypto.default.createDecipheriv(CIPHER_ALGORITHM, key, iv);
    decipher.setAuthTag(tag);
    return decipher.update(encrypted) + decipher.final(`utf8`);
} //# sourceMappingURL=crypto-utils.js.map


/***/ }),

/***/ 9082:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "RouteKind", ({
    enumerable: true,
    get: function() {
        return RouteKind;
    }
}));
var RouteKind;
(function(RouteKind) {
    RouteKind[/**
   * `PAGES` represents all the React pages that are under `pages/`.
   */ "PAGES"] = "PAGES";
    RouteKind[/**
   * `PAGES_API` represents all the API routes under `pages/api/`.
   */ "PAGES_API"] = "PAGES_API";
    RouteKind[/**
   * `APP_PAGE` represents all the React pages that are under `app/` with the
   * filename of `page.{j,t}s{,x}`.
   */ "APP_PAGE"] = "APP_PAGE";
    RouteKind[/**
   * `APP_ROUTE` represents all the API routes and metadata routes that are under `app/` with the
   * filename of `route.{j,t}s{,x}`.
   */ "APP_ROUTE"] = "APP_ROUTE";
})(RouteKind || (RouteKind = {})); //# sourceMappingURL=route-kind.js.map


/***/ }),

/***/ 6590:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "autoImplementMethods", ({
    enumerable: true,
    get: function() {
        return autoImplementMethods;
    }
}));
const _http = __webpack_require__(3018);
const _responsehandlers = __webpack_require__(4431);
const AUTOMATIC_ROUTE_METHODS = [
    "HEAD",
    "OPTIONS"
];
function autoImplementMethods(handlers) {
    // Loop through all the HTTP methods to create the initial methods object.
    // Each of the methods will be set to the the 405 response handler.
    const methods = _http.HTTP_METHODS.reduce((acc, method)=>({
            ...acc,
            // If the userland module implements the method, then use it. Otherwise,
            // use the 405 response handler.
            [method]: handlers[method] ?? _responsehandlers.handleMethodNotAllowedResponse
        }), {});
    // Get all the methods that could be automatically implemented that were not
    // implemented by the userland module.
    const implemented = new Set(_http.HTTP_METHODS.filter((method)=>handlers[method]));
    const missing = AUTOMATIC_ROUTE_METHODS.filter((method)=>!implemented.has(method));
    // Loop over the missing methods to automatically implement them if we can.
    for (const method of missing){
        // If the userland module doesn't implement the HEAD method, then
        // we'll automatically implement it by calling the GET method (if it
        // exists).
        if (method === "HEAD") {
            // If the userland module doesn't implement the GET method, then
            // we're done.
            if (!handlers.GET) break;
            // Implement the HEAD method by calling the GET method.
            methods.HEAD = handlers.GET;
            // Mark it as implemented.
            implemented.add("HEAD");
            continue;
        }
        // If OPTIONS is not provided then implement it.
        if (method === "OPTIONS") {
            // TODO: check if HEAD is implemented, if so, use it to add more headers
            // Get all the methods that were implemented by the userland module.
            const allow = [
                "OPTIONS",
                ...implemented
            ];
            // If the list of methods doesn't include HEAD, but it includes GET, then
            // add HEAD as it's automatically implemented.
            if (!implemented.has("HEAD") && implemented.has("GET")) {
                allow.push("HEAD");
            }
            // Sort and join the list with commas to create the `Allow` header. See:
            // https://httpwg.org/specs/rfc9110.html#field.allow
            const headers = {
                Allow: allow.sort().join(", ")
            };
            // Implement the OPTIONS method by returning a 204 response with the
            // `Allow` header.
            methods.OPTIONS = ()=>new Response(null, {
                    status: 204,
                    headers
                });
            // Mark this method as implemented.
            implemented.add("OPTIONS");
            continue;
        }
        throw new Error(`Invariant: should handle all automatic implementable methods, got method: ${method}`);
    }
    return methods;
} //# sourceMappingURL=auto-implement-methods.js.map


/***/ }),

/***/ 53:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/**
 * Cleans a URL by stripping the protocol, host, and search params.
 *
 * @param urlString the url to clean
 * @returns the cleaned url
 */ 
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "cleanURL", ({
    enumerable: true,
    get: function() {
        return cleanURL;
    }
}));
function cleanURL(urlString) {
    const url = new URL(urlString);
    url.host = "localhost:3000";
    url.search = "";
    url.protocol = "http";
    return url.toString();
} //# sourceMappingURL=clean-url.js.map


/***/ }),

/***/ 8575:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "getNonStaticMethods", ({
    enumerable: true,
    get: function() {
        return getNonStaticMethods;
    }
}));
const NON_STATIC_METHODS = [
    "OPTIONS",
    "POST",
    "PUT",
    "DELETE",
    "PATCH"
];
function getNonStaticMethods(handlers) {
    // We can currently only statically optimize if only GET/HEAD are used as
    // prerender can't be used conditionally based on the method currently.
    const methods = NON_STATIC_METHODS.filter((method)=>handlers[method]);
    if (methods.length === 0) return false;
    return methods;
} //# sourceMappingURL=get-non-static-methods.js.map


/***/ }),

/***/ 5814:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/**
 * Get pathname from absolute path.
 *
 * @param absolutePath the absolute path
 * @returns the pathname
 */ 
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "getPathnameFromAbsolutePath", ({
    enumerable: true,
    get: function() {
        return getPathnameFromAbsolutePath;
    }
}));
function getPathnameFromAbsolutePath(absolutePath) {
    // Remove prefix including app dir
    let appDir = "/app/";
    if (!absolutePath.includes(appDir)) {
        appDir = "\\app\\";
    }
    const [, ...parts] = absolutePath.split(appDir);
    const relativePath = appDir[0] + parts.join(appDir);
    // remove extension
    const pathname = relativePath.split(".").slice(0, -1).join(".");
    return pathname;
} //# sourceMappingURL=get-pathname-from-absolute-path.js.map


/***/ }),

/***/ 2058:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "proxyRequest", ({
    enumerable: true,
    get: function() {
        return proxyRequest;
    }
}));
const _cookies = __webpack_require__(7783);
const _nexturl = __webpack_require__(6299);
const _cleanurl = __webpack_require__(53);
function proxyRequest(request, { dynamic  }, hooks) {
    function handleNextUrlBailout(prop) {
        switch(prop){
            case "search":
            case "searchParams":
            case "toString":
            case "href":
            case "origin":
                hooks.staticGenerationBailout(`nextUrl.${prop}`);
                return;
            default:
                return;
        }
    }
    const cache = {};
    const handleForceStatic = (url, prop)=>{
        switch(prop){
            case "search":
                return "";
            case "searchParams":
                if (!cache.searchParams) cache.searchParams = new URLSearchParams();
                return cache.searchParams;
            case "url":
            case "href":
                if (!cache.url) cache.url = (0, _cleanurl.cleanURL)(url);
                return cache.url;
            case "toJSON":
            case "toString":
                if (!cache.url) cache.url = (0, _cleanurl.cleanURL)(url);
                if (!cache.toString) cache.toString = ()=>cache.url;
                return cache.toString;
            case "headers":
                if (!cache.headers) cache.headers = new Headers();
                return cache.headers;
            case "cookies":
                if (!cache.headers) cache.headers = new Headers();
                if (!cache.cookies) cache.cookies = new _cookies.RequestCookies(cache.headers);
                return cache.cookies;
            case "clone":
                if (!cache.url) cache.url = (0, _cleanurl.cleanURL)(url);
                return ()=>new _nexturl.NextURL(cache.url);
            default:
                break;
        }
    };
    const wrappedNextUrl = new Proxy(request.nextUrl, {
        get (target, prop) {
            handleNextUrlBailout(prop);
            if (dynamic === "force-static" && typeof prop === "string") {
                const result = handleForceStatic(target.href, prop);
                if (result !== undefined) return result;
            }
            const value = target[prop];
            if (typeof value === "function") {
                return value.bind(target);
            }
            return value;
        },
        set (target, prop, value) {
            handleNextUrlBailout(prop);
            target[prop] = value;
            return true;
        }
    });
    const handleReqBailout = (prop)=>{
        switch(prop){
            case "headers":
                hooks.headerHooks.headers();
                return;
            // if request.url is accessed directly instead of
            // request.nextUrl we bail since it includes query
            // values that can be relied on dynamically
            case "url":
            case "body":
            case "blob":
            case "json":
            case "text":
            case "arrayBuffer":
            case "formData":
                hooks.staticGenerationBailout(`request.${prop}`);
                return;
            default:
                return;
        }
    };
    return new Proxy(request, {
        get (target, prop) {
            handleReqBailout(prop);
            if (prop === "nextUrl") {
                return wrappedNextUrl;
            }
            if (dynamic === "force-static" && typeof prop === "string") {
                const result = handleForceStatic(target.url, prop);
                if (result !== undefined) return result;
            }
            const value = target[prop];
            if (typeof value === "function") {
                return value.bind(target);
            }
            return value;
        },
        set (target, prop, value) {
            handleReqBailout(prop);
            target[prop] = value;
            return true;
        }
    });
} //# sourceMappingURL=proxy-request.js.map


/***/ }),

/***/ 4614:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "resolveHandlerError", ({
    enumerable: true,
    get: function() {
        return resolveHandlerError;
    }
}));
const _notfound = __webpack_require__(6925);
const _redirect = __webpack_require__(9498);
const _responsehandlers = __webpack_require__(4431);
function resolveHandlerError(err) {
    if ((0, _redirect.isRedirectError)(err)) {
        const redirect = (0, _redirect.getURLFromRedirectError)(err);
        if (!redirect) {
            throw new Error("Invariant: Unexpected redirect url format");
        }
        // This is a redirect error! Send the redirect response.
        return (0, _responsehandlers.handleTemporaryRedirectResponse)(redirect);
    }
    if ((0, _notfound.isNotFoundError)(err)) {
        // This is a not found error! Send the not found response.
        return (0, _responsehandlers.handleNotFoundResponse)();
    }
    // Return false to indicate that this is not a handled error.
    return false;
} //# sourceMappingURL=resolve-handler-error.js.map


/***/ }),

/***/ 3232:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
0 && (0);
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    AppRouteRouteModule: function() {
        return AppRouteRouteModule;
    },
    default: function() {
        return _default;
    }
});
const _routemodule = __webpack_require__(6611);
const _requestasyncstoragewrapper = __webpack_require__(2415);
const _staticgenerationasyncstoragewrapper = __webpack_require__(9185);
const _responsehandlers = __webpack_require__(4431);
const _http = __webpack_require__(3018);
const _patchfetch = __webpack_require__(6692);
const _tracer = __webpack_require__(2224);
const _constants = __webpack_require__(9707);
const _getpathnamefromabsolutepath = __webpack_require__(5814);
const _proxyrequest = __webpack_require__(2058);
const _resolvehandlererror = __webpack_require__(4614);
const _routekind = __webpack_require__(9082);
const _log = /*#__PURE__*/ _interop_require_wildcard(__webpack_require__(6337));
const _autoimplementmethods = __webpack_require__(6590);
const _getnonstaticmethods = __webpack_require__(8575);
const _requestcookies = __webpack_require__(5697);
const _cookies = __webpack_require__(5153);
const _headers = __webpack_require__(104);
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
class AppRouteRouteModule extends _routemodule.RouteModule {
    constructor({ userland , pathname , resolvedPagePath , nextConfigOutput  }){
        super({
            userland
        });
        /**
   * When true, indicates that the global interfaces have been patched via the
   * `patch()` method.
   */ this.hasSetup = false;
        this.definition = {
            kind: _routekind.RouteKind.APP_ROUTE,
            pathname,
            // The following aren't needed for the route handler.
            page: "",
            bundlePath: "",
            filename: ""
        };
        this.pathname = pathname;
        this.resolvedPagePath = resolvedPagePath;
        this.nextConfigOutput = nextConfigOutput;
        // Automatically implement some methods if they aren't implemented by the
        // userland module.
        this.methods = (0, _autoimplementmethods.autoImplementMethods)(userland);
        // Get the non-static methods for this route.
        this.nonStaticMethods = (0, _getnonstaticmethods.getNonStaticMethods)(userland);
        // Get the dynamic property from the userland module.
        this.dynamic = this.userland.dynamic;
        if (this.nextConfigOutput === "export") {
            if (!this.dynamic || this.dynamic === "auto") {
                this.dynamic = "error";
            } else if (this.dynamic === "force-dynamic") {
                throw new Error(`export const dynamic = "force-dynamic" on page "${pathname}" cannot be used with "output: export". See more info here: https://nextjs.org/docs/advanced-features/static-html-export`);
            }
        }
    }
    /**
   * Validates the userland module to ensure the exported methods and properties
   * are valid.
   */ async setup() {
        // If we've already setup, then return.
        if (this.hasSetup) return;
        // Mark the module as setup. The following warnings about the userland
        // module will run if we're in development. If the module files are modified
        // when in development, then the require cache will be busted for it and
        // this method will be called again (resetting the `hasSetup` flag).
        this.hasSetup = true;
        // We only warn in development after here, so return if we're not in
        // development.
        if (false) {}
    }
    /**
   * Resolves the handler function for the given method.
   *
   * @param method the requested method
   * @returns the handler function for the given method
   */ resolve(method) {
        // Ensure that the requested method is a valid method (to prevent RCE's).
        if (!(0, _http.isHTTPMethod)(method)) return _responsehandlers.handleBadRequestResponse;
        // Return the handler.
        return this.methods[method];
    }
    /**
   * Executes the route handler.
   */ async execute(request, context) {
        // Get the handler function for the given method.
        const handler = this.resolve(request.method);
        // Get the context for the request.
        const requestContext = {
            req: request
        };
        // Get the context for the static generation.
        const staticGenerationContext = {
            pathname: this.definition.pathname,
            renderOpts: // the default values.
            context.staticGenerationContext ?? {
                supportsDynamicHTML: false
            }
        };
        // Add the fetchCache option to the renderOpts.
        staticGenerationContext.renderOpts.fetchCache = this.userland.fetchCache;
        // Run the handler with the request AsyncLocalStorage to inject the helper
        // support. We set this to `unknown` because the type is not known until
        // runtime when we do a instanceof check below.
        const response = await this.actionAsyncStorage.run({
            isAppRoute: true
        }, ()=>{
            return _requestasyncstoragewrapper.RequestAsyncStorageWrapper.wrap(this.requestAsyncStorage, requestContext, ()=>{
                return _staticgenerationasyncstoragewrapper.StaticGenerationAsyncStorageWrapper.wrap(this.staticGenerationAsyncStorage, staticGenerationContext, (staticGenerationStore)=>{
                    var _getTracer_getRootSpanAttributes;
                    // Check to see if we should bail out of static generation based on
                    // having non-static methods.
                    if (this.nonStaticMethods) {
                        this.staticGenerationBailout(`non-static methods used ${this.nonStaticMethods.join(", ")}`);
                    }
                    // Update the static generation store based on the dynamic property.
                    switch(this.dynamic){
                        case "force-dynamic":
                            // The dynamic property is set to force-dynamic, so we should
                            // force the page to be dynamic.
                            staticGenerationStore.forceDynamic = true;
                            this.staticGenerationBailout(`force-dynamic`, {
                                dynamic: this.dynamic
                            });
                            break;
                        case "force-static":
                            // The dynamic property is set to force-static, so we should
                            // force the page to be static.
                            staticGenerationStore.forceStatic = true;
                            break;
                        case "error":
                            // The dynamic property is set to error, so we should throw an
                            // error if the page is being statically generated.
                            staticGenerationStore.dynamicShouldError = true;
                            break;
                        default:
                            break;
                    }
                    // If the static generation store does not have a revalidate value
                    // set, then we should set it the revalidate value from the userland
                    // module or default to false.
                    staticGenerationStore.revalidate ??= this.userland.revalidate ?? false;
                    // Wrap the request so we can add additional functionality to cases
                    // that might change it's output or affect the rendering.
                    const wrappedRequest = (0, _proxyrequest.proxyRequest)(request, {
                        dynamic: this.dynamic
                    }, {
                        headerHooks: this.headerHooks,
                        serverHooks: this.serverHooks,
                        staticGenerationBailout: this.staticGenerationBailout
                    });
                    // TODO: propagate this pathname from route matcher
                    const route = (0, _getpathnamefromabsolutepath.getPathnameFromAbsolutePath)(this.resolvedPagePath);
                    (_getTracer_getRootSpanAttributes = (0, _tracer.getTracer)().getRootSpanAttributes()) == null ? void 0 : _getTracer_getRootSpanAttributes.set("next.route", route);
                    return (0, _tracer.getTracer)().trace(_constants.AppRouteRouteHandlersSpan.runHandler, {
                        spanName: `executing api route (app) ${route}`,
                        attributes: {
                            "next.route": route
                        }
                    }, async ()=>{
                        // Patch the global fetch.
                        (0, _patchfetch.patchFetch)({
                            serverHooks: this.serverHooks,
                            staticGenerationAsyncStorage: this.staticGenerationAsyncStorage
                        });
                        const res = await handler(wrappedRequest, {
                            params: context.params
                        });
                        await Promise.all(staticGenerationStore.pendingRevalidates || []);
                        // It's possible cookies were set in the handler, so we need
                        // to merge the modified cookies and the returned response
                        // here.
                        // TODO: Move this into a helper function.
                        const requestStore = this.requestAsyncStorage.getStore();
                        if (requestStore && requestStore.mutableCookies) {
                            const modifiedCookieValues = requestStore.mutableCookies[_requestcookies.SYMBOL_MODIFY_COOKIE_VALUES];
                            if (modifiedCookieValues.length) {
                                // Return a new response that extends the response with
                                // the modified cookies as fallbacks. `res`' cookies
                                // will still take precedence.
                                const resCookies = new _cookies.ResponseCookies(_headers.HeadersAdapter.from(res.headers));
                                const returnedCookies = resCookies.getAll();
                                // Set the modified cookies as fallbacks.
                                for (const cookie of modifiedCookieValues){
                                    resCookies.set(cookie);
                                }
                                // Set the original cookies as the final values.
                                for (const cookie of returnedCookies){
                                    resCookies.set(cookie);
                                }
                                const responseHeaders = new Headers({});
                                // Set all the headers except for the cookies.
                                res.headers.forEach((value, key)=>{
                                    if (key.toLowerCase() !== "set-cookie") {
                                        responseHeaders.append(key, value);
                                    }
                                });
                                // Set the final cookies, need to append cookies one
                                // at a time otherwise it might not work in some browsers.
                                resCookies.getAll().forEach((cookie)=>{
                                    const tempCookies = new _cookies.ResponseCookies(new Headers());
                                    tempCookies.set(cookie);
                                    responseHeaders.append("Set-Cookie", tempCookies.toString());
                                });
                                return new Response(res.body, {
                                    status: res.status,
                                    statusText: res.statusText,
                                    headers: responseHeaders
                                });
                            }
                        }
                        return res;
                    });
                });
            });
        });
        // If the handler did't return a valid response, then return the internal
        // error response.
        if (!(response instanceof Response)) {
            // TODO: validate the correct handling behavior, maybe log something?
            return (0, _responsehandlers.handleInternalServerErrorResponse)();
        }
        if (response.headers.has("x-middleware-rewrite")) {
            // TODO: move this error into the `NextResponse.rewrite()` function.
            // TODO-APP: re-enable support below when we can proxy these type of requests
            throw new Error("NextResponse.rewrite() was used in a app route handler, this is not currently supported. Please remove the invocation to continue.");
        // // This is a rewrite created via `NextResponse.rewrite()`. We need to send
        // // the response up so it can be handled by the backing server.
        // // If the server is running in minimal mode, we just want to forward the
        // // response (including the rewrite headers) upstream so it can perform the
        // // redirect for us, otherwise return with the special condition so this
        // // server can perform a rewrite.
        // if (!minimalMode) {
        //   return { response, condition: 'rewrite' }
        // }
        // // Relativize the url so it's relative to the base url. This is so the
        // // outgoing headers upstream can be relative.
        // const rewritePath = response.headers.get('x-middleware-rewrite')!
        // const initUrl = getRequestMeta(req, '__NEXT_INIT_URL')!
        // const { pathname } = parseUrl(relativizeURL(rewritePath, initUrl))
        // response.headers.set('x-middleware-rewrite', pathname)
        }
        if (response.headers.get("x-middleware-next") === "1") {
            // TODO: move this error into the `NextResponse.next()` function.
            throw new Error("NextResponse.next() was used in a app route handler, this is not supported. See here for more info: https://nextjs.org/docs/messages/next-response-next-in-app-route-handler");
        }
        return response;
    }
    async handle(request, context) {
        try {
            // Execute the route to get the response.
            const response = await this.execute(request, context);
            // The response was handled, return it.
            return response;
        } catch (err) {
            // Try to resolve the error to a response, else throw it again.
            const response = (0, _resolvehandlererror.resolveHandlerError)(err);
            if (!response) throw err;
            // The response was resolved, return it.
            return response;
        }
    }
}
const _default = AppRouteRouteModule; //# sourceMappingURL=module.js.map


/***/ }),

/***/ 4431:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
0 && (0);
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    handleTemporaryRedirectResponse: function() {
        return handleTemporaryRedirectResponse;
    },
    handleBadRequestResponse: function() {
        return handleBadRequestResponse;
    },
    handleNotFoundResponse: function() {
        return handleNotFoundResponse;
    },
    handleMethodNotAllowedResponse: function() {
        return handleMethodNotAllowedResponse;
    },
    handleInternalServerErrorResponse: function() {
        return handleInternalServerErrorResponse;
    }
});
function handleTemporaryRedirectResponse(url) {
    return new Response(null, {
        status: 302,
        statusText: "Found",
        headers: {
            location: url
        }
    });
}
function handleBadRequestResponse() {
    return new Response(null, {
        status: 400,
        statusText: "Bad Request"
    });
}
function handleNotFoundResponse() {
    return new Response(null, {
        status: 404,
        statusText: "Not Found"
    });
}
function handleMethodNotAllowedResponse() {
    return new Response(null, {
        status: 405,
        statusText: "Method Not Allowed"
    });
}
function handleInternalServerErrorResponse() {
    return new Response(null, {
        status: 500,
        statusText: "Internal Server Error"
    });
} //# sourceMappingURL=response-handlers.js.map


/***/ }),

/***/ 6611:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "RouteModule", ({
    enumerable: true,
    get: function() {
        return RouteModule;
    }
}));
// These are imported weirdly like this because of the way that the bundling
// works. We need to import the built files from the dist directory, but we
// can't do that directly because we need types from the source files. So we
// import the types from the source files and then import the built files.
const { requestAsyncStorage  } = __webpack_require__(6128);
const { staticGenerationAsyncStorage  } = __webpack_require__(7358);
const serverHooks = __webpack_require__(8339);
const headerHooks = __webpack_require__(4534);
const { staticGenerationBailout  } = __webpack_require__(5151);
const { actionAsyncStorage  } = __webpack_require__(4887);
class RouteModule {
    constructor({ userland  }){
        /**
   * A reference to the request async storage.
   */ this.requestAsyncStorage = requestAsyncStorage;
        /**
   * A reference to the static generation async storage.
   */ this.staticGenerationAsyncStorage = staticGenerationAsyncStorage;
        /**
   * An interface to call server hooks which interact with the underlying
   * storage.
   */ this.serverHooks = serverHooks;
        /**
   * An interface to call header hooks which interact with the underlying
   * request storage.
   */ this.headerHooks = headerHooks;
        /**
   * An interface to call static generation bailout hooks which interact with
   * the underlying static generation storage.
   */ this.staticGenerationBailout = staticGenerationBailout;
        /**
   * A reference to the mutation related async storage, such as mutations of
   * cookies.
   */ this.actionAsyncStorage = actionAsyncStorage;
        this.userland = userland;
    }
} //# sourceMappingURL=route-module.js.map


/***/ }),

/***/ 1175:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/**
 * FNV-1a Hash implementation
 * @author Travis Webb (tjwebb) <me@traviswebb.com>
 *
 * Ported from https://github.com/tjwebb/fnv-plus/blob/master/index.js
 *
 * Simplified, optimized and add modified for 52 bit, which provides a larger hash space
 * and still making use of Javascript's 53-bit integer space.
 */ 
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
0 && (0);
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    fnv1a52: function() {
        return fnv1a52;
    },
    generateETag: function() {
        return generateETag;
    }
});
const fnv1a52 = (str)=>{
    const len = str.length;
    let i = 0, t0 = 0, v0 = 0x2325, t1 = 0, v1 = 0x8422, t2 = 0, v2 = 0x9ce4, t3 = 0, v3 = 0xcbf2;
    while(i < len){
        v0 ^= str.charCodeAt(i++);
        t0 = v0 * 435;
        t1 = v1 * 435;
        t2 = v2 * 435;
        t3 = v3 * 435;
        t2 += v0 << 8;
        t3 += v1 << 8;
        t1 += t0 >>> 16;
        v0 = t0 & 65535;
        t2 += t1 >>> 16;
        v1 = t1 & 65535;
        v3 = t3 + (t2 >>> 16) & 65535;
        v2 = t2 & 65535;
    }
    return (v3 & 15) * 281474976710656 + v2 * 4294967296 + v1 * 65536 + (v0 ^ v3 >> 4);
};
const generateETag = (payload, weak = false)=>{
    const prefix = weak ? 'W/"' : '"';
    return prefix + fnv1a52(payload).toString(36) + payload.length.toString(36) + '"';
}; //# sourceMappingURL=etag.js.map


/***/ }),

/***/ 9310:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
0 && (0);
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    MockedRequest: function() {
        return MockedRequest;
    },
    MockedResponse: function() {
        return MockedResponse;
    },
    createRequestResponseMocks: function() {
        return createRequestResponseMocks;
    }
});
const _stream = /*#__PURE__*/ _interop_require_default(__webpack_require__(2781));
const _utils = __webpack_require__(1643);
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
class MockedRequest extends _stream.default.Readable {
    constructor({ url , headers , method , socket =null  }){
        super();
        // This is hardcoded for now, but can be updated to be configurable if needed.
        this.httpVersion = "1.0";
        this.httpVersionMajor = 1;
        this.httpVersionMinor = 0;
        // If we don't actually have a socket, we'll just use a mock one that
        // always returns false for the `encrypted` property.
        this.socket = new Proxy({}, {
            get: (_target, prop)=>{
                if (prop !== "encrypted") {
                    throw new Error("Method not implemented");
                }
                // For this mock request, always ensure we just respond with the encrypted
                // set to false to ensure there's no odd leakages.
                return false;
            }
        });
        this.url = url;
        this.headers = headers;
        this.method = method;
        if (socket) {
            this.socket = socket;
        }
    }
    _read() {
        this.emit("end");
        this.emit("close");
    }
    /**
   * The `connection` property is just an alias for the `socket` property.
   *
   * @deprecated  since v13.0.0 - Use socket instead.
   */ get connection() {
        return this.socket;
    }
    // The following methods are not implemented as they are not used in the
    // Next.js codebase.
    get aborted() {
        throw new Error("Method not implemented");
    }
    get complete() {
        throw new Error("Method not implemented");
    }
    get trailers() {
        throw new Error("Method not implemented");
    }
    get rawTrailers() {
        throw new Error("Method not implemented");
    }
    get rawHeaders() {
        throw new Error("Method not implemented.");
    }
    setTimeout() {
        throw new Error("Method not implemented.");
    }
}
class MockedResponse extends _stream.default.Writable {
    constructor({ socket =null  }){
        super();
        this.statusCode = 200;
        this.statusMessage = "";
        this.finished = false;
        this.headersSent = false;
        /**
   * A list of buffers that have been written to the response.
   */ this.buffers = [];
        this.headers = new Headers();
        this.socket = socket;
        // Attach listeners for the `finish`, `end`, and `error` events to the
        // `MockedResponse` instance.
        this.hasStreamed = new Promise((resolve, reject)=>{
            this.on("finish", ()=>resolve(true));
            this.on("end", ()=>resolve(true));
            this.on("error", (err)=>reject(err));
        });
    }
    /**
   * The `connection` property is just an alias for the `socket` property.
   *
   * @deprecated  since v13.0.0 - Use socket instead.
   */ get connection() {
        return this.socket;
    }
    write(chunk) {
        this.buffers.push(Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk));
        return true;
    }
    /**
   * This method is a no-op because the `MockedResponse` instance is not
   * actually connected to a socket. This method is not specified on the
   * interface type for `ServerResponse` but is called by Node.js.
   *
   * @see https://github.com/nodejs/node/pull/7949
   */ _implicitHeader() {}
    _write(chunk, _encoding, callback) {
        this.write(chunk);
        // According to Node.js documentation, the callback MUST be invoked to
        // signal that the write completed successfully. If this callback is not
        // invoked, the 'finish' event will not be emitted.
        //
        // https://nodejs.org/docs/latest-v16.x/api/stream.html#writable_writechunk-encoding-callback
        callback();
    }
    writeHead(statusCode, statusMessage, headers) {
        if (!headers && typeof statusMessage !== "string") {
            headers = statusMessage;
        } else if (typeof statusMessage === "string" && statusMessage.length > 0) {
            this.statusMessage = statusMessage;
        }
        if (headers) {
            // When headers have been set with response.setHeader(), they will be
            // merged with any headers passed to response.writeHead(), with the
            // headers passed to response.writeHead() given precedence.
            //
            // https://nodejs.org/api/http.html#responsewriteheadstatuscode-statusmessage-headers
            //
            // For this reason, we need to only call `set` to ensure that this will
            // overwrite any existing headers.
            if (Array.isArray(headers)) {
                // headers may be an Array where the keys and values are in the same list.
                // It is not a list of tuples. So, the even-numbered offsets are key
                // values, and the odd-numbered offsets are the associated values. The
                // array is in the same format as request.rawHeaders.
                for(let i = 0; i < headers.length; i += 2){
                    // The header key is always a string according to the spec.
                    this.setHeader(headers[i], headers[i + 1]);
                }
            } else {
                for (const [key, value] of Object.entries(headers)){
                    // Skip undefined values
                    if (typeof value === "undefined") continue;
                    this.setHeader(key, value);
                }
            }
        }
        this.statusCode = statusCode;
        return this;
    }
    hasHeader(name) {
        return this.headers.has(name);
    }
    getHeader(name) {
        return this.headers.get(name) ?? undefined;
    }
    getHeaders() {
        return (0, _utils.toNodeHeaders)(this.headers);
    }
    getHeaderNames() {
        return Array.from(this.headers.keys());
    }
    setHeader(name, value) {
        if (Array.isArray(value)) {
            // Because `set` here should override any existing values, we need to
            // delete the existing values before setting the new ones via `append`.
            this.headers.delete(name);
            for (const v of value){
                this.headers.append(name, v);
            }
        } else if (typeof value === "number") {
            this.headers.set(name, value.toString());
        } else {
            this.headers.set(name, value);
        }
    }
    removeHeader(name) {
        this.headers.delete(name);
    }
    // The following methods are not implemented as they are not used in the
    // Next.js codebase.
    assignSocket() {
        throw new Error("Method not implemented.");
    }
    detachSocket() {
        throw new Error("Method not implemented.");
    }
    writeContinue() {
        throw new Error("Method not implemented.");
    }
    writeProcessing() {
        throw new Error("Method not implemented.");
    }
    get upgrading() {
        throw new Error("Method not implemented.");
    }
    get chunkedEncoding() {
        throw new Error("Method not implemented.");
    }
    get shouldKeepAlive() {
        throw new Error("Method not implemented.");
    }
    get useChunkedEncodingByDefault() {
        throw new Error("Method not implemented.");
    }
    get sendDate() {
        throw new Error("Method not implemented.");
    }
    setTimeout() {
        throw new Error("Method not implemented.");
    }
    addTrailers() {
        throw new Error("Method not implemented.");
    }
    flushHeaders() {
        throw new Error("Method not implemented.");
    }
}
function createRequestResponseMocks({ url , headers ={} , method ="GET" , socket =null  }) {
    return {
        req: new MockedRequest({
            url,
            headers,
            method,
            socket
        }),
        res: new MockedResponse({
            socket
        })
    };
} //# sourceMappingURL=mock-request.js.map


/***/ }),

/***/ 6692:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "patchFetch", ({
    enumerable: true,
    get: function() {
        return patchFetch;
    }
}));
const _constants = __webpack_require__(9707);
const _tracer = __webpack_require__(2224);
const _constants1 = __webpack_require__(2878);
const isEdgeRuntime = "nodejs" === "edge";
function patchFetch({ serverHooks , staticGenerationAsyncStorage  }) {
    if (globalThis.fetch.__nextPatched) return;
    const { DynamicServerError  } = serverHooks;
    const originFetch = globalThis.fetch;
    globalThis.fetch = async (input, init)=>{
        var _init_method;
        let url;
        try {
            url = new URL(input instanceof Request ? input.url : input);
            url.username = "";
            url.password = "";
        } catch  {
            // Error caused by malformed URL should be handled by native fetch
            url = undefined;
        }
        const method = (init == null ? void 0 : (_init_method = init.method) == null ? void 0 : _init_method.toUpperCase()) || "GET";
        return await (0, _tracer.getTracer)().trace(_constants.AppRenderSpan.fetch, {
            kind: _tracer.SpanKind.CLIENT,
            spanName: [
                "fetch",
                method,
                (url == null ? void 0 : url.toString()) ?? input.toString()
            ].filter(Boolean).join(" "),
            attributes: {
                "http.url": url == null ? void 0 : url.toString(),
                "http.method": method,
                "net.peer.name": url == null ? void 0 : url.hostname,
                "net.peer.port": (url == null ? void 0 : url.port) || undefined
            }
        }, async ()=>{
            var _ref, _getRequestMeta;
            const staticGenerationStore = staticGenerationAsyncStorage.getStore();
            const isRequestInput = input && typeof input === "object" && typeof input.method === "string";
            const getRequestMeta = (field)=>{
                let value = isRequestInput ? input[field] : null;
                return value || (init == null ? void 0 : init[field]);
            };
            // If the staticGenerationStore is not available, we can't do any
            // special treatment of fetch, therefore fallback to the original
            // fetch implementation.
            if (!staticGenerationStore || ((_ref = init == null ? void 0 : init.next) == null ? void 0 : _ref.internal)) {
                return originFetch(input, init);
            }
            let revalidate = undefined;
            const getNextField = (field)=>{
                var _init_next, _init_next1, _input_next;
                return typeof (init == null ? void 0 : (_init_next = init.next) == null ? void 0 : _init_next[field]) !== "undefined" ? init == null ? void 0 : (_init_next1 = init.next) == null ? void 0 : _init_next1[field] : isRequestInput ? (_input_next = input.next) == null ? void 0 : _input_next[field] : undefined;
            };
            // RequestInit doesn't keep extra fields e.g. next so it's
            // only available if init is used separate
            let curRevalidate = getNextField("revalidate");
            const tags = getNextField("tags");
            const isOnlyCache = staticGenerationStore.fetchCache === "only-cache";
            const isForceCache = staticGenerationStore.fetchCache === "force-cache";
            const isDefaultNoStore = staticGenerationStore.fetchCache === "default-no-store";
            const isOnlyNoStore = staticGenerationStore.fetchCache === "only-no-store";
            const isForceNoStore = staticGenerationStore.fetchCache === "force-no-store";
            const _cache = getRequestMeta("cache");
            if (_cache === "force-cache" || isForceCache) {
                curRevalidate = false;
            }
            if ([
                "no-cache",
                "no-store"
            ].includes(_cache || "")) {
                curRevalidate = 0;
            }
            if (typeof curRevalidate === "number") {
                revalidate = curRevalidate;
            }
            if (curRevalidate === false) {
                revalidate = _constants1.CACHE_ONE_YEAR;
            }
            const _headers = getRequestMeta("headers");
            const initHeaders = typeof (_headers == null ? void 0 : _headers.get) === "function" ? _headers : new Headers(_headers || {});
            const hasUnCacheableHeader = initHeaders.get("authorization") || initHeaders.get("cookie");
            const isUnCacheableMethod = ![
                "get",
                "head"
            ].includes(((_getRequestMeta = getRequestMeta("method")) == null ? void 0 : _getRequestMeta.toLowerCase()) || "get");
            // if there are authorized headers or a POST method and
            // dynamic data usage was present above the tree we bail
            // e.g. if cookies() is used before an authed/POST fetch
            const autoNoCache = (hasUnCacheableHeader || isUnCacheableMethod) && staticGenerationStore.revalidate === 0;
            if (isForceNoStore) {
                revalidate = 0;
            }
            if (isOnlyNoStore) {
                if (_cache === "force-cache" || revalidate === 0) {
                    throw new Error(`cache: 'force-cache' used on fetch for ${input.toString()} with 'export const fetchCache = 'only-no-store'`);
                }
                revalidate = 0;
            }
            if (typeof revalidate === "undefined") {
                if (isOnlyCache && _cache === "no-store") {
                    throw new Error(`cache: 'no-store' used on fetch for ${input.toString()} with 'export const fetchCache = 'only-cache'`);
                }
                if (autoNoCache) {
                    revalidate = 0;
                } else if (isDefaultNoStore) {
                    revalidate = 0;
                } else {
                    revalidate = typeof staticGenerationStore.revalidate === "boolean" || typeof staticGenerationStore.revalidate === "undefined" ? _constants1.CACHE_ONE_YEAR : staticGenerationStore.revalidate;
                }
            }
            if (// revalidate although if it occurs during build we do
            !autoNoCache && (typeof staticGenerationStore.revalidate === "undefined" || typeof revalidate === "number" && typeof staticGenerationStore.revalidate === "number" && revalidate < staticGenerationStore.revalidate)) {
                staticGenerationStore.revalidate = revalidate;
            }
            let cacheKey;
            if (staticGenerationStore.incrementalCache && typeof revalidate === "number" && revalidate > 0) {
                try {
                    cacheKey = await staticGenerationStore.incrementalCache.fetchCacheKey(isRequestInput ? input.url : input.toString(), isRequestInput ? input : init);
                } catch (err) {
                    console.error(`Failed to generate cache key for`, input);
                }
            }
            const requestInputFields = [
                "cache",
                "credentials",
                "headers",
                "integrity",
                "keepalive",
                "method",
                "mode",
                "redirect",
                "referrer",
                "referrerPolicy",
                "signal",
                "window",
                "duplex"
            ];
            if (isRequestInput) {
                const reqInput = input;
                const reqOptions = {
                    body: reqInput._ogBody || reqInput.body
                };
                for (const field of requestInputFields){
                    // @ts-expect-error custom fields
                    reqOptions[field] = reqInput[field];
                }
                input = new Request(reqInput.url, reqOptions);
            } else if (init) {
                const initialInit = init;
                init = {
                    body: init._ogBody || init.body
                };
                for (const field of requestInputFields){
                    // @ts-expect-error custom fields
                    init[field] = initialInit[field];
                }
            }
            const fetchUrl = (url == null ? void 0 : url.toString()) ?? "";
            const fetchIdx = staticGenerationStore.nextFetchId ?? 1;
            staticGenerationStore.nextFetchId = fetchIdx + 1;
            const doOriginalFetch = async ()=>{
                // add metadata to init without editing the original
                const clonedInit = {
                    ...init,
                    next: {
                        ...init == null ? void 0 : init.next,
                        fetchType: "origin",
                        fetchIdx
                    }
                };
                return originFetch(input, clonedInit).then(async (res)=>{
                    if (res.status === 200 && staticGenerationStore.incrementalCache && cacheKey && typeof revalidate === "number" && revalidate > 0) {
                        const bodyBuffer = Buffer.from(await res.arrayBuffer());
                        try {
                            await staticGenerationStore.incrementalCache.set(cacheKey, {
                                kind: "FETCH",
                                data: {
                                    headers: Object.fromEntries(res.headers.entries()),
                                    body: bodyBuffer.toString("base64"),
                                    status: res.status,
                                    tags
                                },
                                revalidate
                            }, revalidate, true, fetchUrl, fetchIdx);
                        } catch (err) {
                            console.warn(`Failed to set fetch cache`, input, err);
                        }
                        return new Response(bodyBuffer, {
                            headers: new Headers(res.headers),
                            status: res.status
                        });
                    }
                    return res;
                });
            };
            if (cacheKey && (staticGenerationStore == null ? void 0 : staticGenerationStore.incrementalCache)) {
                const entry = staticGenerationStore.isOnDemandRevalidate ? null : await staticGenerationStore.incrementalCache.get(cacheKey, true, revalidate, fetchUrl, fetchIdx);
                if ((entry == null ? void 0 : entry.value) && entry.value.kind === "FETCH") {
                    const currentTags = entry.value.data.tags;
                    // when stale and is revalidating we wait for fresh data
                    // so the revalidated entry has the updated data
                    if (!(staticGenerationStore.isRevalidate && entry.isStale)) {
                        if (entry.isStale) {
                            if (!staticGenerationStore.pendingRevalidates) {
                                staticGenerationStore.pendingRevalidates = [];
                            }
                            staticGenerationStore.pendingRevalidates.push(doOriginalFetch().catch(console.error));
                        } else if (tags && !tags.every((tag)=>{
                            return currentTags == null ? void 0 : currentTags.includes(tag);
                        })) {
                            var _staticGenerationStore_incrementalCache;
                            // if new tags are being added we need to set even if
                            // the data isn't stale
                            if (!entry.value.data.tags) {
                                entry.value.data.tags = [];
                            }
                            for (const tag of tags){
                                if (!entry.value.data.tags.includes(tag)) {
                                    entry.value.data.tags.push(tag);
                                }
                            }
                            (_staticGenerationStore_incrementalCache = staticGenerationStore.incrementalCache) == null ? void 0 : _staticGenerationStore_incrementalCache.set(cacheKey, entry.value, revalidate, true, fetchUrl, fetchIdx);
                        }
                        const resData = entry.value.data;
                        let decodedBody;
                        if (false) {} else {
                            decodedBody = Buffer.from(resData.body, "base64").subarray();
                        }
                        return new Response(decodedBody, {
                            headers: resData.headers,
                            status: resData.status
                        });
                    }
                }
            }
            if (staticGenerationStore.isStaticGeneration) {
                if (init && typeof init === "object") {
                    const cache = init.cache;
                    // Delete `cache` property as Cloudflare Workers will throw an error
                    if (isEdgeRuntime) {
                        delete init.cache;
                    }
                    if (cache === "no-store") {
                        staticGenerationStore.revalidate = 0;
                        // TODO: ensure this error isn't logged to the user
                        // seems it's slipping through currently
                        const dynamicUsageReason = `no-store fetch ${input}${staticGenerationStore.pathname ? ` ${staticGenerationStore.pathname}` : ""}`;
                        const err = new DynamicServerError(dynamicUsageReason);
                        staticGenerationStore.dynamicUsageStack = err.stack;
                        staticGenerationStore.dynamicUsageDescription = dynamicUsageReason;
                        throw err;
                    }
                    const hasNextConfig = "next" in init;
                    const next = init.next || {};
                    if (typeof next.revalidate === "number" && (typeof staticGenerationStore.revalidate === "undefined" || next.revalidate < staticGenerationStore.revalidate)) {
                        const forceDynamic = staticGenerationStore.forceDynamic;
                        if (!forceDynamic || next.revalidate !== 0) {
                            staticGenerationStore.revalidate = next.revalidate;
                        }
                        if (!forceDynamic && next.revalidate === 0) {
                            const dynamicUsageReason = `revalidate: ${next.revalidate} fetch ${input}${staticGenerationStore.pathname ? ` ${staticGenerationStore.pathname}` : ""}`;
                            const err = new DynamicServerError(dynamicUsageReason);
                            staticGenerationStore.dynamicUsageStack = err.stack;
                            staticGenerationStore.dynamicUsageDescription = dynamicUsageReason;
                            throw err;
                        }
                    }
                    if (hasNextConfig) delete init.next;
                }
            }
            return doOriginalFetch();
        });
    };
    fetch.__nextGetStaticStore = ()=>{
        return staticGenerationAsyncStorage;
    };
    fetch.__nextPatched = true;
} //# sourceMappingURL=patch-fetch.js.map


/***/ }),

/***/ 9707:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/**
 * Contains predefined constants for the trace span name in next/server.
 *
 * Currently, next/server/tracer is internal implementation only for tracking
 * next.js's implementation only with known span names defined here.
 **/ // eslint typescript has a bug with TS enums
/* eslint-disable no-shadow */ 
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
0 && (0);
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    NextVanillaSpanAllowlist: function() {
        return NextVanillaSpanAllowlist;
    },
    BaseServerSpan: function() {
        return BaseServerSpan;
    },
    LoadComponentsSpan: function() {
        return LoadComponentsSpan;
    },
    NextServerSpan: function() {
        return NextServerSpan;
    },
    NextNodeServerSpan: function() {
        return NextNodeServerSpan;
    },
    StartServerSpan: function() {
        return StartServerSpan;
    },
    RenderSpan: function() {
        return RenderSpan;
    },
    RouterSpan: function() {
        return RouterSpan;
    },
    AppRenderSpan: function() {
        return AppRenderSpan;
    },
    NodeSpan: function() {
        return NodeSpan;
    },
    AppRouteRouteHandlersSpan: function() {
        return AppRouteRouteHandlersSpan;
    },
    ResolveMetadataSpan: function() {
        return ResolveMetadataSpan;
    }
});
var BaseServerSpan;
(function(BaseServerSpan) {
    BaseServerSpan["handleRequest"] = "BaseServer.handleRequest";
    BaseServerSpan["run"] = "BaseServer.run";
    BaseServerSpan["pipe"] = "BaseServer.pipe";
    BaseServerSpan["getStaticHTML"] = "BaseServer.getStaticHTML";
    BaseServerSpan["render"] = "BaseServer.render";
    BaseServerSpan["renderToResponseWithComponents"] = "BaseServer.renderToResponseWithComponents";
    BaseServerSpan["renderToResponse"] = "BaseServer.renderToResponse";
    BaseServerSpan["renderToHTML"] = "BaseServer.renderToHTML";
    BaseServerSpan["renderError"] = "BaseServer.renderError";
    BaseServerSpan["renderErrorToResponse"] = "BaseServer.renderErrorToResponse";
    BaseServerSpan["renderErrorToHTML"] = "BaseServer.renderErrorToHTML";
    BaseServerSpan["render404"] = "BaseServer.render404";
})(BaseServerSpan || (BaseServerSpan = {}));
var LoadComponentsSpan;
(function(LoadComponentsSpan) {
    LoadComponentsSpan["loadDefaultErrorComponents"] = "LoadComponents.loadDefaultErrorComponents";
    LoadComponentsSpan["loadComponents"] = "LoadComponents.loadComponents";
})(LoadComponentsSpan || (LoadComponentsSpan = {}));
var NextServerSpan;
(function(NextServerSpan) {
    NextServerSpan["getRequestHandler"] = "NextServer.getRequestHandler";
    NextServerSpan["getServer"] = "NextServer.getServer";
    NextServerSpan["getServerRequestHandler"] = "NextServer.getServerRequestHandler";
    NextServerSpan["createServer"] = "createServer.createServer";
})(NextServerSpan || (NextServerSpan = {}));
var NextNodeServerSpan;
(function(NextNodeServerSpan) {
    NextNodeServerSpan["compression"] = "NextNodeServer.compression";
    NextNodeServerSpan["getBuildId"] = "NextNodeServer.getBuildId";
    NextNodeServerSpan["generateStaticRoutes"] = "NextNodeServer.generateStaticRoutes";
    NextNodeServerSpan["generateFsStaticRoutes"] = "NextNodeServer.generateFsStaticRoutes";
    NextNodeServerSpan["generatePublicRoutes"] = "NextNodeServer.generatePublicRoutes";
    NextNodeServerSpan["generateImageRoutes"] = "NextNodeServer.generateImageRoutes.route";
    NextNodeServerSpan["sendRenderResult"] = "NextNodeServer.sendRenderResult";
    NextNodeServerSpan["sendStatic"] = "NextNodeServer.sendStatic";
    NextNodeServerSpan["proxyRequest"] = "NextNodeServer.proxyRequest";
    NextNodeServerSpan["runApi"] = "NextNodeServer.runApi";
    NextNodeServerSpan["render"] = "NextNodeServer.render";
    NextNodeServerSpan["renderHTML"] = "NextNodeServer.renderHTML";
    NextNodeServerSpan["imageOptimizer"] = "NextNodeServer.imageOptimizer";
    NextNodeServerSpan["getPagePath"] = "NextNodeServer.getPagePath";
    NextNodeServerSpan["getRoutesManifest"] = "NextNodeServer.getRoutesManifest";
    NextNodeServerSpan["findPageComponents"] = "NextNodeServer.findPageComponents";
    NextNodeServerSpan["getFontManifest"] = "NextNodeServer.getFontManifest";
    NextNodeServerSpan["getServerComponentManifest"] = "NextNodeServer.getServerComponentManifest";
    NextNodeServerSpan["getRequestHandler"] = "NextNodeServer.getRequestHandler";
    NextNodeServerSpan["renderToHTML"] = "NextNodeServer.renderToHTML";
    NextNodeServerSpan["renderError"] = "NextNodeServer.renderError";
    NextNodeServerSpan["renderErrorToHTML"] = "NextNodeServer.renderErrorToHTML";
    NextNodeServerSpan["render404"] = "NextNodeServer.render404";
    NextNodeServerSpan["route"] = "route";
    NextNodeServerSpan["onProxyReq"] = "onProxyReq";
    NextNodeServerSpan["apiResolver"] = "apiResolver";
})(NextNodeServerSpan || (NextNodeServerSpan = {}));
var StartServerSpan;
(function(StartServerSpan) {
    StartServerSpan["startServer"] = "startServer.startServer";
})(StartServerSpan || (StartServerSpan = {}));
var RenderSpan;
(function(RenderSpan) {
    RenderSpan["getServerSideProps"] = "Render.getServerSideProps";
    RenderSpan["getStaticProps"] = "Render.getStaticProps";
    RenderSpan["renderToString"] = "Render.renderToString";
    RenderSpan["renderDocument"] = "Render.renderDocument";
    RenderSpan["createBodyResult"] = "Render.createBodyResult";
})(RenderSpan || (RenderSpan = {}));
var AppRenderSpan;
(function(AppRenderSpan) {
    AppRenderSpan["renderToString"] = "AppRender.renderToString";
    AppRenderSpan["renderToReadableStream"] = "AppRender.renderToReadableStream";
    AppRenderSpan["getBodyResult"] = "AppRender.getBodyResult";
    AppRenderSpan["fetch"] = "AppRender.fetch";
})(AppRenderSpan || (AppRenderSpan = {}));
var RouterSpan;
(function(RouterSpan) {
    RouterSpan["executeRoute"] = "Router.executeRoute";
})(RouterSpan || (RouterSpan = {}));
var NodeSpan;
(function(NodeSpan) {
    NodeSpan["runHandler"] = "Node.runHandler";
})(NodeSpan || (NodeSpan = {}));
var AppRouteRouteHandlersSpan;
(function(AppRouteRouteHandlersSpan) {
    AppRouteRouteHandlersSpan["runHandler"] = "AppRouteRouteHandlers.runHandler";
})(AppRouteRouteHandlersSpan || (AppRouteRouteHandlersSpan = {}));
var ResolveMetadataSpan;
(function(ResolveMetadataSpan) {
    ResolveMetadataSpan["generateMetadata"] = "ResolveMetadata.generateMetadata";
})(ResolveMetadataSpan || (ResolveMetadataSpan = {}));
const NextVanillaSpanAllowlist = [
    "BaseServer.handleRequest",
    "Render.getServerSideProps",
    "Render.getStaticProps",
    "AppRender.fetch",
    "AppRender.getBodyResult",
    "Render.renderDocument",
    "Node.runHandler",
    "AppRouteRouteHandlers.runHandler",
    "ResolveMetadata.generateMetadata"
]; //# sourceMappingURL=constants.js.map


/***/ }),

/***/ 2224:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
0 && (0);
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    getTracer: function() {
        return getTracer;
    },
    SpanStatusCode: function() {
        return SpanStatusCode;
    },
    SpanKind: function() {
        return SpanKind;
    }
});
const _constants = __webpack_require__(9707);
let api;
// we want to allow users to use their own version of @opentelemetry/api if they
// want to, so we try to require it first, and if it fails we fall back to the
// version that is bundled with Next.js
// this is because @opentelemetry/api has to be synced with the version of
// @opentelemetry/tracing that is used, and we don't want to force users to use
// the version that is bundled with Next.js.
// the API is ~stable, so this should be fine
try {
    api = __webpack_require__(2468);
} catch (err) {
    api = __webpack_require__(8530);
}
const { context , trace , SpanStatusCode , SpanKind  } = api;
const isPromise = (p)=>{
    return p !== null && typeof p === "object" && typeof p.then === "function";
};
const closeSpanWithError = (span, error)=>{
    if (error) {
        span.recordException(error);
    }
    span.setStatus({
        code: SpanStatusCode.ERROR,
        message: error == null ? void 0 : error.message
    });
    span.end();
};
/** we use this map to propagate attributes from nested spans to the top span */ const rootSpanAttributesStore = new Map();
const rootSpanIdKey = api.createContextKey("next.rootSpanId");
let lastSpanId = 0;
const getSpanId = ()=>lastSpanId++;
class NextTracerImpl {
    /**
   * Returns an instance to the trace with configured name.
   * Since wrap / trace can be defined in any place prior to actual trace subscriber initialization,
   * This should be lazily evaluated.
   */ getTracerInstance() {
        return trace.getTracer("next.js", "0.0.1");
    }
    getContext() {
        return context;
    }
    getActiveScopeSpan() {
        return trace.getSpan(context == null ? void 0 : context.active());
    }
    trace(...args) {
        const [type, fnOrOptions, fnOrEmpty] = args;
        // coerce options form overload
        const { fn , options  } = typeof fnOrOptions === "function" ? {
            fn: fnOrOptions,
            options: {}
        } : {
            fn: fnOrEmpty,
            options: {
                ...fnOrOptions
            }
        };
        if (!_constants.NextVanillaSpanAllowlist.includes(type) && process.env.NEXT_OTEL_VERBOSE !== "1" || options.hideSpan) {
            return fn();
        }
        const spanName = options.spanName ?? type;
        // Trying to get active scoped span to assign parent. If option specifies parent span manually, will try to use it.
        let spanContext = this.getSpanContext((options == null ? void 0 : options.parentSpan) ?? this.getActiveScopeSpan());
        let isRootSpan = false;
        if (!spanContext) {
            spanContext = api.ROOT_CONTEXT;
            isRootSpan = true;
        }
        const spanId = getSpanId();
        options.attributes = {
            "next.span_name": spanName,
            "next.span_type": type,
            ...options.attributes
        };
        return api.context.with(spanContext.setValue(rootSpanIdKey, spanId), ()=>this.getTracerInstance().startActiveSpan(spanName, options, (span)=>{
                const onCleanup = ()=>{
                    rootSpanAttributesStore.delete(spanId);
                };
                if (isRootSpan) {
                    rootSpanAttributesStore.set(spanId, new Map(Object.entries(options.attributes ?? {})));
                }
                try {
                    if (fn.length > 1) {
                        return fn(span, (err)=>closeSpanWithError(span, err));
                    }
                    const result = fn(span);
                    if (isPromise(result)) {
                        result.then(()=>span.end(), (err)=>closeSpanWithError(span, err)).finally(onCleanup);
                    } else {
                        span.end();
                        onCleanup();
                    }
                    return result;
                } catch (err) {
                    closeSpanWithError(span, err);
                    onCleanup();
                    throw err;
                }
            }));
    }
    wrap(...args) {
        const tracer = this;
        const [name, options, fn] = args.length === 3 ? args : [
            args[0],
            {},
            args[1]
        ];
        if (!_constants.NextVanillaSpanAllowlist.includes(name) && process.env.NEXT_OTEL_VERBOSE !== "1") {
            return fn;
        }
        return function() {
            let optionsObj = options;
            if (typeof optionsObj === "function" && typeof fn === "function") {
                optionsObj = optionsObj.apply(this, arguments);
            }
            const lastArgId = arguments.length - 1;
            const cb = arguments[lastArgId];
            if (typeof cb === "function") {
                const scopeBoundCb = tracer.getContext().bind(context.active(), cb);
                return tracer.trace(name, optionsObj, (_span, done)=>{
                    arguments[lastArgId] = function(err) {
                        done == null ? void 0 : done(err);
                        return scopeBoundCb.apply(this, arguments);
                    };
                    return fn.apply(this, arguments);
                });
            } else {
                return tracer.trace(name, optionsObj, ()=>fn.apply(this, arguments));
            }
        };
    }
    startSpan(...args) {
        const [type, options] = args;
        const spanContext = this.getSpanContext((options == null ? void 0 : options.parentSpan) ?? this.getActiveScopeSpan());
        return this.getTracerInstance().startSpan(type, options, spanContext);
    }
    getSpanContext(parentSpan) {
        const spanContext = parentSpan ? trace.setSpan(context.active(), parentSpan) : undefined;
        return spanContext;
    }
    getRootSpanAttributes() {
        const spanId = context.active().getValue(rootSpanIdKey);
        return rootSpanAttributesStore.get(spanId);
    }
}
const getTracer = (()=>{
    const tracer = new NextTracerImpl();
    return ()=>tracer;
})(); //# sourceMappingURL=tracer.js.map


/***/ }),

/***/ 8302:
/***/ (() => {

"use strict";
/**
 * Polyfills the `Headers.getAll(name)` method so it'll work in the edge
 * runtime.
 */ 
if (!("getAll" in Headers.prototype)) {
    // @ts-expect-error - this is polyfilling this method so it doesn't exist yet
    Headers.prototype.getAll = function(name) {
        name = name.toLowerCase();
        if (name !== "set-cookie") throw new Error("Headers.getAll is only supported for Set-Cookie header");
        const headers = [
            ...this.entries()
        ].filter(([key])=>key === name);
        return headers.map(([, value])=>value);
    };
} //# sourceMappingURL=node-polyfill-headers.js.map


/***/ }),

/***/ 5122:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
0 && (0);
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    setRevalidateHeaders: function() {
        return _revalidateheaders.setRevalidateHeaders;
    },
    sendEtagResponse: function() {
        return sendEtagResponse;
    },
    sendRenderResult: function() {
        return sendRenderResult;
    }
});
const _utils = __webpack_require__(6199);
const _etag = __webpack_require__(1175);
const _fresh = /*#__PURE__*/ _interop_require_default(__webpack_require__(7664));
const _revalidateheaders = __webpack_require__(3603);
const _approuterheaders = __webpack_require__(4940);
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function sendEtagResponse(req, res, etag) {
    if (etag) {
        /**
     * The server generating a 304 response MUST generate any of the
     * following header fields that would have been sent in a 200 (OK)
     * response to the same request: Cache-Control, Content-Location, Date,
     * ETag, Expires, and Vary. https://tools.ietf.org/html/rfc7232#section-4.1
     */ res.setHeader("ETag", etag);
    }
    if ((0, _fresh.default)(req.headers, {
        etag
    })) {
        res.statusCode = 304;
        res.end();
        return true;
    }
    return false;
}
async function sendRenderResult({ req , res , result , type , generateEtags , poweredByHeader , options  }) {
    if ((0, _utils.isResSent)(res)) {
        return;
    }
    if (poweredByHeader && type === "html") {
        res.setHeader("X-Powered-By", "Next.js");
    }
    const payload = result.isDynamic() ? null : await result.toUnchunkedString();
    if (payload) {
        const etag = generateEtags ? (0, _etag.generateETag)(payload) : undefined;
        if (sendEtagResponse(req, res, etag)) {
            return;
        }
    }
    const resultContentType = result.contentType();
    if (!res.getHeader("Content-Type")) {
        res.setHeader("Content-Type", resultContentType ? resultContentType : type === "rsc" ? _approuterheaders.RSC_CONTENT_TYPE_HEADER : type === "json" ? "application/json" : "text/html; charset=utf-8");
    }
    if (payload) {
        res.setHeader("Content-Length", Buffer.byteLength(payload));
    }
    if (options != null) {
        (0, _revalidateheaders.setRevalidateHeaders)(res, options);
    }
    if (req.method === "HEAD") {
        res.end(null);
    } else if (payload) {
        res.end(payload);
    } else {
        await result.pipe(res);
    }
} //# sourceMappingURL=index.js.map


/***/ }),

/***/ 3603:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "setRevalidateHeaders", ({
    enumerable: true,
    get: function() {
        return setRevalidateHeaders;
    }
}));
function setRevalidateHeaders(res, options) {
    if (options.private || options.stateful) {
        if (options.private || !res.getHeader("Cache-Control")) {
            res.setHeader("Cache-Control", `private, no-cache, no-store, max-age=0, must-revalidate`);
        }
    } else if (typeof options.revalidate === "number") {
        if (options.revalidate < 1) {
            throw new Error(`invariant: invalid Cache-Control duration provided: ${options.revalidate} < 1`);
        }
        res.setHeader("Cache-Control", `s-maxage=${options.revalidate}, stale-while-revalidate`);
    } else if (options.revalidate === false) {
        res.setHeader("Cache-Control", `s-maxage=31536000, stale-while-revalidate`);
    }
} //# sourceMappingURL=revalidate-headers.js.map


/***/ }),

/***/ 7230:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;
// This file is for modularized imports for next/server to get fully-treeshaking.

__webpack_unused_export__ = ({
    value: true
});
Object.defineProperty(exports, "Z", ({
    enumerable: true,
    get: function() {
        return _response.NextResponse;
    }
}));
const _response = __webpack_require__(9160); //# sourceMappingURL=next-response.js.map


/***/ }),

/***/ 3018:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/**
 * List of valid HTTP methods that can be implemented by Next.js's Custom App
 * Routes.
 */ 
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
0 && (0);
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    HTTP_METHODS: function() {
        return HTTP_METHODS;
    },
    isHTTPMethod: function() {
        return isHTTPMethod;
    }
});
const HTTP_METHODS = [
    "GET",
    "HEAD",
    "OPTIONS",
    "POST",
    "PUT",
    "DELETE",
    "PATCH"
];
function isHTTPMethod(maybeMethod) {
    return HTTP_METHODS.includes(maybeMethod);
} //# sourceMappingURL=http.js.map


/***/ }),

/***/ 6299:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "NextURL", ({
    enumerable: true,
    get: function() {
        return NextURL;
    }
}));
const _detectdomainlocale = __webpack_require__(7600);
const _formatnextpathnameinfo = __webpack_require__(6761);
const _gethostname = __webpack_require__(8229);
const _getnextpathnameinfo = __webpack_require__(7612);
const REGEX_LOCALHOST_HOSTNAME = /(?!^https?:\/\/)(127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}|::1|localhost)/;
function parseURL(url, base) {
    return new URL(String(url).replace(REGEX_LOCALHOST_HOSTNAME, "localhost"), base && String(base).replace(REGEX_LOCALHOST_HOSTNAME, "localhost"));
}
const Internal = Symbol("NextURLInternal");
class NextURL {
    constructor(input, baseOrOpts, opts){
        let base;
        let options;
        if (typeof baseOrOpts === "object" && "pathname" in baseOrOpts || typeof baseOrOpts === "string") {
            base = baseOrOpts;
            options = opts || {};
        } else {
            options = opts || baseOrOpts || {};
        }
        this[Internal] = {
            url: parseURL(input, base ?? options.base),
            options: options,
            basePath: ""
        };
        this.analyze();
    }
    analyze() {
        var _this_Internal_options_nextConfig, _this_Internal_options_nextConfig_i18n, _this_Internal_domainLocale, _this_Internal_options_nextConfig1, _this_Internal_options_nextConfig_i18n1;
        const info = (0, _getnextpathnameinfo.getNextPathnameInfo)(this[Internal].url.pathname, {
            nextConfig: this[Internal].options.nextConfig,
            parseData: !undefined,
            i18nProvider: this[Internal].options.i18nProvider
        });
        const hostname = (0, _gethostname.getHostname)(this[Internal].url, this[Internal].options.headers);
        this[Internal].domainLocale = this[Internal].options.i18nProvider ? this[Internal].options.i18nProvider.detectDomainLocale(hostname) : (0, _detectdomainlocale.detectDomainLocale)((_this_Internal_options_nextConfig = this[Internal].options.nextConfig) == null ? void 0 : (_this_Internal_options_nextConfig_i18n = _this_Internal_options_nextConfig.i18n) == null ? void 0 : _this_Internal_options_nextConfig_i18n.domains, hostname);
        const defaultLocale = ((_this_Internal_domainLocale = this[Internal].domainLocale) == null ? void 0 : _this_Internal_domainLocale.defaultLocale) || ((_this_Internal_options_nextConfig1 = this[Internal].options.nextConfig) == null ? void 0 : (_this_Internal_options_nextConfig_i18n1 = _this_Internal_options_nextConfig1.i18n) == null ? void 0 : _this_Internal_options_nextConfig_i18n1.defaultLocale);
        this[Internal].url.pathname = info.pathname;
        this[Internal].defaultLocale = defaultLocale;
        this[Internal].basePath = info.basePath ?? "";
        this[Internal].buildId = info.buildId;
        this[Internal].locale = info.locale ?? defaultLocale;
        this[Internal].trailingSlash = info.trailingSlash;
    }
    formatPathname() {
        return (0, _formatnextpathnameinfo.formatNextPathnameInfo)({
            basePath: this[Internal].basePath,
            buildId: this[Internal].buildId,
            defaultLocale: !this[Internal].options.forceLocale ? this[Internal].defaultLocale : undefined,
            locale: this[Internal].locale,
            pathname: this[Internal].url.pathname,
            trailingSlash: this[Internal].trailingSlash
        });
    }
    formatSearch() {
        return this[Internal].url.search;
    }
    get buildId() {
        return this[Internal].buildId;
    }
    set buildId(buildId) {
        this[Internal].buildId = buildId;
    }
    get locale() {
        return this[Internal].locale ?? "";
    }
    set locale(locale) {
        var _this_Internal_options_nextConfig, _this_Internal_options_nextConfig_i18n;
        if (!this[Internal].locale || !((_this_Internal_options_nextConfig = this[Internal].options.nextConfig) == null ? void 0 : (_this_Internal_options_nextConfig_i18n = _this_Internal_options_nextConfig.i18n) == null ? void 0 : _this_Internal_options_nextConfig_i18n.locales.includes(locale))) {
            throw new TypeError(`The NextURL configuration includes no locale "${locale}"`);
        }
        this[Internal].locale = locale;
    }
    get defaultLocale() {
        return this[Internal].defaultLocale;
    }
    get domainLocale() {
        return this[Internal].domainLocale;
    }
    get searchParams() {
        return this[Internal].url.searchParams;
    }
    get host() {
        return this[Internal].url.host;
    }
    set host(value) {
        this[Internal].url.host = value;
    }
    get hostname() {
        return this[Internal].url.hostname;
    }
    set hostname(value) {
        this[Internal].url.hostname = value;
    }
    get port() {
        return this[Internal].url.port;
    }
    set port(value) {
        this[Internal].url.port = value;
    }
    get protocol() {
        return this[Internal].url.protocol;
    }
    set protocol(value) {
        this[Internal].url.protocol = value;
    }
    get href() {
        const pathname = this.formatPathname();
        const search = this.formatSearch();
        return `${this.protocol}//${this.host}${pathname}${search}${this.hash}`;
    }
    set href(url) {
        this[Internal].url = parseURL(url);
        this.analyze();
    }
    get origin() {
        return this[Internal].url.origin;
    }
    get pathname() {
        return this[Internal].url.pathname;
    }
    set pathname(value) {
        this[Internal].url.pathname = value;
    }
    get hash() {
        return this[Internal].url.hash;
    }
    set hash(value) {
        this[Internal].url.hash = value;
    }
    get search() {
        return this[Internal].url.search;
    }
    set search(value) {
        this[Internal].url.search = value;
    }
    get password() {
        return this[Internal].url.password;
    }
    set password(value) {
        this[Internal].url.password = value;
    }
    get username() {
        return this[Internal].url.username;
    }
    set username(value) {
        this[Internal].url.username = value;
    }
    get basePath() {
        return this[Internal].basePath;
    }
    set basePath(value) {
        this[Internal].basePath = value.startsWith("/") ? value : `/${value}`;
    }
    toString() {
        return this.href;
    }
    toJSON() {
        return this.href;
    }
    [Symbol.for("edge-runtime.inspect.custom")]() {
        return {
            href: this.href,
            origin: this.origin,
            protocol: this.protocol,
            username: this.username,
            password: this.password,
            host: this.host,
            hostname: this.hostname,
            port: this.port,
            pathname: this.pathname,
            search: this.search,
            searchParams: this.searchParams,
            hash: this.hash
        };
    }
    clone() {
        return new NextURL(String(this), this[Internal].options);
    }
} //# sourceMappingURL=next-url.js.map


/***/ }),

/***/ 104:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
0 && (0);
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    ReadonlyHeadersError: function() {
        return ReadonlyHeadersError;
    },
    HeadersAdapter: function() {
        return HeadersAdapter;
    }
});
const _reflect = __webpack_require__(215);
class ReadonlyHeadersError extends Error {
    constructor(){
        super("Headers cannot be modified. Read more: https://nextjs.org/docs/api-reference/headers");
    }
    static callable() {
        throw new ReadonlyHeadersError();
    }
}
class HeadersAdapter extends Headers {
    constructor(headers){
        // We've already overridden the methods that would be called, so we're just
        // calling the super constructor to ensure that the instanceof check works.
        super();
        this.headers = new Proxy(headers, {
            get (target, prop, receiver) {
                // Because this is just an object, we expect that all "get" operations
                // are for properties. If it's a "get" for a symbol, we'll just return
                // the symbol.
                if (typeof prop === "symbol") {
                    return _reflect.ReflectAdapter.get(target, prop, receiver);
                }
                const lowercased = prop.toLowerCase();
                // Let's find the original casing of the key. This assumes that there is
                // no mixed case keys (e.g. "Content-Type" and "content-type") in the
                // headers object.
                const original = Object.keys(headers).find((o)=>o.toLowerCase() === lowercased);
                // If the original casing doesn't exist, return undefined.
                if (typeof original === "undefined") return;
                // If the original casing exists, return the value.
                return _reflect.ReflectAdapter.get(target, original, receiver);
            },
            set (target, prop, value, receiver) {
                if (typeof prop === "symbol") {
                    return _reflect.ReflectAdapter.set(target, prop, value, receiver);
                }
                const lowercased = prop.toLowerCase();
                // Let's find the original casing of the key. This assumes that there is
                // no mixed case keys (e.g. "Content-Type" and "content-type") in the
                // headers object.
                const original = Object.keys(headers).find((o)=>o.toLowerCase() === lowercased);
                // If the original casing doesn't exist, use the prop as the key.
                return _reflect.ReflectAdapter.set(target, original ?? prop, value, receiver);
            },
            has (target, prop) {
                if (typeof prop === "symbol") return _reflect.ReflectAdapter.has(target, prop);
                const lowercased = prop.toLowerCase();
                // Let's find the original casing of the key. This assumes that there is
                // no mixed case keys (e.g. "Content-Type" and "content-type") in the
                // headers object.
                const original = Object.keys(headers).find((o)=>o.toLowerCase() === lowercased);
                // If the original casing doesn't exist, return false.
                if (typeof original === "undefined") return false;
                // If the original casing exists, return true.
                return _reflect.ReflectAdapter.has(target, original);
            },
            deleteProperty (target, prop) {
                if (typeof prop === "symbol") return _reflect.ReflectAdapter.deleteProperty(target, prop);
                const lowercased = prop.toLowerCase();
                // Let's find the original casing of the key. This assumes that there is
                // no mixed case keys (e.g. "Content-Type" and "content-type") in the
                // headers object.
                const original = Object.keys(headers).find((o)=>o.toLowerCase() === lowercased);
                // If the original casing doesn't exist, return true.
                if (typeof original === "undefined") return true;
                // If the original casing exists, delete the property.
                return _reflect.ReflectAdapter.deleteProperty(target, original);
            }
        });
    }
    /**
   * Seals a Headers instance to prevent modification by throwing an error when
   * any mutating method is called.
   */ static seal(headers) {
        return new Proxy(headers, {
            get (target, prop, receiver) {
                switch(prop){
                    case "append":
                    case "delete":
                    case "set":
                        return ReadonlyHeadersError.callable;
                    default:
                        return _reflect.ReflectAdapter.get(target, prop, receiver);
                }
            }
        });
    }
    /**
   * Merges a header value into a string. This stores multiple values as an
   * array, so we need to merge them into a string.
   *
   * @param value a header value
   * @returns a merged header value (a string)
   */ merge(value) {
        if (Array.isArray(value)) return value.join(", ");
        return value;
    }
    /**
   * Creates a Headers instance from a plain object or a Headers instance.
   *
   * @param headers a plain object or a Headers instance
   * @returns a headers instance
   */ static from(headers) {
        if (headers instanceof Headers) return headers;
        return new HeadersAdapter(headers);
    }
    append(name, value) {
        const existing = this.headers[name];
        if (typeof existing === "string") {
            this.headers[name] = [
                existing,
                value
            ];
        } else if (Array.isArray(existing)) {
            existing.push(value);
        } else {
            this.headers[name] = value;
        }
    }
    delete(name) {
        delete this.headers[name];
    }
    get(name) {
        const value = this.headers[name];
        if (typeof value !== "undefined") return this.merge(value);
        return null;
    }
    has(name) {
        return typeof this.headers[name] !== "undefined";
    }
    set(name, value) {
        this.headers[name] = value;
    }
    forEach(callbackfn, thisArg) {
        for (const [name, value] of this.entries()){
            callbackfn.call(thisArg, value, name, this);
        }
    }
    *entries() {
        for (const key of Object.keys(this.headers)){
            const name = key.toLowerCase();
            // We assert here that this is a string because we got it from the
            // Object.keys() call above.
            const value = this.get(name);
            yield [
                name,
                value
            ];
        }
    }
    *keys() {
        for (const key of Object.keys(this.headers)){
            const name = key.toLowerCase();
            yield name;
        }
    }
    *values() {
        for (const key of Object.keys(this.headers)){
            // We assert here that this is a string because we got it from the
            // Object.keys() call above.
            const value = this.get(key);
            yield value;
        }
    }
    [Symbol.iterator]() {
        return this.entries();
    }
} //# sourceMappingURL=headers.js.map


/***/ }),

/***/ 215:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "ReflectAdapter", ({
    enumerable: true,
    get: function() {
        return ReflectAdapter;
    }
}));
class ReflectAdapter {
    static get(target, prop, receiver) {
        const value = Reflect.get(target, prop, receiver);
        if (typeof value === "function") {
            return value.bind(target);
        }
        return value;
    }
    static set(target, prop, value, receiver) {
        return Reflect.set(target, prop, value, receiver);
    }
    static has(target, prop) {
        return Reflect.has(target, prop);
    }
    static deleteProperty(target, prop) {
        return Reflect.deleteProperty(target, prop);
    }
} //# sourceMappingURL=reflect.js.map


/***/ }),

/***/ 5697:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
0 && (0);
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    ReadonlyRequestCookiesError: function() {
        return ReadonlyRequestCookiesError;
    },
    RequestCookiesAdapter: function() {
        return RequestCookiesAdapter;
    },
    SYMBOL_MODIFY_COOKIE_VALUES: function() {
        return SYMBOL_MODIFY_COOKIE_VALUES;
    },
    MutableRequestCookiesAdapter: function() {
        return MutableRequestCookiesAdapter;
    }
});
const _cookies = __webpack_require__(5153);
const _reflect = __webpack_require__(215);
class ReadonlyRequestCookiesError extends Error {
    constructor(){
        super("ReadonlyRequestCookies cannot be modified. Read more: https://nextjs.org/docs/api-reference/cookies");
    }
    static callable() {
        throw new ReadonlyRequestCookiesError();
    }
}
class RequestCookiesAdapter {
    static seal(cookies) {
        return new Proxy(cookies, {
            get (target, prop, receiver) {
                switch(prop){
                    case "clear":
                    case "delete":
                    case "set":
                        return ReadonlyRequestCookiesError.callable;
                    default:
                        return _reflect.ReflectAdapter.get(target, prop, receiver);
                }
            }
        });
    }
}
const SYMBOL_MODIFY_COOKIE_VALUES = Symbol.for("next.mutated.cookies");
class MutableRequestCookiesAdapter {
    static seal(cookies, res) {
        const responseCookes = new _cookies.ResponseCookies(new Headers());
        for (const cookie of cookies.getAll()){
            responseCookes.set(cookie);
        }
        let modifiedValues = [];
        const modifiedCookies = new Set();
        const updateResponseCookies = ()=>{
            const allCookies = responseCookes.getAll();
            modifiedValues = allCookies.filter((c)=>modifiedCookies.has(c.name));
            if (res) {
                const serializedCookies = [];
                for (const cookie of modifiedValues){
                    const tempCookies = new _cookies.ResponseCookies(new Headers());
                    tempCookies.set(cookie);
                    serializedCookies.push(tempCookies.toString());
                }
                res.setHeader("Set-Cookie", serializedCookies);
            }
        };
        return new Proxy(responseCookes, {
            get (target, prop, receiver) {
                switch(prop){
                    // A special symbol to get the modified cookie values
                    case SYMBOL_MODIFY_COOKIE_VALUES:
                        return modifiedValues;
                    // TODO: Throw error if trying to set a cookie after the response
                    // headers have been set.
                    case "delete":
                        return function(...args) {
                            modifiedCookies.add(typeof args[0] === "string" ? args[0] : args[0].name);
                            try {
                                target.delete(...args);
                            } finally{
                                updateResponseCookies();
                            }
                        };
                    case "set":
                        return function(...args) {
                            modifiedCookies.add(typeof args[0] === "string" ? args[0] : args[0].name);
                            try {
                                return target.set(...args);
                            } finally{
                                updateResponseCookies();
                            }
                        };
                    default:
                        return _reflect.ReflectAdapter.get(target, prop, receiver);
                }
            }
        });
    }
} //# sourceMappingURL=request-cookies.js.map


/***/ }),

/***/ 5153:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
0 && 0;
_export_star(__webpack_require__(7783), exports);
function _export_star(from, to) {
    Object.keys(from).forEach(function(k) {
        if (k !== "default" && !Object.prototype.hasOwnProperty.call(to, k)) {
            Object.defineProperty(to, k, {
                enumerable: true,
                get: function() {
                    return from[k];
                }
            });
        }
    });
    return from;
} //# sourceMappingURL=cookies.js.map


/***/ }),

/***/ 9160:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "NextResponse", ({
    enumerable: true,
    get: function() {
        return NextResponse;
    }
}));
const _nexturl = __webpack_require__(6299);
const _utils = __webpack_require__(1643);
const _cookies = __webpack_require__(5153);
const INTERNALS = Symbol("internal response");
const REDIRECTS = new Set([
    301,
    302,
    303,
    307,
    308
]);
function handleMiddlewareField(init, headers) {
    var _init_request;
    if (init == null ? void 0 : (_init_request = init.request) == null ? void 0 : _init_request.headers) {
        if (!(init.request.headers instanceof Headers)) {
            throw new Error("request.headers must be an instance of Headers");
        }
        const keys = [];
        for (const [key, value] of init.request.headers){
            headers.set("x-middleware-request-" + key, value);
            keys.push(key);
        }
        headers.set("x-middleware-override-headers", keys.join(","));
    }
}
class NextResponse extends Response {
    constructor(body, init = {}){
        super(body, init);
        this[INTERNALS] = {
            cookies: new _cookies.ResponseCookies(this.headers),
            url: init.url ? new _nexturl.NextURL(init.url, {
                headers: (0, _utils.toNodeHeaders)(this.headers),
                nextConfig: init.nextConfig
            }) : undefined
        };
    }
    [Symbol.for("edge-runtime.inspect.custom")]() {
        return {
            cookies: this.cookies,
            url: this.url,
            // rest of props come from Response
            body: this.body,
            bodyUsed: this.bodyUsed,
            headers: Object.fromEntries(this.headers),
            ok: this.ok,
            redirected: this.redirected,
            status: this.status,
            statusText: this.statusText,
            type: this.type
        };
    }
    get cookies() {
        return this[INTERNALS].cookies;
    }
    static json(body, init) {
        // @ts-expect-error This is not in lib/dom right now, and we can't augment it.
        const response = Response.json(body, init);
        return new NextResponse(response.body, response);
    }
    static redirect(url, init) {
        const status = typeof init === "number" ? init : (init == null ? void 0 : init.status) ?? 307;
        if (!REDIRECTS.has(status)) {
            throw new RangeError('Failed to execute "redirect" on "response": Invalid status code');
        }
        const initObj = typeof init === "object" ? init : {};
        const headers = new Headers(initObj == null ? void 0 : initObj.headers);
        headers.set("Location", (0, _utils.validateURL)(url));
        return new NextResponse(null, {
            ...initObj,
            headers,
            status
        });
    }
    static rewrite(destination, init) {
        const headers = new Headers(init == null ? void 0 : init.headers);
        headers.set("x-middleware-rewrite", (0, _utils.validateURL)(destination));
        handleMiddlewareField(init, headers);
        return new NextResponse(null, {
            ...init,
            headers
        });
    }
    static next(init) {
        const headers = new Headers(init == null ? void 0 : init.headers);
        headers.set("x-middleware-next", "1");
        handleMiddlewareField(init, headers);
        return new NextResponse(null, {
            ...init,
            headers
        });
    }
} //# sourceMappingURL=response.js.map


/***/ }),

/***/ 1643:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
0 && (0);
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    fromNodeHeaders: function() {
        return fromNodeHeaders;
    },
    splitCookiesString: function() {
        return splitCookiesString;
    },
    toNodeHeaders: function() {
        return toNodeHeaders;
    },
    validateURL: function() {
        return validateURL;
    }
});
function fromNodeHeaders(object) {
    const headers = new Headers();
    for (let [key, value] of Object.entries(object)){
        const values = Array.isArray(value) ? value : [
            value
        ];
        for (let v of values){
            if (typeof v === "undefined") continue;
            if (typeof v === "number") {
                v = v.toString();
            }
            headers.append(key, v);
        }
    }
    return headers;
}
function splitCookiesString(cookiesString) {
    var cookiesStrings = [];
    var pos = 0;
    var start;
    var ch;
    var lastComma;
    var nextStart;
    var cookiesSeparatorFound;
    function skipWhitespace() {
        while(pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))){
            pos += 1;
        }
        return pos < cookiesString.length;
    }
    function notSpecialChar() {
        ch = cookiesString.charAt(pos);
        return ch !== "=" && ch !== ";" && ch !== ",";
    }
    while(pos < cookiesString.length){
        start = pos;
        cookiesSeparatorFound = false;
        while(skipWhitespace()){
            ch = cookiesString.charAt(pos);
            if (ch === ",") {
                // ',' is a cookie separator if we have later first '=', not ';' or ','
                lastComma = pos;
                pos += 1;
                skipWhitespace();
                nextStart = pos;
                while(pos < cookiesString.length && notSpecialChar()){
                    pos += 1;
                }
                // currently special character
                if (pos < cookiesString.length && cookiesString.charAt(pos) === "=") {
                    // we found cookies separator
                    cookiesSeparatorFound = true;
                    // pos is inside the next cookie, so back up and return it.
                    pos = nextStart;
                    cookiesStrings.push(cookiesString.substring(start, lastComma));
                    start = pos;
                } else {
                    // in param ',' or param separator ';',
                    // we continue from that comma
                    pos = lastComma + 1;
                }
            } else {
                pos += 1;
            }
        }
        if (!cookiesSeparatorFound || pos >= cookiesString.length) {
            cookiesStrings.push(cookiesString.substring(start, cookiesString.length));
        }
    }
    return cookiesStrings;
}
function toNodeHeaders(headers) {
    const result = {};
    const cookies = [];
    if (headers) {
        for (const [key, value] of headers.entries()){
            if (key.toLowerCase() === "set-cookie") {
                // We may have gotten a comma joined string of cookies, or multiple
                // set-cookie headers. We need to merge them into one header array
                // to represent all the cookies.
                cookies.push(...splitCookiesString(value));
                result[key] = cookies.length === 1 ? cookies[0] : cookies;
            } else {
                result[key] = value;
            }
        }
    }
    return result;
}
function validateURL(url) {
    try {
        return String(new URL(String(url)));
    } catch (error) {
        throw new Error(`URL is malformed "${String(url)}". Please use only absolute URLs - https://nextjs.org/docs/messages/middleware-relative-urls`, {
            cause: error
        });
    }
} //# sourceMappingURL=utils.js.map


/***/ }),

/***/ 8229:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "getHostname", ({
    enumerable: true,
    get: function() {
        return getHostname;
    }
}));
function getHostname(parsed, headers) {
    // Get the hostname from the headers if it exists, otherwise use the parsed
    // hostname.
    let hostname;
    if ((headers == null ? void 0 : headers.host) && !Array.isArray(headers.host)) {
        hostname = headers.host.toString().split(":")[0];
    } else if (parsed.hostname) {
        hostname = parsed.hostname;
    } else return;
    return hostname.toLowerCase();
} //# sourceMappingURL=get-hostname.js.map


/***/ }),

/***/ 7600:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "detectDomainLocale", ({
    enumerable: true,
    get: function() {
        return detectDomainLocale;
    }
}));
function detectDomainLocale(domainItems, hostname, detectedLocale) {
    if (!domainItems) return;
    if (detectedLocale) {
        detectedLocale = detectedLocale.toLowerCase();
    }
    for (const item of domainItems){
        var _item_domain, _item_locales;
        // remove port if present
        const domainHostname = (_item_domain = item.domain) == null ? void 0 : _item_domain.split(":")[0].toLowerCase();
        if (hostname === domainHostname || detectedLocale === item.defaultLocale.toLowerCase() || ((_item_locales = item.locales) == null ? void 0 : _item_locales.some((locale)=>locale.toLowerCase() === detectedLocale))) {
            return item;
        }
    }
} //# sourceMappingURL=detect-domain-locale.js.map


/***/ }),

/***/ 7252:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "normalizeLocalePath", ({
    enumerable: true,
    get: function() {
        return normalizeLocalePath;
    }
}));
function normalizeLocalePath(pathname, locales) {
    let detectedLocale;
    // first item will be empty string from splitting at first char
    const pathnameParts = pathname.split("/");
    (locales || []).some((locale)=>{
        if (pathnameParts[1] && pathnameParts[1].toLowerCase() === locale.toLowerCase()) {
            detectedLocale = locale;
            pathnameParts.splice(1, 1);
            pathname = pathnameParts.join("/") || "/";
            return true;
        }
        return false;
    });
    return {
        pathname,
        detectedLocale
    };
} //# sourceMappingURL=normalize-locale-path.js.map


/***/ }),

/***/ 9864:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
0 && (0);
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    getObjectClassLabel: function() {
        return getObjectClassLabel;
    },
    isPlainObject: function() {
        return isPlainObject;
    }
});
function getObjectClassLabel(value) {
    return Object.prototype.toString.call(value);
}
function isPlainObject(value) {
    if (getObjectClassLabel(value) !== "[object Object]") {
        return false;
    }
    const prototype = Object.getPrototypeOf(value);
    /**
   * this used to be previously:
   *
   * `return prototype === null || prototype === Object.prototype`
   *
   * but Edge Runtime expose Object from vm, being that kind of type-checking wrongly fail.
   *
   * It was changed to the current implementation since it's resilient to serialization.
   */ return prototype === null || prototype.hasOwnProperty("isPrototypeOf");
} //# sourceMappingURL=is-plain-object.js.map


/***/ }),

/***/ 5069:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "addLocale", ({
    enumerable: true,
    get: function() {
        return addLocale;
    }
}));
const _addpathprefix = __webpack_require__(722);
const _pathhasprefix = __webpack_require__(8744);
function addLocale(path, locale, defaultLocale, ignorePrefix) {
    // If no locale was given or the locale is the default locale, we don't need
    // to prefix the path.
    if (!locale || locale === defaultLocale) return path;
    const lower = path.toLowerCase();
    // If the path is an API path or the path already has the locale prefix, we
    // don't need to prefix the path.
    if (!ignorePrefix) {
        if ((0, _pathhasprefix.pathHasPrefix)(lower, "/api")) return path;
        if ((0, _pathhasprefix.pathHasPrefix)(lower, "/" + locale.toLowerCase())) return path;
    }
    // Add the locale prefix to the path.
    return (0, _addpathprefix.addPathPrefix)(path, "/" + locale);
} //# sourceMappingURL=add-locale.js.map


/***/ }),

/***/ 722:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "addPathPrefix", ({
    enumerable: true,
    get: function() {
        return addPathPrefix;
    }
}));
const _parsepath = __webpack_require__(6053);
function addPathPrefix(path, prefix) {
    if (!path.startsWith("/") || !prefix) {
        return path;
    }
    const { pathname , query , hash  } = (0, _parsepath.parsePath)(path);
    return "" + prefix + pathname + query + hash;
} //# sourceMappingURL=add-path-prefix.js.map


/***/ }),

/***/ 2884:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "addPathSuffix", ({
    enumerable: true,
    get: function() {
        return addPathSuffix;
    }
}));
const _parsepath = __webpack_require__(6053);
function addPathSuffix(path, suffix) {
    if (!path.startsWith("/") || !suffix) {
        return path;
    }
    const { pathname , query , hash  } = (0, _parsepath.parsePath)(path);
    return "" + pathname + suffix + query + hash;
} //# sourceMappingURL=add-path-suffix.js.map


/***/ }),

/***/ 6761:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "formatNextPathnameInfo", ({
    enumerable: true,
    get: function() {
        return formatNextPathnameInfo;
    }
}));
const _removetrailingslash = __webpack_require__(5933);
const _addpathprefix = __webpack_require__(722);
const _addpathsuffix = __webpack_require__(2884);
const _addlocale = __webpack_require__(5069);
function formatNextPathnameInfo(info) {
    let pathname = (0, _addlocale.addLocale)(info.pathname, info.locale, info.buildId ? undefined : info.defaultLocale, info.ignorePrefix);
    if (info.buildId || !info.trailingSlash) {
        pathname = (0, _removetrailingslash.removeTrailingSlash)(pathname);
    }
    if (info.buildId) {
        pathname = (0, _addpathsuffix.addPathSuffix)((0, _addpathprefix.addPathPrefix)(pathname, "/_next/data/" + info.buildId), info.pathname === "/" ? "index.json" : ".json");
    }
    pathname = (0, _addpathprefix.addPathPrefix)(pathname, info.basePath);
    return !info.buildId && info.trailingSlash ? !pathname.endsWith("/") ? (0, _addpathsuffix.addPathSuffix)(pathname, "/") : pathname : (0, _removetrailingslash.removeTrailingSlash)(pathname);
} //# sourceMappingURL=format-next-pathname-info.js.map


/***/ }),

/***/ 7612:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "getNextPathnameInfo", ({
    enumerable: true,
    get: function() {
        return getNextPathnameInfo;
    }
}));
const _normalizelocalepath = __webpack_require__(7252);
const _removepathprefix = __webpack_require__(4146);
const _pathhasprefix = __webpack_require__(8744);
function getNextPathnameInfo(pathname, options) {
    var _options_nextConfig;
    const { basePath , i18n , trailingSlash  } = (_options_nextConfig = options.nextConfig) != null ? _options_nextConfig : {};
    const info = {
        pathname: pathname,
        trailingSlash: pathname !== "/" ? pathname.endsWith("/") : trailingSlash
    };
    if (basePath && (0, _pathhasprefix.pathHasPrefix)(info.pathname, basePath)) {
        info.pathname = (0, _removepathprefix.removePathPrefix)(info.pathname, basePath);
        info.basePath = basePath;
    }
    if (options.parseData === true && info.pathname.startsWith("/_next/data/") && info.pathname.endsWith(".json")) {
        const paths = info.pathname.replace(/^\/_next\/data\//, "").replace(/\.json$/, "").split("/");
        const buildId = paths[0];
        info.pathname = paths[1] !== "index" ? "/" + paths.slice(1).join("/") : "/";
        info.buildId = buildId;
    }
    // If provided, use the locale route normalizer to detect the locale instead
    // of the function below.
    if (options.i18nProvider) {
        const result = options.i18nProvider.analyze(info.pathname);
        info.locale = result.detectedLocale;
        var _result_pathname;
        info.pathname = (_result_pathname = result.pathname) != null ? _result_pathname : info.pathname;
    } else if (i18n) {
        const pathLocale = (0, _normalizelocalepath.normalizeLocalePath)(info.pathname, i18n.locales);
        info.locale = pathLocale.detectedLocale;
        var _pathLocale_pathname;
        info.pathname = (_pathLocale_pathname = pathLocale.pathname) != null ? _pathLocale_pathname : info.pathname;
    }
    return info;
} //# sourceMappingURL=get-next-pathname-info.js.map


/***/ }),

/***/ 6053:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/**
 * Given a path this function will find the pathname, query and hash and return
 * them. This is useful to parse full paths on the client side.
 * @param path A path to parse e.g. /foo/bar?id=1#hash
 */ 
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "parsePath", ({
    enumerable: true,
    get: function() {
        return parsePath;
    }
}));
function parsePath(path) {
    const hashIndex = path.indexOf("#");
    const queryIndex = path.indexOf("?");
    const hasQuery = queryIndex > -1 && (hashIndex < 0 || queryIndex < hashIndex);
    if (hasQuery || hashIndex > -1) {
        return {
            pathname: path.substring(0, hasQuery ? queryIndex : hashIndex),
            query: hasQuery ? path.substring(queryIndex, hashIndex > -1 ? hashIndex : undefined) : "",
            hash: hashIndex > -1 ? path.slice(hashIndex) : ""
        };
    }
    return {
        pathname: path,
        query: "",
        hash: ""
    };
} //# sourceMappingURL=parse-path.js.map


/***/ }),

/***/ 8744:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "pathHasPrefix", ({
    enumerable: true,
    get: function() {
        return pathHasPrefix;
    }
}));
const _parsepath = __webpack_require__(6053);
function pathHasPrefix(path, prefix) {
    if (typeof path !== "string") {
        return false;
    }
    const { pathname  } = (0, _parsepath.parsePath)(path);
    return pathname === prefix || pathname.startsWith(prefix + "/");
} //# sourceMappingURL=path-has-prefix.js.map


/***/ }),

/***/ 4146:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "removePathPrefix", ({
    enumerable: true,
    get: function() {
        return removePathPrefix;
    }
}));
const _pathhasprefix = __webpack_require__(8744);
function removePathPrefix(path, prefix) {
    // If the path doesn't start with the prefix we can return it as is. This
    // protects us from situations where the prefix is a substring of the path
    // prefix such as:
    //
    // For prefix: /blog
    //
    //   /blog -> true
    //   /blog/ -> true
    //   /blog/1 -> true
    //   /blogging -> false
    //   /blogging/ -> false
    //   /blogging/1 -> false
    if (!(0, _pathhasprefix.pathHasPrefix)(path, prefix)) {
        return path;
    }
    // Remove the prefix from the path via slicing.
    const withoutPrefix = path.slice(prefix.length);
    // If the path without the prefix starts with a `/` we can return it as is.
    if (withoutPrefix.startsWith("/")) {
        return withoutPrefix;
    }
    // If the path without the prefix doesn't start with a `/` we need to add it
    // back to the path to make sure it's a valid path.
    return "/" + withoutPrefix;
} //# sourceMappingURL=remove-path-prefix.js.map


/***/ }),

/***/ 5933:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/**
 * Removes the trailing slash for a given route or page path. Preserves the
 * root page. Examples:
 *   - `/foo/bar/` -> `/foo/bar`
 *   - `/foo/bar` -> `/foo/bar`
 *   - `/` -> `/`
 */ 
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "removeTrailingSlash", ({
    enumerable: true,
    get: function() {
        return removeTrailingSlash;
    }
}));
function removeTrailingSlash(route) {
    return route.replace(/\/$/, "") || "/";
} //# sourceMappingURL=remove-trailing-slash.js.map


/***/ }),

/***/ 6199:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
0 && (0);
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    WEB_VITALS: function() {
        return WEB_VITALS;
    },
    execOnce: function() {
        return execOnce;
    },
    isAbsoluteUrl: function() {
        return isAbsoluteUrl;
    },
    getLocationOrigin: function() {
        return getLocationOrigin;
    },
    getURL: function() {
        return getURL;
    },
    getDisplayName: function() {
        return getDisplayName;
    },
    isResSent: function() {
        return isResSent;
    },
    normalizeRepeatedSlashes: function() {
        return normalizeRepeatedSlashes;
    },
    loadGetInitialProps: function() {
        return loadGetInitialProps;
    },
    SP: function() {
        return SP;
    },
    ST: function() {
        return ST;
    },
    DecodeError: function() {
        return DecodeError;
    },
    NormalizeError: function() {
        return NormalizeError;
    },
    PageNotFoundError: function() {
        return PageNotFoundError;
    },
    MissingStaticPage: function() {
        return MissingStaticPage;
    },
    MiddlewareNotFoundError: function() {
        return MiddlewareNotFoundError;
    }
});
const WEB_VITALS = [
    "CLS",
    "FCP",
    "FID",
    "INP",
    "LCP",
    "TTFB"
];
function execOnce(fn) {
    let used = false;
    let result;
    return function() {
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        if (!used) {
            used = true;
            result = fn(...args);
        }
        return result;
    };
}
// Scheme: https://tools.ietf.org/html/rfc3986#section-3.1
// Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3
const ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\d+\-.]*?:/;
const isAbsoluteUrl = (url)=>ABSOLUTE_URL_REGEX.test(url);
function getLocationOrigin() {
    const { protocol , hostname , port  } = window.location;
    return protocol + "//" + hostname + (port ? ":" + port : "");
}
function getURL() {
    const { href  } = window.location;
    const origin = getLocationOrigin();
    return href.substring(origin.length);
}
function getDisplayName(Component) {
    return typeof Component === "string" ? Component : Component.displayName || Component.name || "Unknown";
}
function isResSent(res) {
    return res.finished || res.headersSent;
}
function normalizeRepeatedSlashes(url) {
    const urlParts = url.split("?");
    const urlNoQuery = urlParts[0];
    return urlNoQuery // first we replace any non-encoded backslashes with forward
    // then normalize repeated forward slashes
    .replace(/\\/g, "/").replace(/\/\/+/g, "/") + (urlParts[1] ? "?" + urlParts.slice(1).join("?") : "");
}
async function loadGetInitialProps(App, ctx) {
    if (false) { var _App_prototype; }
    // when called from _app `ctx` is nested in `ctx`
    const res = ctx.res || ctx.ctx && ctx.ctx.res;
    if (!App.getInitialProps) {
        if (ctx.ctx && ctx.Component) {
            // @ts-ignore pageProps default
            return {
                pageProps: await loadGetInitialProps(ctx.Component, ctx.ctx)
            };
        }
        return {};
    }
    const props = await App.getInitialProps(ctx);
    if (res && isResSent(res)) {
        return props;
    }
    if (!props) {
        const message = '"' + getDisplayName(App) + '.getInitialProps()" should resolve to an object. But found "' + props + '" instead.';
        throw new Error(message);
    }
    if (false) {}
    return props;
}
const SP = typeof performance !== "undefined";
const ST = SP && [
    "mark",
    "measure",
    "getEntriesByName"
].every((method)=>typeof performance[method] === "function");
class DecodeError extends Error {
}
class NormalizeError extends Error {
}
class PageNotFoundError extends Error {
    constructor(page){
        super();
        this.code = "ENOENT";
        this.name = "PageNotFoundError";
        this.message = "Cannot find module for page: " + page;
    }
}
class MissingStaticPage extends Error {
    constructor(page, message){
        super();
        this.message = "Failed to load static file for page: " + page + " " + message;
    }
}
class MiddlewareNotFoundError extends Error {
    constructor(){
        super();
        this.code = "ENOENT";
        this.message = "Cannot find the middleware module";
    }
} //# sourceMappingURL=utils.js.map


/***/ }),

/***/ 480:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/*!
 * MIT License
 * 
 * Copyright (c) 2017-2022 Peculiar Ventures, LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 * 
 */ 
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const ARRAY_BUFFER_NAME = "[object ArrayBuffer]";
class BufferSourceConverter {
    static isArrayBuffer(data) {
        return Object.prototype.toString.call(data) === ARRAY_BUFFER_NAME;
    }
    static toArrayBuffer(data) {
        if (this.isArrayBuffer(data)) {
            return data;
        }
        if (data.byteLength === data.buffer.byteLength) {
            return data.buffer;
        }
        return this.toUint8Array(data).slice().buffer;
    }
    static toUint8Array(data) {
        return this.toView(data, Uint8Array);
    }
    static toView(data, type) {
        if (data.constructor === type) {
            return data;
        }
        if (this.isArrayBuffer(data)) {
            return new type(data);
        }
        if (this.isArrayBufferView(data)) {
            return new type(data.buffer, data.byteOffset, data.byteLength);
        }
        throw new TypeError("The provided value is not of type '(ArrayBuffer or ArrayBufferView)'");
    }
    static isBufferSource(data) {
        return this.isArrayBufferView(data) || this.isArrayBuffer(data);
    }
    static isArrayBufferView(data) {
        return ArrayBuffer.isView(data) || data && this.isArrayBuffer(data.buffer);
    }
    static isEqual(a, b) {
        const aView = BufferSourceConverter.toUint8Array(a);
        const bView = BufferSourceConverter.toUint8Array(b);
        if (aView.length !== bView.byteLength) {
            return false;
        }
        for(let i = 0; i < aView.length; i++){
            if (aView[i] !== bView[i]) {
                return false;
            }
        }
        return true;
    }
    static concat(...args) {
        if (Array.isArray(args[0])) {
            const buffers = args[0];
            let size = 0;
            for (const buffer of buffers){
                size += buffer.byteLength;
            }
            const res = new Uint8Array(size);
            let offset = 0;
            for (const buffer of buffers){
                const view = this.toUint8Array(buffer);
                res.set(view, offset);
                offset += view.length;
            }
            if (args[1]) {
                return this.toView(res, args[1]);
            }
            return res.buffer;
        } else {
            return this.concat(args);
        }
    }
}
class Utf8Converter {
    static fromString(text) {
        const s = unescape(encodeURIComponent(text));
        const uintArray = new Uint8Array(s.length);
        for(let i = 0; i < s.length; i++){
            uintArray[i] = s.charCodeAt(i);
        }
        return uintArray.buffer;
    }
    static toString(buffer) {
        const buf = BufferSourceConverter.toUint8Array(buffer);
        let encodedString = "";
        for(let i = 0; i < buf.length; i++){
            encodedString += String.fromCharCode(buf[i]);
        }
        const decodedString = decodeURIComponent(escape(encodedString));
        return decodedString;
    }
}
class Utf16Converter {
    static toString(buffer, littleEndian = false) {
        const arrayBuffer = BufferSourceConverter.toArrayBuffer(buffer);
        const dataView = new DataView(arrayBuffer);
        let res = "";
        for(let i = 0; i < arrayBuffer.byteLength; i += 2){
            const code = dataView.getUint16(i, littleEndian);
            res += String.fromCharCode(code);
        }
        return res;
    }
    static fromString(text, littleEndian = false) {
        const res = new ArrayBuffer(text.length * 2);
        const dataView = new DataView(res);
        for(let i = 0; i < text.length; i++){
            dataView.setUint16(i * 2, text.charCodeAt(i), littleEndian);
        }
        return res;
    }
}
class Convert {
    static isHex(data) {
        return typeof data === "string" && /^[a-z0-9]+$/i.test(data);
    }
    static isBase64(data) {
        return typeof data === "string" && /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(data);
    }
    static isBase64Url(data) {
        return typeof data === "string" && /^[a-zA-Z0-9-_]+$/i.test(data);
    }
    static ToString(buffer, enc = "utf8") {
        const buf = BufferSourceConverter.toUint8Array(buffer);
        switch(enc.toLowerCase()){
            case "utf8":
                return this.ToUtf8String(buf);
            case "binary":
                return this.ToBinary(buf);
            case "hex":
                return this.ToHex(buf);
            case "base64":
                return this.ToBase64(buf);
            case "base64url":
                return this.ToBase64Url(buf);
            case "utf16le":
                return Utf16Converter.toString(buf, true);
            case "utf16":
            case "utf16be":
                return Utf16Converter.toString(buf);
            default:
                throw new Error(`Unknown type of encoding '${enc}'`);
        }
    }
    static FromString(str, enc = "utf8") {
        if (!str) {
            return new ArrayBuffer(0);
        }
        switch(enc.toLowerCase()){
            case "utf8":
                return this.FromUtf8String(str);
            case "binary":
                return this.FromBinary(str);
            case "hex":
                return this.FromHex(str);
            case "base64":
                return this.FromBase64(str);
            case "base64url":
                return this.FromBase64Url(str);
            case "utf16le":
                return Utf16Converter.fromString(str, true);
            case "utf16":
            case "utf16be":
                return Utf16Converter.fromString(str);
            default:
                throw new Error(`Unknown type of encoding '${enc}'`);
        }
    }
    static ToBase64(buffer) {
        const buf = BufferSourceConverter.toUint8Array(buffer);
        if (typeof btoa !== "undefined") {
            const binary = this.ToString(buf, "binary");
            return btoa(binary);
        } else {
            return Buffer.from(buf).toString("base64");
        }
    }
    static FromBase64(base64) {
        const formatted = this.formatString(base64);
        if (!formatted) {
            return new ArrayBuffer(0);
        }
        if (!Convert.isBase64(formatted)) {
            throw new TypeError("Argument 'base64Text' is not Base64 encoded");
        }
        if (typeof atob !== "undefined") {
            return this.FromBinary(atob(formatted));
        } else {
            return new Uint8Array(Buffer.from(formatted, "base64")).buffer;
        }
    }
    static FromBase64Url(base64url) {
        const formatted = this.formatString(base64url);
        if (!formatted) {
            return new ArrayBuffer(0);
        }
        if (!Convert.isBase64Url(formatted)) {
            throw new TypeError("Argument 'base64url' is not Base64Url encoded");
        }
        return this.FromBase64(this.Base64Padding(formatted.replace(/\-/g, "+").replace(/\_/g, "/")));
    }
    static ToBase64Url(data) {
        return this.ToBase64(data).replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
    }
    static FromUtf8String(text, encoding = Convert.DEFAULT_UTF8_ENCODING) {
        switch(encoding){
            case "ascii":
                return this.FromBinary(text);
            case "utf8":
                return Utf8Converter.fromString(text);
            case "utf16":
            case "utf16be":
                return Utf16Converter.fromString(text);
            case "utf16le":
            case "usc2":
                return Utf16Converter.fromString(text, true);
            default:
                throw new Error(`Unknown type of encoding '${encoding}'`);
        }
    }
    static ToUtf8String(buffer, encoding = Convert.DEFAULT_UTF8_ENCODING) {
        switch(encoding){
            case "ascii":
                return this.ToBinary(buffer);
            case "utf8":
                return Utf8Converter.toString(buffer);
            case "utf16":
            case "utf16be":
                return Utf16Converter.toString(buffer);
            case "utf16le":
            case "usc2":
                return Utf16Converter.toString(buffer, true);
            default:
                throw new Error(`Unknown type of encoding '${encoding}'`);
        }
    }
    static FromBinary(text) {
        const stringLength = text.length;
        const resultView = new Uint8Array(stringLength);
        for(let i = 0; i < stringLength; i++){
            resultView[i] = text.charCodeAt(i);
        }
        return resultView.buffer;
    }
    static ToBinary(buffer) {
        const buf = BufferSourceConverter.toUint8Array(buffer);
        let res = "";
        for(let i = 0; i < buf.length; i++){
            res += String.fromCharCode(buf[i]);
        }
        return res;
    }
    static ToHex(buffer) {
        const buf = BufferSourceConverter.toUint8Array(buffer);
        const splitter = "";
        const res = [];
        const len = buf.length;
        for(let i = 0; i < len; i++){
            const char = buf[i].toString(16).padStart(2, "0");
            res.push(char);
        }
        return res.join(splitter);
    }
    static FromHex(hexString) {
        let formatted = this.formatString(hexString);
        if (!formatted) {
            return new ArrayBuffer(0);
        }
        if (!Convert.isHex(formatted)) {
            throw new TypeError("Argument 'hexString' is not HEX encoded");
        }
        if (formatted.length % 2) {
            formatted = `0${formatted}`;
        }
        const res = new Uint8Array(formatted.length / 2);
        for(let i = 0; i < formatted.length; i = i + 2){
            const c = formatted.slice(i, i + 2);
            res[i / 2] = parseInt(c, 16);
        }
        return res.buffer;
    }
    static ToUtf16String(buffer, littleEndian = false) {
        return Utf16Converter.toString(buffer, littleEndian);
    }
    static FromUtf16String(text, littleEndian = false) {
        return Utf16Converter.fromString(text, littleEndian);
    }
    static Base64Padding(base64) {
        const padCount = 4 - base64.length % 4;
        if (padCount < 4) {
            for(let i = 0; i < padCount; i++){
                base64 += "=";
            }
        }
        return base64;
    }
    static formatString(data) {
        return (data === null || data === void 0 ? void 0 : data.replace(/[\n\r\t ]/g, "")) || "";
    }
}
Convert.DEFAULT_UTF8_ENCODING = "utf8";
function assign(target, ...sources) {
    const res = arguments[0];
    for(let i = 1; i < arguments.length; i++){
        const obj = arguments[i];
        for(const prop in obj){
            res[prop] = obj[prop];
        }
    }
    return res;
}
function combine(...buf) {
    const totalByteLength = buf.map((item)=>item.byteLength).reduce((prev, cur)=>prev + cur);
    const res = new Uint8Array(totalByteLength);
    let currentPos = 0;
    buf.map((item)=>new Uint8Array(item)).forEach((arr)=>{
        for (const item2 of arr){
            res[currentPos++] = item2;
        }
    });
    return res.buffer;
}
function isEqual(bytes1, bytes2) {
    if (!(bytes1 && bytes2)) {
        return false;
    }
    if (bytes1.byteLength !== bytes2.byteLength) {
        return false;
    }
    const b1 = new Uint8Array(bytes1);
    const b2 = new Uint8Array(bytes2);
    for(let i = 0; i < bytes1.byteLength; i++){
        if (b1[i] !== b2[i]) {
            return false;
        }
    }
    return true;
}
exports.BufferSourceConverter = BufferSourceConverter;
exports.Convert = Convert;
exports.assign = assign;
exports.combine = combine;
exports.isEqual = isEqual;


/***/ }),

/***/ 1745:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/*!
 Copyright (c) Peculiar Ventures, LLC
*/ 
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function getUTCDate(date) {
    return new Date(date.getTime() + date.getTimezoneOffset() * 60000);
}
function getParametersValue(parameters, name, defaultValue) {
    var _a;
    if (parameters instanceof Object === false) {
        return defaultValue;
    }
    return (_a = parameters[name]) !== null && _a !== void 0 ? _a : defaultValue;
}
function bufferToHexCodes(inputBuffer, inputOffset = 0, inputLength = inputBuffer.byteLength - inputOffset, insertSpace = false) {
    let result = "";
    for (const item of new Uint8Array(inputBuffer, inputOffset, inputLength)){
        const str = item.toString(16).toUpperCase();
        if (str.length === 1) {
            result += "0";
        }
        result += str;
        if (insertSpace) {
            result += " ";
        }
    }
    return result.trim();
}
function checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength) {
    if (!(inputBuffer instanceof ArrayBuffer)) {
        baseBlock.error = 'Wrong parameter: inputBuffer must be "ArrayBuffer"';
        return false;
    }
    if (!inputBuffer.byteLength) {
        baseBlock.error = "Wrong parameter: inputBuffer has zero length";
        return false;
    }
    if (inputOffset < 0) {
        baseBlock.error = "Wrong parameter: inputOffset less than zero";
        return false;
    }
    if (inputLength < 0) {
        baseBlock.error = "Wrong parameter: inputLength less than zero";
        return false;
    }
    if (inputBuffer.byteLength - inputOffset - inputLength < 0) {
        baseBlock.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
        return false;
    }
    return true;
}
function utilFromBase(inputBuffer, inputBase) {
    let result = 0;
    if (inputBuffer.length === 1) {
        return inputBuffer[0];
    }
    for(let i = inputBuffer.length - 1; i >= 0; i--){
        result += inputBuffer[inputBuffer.length - 1 - i] * Math.pow(2, inputBase * i);
    }
    return result;
}
function utilToBase(value, base, reserved = -1) {
    const internalReserved = reserved;
    let internalValue = value;
    let result = 0;
    let biggest = Math.pow(2, base);
    for(let i = 1; i < 8; i++){
        if (value < biggest) {
            let retBuf;
            if (internalReserved < 0) {
                retBuf = new ArrayBuffer(i);
                result = i;
            } else {
                if (internalReserved < i) {
                    return new ArrayBuffer(0);
                }
                retBuf = new ArrayBuffer(internalReserved);
                result = internalReserved;
            }
            const retView = new Uint8Array(retBuf);
            for(let j = i - 1; j >= 0; j--){
                const basis = Math.pow(2, j * base);
                retView[result - j - 1] = Math.floor(internalValue / basis);
                internalValue -= retView[result - j - 1] * basis;
            }
            return retBuf;
        }
        biggest *= Math.pow(2, base);
    }
    return new ArrayBuffer(0);
}
function utilConcatBuf(...buffers) {
    let outputLength = 0;
    let prevLength = 0;
    for (const buffer of buffers){
        outputLength += buffer.byteLength;
    }
    const retBuf = new ArrayBuffer(outputLength);
    const retView = new Uint8Array(retBuf);
    for (const buffer of buffers){
        retView.set(new Uint8Array(buffer), prevLength);
        prevLength += buffer.byteLength;
    }
    return retBuf;
}
function utilConcatView(...views) {
    let outputLength = 0;
    let prevLength = 0;
    for (const view of views){
        outputLength += view.length;
    }
    const retBuf = new ArrayBuffer(outputLength);
    const retView = new Uint8Array(retBuf);
    for (const view of views){
        retView.set(view, prevLength);
        prevLength += view.length;
    }
    return retView;
}
function utilDecodeTC() {
    const buf = new Uint8Array(this.valueHex);
    if (this.valueHex.byteLength >= 2) {
        const condition1 = buf[0] === 0xFF && buf[1] & 0x80;
        const condition2 = buf[0] === 0x00 && (buf[1] & 0x80) === 0x00;
        if (condition1 || condition2) {
            this.warnings.push("Needlessly long format");
        }
    }
    const bigIntBuffer = new ArrayBuffer(this.valueHex.byteLength);
    const bigIntView = new Uint8Array(bigIntBuffer);
    for(let i = 0; i < this.valueHex.byteLength; i++){
        bigIntView[i] = 0;
    }
    bigIntView[0] = buf[0] & 0x80;
    const bigInt = utilFromBase(bigIntView, 8);
    const smallIntBuffer = new ArrayBuffer(this.valueHex.byteLength);
    const smallIntView = new Uint8Array(smallIntBuffer);
    for(let j = 0; j < this.valueHex.byteLength; j++){
        smallIntView[j] = buf[j];
    }
    smallIntView[0] &= 0x7F;
    const smallInt = utilFromBase(smallIntView, 8);
    return smallInt - bigInt;
}
function utilEncodeTC(value) {
    const modValue = value < 0 ? value * -1 : value;
    let bigInt = 128;
    for(let i = 1; i < 8; i++){
        if (modValue <= bigInt) {
            if (value < 0) {
                const smallInt = bigInt - modValue;
                const retBuf = utilToBase(smallInt, 8, i);
                const retView = new Uint8Array(retBuf);
                retView[0] |= 0x80;
                return retBuf;
            }
            let retBuf = utilToBase(modValue, 8, i);
            let retView = new Uint8Array(retBuf);
            if (retView[0] & 0x80) {
                const tempBuf = retBuf.slice(0);
                const tempView = new Uint8Array(tempBuf);
                retBuf = new ArrayBuffer(retBuf.byteLength + 1);
                retView = new Uint8Array(retBuf);
                for(let k = 0; k < tempBuf.byteLength; k++){
                    retView[k + 1] = tempView[k];
                }
                retView[0] = 0x00;
            }
            return retBuf;
        }
        bigInt *= Math.pow(2, 8);
    }
    return new ArrayBuffer(0);
}
function isEqualBuffer(inputBuffer1, inputBuffer2) {
    if (inputBuffer1.byteLength !== inputBuffer2.byteLength) {
        return false;
    }
    const view1 = new Uint8Array(inputBuffer1);
    const view2 = new Uint8Array(inputBuffer2);
    for(let i = 0; i < view1.length; i++){
        if (view1[i] !== view2[i]) {
            return false;
        }
    }
    return true;
}
function padNumber(inputNumber, fullLength) {
    const str = inputNumber.toString(10);
    if (fullLength < str.length) {
        return "";
    }
    const dif = fullLength - str.length;
    const padding = new Array(dif);
    for(let i = 0; i < dif; i++){
        padding[i] = "0";
    }
    const paddingString = padding.join("");
    return paddingString.concat(str);
}
const base64Template = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
const base64UrlTemplate = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=";
function toBase64(input, useUrlTemplate = false, skipPadding = false, skipLeadingZeros = false) {
    let i = 0;
    let flag1 = 0;
    let flag2 = 0;
    let output = "";
    const template = useUrlTemplate ? base64UrlTemplate : base64Template;
    if (skipLeadingZeros) {
        let nonZeroPosition = 0;
        for(let i = 0; i < input.length; i++){
            if (input.charCodeAt(i) !== 0) {
                nonZeroPosition = i;
                break;
            }
        }
        input = input.slice(nonZeroPosition);
    }
    while(i < input.length){
        const chr1 = input.charCodeAt(i++);
        if (i >= input.length) {
            flag1 = 1;
        }
        const chr2 = input.charCodeAt(i++);
        if (i >= input.length) {
            flag2 = 1;
        }
        const chr3 = input.charCodeAt(i++);
        const enc1 = chr1 >> 2;
        const enc2 = (chr1 & 0x03) << 4 | chr2 >> 4;
        let enc3 = (chr2 & 0x0F) << 2 | chr3 >> 6;
        let enc4 = chr3 & 0x3F;
        if (flag1 === 1) {
            enc3 = enc4 = 64;
        } else {
            if (flag2 === 1) {
                enc4 = 64;
            }
        }
        if (skipPadding) {
            if (enc3 === 64) {
                output += `${template.charAt(enc1)}${template.charAt(enc2)}`;
            } else {
                if (enc4 === 64) {
                    output += `${template.charAt(enc1)}${template.charAt(enc2)}${template.charAt(enc3)}`;
                } else {
                    output += `${template.charAt(enc1)}${template.charAt(enc2)}${template.charAt(enc3)}${template.charAt(enc4)}`;
                }
            }
        } else {
            output += `${template.charAt(enc1)}${template.charAt(enc2)}${template.charAt(enc3)}${template.charAt(enc4)}`;
        }
    }
    return output;
}
function fromBase64(input, useUrlTemplate = false, cutTailZeros = false) {
    const template = useUrlTemplate ? base64UrlTemplate : base64Template;
    function indexOf(toSearch) {
        for(let i = 0; i < 64; i++){
            if (template.charAt(i) === toSearch) return i;
        }
        return 64;
    }
    function test(incoming) {
        return incoming === 64 ? 0x00 : incoming;
    }
    let i = 0;
    let output = "";
    while(i < input.length){
        const enc1 = indexOf(input.charAt(i++));
        const enc2 = i >= input.length ? 0x00 : indexOf(input.charAt(i++));
        const enc3 = i >= input.length ? 0x00 : indexOf(input.charAt(i++));
        const enc4 = i >= input.length ? 0x00 : indexOf(input.charAt(i++));
        const chr1 = test(enc1) << 2 | test(enc2) >> 4;
        const chr2 = (test(enc2) & 0x0F) << 4 | test(enc3) >> 2;
        const chr3 = (test(enc3) & 0x03) << 6 | test(enc4);
        output += String.fromCharCode(chr1);
        if (enc3 !== 64) {
            output += String.fromCharCode(chr2);
        }
        if (enc4 !== 64) {
            output += String.fromCharCode(chr3);
        }
    }
    if (cutTailZeros) {
        const outputLength = output.length;
        let nonZeroStart = -1;
        for(let i = outputLength - 1; i >= 0; i--){
            if (output.charCodeAt(i) !== 0) {
                nonZeroStart = i;
                break;
            }
        }
        if (nonZeroStart !== -1) {
            output = output.slice(0, nonZeroStart + 1);
        } else {
            output = "";
        }
    }
    return output;
}
function arrayBufferToString(buffer) {
    let resultString = "";
    const view = new Uint8Array(buffer);
    for (const element of view){
        resultString += String.fromCharCode(element);
    }
    return resultString;
}
function stringToArrayBuffer(str) {
    const stringLength = str.length;
    const resultBuffer = new ArrayBuffer(stringLength);
    const resultView = new Uint8Array(resultBuffer);
    for(let i = 0; i < stringLength; i++){
        resultView[i] = str.charCodeAt(i);
    }
    return resultBuffer;
}
const log2 = Math.log(2);
function nearestPowerOf2(length) {
    const base = Math.log(length) / log2;
    const floor = Math.floor(base);
    const round = Math.round(base);
    return floor === round ? floor : round;
}
function clearProps(object, propsArray) {
    for (const prop of propsArray){
        delete object[prop];
    }
}
exports.arrayBufferToString = arrayBufferToString;
exports.bufferToHexCodes = bufferToHexCodes;
exports.checkBufferParams = checkBufferParams;
exports.clearProps = clearProps;
exports.fromBase64 = fromBase64;
exports.getParametersValue = getParametersValue;
exports.getUTCDate = getUTCDate;
exports.isEqualBuffer = isEqualBuffer;
exports.nearestPowerOf2 = nearestPowerOf2;
exports.padNumber = padNumber;
exports.stringToArrayBuffer = stringToArrayBuffer;
exports.toBase64 = toBase64;
exports.utilConcatBuf = utilConcatBuf;
exports.utilConcatView = utilConcatView;
exports.utilDecodeTC = utilDecodeTC;
exports.utilEncodeTC = utilEncodeTC;
exports.utilFromBase = utilFromBase;
exports.utilToBase = utilToBase;


/***/ }),

/***/ 4392:
/***/ ((module) => {

"use strict";

!function(e, r) {
     true ? module.exports = r() : 0;
}(void 0, function() {
    return function(e) {
        function r(t) {
            if (n[t]) return n[t].exports;
            var o = n[t] = {
                i: t,
                l: !1,
                exports: {}
            };
            return e[t].call(o.exports, o, o.exports, r), o.l = !0, o.exports;
        }
        var n = {};
        return r.m = e, r.c = n, r.i = function(e) {
            return e;
        }, r.d = function(e, n, t) {
            r.o(e, n) || Object.defineProperty(e, n, {
                configurable: !1,
                enumerable: !0,
                get: t
            });
        }, r.n = function(e) {
            var n = e && e.__esModule ? function() {
                return e.default;
            } : function() {
                return e;
            };
            return r.d(n, "a", n), n;
        }, r.o = function(e, r) {
            return Object.prototype.hasOwnProperty.call(e, r);
        }, r.p = "", r(r.s = 1);
    }([
        function(e, r, n) {
            "use strict";
            function t(e, r) {
                if (!(e instanceof r)) throw new TypeError("Cannot call a class as a function");
            }
            Object.defineProperty(r, "__esModule", {
                value: !0
            });
            var o = function() {
                function e(e, r) {
                    for(var n = 0; n < r.length; n++){
                        var t = r[n];
                        t.enumerable = t.enumerable || !1, t.configurable = !0, "value" in t && (t.writable = !0), Object.defineProperty(e, t.key, t);
                    }
                }
                return function(r, n, t) {
                    return n && e(r.prototype, n), t && e(r, t), r;
                };
            }(), u = function() {
                function e() {
                    t(this, e);
                }
                return o(e, null, [
                    {
                        key: "hash",
                        value: function(r) {
                            return e.stringToHex(e.arrayToString(e.run(e.stringToArray(r), 8 * r.length)));
                        }
                    },
                    {
                        key: "run",
                        value: function(r, n) {
                            var t = 15 + (n + 64 >> 9 << 4), o = [
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0
                            ], u = 0, a = 1732584193, f = -271733879, c = -1732584194, i = 271733878, l = -1009589776, d = a, s = f, y = c, p = i, v = l;
                            for(r[n >> 5] |= 128 << 24 - n % 32, r[t] = n; u < t; u += 16){
                                a = d, f = s, c = y, i = p, l = v;
                                for(var h = 0, g = null; h < 80; h += 1)o[h] = h < 16 ? r[u + h] : e.rotl(o[h - 3] ^ o[h - 8] ^ o[h - 14] ^ o[h - 16], 1), g = e.add(e.add(e.rotl(d, 5), e.chMajPty(h, s, y, p)), e.add(e.add(v, o[h]), e.cnst(h))), v = p, p = y, y = e.rotl(s, 30), s = d, d = g;
                                d = e.add(d, a), s = e.add(s, f), y = e.add(y, c), p = e.add(p, i), v = e.add(v, l);
                            }
                            return [
                                d,
                                s,
                                y,
                                p,
                                v
                            ];
                        }
                    },
                    {
                        key: "arrayToString",
                        value: function(e) {
                            for(var r = 32 * e.length, n = 0, t = ""; n < r; n += 8)t += String.fromCharCode(e[n >> 5] >>> 24 - n % 32 & 255);
                            return t;
                        }
                    },
                    {
                        key: "stringToArray",
                        value: function(e) {
                            var r = 8 * e.length, n = Array(e.length >> 2), t = n.length, o = 0;
                            for(o = 0; o < t; o += 1)n[o] = 0;
                            for(o = 0; o < r; o += 8)n[o >> 5] |= (255 & e.charCodeAt(o / 8)) << 24 - o % 32;
                            return n;
                        }
                    },
                    {
                        key: "stringToHex",
                        value: function(e) {
                            for(var r = "0123456789abcdef", n = e.length, t = "", o = 0, u = 0; u < n; u += 1)o = e.charCodeAt(u), t += r.charAt(o >>> 4 & 15) + r.charAt(15 & o);
                            return t;
                        }
                    },
                    {
                        key: "chMajPty",
                        value: function(e, r, n, t) {
                            return e < 20 ? r & n | ~r & t : e < 40 ? r ^ n ^ t : e < 60 ? r & n | r & t | n & t : r ^ n ^ t;
                        }
                    },
                    {
                        key: "cnst",
                        value: function(e) {
                            return e < 20 ? 1518500249 : e < 40 ? 1859775393 : e < 60 ? -1894007588 : -899497514;
                        }
                    },
                    {
                        key: "rotl",
                        value: function(e, r) {
                            return e << r | e >>> 32 - r;
                        }
                    },
                    {
                        key: "add",
                        value: function(e, r) {
                            var n = (65535 & e) + (65535 & r);
                            return (e >> 16) + (r >> 16) + (n >> 16) << 16 | 65535 & n;
                        }
                    }
                ]), e;
            }();
            r.default = u;
        },
        function(e, r, n) {
            e.exports = n(0);
        }
    ]);
}); //# sourceMappingURL=sha1-es.min.js.map


/***/ }),

/***/ 6298:
/***/ ((module) => {

"use strict";

/*
  Based heavily on the Streaming Boyer-Moore-Horspool C++ implementation
  by Hongli Lai at: https://github.com/FooBarWidget/boyer-moore-horspool
*/ function memcmp(buf1, pos1, buf2, pos2, num) {
    for(let i = 0; i < num; ++i){
        if (buf1[pos1 + i] !== buf2[pos2 + i]) return false;
    }
    return true;
}
class SBMH {
    constructor(needle, cb){
        if (typeof cb !== "function") throw new Error("Missing match callback");
        if (typeof needle === "string") needle = Buffer.from(needle);
        else if (!Buffer.isBuffer(needle)) throw new Error(`Expected Buffer for needle, got ${typeof needle}`);
        const needleLen = needle.length;
        this.maxMatches = Infinity;
        this.matches = 0;
        this._cb = cb;
        this._lookbehindSize = 0;
        this._needle = needle;
        this._bufPos = 0;
        this._lookbehind = Buffer.allocUnsafe(needleLen);
        // Initialize occurrence table.
        this._occ = [
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen
        ];
        // Populate occurrence table with analysis of the needle, ignoring the last
        // letter.
        if (needleLen > 1) {
            for(let i = 0; i < needleLen - 1; ++i)this._occ[needle[i]] = needleLen - 1 - i;
        }
    }
    reset() {
        this.matches = 0;
        this._lookbehindSize = 0;
        this._bufPos = 0;
    }
    push(chunk, pos) {
        let result;
        if (!Buffer.isBuffer(chunk)) chunk = Buffer.from(chunk, "latin1");
        const chunkLen = chunk.length;
        this._bufPos = pos || 0;
        while(result !== chunkLen && this.matches < this.maxMatches)result = feed(this, chunk);
        return result;
    }
    destroy() {
        const lbSize = this._lookbehindSize;
        if (lbSize) this._cb(false, this._lookbehind, 0, lbSize, false);
        this.reset();
    }
}
function feed(self, data) {
    const len = data.length;
    const needle = self._needle;
    const needleLen = needle.length;
    // Positive: points to a position in `data`
    //           pos == 3 points to data[3]
    // Negative: points to a position in the lookbehind buffer
    //           pos == -2 points to lookbehind[lookbehindSize - 2]
    let pos = -self._lookbehindSize;
    const lastNeedleCharPos = needleLen - 1;
    const lastNeedleChar = needle[lastNeedleCharPos];
    const end = len - needleLen;
    const occ = self._occ;
    const lookbehind = self._lookbehind;
    if (pos < 0) {
        // Lookbehind buffer is not empty. Perform Boyer-Moore-Horspool
        // search with character lookup code that considers both the
        // lookbehind buffer and the current round's haystack data.
        //
        // Loop until
        //   there is a match.
        // or until
        //   we've moved past the position that requires the
        //   lookbehind buffer. In this case we switch to the
        //   optimized loop.
        // or until
        //   the character to look at lies outside the haystack.
        while(pos < 0 && pos <= end){
            const nextPos = pos + lastNeedleCharPos;
            const ch = nextPos < 0 ? lookbehind[self._lookbehindSize + nextPos] : data[nextPos];
            if (ch === lastNeedleChar && matchNeedle(self, data, pos, lastNeedleCharPos)) {
                self._lookbehindSize = 0;
                ++self.matches;
                if (pos > -self._lookbehindSize) self._cb(true, lookbehind, 0, self._lookbehindSize + pos, false);
                else self._cb(true, undefined, 0, 0, true);
                return self._bufPos = pos + needleLen;
            }
            pos += occ[ch];
        }
        // No match.
        // There's too few data for Boyer-Moore-Horspool to run,
        // so let's use a different algorithm to skip as much as
        // we can.
        // Forward pos until
        //   the trailing part of lookbehind + data
        //   looks like the beginning of the needle
        // or until
        //   pos == 0
        while(pos < 0 && !matchNeedle(self, data, pos, len - pos))++pos;
        if (pos < 0) {
            // Cut off part of the lookbehind buffer that has
            // been processed and append the entire haystack
            // into it.
            const bytesToCutOff = self._lookbehindSize + pos;
            if (bytesToCutOff > 0) {
                // The cut off data is guaranteed not to contain the needle.
                self._cb(false, lookbehind, 0, bytesToCutOff, false);
            }
            self._lookbehindSize -= bytesToCutOff;
            lookbehind.copy(lookbehind, 0, bytesToCutOff, self._lookbehindSize);
            lookbehind.set(data, self._lookbehindSize);
            self._lookbehindSize += len;
            self._bufPos = len;
            return len;
        }
        // Discard lookbehind buffer.
        self._cb(false, lookbehind, 0, self._lookbehindSize, false);
        self._lookbehindSize = 0;
    }
    pos += self._bufPos;
    const firstNeedleChar = needle[0];
    // Lookbehind buffer is now empty. Perform Boyer-Moore-Horspool
    // search with optimized character lookup code that only considers
    // the current round's haystack data.
    while(pos <= end){
        const ch = data[pos + lastNeedleCharPos];
        if (ch === lastNeedleChar && data[pos] === firstNeedleChar && memcmp(needle, 0, data, pos, lastNeedleCharPos)) {
            ++self.matches;
            if (pos > 0) self._cb(true, data, self._bufPos, pos, true);
            else self._cb(true, undefined, 0, 0, true);
            return self._bufPos = pos + needleLen;
        }
        pos += occ[ch];
    }
    // There was no match. If there's trailing haystack data that we cannot
    // match yet using the Boyer-Moore-Horspool algorithm (because the trailing
    // data is less than the needle size) then match using a modified
    // algorithm that starts matching from the beginning instead of the end.
    // Whatever trailing data is left after running this algorithm is added to
    // the lookbehind buffer.
    while(pos < len){
        if (data[pos] !== firstNeedleChar || !memcmp(data, pos, needle, 0, len - pos)) {
            ++pos;
            continue;
        }
        data.copy(lookbehind, 0, pos, len);
        self._lookbehindSize = len - pos;
        break;
    }
    // Everything until `pos` is guaranteed not to contain needle data.
    if (pos > 0) self._cb(false, data, self._bufPos, pos < len ? pos : len, true);
    self._bufPos = len;
    return len;
}
function matchNeedle(self, data, pos, len) {
    const lb = self._lookbehind;
    const lbSize = self._lookbehindSize;
    const needle = self._needle;
    for(let i = 0; i < len; ++i, ++pos){
        const ch = pos < 0 ? lb[lbSize + pos] : data[pos];
        if (ch !== needle[i]) return false;
    }
    return true;
}
module.exports = SBMH;


/***/ }),

/***/ 4479:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "__assign": () => (/* binding */ __assign),
/* harmony export */   "__asyncDelegator": () => (/* binding */ __asyncDelegator),
/* harmony export */   "__asyncGenerator": () => (/* binding */ __asyncGenerator),
/* harmony export */   "__asyncValues": () => (/* binding */ __asyncValues),
/* harmony export */   "__await": () => (/* binding */ __await),
/* harmony export */   "__awaiter": () => (/* binding */ __awaiter),
/* harmony export */   "__classPrivateFieldGet": () => (/* binding */ __classPrivateFieldGet),
/* harmony export */   "__classPrivateFieldIn": () => (/* binding */ __classPrivateFieldIn),
/* harmony export */   "__classPrivateFieldSet": () => (/* binding */ __classPrivateFieldSet),
/* harmony export */   "__createBinding": () => (/* binding */ __createBinding),
/* harmony export */   "__decorate": () => (/* binding */ __decorate),
/* harmony export */   "__esDecorate": () => (/* binding */ __esDecorate),
/* harmony export */   "__exportStar": () => (/* binding */ __exportStar),
/* harmony export */   "__extends": () => (/* binding */ __extends),
/* harmony export */   "__generator": () => (/* binding */ __generator),
/* harmony export */   "__importDefault": () => (/* binding */ __importDefault),
/* harmony export */   "__importStar": () => (/* binding */ __importStar),
/* harmony export */   "__makeTemplateObject": () => (/* binding */ __makeTemplateObject),
/* harmony export */   "__metadata": () => (/* binding */ __metadata),
/* harmony export */   "__param": () => (/* binding */ __param),
/* harmony export */   "__propKey": () => (/* binding */ __propKey),
/* harmony export */   "__read": () => (/* binding */ __read),
/* harmony export */   "__rest": () => (/* binding */ __rest),
/* harmony export */   "__runInitializers": () => (/* binding */ __runInitializers),
/* harmony export */   "__setFunctionName": () => (/* binding */ __setFunctionName),
/* harmony export */   "__spread": () => (/* binding */ __spread),
/* harmony export */   "__spreadArray": () => (/* binding */ __spreadArray),
/* harmony export */   "__spreadArrays": () => (/* binding */ __spreadArrays),
/* harmony export */   "__values": () => (/* binding */ __values)
/* harmony export */ });
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */ /* global Reflect, Promise */ var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || ({
        __proto__: []
    }) instanceof Array && function(d, b) {
        d.__proto__ = b;
    } || function(d, b) {
        for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };
    return extendStatics(d, b);
};
function __extends(d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
function __rest(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
}
function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) {
        if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
        return f;
    }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for(var i = decorators.length - 1; i >= 0; i--){
        var context = {};
        for(var p in contextIn)context[p] = p === "access" ? {} : contextIn[p];
        for(var p in contextIn.access)context.access[p] = contextIn.access[p];
        context.addInitializer = function(f) {
            if (done) throw new TypeError("Cannot add initializers after decoration has completed");
            extraInitializers.push(accept(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? {
            get: descriptor.get,
            set: descriptor.set
        } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.push(_);
        } else if (_ = accept(result)) {
            if (kind === "field") initializers.push(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
}
;
function __runInitializers(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for(var i = 0; i < initializers.length; i++){
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
}
;
function __propKey(x) {
    return typeof x === "symbol" ? x : "".concat(x);
}
;
function __setFunctionName(f, name, prefix) {
    if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
    return Object.defineProperty(f, "name", {
        configurable: true,
        value: prefix ? "".concat(prefix, " ", name) : name
    });
}
;
function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}
function __generator(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(g && (g = 0, op[0] && (_ = 0)), _)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
}
var __createBinding = Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
};
function __exportStar(m, o) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}
function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
}
/** @deprecated */ function __spread() {
    for(var ar = [], i = 0; i < arguments.length; i++)ar = ar.concat(__read(arguments[i]));
    return ar;
}
/** @deprecated */ function __spreadArrays() {
    for(var s = 0, i = 0, il = arguments.length; i < il; i++)s += arguments[i].length;
    for(var r = Array(s), k = 0, i = 0; i < il; i++)for(var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)r[k] = a[j];
    return r;
}
function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}
function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
    }, i;
    function verb(n) {
        if (g[n]) i[n] = function(v) {
            return new Promise(function(a, b) {
                q.push([
                    n,
                    v,
                    a,
                    b
                ]) > 1 || resume(n, v);
            });
        };
    }
    function resume(n, v) {
        try {
            step(g[n](v));
        } catch (e) {
            settle(q[0][3], e);
        }
    }
    function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
        resume("next", value);
    }
    function reject(value) {
        resume("throw", value);
    }
    function settle(f, v) {
        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
    }
}
function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function(e) {
        throw e;
    }), verb("return"), i[Symbol.iterator] = function() {
        return this;
    }, i;
    function verb(n, f) {
        i[n] = o[n] ? function(v) {
            return (p = !p) ? {
                value: __await(o[n](v)),
                done: false
            } : f ? f(v) : v;
        } : f;
    }
}
function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
    }, i);
    function verb(n) {
        i[n] = o[n] && function(v) {
            return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
        };
    }
    function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v) {
            resolve({
                value: v,
                done: d
            });
        }, reject);
    }
}
function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", {
            value: raw
        });
    } else {
        cooked.raw = raw;
    }
    return cooked;
}
;
var __setModuleDefault = Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
};
function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
}
function __importDefault(mod) {
    return mod && mod.__esModule ? mod : {
        default: mod
    };
}
function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldIn(state, receiver) {
    if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
    return typeof state === "function" ? receiver === state : state.has(receiver);
}


/***/ }),

/***/ 6303:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.ValueOrPromise = void 0;
function isPromiseLike(object) {
    return object != null && typeof object.then === "function";
}
const defaultOnRejectedFn = (reason)=>{
    throw reason;
};
class ValueOrPromise {
    constructor(executor){
        let value;
        try {
            value = executor();
        } catch (reason) {
            this.state = {
                status: "rejected",
                value: reason
            };
            return;
        }
        if (isPromiseLike(value)) {
            this.state = {
                status: "pending",
                value
            };
            return;
        }
        this.state = {
            status: "fulfilled",
            value
        };
    }
    then(onFulfilled, onRejected) {
        const state = this.state;
        if (state.status === "pending") {
            return new ValueOrPromise(()=>state.value.then(onFulfilled, onRejected));
        }
        const onRejectedFn = typeof onRejected === "function" ? onRejected : defaultOnRejectedFn;
        if (state.status === "rejected") {
            return new ValueOrPromise(()=>onRejectedFn(state.value));
        }
        try {
            const onFulfilledFn = typeof onFulfilled === "function" ? onFulfilled : undefined;
            return onFulfilledFn === undefined ? new ValueOrPromise(()=>state.value) : new ValueOrPromise(()=>onFulfilledFn(state.value));
        } catch (e) {
            return new ValueOrPromise(()=>onRejectedFn(e));
        }
    }
    catch(onRejected) {
        return this.then(undefined, onRejected);
    }
    resolve() {
        const state = this.state;
        if (state.status === "pending") {
            return Promise.resolve(state.value);
        }
        if (state.status === "rejected") {
            throw state.value;
        }
        return state.value;
    }
    static all(valueOrPromises) {
        let rejected = false;
        let reason;
        let containsPromise = false;
        const values = [];
        for (const valueOrPromise of valueOrPromises){
            const state = valueOrPromise.state;
            if (state.status === "rejected") {
                if (rejected) {
                    continue;
                }
                rejected = true;
                reason = state.value;
                continue;
            }
            if (state.status === "pending") {
                containsPromise = true;
            }
            values.push(state.value);
        }
        if (containsPromise) {
            if (rejected) {
                Promise.all(values).catch(()=>{
                // Ignore errors
                });
                return new ValueOrPromise(()=>{
                    throw reason;
                });
            }
            return new ValueOrPromise(()=>Promise.all(values));
        }
        return new ValueOrPromise(()=>values);
    }
}
exports.ValueOrPromise = ValueOrPromise; //# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVmFsdWVPclByb21pc2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvVmFsdWVPclByb21pc2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsU0FBUyxhQUFhLENBQUksTUFBZTtJQUN2QyxPQUFPLENBQ0wsTUFBTSxJQUFJLElBQUksSUFBSSxPQUFRLE1BQXlCLENBQUMsSUFBSSxLQUFLLFVBQVUsQ0FDeEUsQ0FBQztBQUNKLENBQUM7QUFtQkQsTUFBTSxtQkFBbUIsR0FBRyxDQUFDLE1BQWUsRUFBRSxFQUFFO0lBQzlDLE1BQU0sTUFBTSxDQUFDO0FBQ2YsQ0FBQyxDQUFDO0FBRUYsTUFBYSxjQUFjO0lBR3pCLFlBQVksUUFBa0M7UUFDNUMsSUFBSSxLQUF5QixDQUFDO1FBRTlCLElBQUk7WUFDRixLQUFLLEdBQUcsUUFBUSxFQUFFLENBQUM7U0FDcEI7UUFBQyxPQUFPLE1BQU0sRUFBRTtZQUNmLElBQUksQ0FBQyxLQUFLLEdBQUcsRUFBRSxNQUFNLEVBQUUsVUFBVSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsQ0FBQztZQUNuRCxPQUFPO1NBQ1I7UUFFRCxJQUFJLGFBQWEsQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUN4QixJQUFJLENBQUMsS0FBSyxHQUFHLEVBQUUsTUFBTSxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsQ0FBQztZQUMxQyxPQUFPO1NBQ1I7UUFFRCxJQUFJLENBQUMsS0FBSyxHQUFHLEVBQUUsTUFBTSxFQUFFLFdBQVcsRUFBRSxLQUFLLEVBQUUsQ0FBQztJQUM5QyxDQUFDO0lBRU0sSUFBSSxDQUNULFdBR1EsRUFDUixVQUdRO1FBRVIsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQztRQUV6QixJQUFJLEtBQUssQ0FBQyxNQUFNLEtBQUssU0FBUyxFQUFFO1lBQzlCLE9BQU8sSUFBSSxjQUFjLENBQUMsR0FBRyxFQUFFLENBQzdCLEtBQUssQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxVQUFVLENBQUMsQ0FDMUMsQ0FBQztTQUNIO1FBRUQsTUFBTSxZQUFZLEdBQ2hCLE9BQU8sVUFBVSxLQUFLLFVBQVUsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxtQkFBbUIsQ0FBQztRQUV0RSxJQUFJLEtBQUssQ0FBQyxNQUFNLEtBQUssVUFBVSxFQUFFO1lBQy9CLE9BQU8sSUFBSSxjQUFjLENBQUMsR0FBRyxFQUFFLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO1NBQzVEO1FBRUQsSUFBSTtZQUNGLE1BQU0sYUFBYSxHQUNqQixPQUFPLFdBQVcsS0FBSyxVQUFVLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDO1lBRTlELE9BQU8sYUFBYSxLQUFLLFNBQVM7Z0JBQ2hDLENBQUMsQ0FBQyxJQUFJLGNBQWMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxLQUFLLENBQUMsS0FBNEIsQ0FBQztnQkFDOUQsQ0FBQyxDQUFDLElBQUksY0FBYyxDQUFDLEdBQUcsRUFBRSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsS0FBVSxDQUFDLENBQUMsQ0FBQztTQUMvRDtRQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ1YsT0FBTyxJQUFJLGNBQWMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUNsRDtJQUNILENBQUM7SUFFTSxLQUFLLENBQ1YsVUFHUTtRQUVSLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsVUFBVSxDQUFDLENBQUM7SUFDMUMsQ0FBQztJQUVNLE9BQU87UUFDWixNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDO1FBRXpCLElBQUksS0FBSyxDQUFDLE1BQU0sS0FBSyxTQUFTLEVBQUU7WUFDOUIsT0FBTyxPQUFPLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUNyQztRQUVELElBQUksS0FBSyxDQUFDLE1BQU0sS0FBSyxVQUFVLEVBQUU7WUFDL0IsTUFBTSxLQUFLLENBQUMsS0FBSyxDQUFDO1NBQ25CO1FBRUQsT0FBTyxLQUFLLENBQUMsS0FBSyxDQUFDO0lBQ3JCLENBQUM7SUE0Rk0sTUFBTSxDQUFDLEdBQUcsQ0FDZixlQUFpRDtRQUVqRCxJQUFJLFFBQVEsR0FBRyxLQUFLLENBQUM7UUFDckIsSUFBSSxNQUFlLENBQUM7UUFDcEIsSUFBSSxlQUFlLEdBQUcsS0FBSyxDQUFDO1FBRTVCLE1BQU0sTUFBTSxHQUE4QixFQUFFLENBQUM7UUFDN0MsS0FBSyxNQUFNLGNBQWMsSUFBSSxlQUFlLEVBQUU7WUFDNUMsTUFBTSxLQUFLLEdBQUcsY0FBYyxDQUFDLEtBQUssQ0FBQztZQUVuQyxJQUFJLEtBQUssQ0FBQyxNQUFNLEtBQUssVUFBVSxFQUFFO2dCQUMvQixJQUFJLFFBQVEsRUFBRTtvQkFDWixTQUFTO2lCQUNWO2dCQUNELFFBQVEsR0FBRyxJQUFJLENBQUM7Z0JBQ2hCLE1BQU0sR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDO2dCQUNyQixTQUFTO2FBQ1Y7WUFFRCxJQUFJLEtBQUssQ0FBQyxNQUFNLEtBQUssU0FBUyxFQUFFO2dCQUM5QixlQUFlLEdBQUcsSUFBSSxDQUFDO2FBQ3hCO1lBRUQsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDMUI7UUFFRCxJQUFJLGVBQWUsRUFBRTtZQUNuQixJQUFJLFFBQVEsRUFBRTtnQkFDWixPQUFPLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUU7b0JBQzdCLGdCQUFnQjtnQkFDbEIsQ0FBQyxDQUFDLENBQUM7Z0JBRUgsT0FBTyxJQUFJLGNBQWMsQ0FBQyxHQUFHLEVBQUU7b0JBQzdCLE1BQU0sTUFBTSxDQUFDO2dCQUNmLENBQUMsQ0FBQyxDQUFDO2FBQ0o7WUFFRCxPQUFPLElBQUksY0FBYyxDQUFDLEdBQUcsRUFBRSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztTQUN0RDtRQUVELE9BQU8sSUFBSSxjQUFjLENBQUMsR0FBRyxFQUFFLENBQUMsTUFBa0IsQ0FBQyxDQUFDO0lBQ3RELENBQUM7Q0FDRjtBQXRORCx3Q0FzTkMifQ==


/***/ }),

/***/ 8323:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = (void 0) && (void 0).__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
__exportStar(__webpack_require__(6303), exports); //# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLG1EQUFpQyJ9


/***/ }),

/***/ 896:
/***/ (function(__unused_webpack_module, exports) {

/**
 * web-streams-polyfill v3.2.1
 */ (function(global1, factory) {
     true ? factory(exports) : 0;
})(this, function(exports1) {
    "use strict";
    /// <reference lib="es2015.symbol" />
    var SymbolPolyfill = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol : function(description) {
        return "Symbol(" + description + ")";
    };
    /// <reference lib="dom" />
    function noop() {
        return undefined;
    }
    function getGlobals() {
        if (typeof self !== "undefined") {
            return self;
        } else if (false) {} else if (typeof global !== "undefined") {
            return global;
        }
        return undefined;
    }
    var globals = getGlobals();
    function typeIsObject(x) {
        return typeof x === "object" && x !== null || typeof x === "function";
    }
    var rethrowAssertionErrorRejection = noop;
    var originalPromise = Promise;
    var originalPromiseThen = Promise.prototype.then;
    var originalPromiseResolve = Promise.resolve.bind(originalPromise);
    var originalPromiseReject = Promise.reject.bind(originalPromise);
    function newPromise(executor) {
        return new originalPromise(executor);
    }
    function promiseResolvedWith(value) {
        return originalPromiseResolve(value);
    }
    function promiseRejectedWith(reason) {
        return originalPromiseReject(reason);
    }
    function PerformPromiseThen(promise, onFulfilled, onRejected) {
        // There doesn't appear to be any way to correctly emulate the behaviour from JavaScript, so this is just an
        // approximation.
        return originalPromiseThen.call(promise, onFulfilled, onRejected);
    }
    function uponPromise(promise, onFulfilled, onRejected) {
        PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), undefined, rethrowAssertionErrorRejection);
    }
    function uponFulfillment(promise, onFulfilled) {
        uponPromise(promise, onFulfilled);
    }
    function uponRejection(promise, onRejected) {
        uponPromise(promise, undefined, onRejected);
    }
    function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {
        return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);
    }
    function setPromiseIsHandledToTrue(promise) {
        PerformPromiseThen(promise, undefined, rethrowAssertionErrorRejection);
    }
    var queueMicrotask = function() {
        var globalQueueMicrotask = globals && globals.queueMicrotask;
        if (typeof globalQueueMicrotask === "function") {
            return globalQueueMicrotask;
        }
        var resolvedPromise = promiseResolvedWith(undefined);
        return function(fn) {
            return PerformPromiseThen(resolvedPromise, fn);
        };
    }();
    function reflectCall(F, V, args) {
        if (typeof F !== "function") {
            throw new TypeError("Argument is not a function");
        }
        return Function.prototype.apply.call(F, V, args);
    }
    function promiseCall(F, V, args) {
        try {
            return promiseResolvedWith(reflectCall(F, V, args));
        } catch (value) {
            return promiseRejectedWith(value);
        }
    }
    // Original from Chromium
    // https://chromium.googlesource.com/chromium/src/+/0aee4434a4dba42a42abaea9bfbc0cd196a63bc1/third_party/blink/renderer/core/streams/SimpleQueue.js
    var QUEUE_MAX_ARRAY_SIZE = 16384;
    /**
     * Simple queue structure.
     *
     * Avoids scalability issues with using a packed array directly by using
     * multiple arrays in a linked list and keeping the array size bounded.
     */ var SimpleQueue = /** @class */ function() {
        function SimpleQueue() {
            this._cursor = 0;
            this._size = 0;
            // _front and _back are always defined.
            this._front = {
                _elements: [],
                _next: undefined
            };
            this._back = this._front;
            // The cursor is used to avoid calling Array.shift().
            // It contains the index of the front element of the array inside the
            // front-most node. It is always in the range [0, QUEUE_MAX_ARRAY_SIZE).
            this._cursor = 0;
            // When there is only one node, size === elements.length - cursor.
            this._size = 0;
        }
        Object.defineProperty(SimpleQueue.prototype, "length", {
            get: function() {
                return this._size;
            },
            enumerable: false,
            configurable: true
        });
        // For exception safety, this method is structured in order:
        // 1. Read state
        // 2. Calculate required state mutations
        // 3. Perform state mutations
        SimpleQueue.prototype.push = function(element) {
            var oldBack = this._back;
            var newBack = oldBack;
            if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {
                newBack = {
                    _elements: [],
                    _next: undefined
                };
            }
            // push() is the mutation most likely to throw an exception, so it
            // goes first.
            oldBack._elements.push(element);
            if (newBack !== oldBack) {
                this._back = newBack;
                oldBack._next = newBack;
            }
            ++this._size;
        };
        // Like push(), shift() follows the read -> calculate -> mutate pattern for
        // exception safety.
        SimpleQueue.prototype.shift = function() {
            var oldFront = this._front;
            var newFront = oldFront;
            var oldCursor = this._cursor;
            var newCursor = oldCursor + 1;
            var elements = oldFront._elements;
            var element = elements[oldCursor];
            if (newCursor === QUEUE_MAX_ARRAY_SIZE) {
                newFront = oldFront._next;
                newCursor = 0;
            }
            // No mutations before this point.
            --this._size;
            this._cursor = newCursor;
            if (oldFront !== newFront) {
                this._front = newFront;
            }
            // Permit shifted element to be garbage collected.
            elements[oldCursor] = undefined;
            return element;
        };
        // The tricky thing about forEach() is that it can be called
        // re-entrantly. The queue may be mutated inside the callback. It is easy to
        // see that push() within the callback has no negative effects since the end
        // of the queue is checked for on every iteration. If shift() is called
        // repeatedly within the callback then the next iteration may return an
        // element that has been removed. In this case the callback will be called
        // with undefined values until we either "catch up" with elements that still
        // exist or reach the back of the queue.
        SimpleQueue.prototype.forEach = function(callback) {
            var i = this._cursor;
            var node = this._front;
            var elements = node._elements;
            while(i !== elements.length || node._next !== undefined){
                if (i === elements.length) {
                    node = node._next;
                    elements = node._elements;
                    i = 0;
                    if (elements.length === 0) {
                        break;
                    }
                }
                callback(elements[i]);
                ++i;
            }
        };
        // Return the element that would be returned if shift() was called now,
        // without modifying the queue.
        SimpleQueue.prototype.peek = function() {
            var front = this._front;
            var cursor = this._cursor;
            return front._elements[cursor];
        };
        return SimpleQueue;
    }();
    function ReadableStreamReaderGenericInitialize(reader, stream) {
        reader._ownerReadableStream = stream;
        stream._reader = reader;
        if (stream._state === "readable") {
            defaultReaderClosedPromiseInitialize(reader);
        } else if (stream._state === "closed") {
            defaultReaderClosedPromiseInitializeAsResolved(reader);
        } else {
            defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);
        }
    }
    // A client of ReadableStreamDefaultReader and ReadableStreamBYOBReader may use these functions directly to bypass state
    // check.
    function ReadableStreamReaderGenericCancel(reader, reason) {
        var stream = reader._ownerReadableStream;
        return ReadableStreamCancel(stream, reason);
    }
    function ReadableStreamReaderGenericRelease(reader) {
        if (reader._ownerReadableStream._state === "readable") {
            defaultReaderClosedPromiseReject(reader, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness"));
        } else {
            defaultReaderClosedPromiseResetToRejected(reader, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness"));
        }
        reader._ownerReadableStream._reader = undefined;
        reader._ownerReadableStream = undefined;
    }
    // Helper functions for the readers.
    function readerLockException(name) {
        return new TypeError("Cannot " + name + " a stream using a released reader");
    }
    // Helper functions for the ReadableStreamDefaultReader.
    function defaultReaderClosedPromiseInitialize(reader) {
        reader._closedPromise = newPromise(function(resolve, reject) {
            reader._closedPromise_resolve = resolve;
            reader._closedPromise_reject = reject;
        });
    }
    function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {
        defaultReaderClosedPromiseInitialize(reader);
        defaultReaderClosedPromiseReject(reader, reason);
    }
    function defaultReaderClosedPromiseInitializeAsResolved(reader) {
        defaultReaderClosedPromiseInitialize(reader);
        defaultReaderClosedPromiseResolve(reader);
    }
    function defaultReaderClosedPromiseReject(reader, reason) {
        if (reader._closedPromise_reject === undefined) {
            return;
        }
        setPromiseIsHandledToTrue(reader._closedPromise);
        reader._closedPromise_reject(reason);
        reader._closedPromise_resolve = undefined;
        reader._closedPromise_reject = undefined;
    }
    function defaultReaderClosedPromiseResetToRejected(reader, reason) {
        defaultReaderClosedPromiseInitializeAsRejected(reader, reason);
    }
    function defaultReaderClosedPromiseResolve(reader) {
        if (reader._closedPromise_resolve === undefined) {
            return;
        }
        reader._closedPromise_resolve(undefined);
        reader._closedPromise_resolve = undefined;
        reader._closedPromise_reject = undefined;
    }
    var AbortSteps = SymbolPolyfill("[[AbortSteps]]");
    var ErrorSteps = SymbolPolyfill("[[ErrorSteps]]");
    var CancelSteps = SymbolPolyfill("[[CancelSteps]]");
    var PullSteps = SymbolPolyfill("[[PullSteps]]");
    /// <reference lib="es2015.core" />
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isFinite#Polyfill
    var NumberIsFinite = Number.isFinite || function(x) {
        return typeof x === "number" && isFinite(x);
    };
    /// <reference lib="es2015.core" />
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc#Polyfill
    var MathTrunc = Math.trunc || function(v) {
        return v < 0 ? Math.ceil(v) : Math.floor(v);
    };
    // https://heycam.github.io/webidl/#idl-dictionaries
    function isDictionary(x) {
        return typeof x === "object" || typeof x === "function";
    }
    function assertDictionary(obj, context) {
        if (obj !== undefined && !isDictionary(obj)) {
            throw new TypeError(context + " is not an object.");
        }
    }
    // https://heycam.github.io/webidl/#idl-callback-functions
    function assertFunction(x, context) {
        if (typeof x !== "function") {
            throw new TypeError(context + " is not a function.");
        }
    }
    // https://heycam.github.io/webidl/#idl-object
    function isObject(x) {
        return typeof x === "object" && x !== null || typeof x === "function";
    }
    function assertObject(x, context) {
        if (!isObject(x)) {
            throw new TypeError(context + " is not an object.");
        }
    }
    function assertRequiredArgument(x, position, context) {
        if (x === undefined) {
            throw new TypeError("Parameter " + position + " is required in '" + context + "'.");
        }
    }
    function assertRequiredField(x, field, context) {
        if (x === undefined) {
            throw new TypeError(field + " is required in '" + context + "'.");
        }
    }
    // https://heycam.github.io/webidl/#idl-unrestricted-double
    function convertUnrestrictedDouble(value) {
        return Number(value);
    }
    function censorNegativeZero(x) {
        return x === 0 ? 0 : x;
    }
    function integerPart(x) {
        return censorNegativeZero(MathTrunc(x));
    }
    // https://heycam.github.io/webidl/#idl-unsigned-long-long
    function convertUnsignedLongLongWithEnforceRange(value, context) {
        var lowerBound = 0;
        var upperBound = Number.MAX_SAFE_INTEGER;
        var x = Number(value);
        x = censorNegativeZero(x);
        if (!NumberIsFinite(x)) {
            throw new TypeError(context + " is not a finite number");
        }
        x = integerPart(x);
        if (x < lowerBound || x > upperBound) {
            throw new TypeError(context + " is outside the accepted range of " + lowerBound + " to " + upperBound + ", inclusive");
        }
        if (!NumberIsFinite(x) || x === 0) {
            return 0;
        }
        // TODO Use BigInt if supported?
        // let xBigInt = BigInt(integerPart(x));
        // xBigInt = BigInt.asUintN(64, xBigInt);
        // return Number(xBigInt);
        return x;
    }
    function assertReadableStream(x, context) {
        if (!IsReadableStream(x)) {
            throw new TypeError(context + " is not a ReadableStream.");
        }
    }
    // Abstract operations for the ReadableStream.
    function AcquireReadableStreamDefaultReader(stream) {
        return new ReadableStreamDefaultReader(stream);
    }
    // ReadableStream API exposed for controllers.
    function ReadableStreamAddReadRequest(stream, readRequest) {
        stream._reader._readRequests.push(readRequest);
    }
    function ReadableStreamFulfillReadRequest(stream, chunk, done) {
        var reader = stream._reader;
        var readRequest = reader._readRequests.shift();
        if (done) {
            readRequest._closeSteps();
        } else {
            readRequest._chunkSteps(chunk);
        }
    }
    function ReadableStreamGetNumReadRequests(stream) {
        return stream._reader._readRequests.length;
    }
    function ReadableStreamHasDefaultReader(stream) {
        var reader = stream._reader;
        if (reader === undefined) {
            return false;
        }
        if (!IsReadableStreamDefaultReader(reader)) {
            return false;
        }
        return true;
    }
    /**
     * A default reader vended by a {@link ReadableStream}.
     *
     * @public
     */ var ReadableStreamDefaultReader = /** @class */ function() {
        function ReadableStreamDefaultReader(stream) {
            assertRequiredArgument(stream, 1, "ReadableStreamDefaultReader");
            assertReadableStream(stream, "First parameter");
            if (IsReadableStreamLocked(stream)) {
                throw new TypeError("This stream has already been locked for exclusive reading by another reader");
            }
            ReadableStreamReaderGenericInitialize(this, stream);
            this._readRequests = new SimpleQueue();
        }
        Object.defineProperty(ReadableStreamDefaultReader.prototype, "closed", {
            /**
             * Returns a promise that will be fulfilled when the stream becomes closed,
             * or rejected if the stream ever errors or the reader's lock is released before the stream finishes closing.
             */ get: function() {
                if (!IsReadableStreamDefaultReader(this)) {
                    return promiseRejectedWith(defaultReaderBrandCheckException("closed"));
                }
                return this._closedPromise;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.
         */ ReadableStreamDefaultReader.prototype.cancel = function(reason) {
            if (reason === void 0) {
                reason = undefined;
            }
            if (!IsReadableStreamDefaultReader(this)) {
                return promiseRejectedWith(defaultReaderBrandCheckException("cancel"));
            }
            if (this._ownerReadableStream === undefined) {
                return promiseRejectedWith(readerLockException("cancel"));
            }
            return ReadableStreamReaderGenericCancel(this, reason);
        };
        /**
         * Returns a promise that allows access to the next chunk from the stream's internal queue, if available.
         *
         * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.
         */ ReadableStreamDefaultReader.prototype.read = function() {
            if (!IsReadableStreamDefaultReader(this)) {
                return promiseRejectedWith(defaultReaderBrandCheckException("read"));
            }
            if (this._ownerReadableStream === undefined) {
                return promiseRejectedWith(readerLockException("read from"));
            }
            var resolvePromise;
            var rejectPromise;
            var promise = newPromise(function(resolve, reject) {
                resolvePromise = resolve;
                rejectPromise = reject;
            });
            var readRequest = {
                _chunkSteps: function(chunk) {
                    return resolvePromise({
                        value: chunk,
                        done: false
                    });
                },
                _closeSteps: function() {
                    return resolvePromise({
                        value: undefined,
                        done: true
                    });
                },
                _errorSteps: function(e) {
                    return rejectPromise(e);
                }
            };
            ReadableStreamDefaultReaderRead(this, readRequest);
            return promise;
        };
        /**
         * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.
         * If the associated stream is errored when the lock is released, the reader will appear errored in the same way
         * from now on; otherwise, the reader will appear closed.
         *
         * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by
         * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to
         * do so will throw a `TypeError` and leave the reader locked to the stream.
         */ ReadableStreamDefaultReader.prototype.releaseLock = function() {
            if (!IsReadableStreamDefaultReader(this)) {
                throw defaultReaderBrandCheckException("releaseLock");
            }
            if (this._ownerReadableStream === undefined) {
                return;
            }
            if (this._readRequests.length > 0) {
                throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
            }
            ReadableStreamReaderGenericRelease(this);
        };
        return ReadableStreamDefaultReader;
    }();
    Object.defineProperties(ReadableStreamDefaultReader.prototype, {
        cancel: {
            enumerable: true
        },
        read: {
            enumerable: true
        },
        releaseLock: {
            enumerable: true
        },
        closed: {
            enumerable: true
        }
    });
    if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ReadableStreamDefaultReader.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamDefaultReader",
            configurable: true
        });
    }
    // Abstract operations for the readers.
    function IsReadableStreamDefaultReader(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_readRequests")) {
            return false;
        }
        return x instanceof ReadableStreamDefaultReader;
    }
    function ReadableStreamDefaultReaderRead(reader, readRequest) {
        var stream = reader._ownerReadableStream;
        stream._disturbed = true;
        if (stream._state === "closed") {
            readRequest._closeSteps();
        } else if (stream._state === "errored") {
            readRequest._errorSteps(stream._storedError);
        } else {
            stream._readableStreamController[PullSteps](readRequest);
        }
    }
    // Helper functions for the ReadableStreamDefaultReader.
    function defaultReaderBrandCheckException(name) {
        return new TypeError("ReadableStreamDefaultReader.prototype." + name + " can only be used on a ReadableStreamDefaultReader");
    }
    /// <reference lib="es2018.asynciterable" />
    var _a;
    var AsyncIteratorPrototype;
    if (typeof SymbolPolyfill.asyncIterator === "symbol") {
        // We're running inside a ES2018+ environment, but we're compiling to an older syntax.
        // We cannot access %AsyncIteratorPrototype% without non-ES2018 syntax, but we can re-create it.
        AsyncIteratorPrototype = (_a = {}, // 25.1.3.1 %AsyncIteratorPrototype% [ @@asyncIterator ] ( )
        // https://tc39.github.io/ecma262/#sec-asynciteratorprototype-asynciterator
        _a[SymbolPolyfill.asyncIterator] = function() {
            return this;
        }, _a);
        Object.defineProperty(AsyncIteratorPrototype, SymbolPolyfill.asyncIterator, {
            enumerable: false
        });
    }
    /// <reference lib="es2018.asynciterable" />
    var ReadableStreamAsyncIteratorImpl = /** @class */ function() {
        function ReadableStreamAsyncIteratorImpl(reader, preventCancel) {
            this._ongoingPromise = undefined;
            this._isFinished = false;
            this._reader = reader;
            this._preventCancel = preventCancel;
        }
        ReadableStreamAsyncIteratorImpl.prototype.next = function() {
            var _this = this;
            var nextSteps = function() {
                return _this._nextSteps();
            };
            this._ongoingPromise = this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) : nextSteps();
            return this._ongoingPromise;
        };
        ReadableStreamAsyncIteratorImpl.prototype.return = function(value) {
            var _this = this;
            var returnSteps = function() {
                return _this._returnSteps(value);
            };
            return this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) : returnSteps();
        };
        ReadableStreamAsyncIteratorImpl.prototype._nextSteps = function() {
            var _this = this;
            if (this._isFinished) {
                return Promise.resolve({
                    value: undefined,
                    done: true
                });
            }
            var reader = this._reader;
            if (reader._ownerReadableStream === undefined) {
                return promiseRejectedWith(readerLockException("iterate"));
            }
            var resolvePromise;
            var rejectPromise;
            var promise = newPromise(function(resolve, reject) {
                resolvePromise = resolve;
                rejectPromise = reject;
            });
            var readRequest = {
                _chunkSteps: function(chunk) {
                    _this._ongoingPromise = undefined;
                    // This needs to be delayed by one microtask, otherwise we stop pulling too early which breaks a test.
                    // FIXME Is this a bug in the specification, or in the test?
                    queueMicrotask(function() {
                        return resolvePromise({
                            value: chunk,
                            done: false
                        });
                    });
                },
                _closeSteps: function() {
                    _this._ongoingPromise = undefined;
                    _this._isFinished = true;
                    ReadableStreamReaderGenericRelease(reader);
                    resolvePromise({
                        value: undefined,
                        done: true
                    });
                },
                _errorSteps: function(reason) {
                    _this._ongoingPromise = undefined;
                    _this._isFinished = true;
                    ReadableStreamReaderGenericRelease(reader);
                    rejectPromise(reason);
                }
            };
            ReadableStreamDefaultReaderRead(reader, readRequest);
            return promise;
        };
        ReadableStreamAsyncIteratorImpl.prototype._returnSteps = function(value) {
            if (this._isFinished) {
                return Promise.resolve({
                    value: value,
                    done: true
                });
            }
            this._isFinished = true;
            var reader = this._reader;
            if (reader._ownerReadableStream === undefined) {
                return promiseRejectedWith(readerLockException("finish iterating"));
            }
            if (!this._preventCancel) {
                var result = ReadableStreamReaderGenericCancel(reader, value);
                ReadableStreamReaderGenericRelease(reader);
                return transformPromiseWith(result, function() {
                    return {
                        value: value,
                        done: true
                    };
                });
            }
            ReadableStreamReaderGenericRelease(reader);
            return promiseResolvedWith({
                value: value,
                done: true
            });
        };
        return ReadableStreamAsyncIteratorImpl;
    }();
    var ReadableStreamAsyncIteratorPrototype = {
        next: function() {
            if (!IsReadableStreamAsyncIterator(this)) {
                return promiseRejectedWith(streamAsyncIteratorBrandCheckException("next"));
            }
            return this._asyncIteratorImpl.next();
        },
        return: function(value) {
            if (!IsReadableStreamAsyncIterator(this)) {
                return promiseRejectedWith(streamAsyncIteratorBrandCheckException("return"));
            }
            return this._asyncIteratorImpl.return(value);
        }
    };
    if (AsyncIteratorPrototype !== undefined) {
        Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);
    }
    // Abstract operations for the ReadableStream.
    function AcquireReadableStreamAsyncIterator(stream, preventCancel) {
        var reader = AcquireReadableStreamDefaultReader(stream);
        var impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);
        var iterator = Object.create(ReadableStreamAsyncIteratorPrototype);
        iterator._asyncIteratorImpl = impl;
        return iterator;
    }
    function IsReadableStreamAsyncIterator(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_asyncIteratorImpl")) {
            return false;
        }
        try {
            // noinspection SuspiciousTypeOfGuard
            return x._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl;
        } catch (_a) {
            return false;
        }
    }
    // Helper functions for the ReadableStream.
    function streamAsyncIteratorBrandCheckException(name) {
        return new TypeError("ReadableStreamAsyncIterator." + name + " can only be used on a ReadableSteamAsyncIterator");
    }
    /// <reference lib="es2015.core" />
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN#Polyfill
    var NumberIsNaN = Number.isNaN || function(x) {
        // eslint-disable-next-line no-self-compare
        return x !== x;
    };
    function CreateArrayFromList(elements) {
        // We use arrays to represent lists, so this is basically a no-op.
        // Do a slice though just in case we happen to depend on the unique-ness.
        return elements.slice();
    }
    function CopyDataBlockBytes(dest, destOffset, src, srcOffset, n) {
        new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);
    }
    // Not implemented correctly
    function TransferArrayBuffer(O) {
        return O;
    }
    // Not implemented correctly
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    function IsDetachedBuffer(O) {
        return false;
    }
    function ArrayBufferSlice(buffer, begin, end) {
        // ArrayBuffer.prototype.slice is not available on IE10
        // https://www.caniuse.com/mdn-javascript_builtins_arraybuffer_slice
        if (buffer.slice) {
            return buffer.slice(begin, end);
        }
        var length = end - begin;
        var slice = new ArrayBuffer(length);
        CopyDataBlockBytes(slice, 0, buffer, begin, length);
        return slice;
    }
    function IsNonNegativeNumber(v) {
        if (typeof v !== "number") {
            return false;
        }
        if (NumberIsNaN(v)) {
            return false;
        }
        if (v < 0) {
            return false;
        }
        return true;
    }
    function CloneAsUint8Array(O) {
        var buffer = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);
        return new Uint8Array(buffer);
    }
    function DequeueValue(container) {
        var pair = container._queue.shift();
        container._queueTotalSize -= pair.size;
        if (container._queueTotalSize < 0) {
            container._queueTotalSize = 0;
        }
        return pair.value;
    }
    function EnqueueValueWithSize(container, value, size) {
        if (!IsNonNegativeNumber(size) || size === Infinity) {
            throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
        }
        container._queue.push({
            value: value,
            size: size
        });
        container._queueTotalSize += size;
    }
    function PeekQueueValue(container) {
        var pair = container._queue.peek();
        return pair.value;
    }
    function ResetQueue(container) {
        container._queue = new SimpleQueue();
        container._queueTotalSize = 0;
    }
    /**
     * A pull-into request in a {@link ReadableByteStreamController}.
     *
     * @public
     */ var ReadableStreamBYOBRequest = /** @class */ function() {
        function ReadableStreamBYOBRequest() {
            throw new TypeError("Illegal constructor");
        }
        Object.defineProperty(ReadableStreamBYOBRequest.prototype, "view", {
            /**
             * Returns the view for writing in to, or `null` if the BYOB request has already been responded to.
             */ get: function() {
                if (!IsReadableStreamBYOBRequest(this)) {
                    throw byobRequestBrandCheckException("view");
                }
                return this._view;
            },
            enumerable: false,
            configurable: true
        });
        ReadableStreamBYOBRequest.prototype.respond = function(bytesWritten) {
            if (!IsReadableStreamBYOBRequest(this)) {
                throw byobRequestBrandCheckException("respond");
            }
            assertRequiredArgument(bytesWritten, 1, "respond");
            bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, "First parameter");
            if (this._associatedReadableByteStreamController === undefined) {
                throw new TypeError("This BYOB request has been invalidated");
            }
            if (IsDetachedBuffer(this._view.buffer)) ;
            ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);
        };
        ReadableStreamBYOBRequest.prototype.respondWithNewView = function(view) {
            if (!IsReadableStreamBYOBRequest(this)) {
                throw byobRequestBrandCheckException("respondWithNewView");
            }
            assertRequiredArgument(view, 1, "respondWithNewView");
            if (!ArrayBuffer.isView(view)) {
                throw new TypeError("You can only respond with array buffer views");
            }
            if (this._associatedReadableByteStreamController === undefined) {
                throw new TypeError("This BYOB request has been invalidated");
            }
            if (IsDetachedBuffer(view.buffer)) ;
            ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);
        };
        return ReadableStreamBYOBRequest;
    }();
    Object.defineProperties(ReadableStreamBYOBRequest.prototype, {
        respond: {
            enumerable: true
        },
        respondWithNewView: {
            enumerable: true
        },
        view: {
            enumerable: true
        }
    });
    if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ReadableStreamBYOBRequest.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamBYOBRequest",
            configurable: true
        });
    }
    /**
     * Allows control of a {@link ReadableStream | readable byte stream}'s state and internal queue.
     *
     * @public
     */ var ReadableByteStreamController = /** @class */ function() {
        function ReadableByteStreamController() {
            throw new TypeError("Illegal constructor");
        }
        Object.defineProperty(ReadableByteStreamController.prototype, "byobRequest", {
            /**
             * Returns the current BYOB pull request, or `null` if there isn't one.
             */ get: function() {
                if (!IsReadableByteStreamController(this)) {
                    throw byteStreamControllerBrandCheckException("byobRequest");
                }
                return ReadableByteStreamControllerGetBYOBRequest(this);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ReadableByteStreamController.prototype, "desiredSize", {
            /**
             * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is
             * over-full. An underlying byte source ought to use this information to determine when and how to apply backpressure.
             */ get: function() {
                if (!IsReadableByteStreamController(this)) {
                    throw byteStreamControllerBrandCheckException("desiredSize");
                }
                return ReadableByteStreamControllerGetDesiredSize(this);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from
         * the stream, but once those are read, the stream will become closed.
         */ ReadableByteStreamController.prototype.close = function() {
            if (!IsReadableByteStreamController(this)) {
                throw byteStreamControllerBrandCheckException("close");
            }
            if (this._closeRequested) {
                throw new TypeError("The stream has already been closed; do not close it again!");
            }
            var state = this._controlledReadableByteStream._state;
            if (state !== "readable") {
                throw new TypeError("The stream (in " + state + " state) is not in the readable state and cannot be closed");
            }
            ReadableByteStreamControllerClose(this);
        };
        ReadableByteStreamController.prototype.enqueue = function(chunk) {
            if (!IsReadableByteStreamController(this)) {
                throw byteStreamControllerBrandCheckException("enqueue");
            }
            assertRequiredArgument(chunk, 1, "enqueue");
            if (!ArrayBuffer.isView(chunk)) {
                throw new TypeError("chunk must be an array buffer view");
            }
            if (chunk.byteLength === 0) {
                throw new TypeError("chunk must have non-zero byteLength");
            }
            if (chunk.buffer.byteLength === 0) {
                throw new TypeError("chunk's buffer must have non-zero byteLength");
            }
            if (this._closeRequested) {
                throw new TypeError("stream is closed or draining");
            }
            var state = this._controlledReadableByteStream._state;
            if (state !== "readable") {
                throw new TypeError("The stream (in " + state + " state) is not in the readable state and cannot be enqueued to");
            }
            ReadableByteStreamControllerEnqueue(this, chunk);
        };
        /**
         * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.
         */ ReadableByteStreamController.prototype.error = function(e) {
            if (e === void 0) {
                e = undefined;
            }
            if (!IsReadableByteStreamController(this)) {
                throw byteStreamControllerBrandCheckException("error");
            }
            ReadableByteStreamControllerError(this, e);
        };
        /** @internal */ ReadableByteStreamController.prototype[CancelSteps] = function(reason) {
            ReadableByteStreamControllerClearPendingPullIntos(this);
            ResetQueue(this);
            var result = this._cancelAlgorithm(reason);
            ReadableByteStreamControllerClearAlgorithms(this);
            return result;
        };
        /** @internal */ ReadableByteStreamController.prototype[PullSteps] = function(readRequest) {
            var stream = this._controlledReadableByteStream;
            if (this._queueTotalSize > 0) {
                var entry = this._queue.shift();
                this._queueTotalSize -= entry.byteLength;
                ReadableByteStreamControllerHandleQueueDrain(this);
                var view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);
                readRequest._chunkSteps(view);
                return;
            }
            var autoAllocateChunkSize = this._autoAllocateChunkSize;
            if (autoAllocateChunkSize !== undefined) {
                var buffer = void 0;
                try {
                    buffer = new ArrayBuffer(autoAllocateChunkSize);
                } catch (bufferE) {
                    readRequest._errorSteps(bufferE);
                    return;
                }
                var pullIntoDescriptor = {
                    buffer: buffer,
                    bufferByteLength: autoAllocateChunkSize,
                    byteOffset: 0,
                    byteLength: autoAllocateChunkSize,
                    bytesFilled: 0,
                    elementSize: 1,
                    viewConstructor: Uint8Array,
                    readerType: "default"
                };
                this._pendingPullIntos.push(pullIntoDescriptor);
            }
            ReadableStreamAddReadRequest(stream, readRequest);
            ReadableByteStreamControllerCallPullIfNeeded(this);
        };
        return ReadableByteStreamController;
    }();
    Object.defineProperties(ReadableByteStreamController.prototype, {
        close: {
            enumerable: true
        },
        enqueue: {
            enumerable: true
        },
        error: {
            enumerable: true
        },
        byobRequest: {
            enumerable: true
        },
        desiredSize: {
            enumerable: true
        }
    });
    if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ReadableByteStreamController.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableByteStreamController",
            configurable: true
        });
    }
    // Abstract operations for the ReadableByteStreamController.
    function IsReadableByteStreamController(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_controlledReadableByteStream")) {
            return false;
        }
        return x instanceof ReadableByteStreamController;
    }
    function IsReadableStreamBYOBRequest(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_associatedReadableByteStreamController")) {
            return false;
        }
        return x instanceof ReadableStreamBYOBRequest;
    }
    function ReadableByteStreamControllerCallPullIfNeeded(controller) {
        var shouldPull = ReadableByteStreamControllerShouldCallPull(controller);
        if (!shouldPull) {
            return;
        }
        if (controller._pulling) {
            controller._pullAgain = true;
            return;
        }
        controller._pulling = true;
        // TODO: Test controller argument
        var pullPromise = controller._pullAlgorithm();
        uponPromise(pullPromise, function() {
            controller._pulling = false;
            if (controller._pullAgain) {
                controller._pullAgain = false;
                ReadableByteStreamControllerCallPullIfNeeded(controller);
            }
        }, function(e) {
            ReadableByteStreamControllerError(controller, e);
        });
    }
    function ReadableByteStreamControllerClearPendingPullIntos(controller) {
        ReadableByteStreamControllerInvalidateBYOBRequest(controller);
        controller._pendingPullIntos = new SimpleQueue();
    }
    function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {
        var done = false;
        if (stream._state === "closed") {
            done = true;
        }
        var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
        if (pullIntoDescriptor.readerType === "default") {
            ReadableStreamFulfillReadRequest(stream, filledView, done);
        } else {
            ReadableStreamFulfillReadIntoRequest(stream, filledView, done);
        }
    }
    function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
        var bytesFilled = pullIntoDescriptor.bytesFilled;
        var elementSize = pullIntoDescriptor.elementSize;
        return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
    }
    function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {
        controller._queue.push({
            buffer: buffer,
            byteOffset: byteOffset,
            byteLength: byteLength
        });
        controller._queueTotalSize += byteLength;
    }
    function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
        var elementSize = pullIntoDescriptor.elementSize;
        var currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;
        var maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);
        var maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;
        var maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;
        var totalBytesToCopyRemaining = maxBytesToCopy;
        var ready = false;
        if (maxAlignedBytes > currentAlignedBytes) {
            totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;
            ready = true;
        }
        var queue = controller._queue;
        while(totalBytesToCopyRemaining > 0){
            var headOfQueue = queue.peek();
            var bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);
            var destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
            CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);
            if (headOfQueue.byteLength === bytesToCopy) {
                queue.shift();
            } else {
                headOfQueue.byteOffset += bytesToCopy;
                headOfQueue.byteLength -= bytesToCopy;
            }
            controller._queueTotalSize -= bytesToCopy;
            ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);
            totalBytesToCopyRemaining -= bytesToCopy;
        }
        return ready;
    }
    function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {
        pullIntoDescriptor.bytesFilled += size;
    }
    function ReadableByteStreamControllerHandleQueueDrain(controller) {
        if (controller._queueTotalSize === 0 && controller._closeRequested) {
            ReadableByteStreamControllerClearAlgorithms(controller);
            ReadableStreamClose(controller._controlledReadableByteStream);
        } else {
            ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
    }
    function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
        if (controller._byobRequest === null) {
            return;
        }
        controller._byobRequest._associatedReadableByteStreamController = undefined;
        controller._byobRequest._view = null;
        controller._byobRequest = null;
    }
    function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
        while(controller._pendingPullIntos.length > 0){
            if (controller._queueTotalSize === 0) {
                return;
            }
            var pullIntoDescriptor = controller._pendingPullIntos.peek();
            if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
                ReadableByteStreamControllerShiftPendingPullInto(controller);
                ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
            }
        }
    }
    function ReadableByteStreamControllerPullInto(controller, view, readIntoRequest) {
        var stream = controller._controlledReadableByteStream;
        var elementSize = 1;
        if (view.constructor !== DataView) {
            elementSize = view.constructor.BYTES_PER_ELEMENT;
        }
        var ctor = view.constructor;
        // try {
        var buffer = TransferArrayBuffer(view.buffer);
        // } catch (e) {
        //   readIntoRequest._errorSteps(e);
        //   return;
        // }
        var pullIntoDescriptor = {
            buffer: buffer,
            bufferByteLength: buffer.byteLength,
            byteOffset: view.byteOffset,
            byteLength: view.byteLength,
            bytesFilled: 0,
            elementSize: elementSize,
            viewConstructor: ctor,
            readerType: "byob"
        };
        if (controller._pendingPullIntos.length > 0) {
            controller._pendingPullIntos.push(pullIntoDescriptor);
            // No ReadableByteStreamControllerCallPullIfNeeded() call since:
            // - No change happens on desiredSize
            // - The source has already been notified of that there's at least 1 pending read(view)
            ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
            return;
        }
        if (stream._state === "closed") {
            var emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);
            readIntoRequest._closeSteps(emptyView);
            return;
        }
        if (controller._queueTotalSize > 0) {
            if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
                var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
                ReadableByteStreamControllerHandleQueueDrain(controller);
                readIntoRequest._chunkSteps(filledView);
                return;
            }
            if (controller._closeRequested) {
                var e = new TypeError("Insufficient bytes to fill elements in the given buffer");
                ReadableByteStreamControllerError(controller, e);
                readIntoRequest._errorSteps(e);
                return;
            }
        }
        controller._pendingPullIntos.push(pullIntoDescriptor);
        ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
        ReadableByteStreamControllerCallPullIfNeeded(controller);
    }
    function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
        var stream = controller._controlledReadableByteStream;
        if (ReadableStreamHasBYOBReader(stream)) {
            while(ReadableStreamGetNumReadIntoRequests(stream) > 0){
                var pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);
                ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);
            }
        }
    }
    function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {
        ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);
        if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {
            return;
        }
        ReadableByteStreamControllerShiftPendingPullInto(controller);
        var remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
        if (remainderSize > 0) {
            var end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
            var remainder = ArrayBufferSlice(pullIntoDescriptor.buffer, end - remainderSize, end);
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);
        }
        pullIntoDescriptor.bytesFilled -= remainderSize;
        ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
        ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
    }
    function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
        var firstDescriptor = controller._pendingPullIntos.peek();
        ReadableByteStreamControllerInvalidateBYOBRequest(controller);
        var state = controller._controlledReadableByteStream._state;
        if (state === "closed") {
            ReadableByteStreamControllerRespondInClosedState(controller);
        } else {
            ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);
        }
        ReadableByteStreamControllerCallPullIfNeeded(controller);
    }
    function ReadableByteStreamControllerShiftPendingPullInto(controller) {
        var descriptor = controller._pendingPullIntos.shift();
        return descriptor;
    }
    function ReadableByteStreamControllerShouldCallPull(controller) {
        var stream = controller._controlledReadableByteStream;
        if (stream._state !== "readable") {
            return false;
        }
        if (controller._closeRequested) {
            return false;
        }
        if (!controller._started) {
            return false;
        }
        if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
            return true;
        }
        if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {
            return true;
        }
        var desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);
        if (desiredSize > 0) {
            return true;
        }
        return false;
    }
    function ReadableByteStreamControllerClearAlgorithms(controller) {
        controller._pullAlgorithm = undefined;
        controller._cancelAlgorithm = undefined;
    }
    // A client of ReadableByteStreamController may use these functions directly to bypass state check.
    function ReadableByteStreamControllerClose(controller) {
        var stream = controller._controlledReadableByteStream;
        if (controller._closeRequested || stream._state !== "readable") {
            return;
        }
        if (controller._queueTotalSize > 0) {
            controller._closeRequested = true;
            return;
        }
        if (controller._pendingPullIntos.length > 0) {
            var firstPendingPullInto = controller._pendingPullIntos.peek();
            if (firstPendingPullInto.bytesFilled > 0) {
                var e = new TypeError("Insufficient bytes to fill elements in the given buffer");
                ReadableByteStreamControllerError(controller, e);
                throw e;
            }
        }
        ReadableByteStreamControllerClearAlgorithms(controller);
        ReadableStreamClose(stream);
    }
    function ReadableByteStreamControllerEnqueue(controller, chunk) {
        var stream = controller._controlledReadableByteStream;
        if (controller._closeRequested || stream._state !== "readable") {
            return;
        }
        var buffer = chunk.buffer;
        var byteOffset = chunk.byteOffset;
        var byteLength = chunk.byteLength;
        var transferredBuffer = TransferArrayBuffer(buffer);
        if (controller._pendingPullIntos.length > 0) {
            var firstPendingPullInto = controller._pendingPullIntos.peek();
            if (IsDetachedBuffer(firstPendingPullInto.buffer)) ;
            firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);
        }
        ReadableByteStreamControllerInvalidateBYOBRequest(controller);
        if (ReadableStreamHasDefaultReader(stream)) {
            if (ReadableStreamGetNumReadRequests(stream) === 0) {
                ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
            } else {
                if (controller._pendingPullIntos.length > 0) {
                    ReadableByteStreamControllerShiftPendingPullInto(controller);
                }
                var transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);
                ReadableStreamFulfillReadRequest(stream, transferredView, false);
            }
        } else if (ReadableStreamHasBYOBReader(stream)) {
            // TODO: Ideally in this branch detaching should happen only if the buffer is not consumed fully.
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
            ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
        } else {
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
        }
        ReadableByteStreamControllerCallPullIfNeeded(controller);
    }
    function ReadableByteStreamControllerError(controller, e) {
        var stream = controller._controlledReadableByteStream;
        if (stream._state !== "readable") {
            return;
        }
        ReadableByteStreamControllerClearPendingPullIntos(controller);
        ResetQueue(controller);
        ReadableByteStreamControllerClearAlgorithms(controller);
        ReadableStreamError(stream, e);
    }
    function ReadableByteStreamControllerGetBYOBRequest(controller) {
        if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {
            var firstDescriptor = controller._pendingPullIntos.peek();
            var view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);
            var byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);
            SetUpReadableStreamBYOBRequest(byobRequest, controller, view);
            controller._byobRequest = byobRequest;
        }
        return controller._byobRequest;
    }
    function ReadableByteStreamControllerGetDesiredSize(controller) {
        var state = controller._controlledReadableByteStream._state;
        if (state === "errored") {
            return null;
        }
        if (state === "closed") {
            return 0;
        }
        return controller._strategyHWM - controller._queueTotalSize;
    }
    function ReadableByteStreamControllerRespond(controller, bytesWritten) {
        var firstDescriptor = controller._pendingPullIntos.peek();
        var state = controller._controlledReadableByteStream._state;
        if (state === "closed") {
            if (bytesWritten !== 0) {
                throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
            }
        } else {
            if (bytesWritten === 0) {
                throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");
            }
            if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {
                throw new RangeError("bytesWritten out of range");
            }
        }
        firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);
        ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
    }
    function ReadableByteStreamControllerRespondWithNewView(controller, view) {
        var firstDescriptor = controller._pendingPullIntos.peek();
        var state = controller._controlledReadableByteStream._state;
        if (state === "closed") {
            if (view.byteLength !== 0) {
                throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream");
            }
        } else {
            if (view.byteLength === 0) {
                throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");
            }
        }
        if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {
            throw new RangeError("The region specified by view does not match byobRequest");
        }
        if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {
            throw new RangeError("The buffer of view has different capacity than byobRequest");
        }
        if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {
            throw new RangeError("The region specified by view is larger than byobRequest");
        }
        var viewByteLength = view.byteLength;
        firstDescriptor.buffer = TransferArrayBuffer(view.buffer);
        ReadableByteStreamControllerRespondInternal(controller, viewByteLength);
    }
    function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {
        controller._controlledReadableByteStream = stream;
        controller._pullAgain = false;
        controller._pulling = false;
        controller._byobRequest = null;
        // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.
        controller._queue = controller._queueTotalSize = undefined;
        ResetQueue(controller);
        controller._closeRequested = false;
        controller._started = false;
        controller._strategyHWM = highWaterMark;
        controller._pullAlgorithm = pullAlgorithm;
        controller._cancelAlgorithm = cancelAlgorithm;
        controller._autoAllocateChunkSize = autoAllocateChunkSize;
        controller._pendingPullIntos = new SimpleQueue();
        stream._readableStreamController = controller;
        var startResult = startAlgorithm();
        uponPromise(promiseResolvedWith(startResult), function() {
            controller._started = true;
            ReadableByteStreamControllerCallPullIfNeeded(controller);
        }, function(r) {
            ReadableByteStreamControllerError(controller, r);
        });
    }
    function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {
        var controller = Object.create(ReadableByteStreamController.prototype);
        var startAlgorithm = function() {
            return undefined;
        };
        var pullAlgorithm = function() {
            return promiseResolvedWith(undefined);
        };
        var cancelAlgorithm = function() {
            return promiseResolvedWith(undefined);
        };
        if (underlyingByteSource.start !== undefined) {
            startAlgorithm = function() {
                return underlyingByteSource.start(controller);
            };
        }
        if (underlyingByteSource.pull !== undefined) {
            pullAlgorithm = function() {
                return underlyingByteSource.pull(controller);
            };
        }
        if (underlyingByteSource.cancel !== undefined) {
            cancelAlgorithm = function(reason) {
                return underlyingByteSource.cancel(reason);
            };
        }
        var autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;
        if (autoAllocateChunkSize === 0) {
            throw new TypeError("autoAllocateChunkSize must be greater than 0");
        }
        SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);
    }
    function SetUpReadableStreamBYOBRequest(request, controller, view) {
        request._associatedReadableByteStreamController = controller;
        request._view = view;
    }
    // Helper functions for the ReadableStreamBYOBRequest.
    function byobRequestBrandCheckException(name) {
        return new TypeError("ReadableStreamBYOBRequest.prototype." + name + " can only be used on a ReadableStreamBYOBRequest");
    }
    // Helper functions for the ReadableByteStreamController.
    function byteStreamControllerBrandCheckException(name) {
        return new TypeError("ReadableByteStreamController.prototype." + name + " can only be used on a ReadableByteStreamController");
    }
    // Abstract operations for the ReadableStream.
    function AcquireReadableStreamBYOBReader(stream) {
        return new ReadableStreamBYOBReader(stream);
    }
    // ReadableStream API exposed for controllers.
    function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {
        stream._reader._readIntoRequests.push(readIntoRequest);
    }
    function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {
        var reader = stream._reader;
        var readIntoRequest = reader._readIntoRequests.shift();
        if (done) {
            readIntoRequest._closeSteps(chunk);
        } else {
            readIntoRequest._chunkSteps(chunk);
        }
    }
    function ReadableStreamGetNumReadIntoRequests(stream) {
        return stream._reader._readIntoRequests.length;
    }
    function ReadableStreamHasBYOBReader(stream) {
        var reader = stream._reader;
        if (reader === undefined) {
            return false;
        }
        if (!IsReadableStreamBYOBReader(reader)) {
            return false;
        }
        return true;
    }
    /**
     * A BYOB reader vended by a {@link ReadableStream}.
     *
     * @public
     */ var ReadableStreamBYOBReader = /** @class */ function() {
        function ReadableStreamBYOBReader(stream) {
            assertRequiredArgument(stream, 1, "ReadableStreamBYOBReader");
            assertReadableStream(stream, "First parameter");
            if (IsReadableStreamLocked(stream)) {
                throw new TypeError("This stream has already been locked for exclusive reading by another reader");
            }
            if (!IsReadableByteStreamController(stream._readableStreamController)) {
                throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte " + "source");
            }
            ReadableStreamReaderGenericInitialize(this, stream);
            this._readIntoRequests = new SimpleQueue();
        }
        Object.defineProperty(ReadableStreamBYOBReader.prototype, "closed", {
            /**
             * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or
             * the reader's lock is released before the stream finishes closing.
             */ get: function() {
                if (!IsReadableStreamBYOBReader(this)) {
                    return promiseRejectedWith(byobReaderBrandCheckException("closed"));
                }
                return this._closedPromise;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.
         */ ReadableStreamBYOBReader.prototype.cancel = function(reason) {
            if (reason === void 0) {
                reason = undefined;
            }
            if (!IsReadableStreamBYOBReader(this)) {
                return promiseRejectedWith(byobReaderBrandCheckException("cancel"));
            }
            if (this._ownerReadableStream === undefined) {
                return promiseRejectedWith(readerLockException("cancel"));
            }
            return ReadableStreamReaderGenericCancel(this, reason);
        };
        /**
         * Attempts to reads bytes into view, and returns a promise resolved with the result.
         *
         * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.
         */ ReadableStreamBYOBReader.prototype.read = function(view) {
            if (!IsReadableStreamBYOBReader(this)) {
                return promiseRejectedWith(byobReaderBrandCheckException("read"));
            }
            if (!ArrayBuffer.isView(view)) {
                return promiseRejectedWith(new TypeError("view must be an array buffer view"));
            }
            if (view.byteLength === 0) {
                return promiseRejectedWith(new TypeError("view must have non-zero byteLength"));
            }
            if (view.buffer.byteLength === 0) {
                return promiseRejectedWith(new TypeError("view's buffer must have non-zero byteLength"));
            }
            if (IsDetachedBuffer(view.buffer)) ;
            if (this._ownerReadableStream === undefined) {
                return promiseRejectedWith(readerLockException("read from"));
            }
            var resolvePromise;
            var rejectPromise;
            var promise = newPromise(function(resolve, reject) {
                resolvePromise = resolve;
                rejectPromise = reject;
            });
            var readIntoRequest = {
                _chunkSteps: function(chunk) {
                    return resolvePromise({
                        value: chunk,
                        done: false
                    });
                },
                _closeSteps: function(chunk) {
                    return resolvePromise({
                        value: chunk,
                        done: true
                    });
                },
                _errorSteps: function(e) {
                    return rejectPromise(e);
                }
            };
            ReadableStreamBYOBReaderRead(this, view, readIntoRequest);
            return promise;
        };
        /**
         * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.
         * If the associated stream is errored when the lock is released, the reader will appear errored in the same way
         * from now on; otherwise, the reader will appear closed.
         *
         * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by
         * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to
         * do so will throw a `TypeError` and leave the reader locked to the stream.
         */ ReadableStreamBYOBReader.prototype.releaseLock = function() {
            if (!IsReadableStreamBYOBReader(this)) {
                throw byobReaderBrandCheckException("releaseLock");
            }
            if (this._ownerReadableStream === undefined) {
                return;
            }
            if (this._readIntoRequests.length > 0) {
                throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
            }
            ReadableStreamReaderGenericRelease(this);
        };
        return ReadableStreamBYOBReader;
    }();
    Object.defineProperties(ReadableStreamBYOBReader.prototype, {
        cancel: {
            enumerable: true
        },
        read: {
            enumerable: true
        },
        releaseLock: {
            enumerable: true
        },
        closed: {
            enumerable: true
        }
    });
    if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ReadableStreamBYOBReader.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamBYOBReader",
            configurable: true
        });
    }
    // Abstract operations for the readers.
    function IsReadableStreamBYOBReader(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_readIntoRequests")) {
            return false;
        }
        return x instanceof ReadableStreamBYOBReader;
    }
    function ReadableStreamBYOBReaderRead(reader, view, readIntoRequest) {
        var stream = reader._ownerReadableStream;
        stream._disturbed = true;
        if (stream._state === "errored") {
            readIntoRequest._errorSteps(stream._storedError);
        } else {
            ReadableByteStreamControllerPullInto(stream._readableStreamController, view, readIntoRequest);
        }
    }
    // Helper functions for the ReadableStreamBYOBReader.
    function byobReaderBrandCheckException(name) {
        return new TypeError("ReadableStreamBYOBReader.prototype." + name + " can only be used on a ReadableStreamBYOBReader");
    }
    function ExtractHighWaterMark(strategy, defaultHWM) {
        var highWaterMark = strategy.highWaterMark;
        if (highWaterMark === undefined) {
            return defaultHWM;
        }
        if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {
            throw new RangeError("Invalid highWaterMark");
        }
        return highWaterMark;
    }
    function ExtractSizeAlgorithm(strategy) {
        var size = strategy.size;
        if (!size) {
            return function() {
                return 1;
            };
        }
        return size;
    }
    function convertQueuingStrategy(init, context) {
        assertDictionary(init, context);
        var highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;
        var size = init === null || init === void 0 ? void 0 : init.size;
        return {
            highWaterMark: highWaterMark === undefined ? undefined : convertUnrestrictedDouble(highWaterMark),
            size: size === undefined ? undefined : convertQueuingStrategySize(size, context + " has member 'size' that")
        };
    }
    function convertQueuingStrategySize(fn, context) {
        assertFunction(fn, context);
        return function(chunk) {
            return convertUnrestrictedDouble(fn(chunk));
        };
    }
    function convertUnderlyingSink(original, context) {
        assertDictionary(original, context);
        var abort = original === null || original === void 0 ? void 0 : original.abort;
        var close = original === null || original === void 0 ? void 0 : original.close;
        var start = original === null || original === void 0 ? void 0 : original.start;
        var type = original === null || original === void 0 ? void 0 : original.type;
        var write = original === null || original === void 0 ? void 0 : original.write;
        return {
            abort: abort === undefined ? undefined : convertUnderlyingSinkAbortCallback(abort, original, context + " has member 'abort' that"),
            close: close === undefined ? undefined : convertUnderlyingSinkCloseCallback(close, original, context + " has member 'close' that"),
            start: start === undefined ? undefined : convertUnderlyingSinkStartCallback(start, original, context + " has member 'start' that"),
            write: write === undefined ? undefined : convertUnderlyingSinkWriteCallback(write, original, context + " has member 'write' that"),
            type: type
        };
    }
    function convertUnderlyingSinkAbortCallback(fn, original, context) {
        assertFunction(fn, context);
        return function(reason) {
            return promiseCall(fn, original, [
                reason
            ]);
        };
    }
    function convertUnderlyingSinkCloseCallback(fn, original, context) {
        assertFunction(fn, context);
        return function() {
            return promiseCall(fn, original, []);
        };
    }
    function convertUnderlyingSinkStartCallback(fn, original, context) {
        assertFunction(fn, context);
        return function(controller) {
            return reflectCall(fn, original, [
                controller
            ]);
        };
    }
    function convertUnderlyingSinkWriteCallback(fn, original, context) {
        assertFunction(fn, context);
        return function(chunk, controller) {
            return promiseCall(fn, original, [
                chunk,
                controller
            ]);
        };
    }
    function assertWritableStream(x, context) {
        if (!IsWritableStream(x)) {
            throw new TypeError(context + " is not a WritableStream.");
        }
    }
    function isAbortSignal(value) {
        if (typeof value !== "object" || value === null) {
            return false;
        }
        try {
            return typeof value.aborted === "boolean";
        } catch (_a) {
            // AbortSignal.prototype.aborted throws if its brand check fails
            return false;
        }
    }
    var supportsAbortController = typeof AbortController === "function";
    /**
     * Construct a new AbortController, if supported by the platform.
     *
     * @internal
     */ function createAbortController() {
        if (supportsAbortController) {
            return new AbortController();
        }
        return undefined;
    }
    /**
     * A writable stream represents a destination for data, into which you can write.
     *
     * @public
     */ var WritableStream = /** @class */ function() {
        function WritableStream(rawUnderlyingSink, rawStrategy) {
            if (rawUnderlyingSink === void 0) {
                rawUnderlyingSink = {};
            }
            if (rawStrategy === void 0) {
                rawStrategy = {};
            }
            if (rawUnderlyingSink === undefined) {
                rawUnderlyingSink = null;
            } else {
                assertObject(rawUnderlyingSink, "First parameter");
            }
            var strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
            var underlyingSink = convertUnderlyingSink(rawUnderlyingSink, "First parameter");
            InitializeWritableStream(this);
            var type = underlyingSink.type;
            if (type !== undefined) {
                throw new RangeError("Invalid type is specified");
            }
            var sizeAlgorithm = ExtractSizeAlgorithm(strategy);
            var highWaterMark = ExtractHighWaterMark(strategy, 1);
            SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);
        }
        Object.defineProperty(WritableStream.prototype, "locked", {
            /**
             * Returns whether or not the writable stream is locked to a writer.
             */ get: function() {
                if (!IsWritableStream(this)) {
                    throw streamBrandCheckException$2("locked");
                }
                return IsWritableStreamLocked(this);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Aborts the stream, signaling that the producer can no longer successfully write to the stream and it is to be
         * immediately moved to an errored state, with any queued-up writes discarded. This will also execute any abort
         * mechanism of the underlying sink.
         *
         * The returned promise will fulfill if the stream shuts down successfully, or reject if the underlying sink signaled
         * that there was an error doing so. Additionally, it will reject with a `TypeError` (without attempting to cancel
         * the stream) if the stream is currently locked.
         */ WritableStream.prototype.abort = function(reason) {
            if (reason === void 0) {
                reason = undefined;
            }
            if (!IsWritableStream(this)) {
                return promiseRejectedWith(streamBrandCheckException$2("abort"));
            }
            if (IsWritableStreamLocked(this)) {
                return promiseRejectedWith(new TypeError("Cannot abort a stream that already has a writer"));
            }
            return WritableStreamAbort(this, reason);
        };
        /**
         * Closes the stream. The underlying sink will finish processing any previously-written chunks, before invoking its
         * close behavior. During this time any further attempts to write will fail (without erroring the stream).
         *
         * The method returns a promise that will fulfill if all remaining chunks are successfully written and the stream
         * successfully closes, or rejects if an error is encountered during this process. Additionally, it will reject with
         * a `TypeError` (without attempting to cancel the stream) if the stream is currently locked.
         */ WritableStream.prototype.close = function() {
            if (!IsWritableStream(this)) {
                return promiseRejectedWith(streamBrandCheckException$2("close"));
            }
            if (IsWritableStreamLocked(this)) {
                return promiseRejectedWith(new TypeError("Cannot close a stream that already has a writer"));
            }
            if (WritableStreamCloseQueuedOrInFlight(this)) {
                return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
            }
            return WritableStreamClose(this);
        };
        /**
         * Creates a {@link WritableStreamDefaultWriter | writer} and locks the stream to the new writer. While the stream
         * is locked, no other writer can be acquired until this one is released.
         *
         * This functionality is especially useful for creating abstractions that desire the ability to write to a stream
         * without interruption or interleaving. By getting a writer for the stream, you can ensure nobody else can write at
         * the same time, which would cause the resulting written data to be unpredictable and probably useless.
         */ WritableStream.prototype.getWriter = function() {
            if (!IsWritableStream(this)) {
                throw streamBrandCheckException$2("getWriter");
            }
            return AcquireWritableStreamDefaultWriter(this);
        };
        return WritableStream;
    }();
    Object.defineProperties(WritableStream.prototype, {
        abort: {
            enumerable: true
        },
        close: {
            enumerable: true
        },
        getWriter: {
            enumerable: true
        },
        locked: {
            enumerable: true
        }
    });
    if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(WritableStream.prototype, SymbolPolyfill.toStringTag, {
            value: "WritableStream",
            configurable: true
        });
    }
    // Abstract operations for the WritableStream.
    function AcquireWritableStreamDefaultWriter(stream) {
        return new WritableStreamDefaultWriter(stream);
    }
    // Throws if and only if startAlgorithm throws.
    function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
        if (highWaterMark === void 0) {
            highWaterMark = 1;
        }
        if (sizeAlgorithm === void 0) {
            sizeAlgorithm = function() {
                return 1;
            };
        }
        var stream = Object.create(WritableStream.prototype);
        InitializeWritableStream(stream);
        var controller = Object.create(WritableStreamDefaultController.prototype);
        SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
        return stream;
    }
    function InitializeWritableStream(stream) {
        stream._state = "writable";
        // The error that will be reported by new method calls once the state becomes errored. Only set when [[state]] is
        // 'erroring' or 'errored'. May be set to an undefined value.
        stream._storedError = undefined;
        stream._writer = undefined;
        // Initialize to undefined first because the constructor of the controller checks this
        // variable to validate the caller.
        stream._writableStreamController = undefined;
        // This queue is placed here instead of the writer class in order to allow for passing a writer to the next data
        // producer without waiting for the queued writes to finish.
        stream._writeRequests = new SimpleQueue();
        // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents
        // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.
        stream._inFlightWriteRequest = undefined;
        // The promise that was returned from writer.close(). Stored here because it may be fulfilled after the writer
        // has been detached.
        stream._closeRequest = undefined;
        // Close request is removed from _closeRequest when close() is called on the underlying sink. This prevents it
        // from being erroneously rejected on error. If a close() call is in-flight, the request is stored here.
        stream._inFlightCloseRequest = undefined;
        // The promise that was returned from writer.abort(). This may also be fulfilled after the writer has detached.
        stream._pendingAbortRequest = undefined;
        // The backpressure signal set by the controller.
        stream._backpressure = false;
    }
    function IsWritableStream(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_writableStreamController")) {
            return false;
        }
        return x instanceof WritableStream;
    }
    function IsWritableStreamLocked(stream) {
        if (stream._writer === undefined) {
            return false;
        }
        return true;
    }
    function WritableStreamAbort(stream, reason) {
        var _a;
        if (stream._state === "closed" || stream._state === "errored") {
            return promiseResolvedWith(undefined);
        }
        stream._writableStreamController._abortReason = reason;
        (_a = stream._writableStreamController._abortController) === null || _a === void 0 ? void 0 : _a.abort();
        // TypeScript narrows the type of `stream._state` down to 'writable' | 'erroring',
        // but it doesn't know that signaling abort runs author code that might have changed the state.
        // Widen the type again by casting to WritableStreamState.
        var state = stream._state;
        if (state === "closed" || state === "errored") {
            return promiseResolvedWith(undefined);
        }
        if (stream._pendingAbortRequest !== undefined) {
            return stream._pendingAbortRequest._promise;
        }
        var wasAlreadyErroring = false;
        if (state === "erroring") {
            wasAlreadyErroring = true;
            // reason will not be used, so don't keep a reference to it.
            reason = undefined;
        }
        var promise = newPromise(function(resolve, reject) {
            stream._pendingAbortRequest = {
                _promise: undefined,
                _resolve: resolve,
                _reject: reject,
                _reason: reason,
                _wasAlreadyErroring: wasAlreadyErroring
            };
        });
        stream._pendingAbortRequest._promise = promise;
        if (!wasAlreadyErroring) {
            WritableStreamStartErroring(stream, reason);
        }
        return promise;
    }
    function WritableStreamClose(stream) {
        var state = stream._state;
        if (state === "closed" || state === "errored") {
            return promiseRejectedWith(new TypeError("The stream (in " + state + " state) is not in the writable state and cannot be closed"));
        }
        var promise = newPromise(function(resolve, reject) {
            var closeRequest = {
                _resolve: resolve,
                _reject: reject
            };
            stream._closeRequest = closeRequest;
        });
        var writer = stream._writer;
        if (writer !== undefined && stream._backpressure && state === "writable") {
            defaultWriterReadyPromiseResolve(writer);
        }
        WritableStreamDefaultControllerClose(stream._writableStreamController);
        return promise;
    }
    // WritableStream API exposed for controllers.
    function WritableStreamAddWriteRequest(stream) {
        var promise = newPromise(function(resolve, reject) {
            var writeRequest = {
                _resolve: resolve,
                _reject: reject
            };
            stream._writeRequests.push(writeRequest);
        });
        return promise;
    }
    function WritableStreamDealWithRejection(stream, error) {
        var state = stream._state;
        if (state === "writable") {
            WritableStreamStartErroring(stream, error);
            return;
        }
        WritableStreamFinishErroring(stream);
    }
    function WritableStreamStartErroring(stream, reason) {
        var controller = stream._writableStreamController;
        stream._state = "erroring";
        stream._storedError = reason;
        var writer = stream._writer;
        if (writer !== undefined) {
            WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);
        }
        if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {
            WritableStreamFinishErroring(stream);
        }
    }
    function WritableStreamFinishErroring(stream) {
        stream._state = "errored";
        stream._writableStreamController[ErrorSteps]();
        var storedError = stream._storedError;
        stream._writeRequests.forEach(function(writeRequest) {
            writeRequest._reject(storedError);
        });
        stream._writeRequests = new SimpleQueue();
        if (stream._pendingAbortRequest === undefined) {
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
            return;
        }
        var abortRequest = stream._pendingAbortRequest;
        stream._pendingAbortRequest = undefined;
        if (abortRequest._wasAlreadyErroring) {
            abortRequest._reject(storedError);
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
            return;
        }
        var promise = stream._writableStreamController[AbortSteps](abortRequest._reason);
        uponPromise(promise, function() {
            abortRequest._resolve();
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
        }, function(reason) {
            abortRequest._reject(reason);
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
        });
    }
    function WritableStreamFinishInFlightWrite(stream) {
        stream._inFlightWriteRequest._resolve(undefined);
        stream._inFlightWriteRequest = undefined;
    }
    function WritableStreamFinishInFlightWriteWithError(stream, error) {
        stream._inFlightWriteRequest._reject(error);
        stream._inFlightWriteRequest = undefined;
        WritableStreamDealWithRejection(stream, error);
    }
    function WritableStreamFinishInFlightClose(stream) {
        stream._inFlightCloseRequest._resolve(undefined);
        stream._inFlightCloseRequest = undefined;
        var state = stream._state;
        if (state === "erroring") {
            // The error was too late to do anything, so it is ignored.
            stream._storedError = undefined;
            if (stream._pendingAbortRequest !== undefined) {
                stream._pendingAbortRequest._resolve();
                stream._pendingAbortRequest = undefined;
            }
        }
        stream._state = "closed";
        var writer = stream._writer;
        if (writer !== undefined) {
            defaultWriterClosedPromiseResolve(writer);
        }
    }
    function WritableStreamFinishInFlightCloseWithError(stream, error) {
        stream._inFlightCloseRequest._reject(error);
        stream._inFlightCloseRequest = undefined;
        // Never execute sink abort() after sink close().
        if (stream._pendingAbortRequest !== undefined) {
            stream._pendingAbortRequest._reject(error);
            stream._pendingAbortRequest = undefined;
        }
        WritableStreamDealWithRejection(stream, error);
    }
    // TODO(ricea): Fix alphabetical order.
    function WritableStreamCloseQueuedOrInFlight(stream) {
        if (stream._closeRequest === undefined && stream._inFlightCloseRequest === undefined) {
            return false;
        }
        return true;
    }
    function WritableStreamHasOperationMarkedInFlight(stream) {
        if (stream._inFlightWriteRequest === undefined && stream._inFlightCloseRequest === undefined) {
            return false;
        }
        return true;
    }
    function WritableStreamMarkCloseRequestInFlight(stream) {
        stream._inFlightCloseRequest = stream._closeRequest;
        stream._closeRequest = undefined;
    }
    function WritableStreamMarkFirstWriteRequestInFlight(stream) {
        stream._inFlightWriteRequest = stream._writeRequests.shift();
    }
    function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {
        if (stream._closeRequest !== undefined) {
            stream._closeRequest._reject(stream._storedError);
            stream._closeRequest = undefined;
        }
        var writer = stream._writer;
        if (writer !== undefined) {
            defaultWriterClosedPromiseReject(writer, stream._storedError);
        }
    }
    function WritableStreamUpdateBackpressure(stream, backpressure) {
        var writer = stream._writer;
        if (writer !== undefined && backpressure !== stream._backpressure) {
            if (backpressure) {
                defaultWriterReadyPromiseReset(writer);
            } else {
                defaultWriterReadyPromiseResolve(writer);
            }
        }
        stream._backpressure = backpressure;
    }
    /**
     * A default writer vended by a {@link WritableStream}.
     *
     * @public
     */ var WritableStreamDefaultWriter = /** @class */ function() {
        function WritableStreamDefaultWriter(stream) {
            assertRequiredArgument(stream, 1, "WritableStreamDefaultWriter");
            assertWritableStream(stream, "First parameter");
            if (IsWritableStreamLocked(stream)) {
                throw new TypeError("This stream has already been locked for exclusive writing by another writer");
            }
            this._ownerWritableStream = stream;
            stream._writer = this;
            var state = stream._state;
            if (state === "writable") {
                if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {
                    defaultWriterReadyPromiseInitialize(this);
                } else {
                    defaultWriterReadyPromiseInitializeAsResolved(this);
                }
                defaultWriterClosedPromiseInitialize(this);
            } else if (state === "erroring") {
                defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);
                defaultWriterClosedPromiseInitialize(this);
            } else if (state === "closed") {
                defaultWriterReadyPromiseInitializeAsResolved(this);
                defaultWriterClosedPromiseInitializeAsResolved(this);
            } else {
                var storedError = stream._storedError;
                defaultWriterReadyPromiseInitializeAsRejected(this, storedError);
                defaultWriterClosedPromiseInitializeAsRejected(this, storedError);
            }
        }
        Object.defineProperty(WritableStreamDefaultWriter.prototype, "closed", {
            /**
             * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or
             * the writers lock is released before the stream finishes closing.
             */ get: function() {
                if (!IsWritableStreamDefaultWriter(this)) {
                    return promiseRejectedWith(defaultWriterBrandCheckException("closed"));
                }
                return this._closedPromise;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(WritableStreamDefaultWriter.prototype, "desiredSize", {
            /**
             * Returns the desired size to fill the streams internal queue. It can be negative, if the queue is over-full.
             * A producer can use this information to determine the right amount of data to write.
             *
             * It will be `null` if the stream cannot be successfully written to (due to either being errored, or having an abort
             * queued up). It will return zero if the stream is closed. And the getter will throw an exception if invoked when
             * the writers lock is released.
             */ get: function() {
                if (!IsWritableStreamDefaultWriter(this)) {
                    throw defaultWriterBrandCheckException("desiredSize");
                }
                if (this._ownerWritableStream === undefined) {
                    throw defaultWriterLockException("desiredSize");
                }
                return WritableStreamDefaultWriterGetDesiredSize(this);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(WritableStreamDefaultWriter.prototype, "ready", {
            /**
             * Returns a promise that will be fulfilled when the desired size to fill the streams internal queue transitions
             * from non-positive to positive, signaling that it is no longer applying backpressure. Once the desired size dips
             * back to zero or below, the getter will return a new promise that stays pending until the next transition.
             *
             * If the stream becomes errored or aborted, or the writers lock is released, the returned promise will become
             * rejected.
             */ get: function() {
                if (!IsWritableStreamDefaultWriter(this)) {
                    return promiseRejectedWith(defaultWriterBrandCheckException("ready"));
                }
                return this._readyPromise;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * If the reader is active, behaves the same as {@link WritableStream.abort | stream.abort(reason)}.
         */ WritableStreamDefaultWriter.prototype.abort = function(reason) {
            if (reason === void 0) {
                reason = undefined;
            }
            if (!IsWritableStreamDefaultWriter(this)) {
                return promiseRejectedWith(defaultWriterBrandCheckException("abort"));
            }
            if (this._ownerWritableStream === undefined) {
                return promiseRejectedWith(defaultWriterLockException("abort"));
            }
            return WritableStreamDefaultWriterAbort(this, reason);
        };
        /**
         * If the reader is active, behaves the same as {@link WritableStream.close | stream.close()}.
         */ WritableStreamDefaultWriter.prototype.close = function() {
            if (!IsWritableStreamDefaultWriter(this)) {
                return promiseRejectedWith(defaultWriterBrandCheckException("close"));
            }
            var stream = this._ownerWritableStream;
            if (stream === undefined) {
                return promiseRejectedWith(defaultWriterLockException("close"));
            }
            if (WritableStreamCloseQueuedOrInFlight(stream)) {
                return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
            }
            return WritableStreamDefaultWriterClose(this);
        };
        /**
         * Releases the writers lock on the corresponding stream. After the lock is released, the writer is no longer active.
         * If the associated stream is errored when the lock is released, the writer will appear errored in the same way from
         * now on; otherwise, the writer will appear closed.
         *
         * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the
         * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).
         * Its not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents
         * other producers from writing in an interleaved manner.
         */ WritableStreamDefaultWriter.prototype.releaseLock = function() {
            if (!IsWritableStreamDefaultWriter(this)) {
                throw defaultWriterBrandCheckException("releaseLock");
            }
            var stream = this._ownerWritableStream;
            if (stream === undefined) {
                return;
            }
            WritableStreamDefaultWriterRelease(this);
        };
        WritableStreamDefaultWriter.prototype.write = function(chunk) {
            if (chunk === void 0) {
                chunk = undefined;
            }
            if (!IsWritableStreamDefaultWriter(this)) {
                return promiseRejectedWith(defaultWriterBrandCheckException("write"));
            }
            if (this._ownerWritableStream === undefined) {
                return promiseRejectedWith(defaultWriterLockException("write to"));
            }
            return WritableStreamDefaultWriterWrite(this, chunk);
        };
        return WritableStreamDefaultWriter;
    }();
    Object.defineProperties(WritableStreamDefaultWriter.prototype, {
        abort: {
            enumerable: true
        },
        close: {
            enumerable: true
        },
        releaseLock: {
            enumerable: true
        },
        write: {
            enumerable: true
        },
        closed: {
            enumerable: true
        },
        desiredSize: {
            enumerable: true
        },
        ready: {
            enumerable: true
        }
    });
    if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(WritableStreamDefaultWriter.prototype, SymbolPolyfill.toStringTag, {
            value: "WritableStreamDefaultWriter",
            configurable: true
        });
    }
    // Abstract operations for the WritableStreamDefaultWriter.
    function IsWritableStreamDefaultWriter(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_ownerWritableStream")) {
            return false;
        }
        return x instanceof WritableStreamDefaultWriter;
    }
    // A client of WritableStreamDefaultWriter may use these functions directly to bypass state check.
    function WritableStreamDefaultWriterAbort(writer, reason) {
        var stream = writer._ownerWritableStream;
        return WritableStreamAbort(stream, reason);
    }
    function WritableStreamDefaultWriterClose(writer) {
        var stream = writer._ownerWritableStream;
        return WritableStreamClose(stream);
    }
    function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {
        var stream = writer._ownerWritableStream;
        var state = stream._state;
        if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
            return promiseResolvedWith(undefined);
        }
        if (state === "errored") {
            return promiseRejectedWith(stream._storedError);
        }
        return WritableStreamDefaultWriterClose(writer);
    }
    function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {
        if (writer._closedPromiseState === "pending") {
            defaultWriterClosedPromiseReject(writer, error);
        } else {
            defaultWriterClosedPromiseResetToRejected(writer, error);
        }
    }
    function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {
        if (writer._readyPromiseState === "pending") {
            defaultWriterReadyPromiseReject(writer, error);
        } else {
            defaultWriterReadyPromiseResetToRejected(writer, error);
        }
    }
    function WritableStreamDefaultWriterGetDesiredSize(writer) {
        var stream = writer._ownerWritableStream;
        var state = stream._state;
        if (state === "errored" || state === "erroring") {
            return null;
        }
        if (state === "closed") {
            return 0;
        }
        return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);
    }
    function WritableStreamDefaultWriterRelease(writer) {
        var stream = writer._ownerWritableStream;
        var releasedError = new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");
        WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);
        // The state transitions to "errored" before the sink abort() method runs, but the writer.closed promise is not
        // rejected until afterwards. This means that simply testing state will not work.
        WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);
        stream._writer = undefined;
        writer._ownerWritableStream = undefined;
    }
    function WritableStreamDefaultWriterWrite(writer, chunk) {
        var stream = writer._ownerWritableStream;
        var controller = stream._writableStreamController;
        var chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);
        if (stream !== writer._ownerWritableStream) {
            return promiseRejectedWith(defaultWriterLockException("write to"));
        }
        var state = stream._state;
        if (state === "errored") {
            return promiseRejectedWith(stream._storedError);
        }
        if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
            return promiseRejectedWith(new TypeError("The stream is closing or closed and cannot be written to"));
        }
        if (state === "erroring") {
            return promiseRejectedWith(stream._storedError);
        }
        var promise = WritableStreamAddWriteRequest(stream);
        WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);
        return promise;
    }
    var closeSentinel = {};
    /**
     * Allows control of a {@link WritableStream | writable stream}'s state and internal queue.
     *
     * @public
     */ var WritableStreamDefaultController = /** @class */ function() {
        function WritableStreamDefaultController() {
            throw new TypeError("Illegal constructor");
        }
        Object.defineProperty(WritableStreamDefaultController.prototype, "abortReason", {
            /**
             * The reason which was passed to `WritableStream.abort(reason)` when the stream was aborted.
             *
             * @deprecated
             *  This property has been removed from the specification, see https://github.com/whatwg/streams/pull/1177.
             *  Use {@link WritableStreamDefaultController.signal}'s `reason` instead.
             */ get: function() {
                if (!IsWritableStreamDefaultController(this)) {
                    throw defaultControllerBrandCheckException$2("abortReason");
                }
                return this._abortReason;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(WritableStreamDefaultController.prototype, "signal", {
            /**
             * An `AbortSignal` that can be used to abort the pending write or close operation when the stream is aborted.
             */ get: function() {
                if (!IsWritableStreamDefaultController(this)) {
                    throw defaultControllerBrandCheckException$2("signal");
                }
                if (this._abortController === undefined) {
                    // Older browsers or older Node versions may not support `AbortController` or `AbortSignal`.
                    // We don't want to bundle and ship an `AbortController` polyfill together with our polyfill,
                    // so instead we only implement support for `signal` if we find a global `AbortController` constructor.
                    throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");
                }
                return this._abortController.signal;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Closes the controlled writable stream, making all future interactions with it fail with the given error `e`.
         *
         * This method is rarely used, since usually it suffices to return a rejected promise from one of the underlying
         * sink's methods. However, it can be useful for suddenly shutting down a stream in response to an event outside the
         * normal lifecycle of interactions with the underlying sink.
         */ WritableStreamDefaultController.prototype.error = function(e) {
            if (e === void 0) {
                e = undefined;
            }
            if (!IsWritableStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException$2("error");
            }
            var state = this._controlledWritableStream._state;
            if (state !== "writable") {
                // The stream is closed, errored or will be soon. The sink can't do anything useful if it gets an error here, so
                // just treat it as a no-op.
                return;
            }
            WritableStreamDefaultControllerError(this, e);
        };
        /** @internal */ WritableStreamDefaultController.prototype[AbortSteps] = function(reason) {
            var result = this._abortAlgorithm(reason);
            WritableStreamDefaultControllerClearAlgorithms(this);
            return result;
        };
        /** @internal */ WritableStreamDefaultController.prototype[ErrorSteps] = function() {
            ResetQueue(this);
        };
        return WritableStreamDefaultController;
    }();
    Object.defineProperties(WritableStreamDefaultController.prototype, {
        abortReason: {
            enumerable: true
        },
        signal: {
            enumerable: true
        },
        error: {
            enumerable: true
        }
    });
    if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(WritableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
            value: "WritableStreamDefaultController",
            configurable: true
        });
    }
    // Abstract operations implementing interface required by the WritableStream.
    function IsWritableStreamDefaultController(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_controlledWritableStream")) {
            return false;
        }
        return x instanceof WritableStreamDefaultController;
    }
    function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
        controller._controlledWritableStream = stream;
        stream._writableStreamController = controller;
        // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.
        controller._queue = undefined;
        controller._queueTotalSize = undefined;
        ResetQueue(controller);
        controller._abortReason = undefined;
        controller._abortController = createAbortController();
        controller._started = false;
        controller._strategySizeAlgorithm = sizeAlgorithm;
        controller._strategyHWM = highWaterMark;
        controller._writeAlgorithm = writeAlgorithm;
        controller._closeAlgorithm = closeAlgorithm;
        controller._abortAlgorithm = abortAlgorithm;
        var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
        WritableStreamUpdateBackpressure(stream, backpressure);
        var startResult = startAlgorithm();
        var startPromise = promiseResolvedWith(startResult);
        uponPromise(startPromise, function() {
            controller._started = true;
            WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        }, function(r) {
            controller._started = true;
            WritableStreamDealWithRejection(stream, r);
        });
    }
    function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {
        var controller = Object.create(WritableStreamDefaultController.prototype);
        var startAlgorithm = function() {
            return undefined;
        };
        var writeAlgorithm = function() {
            return promiseResolvedWith(undefined);
        };
        var closeAlgorithm = function() {
            return promiseResolvedWith(undefined);
        };
        var abortAlgorithm = function() {
            return promiseResolvedWith(undefined);
        };
        if (underlyingSink.start !== undefined) {
            startAlgorithm = function() {
                return underlyingSink.start(controller);
            };
        }
        if (underlyingSink.write !== undefined) {
            writeAlgorithm = function(chunk) {
                return underlyingSink.write(chunk, controller);
            };
        }
        if (underlyingSink.close !== undefined) {
            closeAlgorithm = function() {
                return underlyingSink.close();
            };
        }
        if (underlyingSink.abort !== undefined) {
            abortAlgorithm = function(reason) {
                return underlyingSink.abort(reason);
            };
        }
        SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
    }
    // ClearAlgorithms may be called twice. Erroring the same stream in multiple ways will often result in redundant calls.
    function WritableStreamDefaultControllerClearAlgorithms(controller) {
        controller._writeAlgorithm = undefined;
        controller._closeAlgorithm = undefined;
        controller._abortAlgorithm = undefined;
        controller._strategySizeAlgorithm = undefined;
    }
    function WritableStreamDefaultControllerClose(controller) {
        EnqueueValueWithSize(controller, closeSentinel, 0);
        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
    }
    function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {
        try {
            return controller._strategySizeAlgorithm(chunk);
        } catch (chunkSizeE) {
            WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);
            return 1;
        }
    }
    function WritableStreamDefaultControllerGetDesiredSize(controller) {
        return controller._strategyHWM - controller._queueTotalSize;
    }
    function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {
        try {
            EnqueueValueWithSize(controller, chunk, chunkSize);
        } catch (enqueueE) {
            WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
            return;
        }
        var stream = controller._controlledWritableStream;
        if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === "writable") {
            var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
            WritableStreamUpdateBackpressure(stream, backpressure);
        }
        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
    }
    // Abstract operations for the WritableStreamDefaultController.
    function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
        var stream = controller._controlledWritableStream;
        if (!controller._started) {
            return;
        }
        if (stream._inFlightWriteRequest !== undefined) {
            return;
        }
        var state = stream._state;
        if (state === "erroring") {
            WritableStreamFinishErroring(stream);
            return;
        }
        if (controller._queue.length === 0) {
            return;
        }
        var value = PeekQueueValue(controller);
        if (value === closeSentinel) {
            WritableStreamDefaultControllerProcessClose(controller);
        } else {
            WritableStreamDefaultControllerProcessWrite(controller, value);
        }
    }
    function WritableStreamDefaultControllerErrorIfNeeded(controller, error) {
        if (controller._controlledWritableStream._state === "writable") {
            WritableStreamDefaultControllerError(controller, error);
        }
    }
    function WritableStreamDefaultControllerProcessClose(controller) {
        var stream = controller._controlledWritableStream;
        WritableStreamMarkCloseRequestInFlight(stream);
        DequeueValue(controller);
        var sinkClosePromise = controller._closeAlgorithm();
        WritableStreamDefaultControllerClearAlgorithms(controller);
        uponPromise(sinkClosePromise, function() {
            WritableStreamFinishInFlightClose(stream);
        }, function(reason) {
            WritableStreamFinishInFlightCloseWithError(stream, reason);
        });
    }
    function WritableStreamDefaultControllerProcessWrite(controller, chunk) {
        var stream = controller._controlledWritableStream;
        WritableStreamMarkFirstWriteRequestInFlight(stream);
        var sinkWritePromise = controller._writeAlgorithm(chunk);
        uponPromise(sinkWritePromise, function() {
            WritableStreamFinishInFlightWrite(stream);
            var state = stream._state;
            DequeueValue(controller);
            if (!WritableStreamCloseQueuedOrInFlight(stream) && state === "writable") {
                var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
                WritableStreamUpdateBackpressure(stream, backpressure);
            }
            WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        }, function(reason) {
            if (stream._state === "writable") {
                WritableStreamDefaultControllerClearAlgorithms(controller);
            }
            WritableStreamFinishInFlightWriteWithError(stream, reason);
        });
    }
    function WritableStreamDefaultControllerGetBackpressure(controller) {
        var desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);
        return desiredSize <= 0;
    }
    // A client of WritableStreamDefaultController may use these functions directly to bypass state check.
    function WritableStreamDefaultControllerError(controller, error) {
        var stream = controller._controlledWritableStream;
        WritableStreamDefaultControllerClearAlgorithms(controller);
        WritableStreamStartErroring(stream, error);
    }
    // Helper functions for the WritableStream.
    function streamBrandCheckException$2(name) {
        return new TypeError("WritableStream.prototype." + name + " can only be used on a WritableStream");
    }
    // Helper functions for the WritableStreamDefaultController.
    function defaultControllerBrandCheckException$2(name) {
        return new TypeError("WritableStreamDefaultController.prototype." + name + " can only be used on a WritableStreamDefaultController");
    }
    // Helper functions for the WritableStreamDefaultWriter.
    function defaultWriterBrandCheckException(name) {
        return new TypeError("WritableStreamDefaultWriter.prototype." + name + " can only be used on a WritableStreamDefaultWriter");
    }
    function defaultWriterLockException(name) {
        return new TypeError("Cannot " + name + " a stream using a released writer");
    }
    function defaultWriterClosedPromiseInitialize(writer) {
        writer._closedPromise = newPromise(function(resolve, reject) {
            writer._closedPromise_resolve = resolve;
            writer._closedPromise_reject = reject;
            writer._closedPromiseState = "pending";
        });
    }
    function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {
        defaultWriterClosedPromiseInitialize(writer);
        defaultWriterClosedPromiseReject(writer, reason);
    }
    function defaultWriterClosedPromiseInitializeAsResolved(writer) {
        defaultWriterClosedPromiseInitialize(writer);
        defaultWriterClosedPromiseResolve(writer);
    }
    function defaultWriterClosedPromiseReject(writer, reason) {
        if (writer._closedPromise_reject === undefined) {
            return;
        }
        setPromiseIsHandledToTrue(writer._closedPromise);
        writer._closedPromise_reject(reason);
        writer._closedPromise_resolve = undefined;
        writer._closedPromise_reject = undefined;
        writer._closedPromiseState = "rejected";
    }
    function defaultWriterClosedPromiseResetToRejected(writer, reason) {
        defaultWriterClosedPromiseInitializeAsRejected(writer, reason);
    }
    function defaultWriterClosedPromiseResolve(writer) {
        if (writer._closedPromise_resolve === undefined) {
            return;
        }
        writer._closedPromise_resolve(undefined);
        writer._closedPromise_resolve = undefined;
        writer._closedPromise_reject = undefined;
        writer._closedPromiseState = "resolved";
    }
    function defaultWriterReadyPromiseInitialize(writer) {
        writer._readyPromise = newPromise(function(resolve, reject) {
            writer._readyPromise_resolve = resolve;
            writer._readyPromise_reject = reject;
        });
        writer._readyPromiseState = "pending";
    }
    function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {
        defaultWriterReadyPromiseInitialize(writer);
        defaultWriterReadyPromiseReject(writer, reason);
    }
    function defaultWriterReadyPromiseInitializeAsResolved(writer) {
        defaultWriterReadyPromiseInitialize(writer);
        defaultWriterReadyPromiseResolve(writer);
    }
    function defaultWriterReadyPromiseReject(writer, reason) {
        if (writer._readyPromise_reject === undefined) {
            return;
        }
        setPromiseIsHandledToTrue(writer._readyPromise);
        writer._readyPromise_reject(reason);
        writer._readyPromise_resolve = undefined;
        writer._readyPromise_reject = undefined;
        writer._readyPromiseState = "rejected";
    }
    function defaultWriterReadyPromiseReset(writer) {
        defaultWriterReadyPromiseInitialize(writer);
    }
    function defaultWriterReadyPromiseResetToRejected(writer, reason) {
        defaultWriterReadyPromiseInitializeAsRejected(writer, reason);
    }
    function defaultWriterReadyPromiseResolve(writer) {
        if (writer._readyPromise_resolve === undefined) {
            return;
        }
        writer._readyPromise_resolve(undefined);
        writer._readyPromise_resolve = undefined;
        writer._readyPromise_reject = undefined;
        writer._readyPromiseState = "fulfilled";
    }
    /// <reference lib="dom" />
    var NativeDOMException = typeof DOMException !== "undefined" ? DOMException : undefined;
    /// <reference types="node" />
    function isDOMExceptionConstructor(ctor) {
        if (!(typeof ctor === "function" || typeof ctor === "object")) {
            return false;
        }
        try {
            new ctor();
            return true;
        } catch (_a) {
            return false;
        }
    }
    function createDOMExceptionPolyfill() {
        // eslint-disable-next-line no-shadow
        var ctor = function DOMException1(message, name) {
            this.message = message || "";
            this.name = name || "Error";
            if (Error.captureStackTrace) {
                Error.captureStackTrace(this, this.constructor);
            }
        };
        ctor.prototype = Object.create(Error.prototype);
        Object.defineProperty(ctor.prototype, "constructor", {
            value: ctor,
            writable: true,
            configurable: true
        });
        return ctor;
    }
    // eslint-disable-next-line no-redeclare
    var DOMException$1 = isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();
    function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {
        var reader = AcquireReadableStreamDefaultReader(source);
        var writer = AcquireWritableStreamDefaultWriter(dest);
        source._disturbed = true;
        var shuttingDown = false;
        // This is used to keep track of the spec's requirement that we wait for ongoing writes during shutdown.
        var currentWrite = promiseResolvedWith(undefined);
        return newPromise(function(resolve, reject) {
            var abortAlgorithm;
            if (signal !== undefined) {
                abortAlgorithm = function() {
                    var error = new DOMException$1("Aborted", "AbortError");
                    var actions = [];
                    if (!preventAbort) {
                        actions.push(function() {
                            if (dest._state === "writable") {
                                return WritableStreamAbort(dest, error);
                            }
                            return promiseResolvedWith(undefined);
                        });
                    }
                    if (!preventCancel) {
                        actions.push(function() {
                            if (source._state === "readable") {
                                return ReadableStreamCancel(source, error);
                            }
                            return promiseResolvedWith(undefined);
                        });
                    }
                    shutdownWithAction(function() {
                        return Promise.all(actions.map(function(action) {
                            return action();
                        }));
                    }, true, error);
                };
                if (signal.aborted) {
                    abortAlgorithm();
                    return;
                }
                signal.addEventListener("abort", abortAlgorithm);
            }
            // Using reader and writer, read all chunks from this and write them to dest
            // - Backpressure must be enforced
            // - Shutdown must stop all activity
            function pipeLoop() {
                return newPromise(function(resolveLoop, rejectLoop) {
                    function next(done) {
                        if (done) {
                            resolveLoop();
                        } else {
                            // Use `PerformPromiseThen` instead of `uponPromise` to avoid
                            // adding unnecessary `.catch(rethrowAssertionErrorRejection)` handlers
                            PerformPromiseThen(pipeStep(), next, rejectLoop);
                        }
                    }
                    next(false);
                });
            }
            function pipeStep() {
                if (shuttingDown) {
                    return promiseResolvedWith(true);
                }
                return PerformPromiseThen(writer._readyPromise, function() {
                    return newPromise(function(resolveRead, rejectRead) {
                        ReadableStreamDefaultReaderRead(reader, {
                            _chunkSteps: function(chunk) {
                                currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), undefined, noop);
                                resolveRead(false);
                            },
                            _closeSteps: function() {
                                return resolveRead(true);
                            },
                            _errorSteps: rejectRead
                        });
                    });
                });
            }
            // Errors must be propagated forward
            isOrBecomesErrored(source, reader._closedPromise, function(storedError) {
                if (!preventAbort) {
                    shutdownWithAction(function() {
                        return WritableStreamAbort(dest, storedError);
                    }, true, storedError);
                } else {
                    shutdown(true, storedError);
                }
            });
            // Errors must be propagated backward
            isOrBecomesErrored(dest, writer._closedPromise, function(storedError) {
                if (!preventCancel) {
                    shutdownWithAction(function() {
                        return ReadableStreamCancel(source, storedError);
                    }, true, storedError);
                } else {
                    shutdown(true, storedError);
                }
            });
            // Closing must be propagated forward
            isOrBecomesClosed(source, reader._closedPromise, function() {
                if (!preventClose) {
                    shutdownWithAction(function() {
                        return WritableStreamDefaultWriterCloseWithErrorPropagation(writer);
                    });
                } else {
                    shutdown();
                }
            });
            // Closing must be propagated backward
            if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === "closed") {
                var destClosed_1 = new TypeError("the destination writable stream closed before all data could be piped to it");
                if (!preventCancel) {
                    shutdownWithAction(function() {
                        return ReadableStreamCancel(source, destClosed_1);
                    }, true, destClosed_1);
                } else {
                    shutdown(true, destClosed_1);
                }
            }
            setPromiseIsHandledToTrue(pipeLoop());
            function waitForWritesToFinish() {
                // Another write may have started while we were waiting on this currentWrite, so we have to be sure to wait
                // for that too.
                var oldCurrentWrite = currentWrite;
                return PerformPromiseThen(currentWrite, function() {
                    return oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : undefined;
                });
            }
            function isOrBecomesErrored(stream, promise, action) {
                if (stream._state === "errored") {
                    action(stream._storedError);
                } else {
                    uponRejection(promise, action);
                }
            }
            function isOrBecomesClosed(stream, promise, action) {
                if (stream._state === "closed") {
                    action();
                } else {
                    uponFulfillment(promise, action);
                }
            }
            function shutdownWithAction(action, originalIsError, originalError) {
                if (shuttingDown) {
                    return;
                }
                shuttingDown = true;
                if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
                    uponFulfillment(waitForWritesToFinish(), doTheRest);
                } else {
                    doTheRest();
                }
                function doTheRest() {
                    uponPromise(action(), function() {
                        return finalize(originalIsError, originalError);
                    }, function(newError) {
                        return finalize(true, newError);
                    });
                }
            }
            function shutdown(isError, error) {
                if (shuttingDown) {
                    return;
                }
                shuttingDown = true;
                if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
                    uponFulfillment(waitForWritesToFinish(), function() {
                        return finalize(isError, error);
                    });
                } else {
                    finalize(isError, error);
                }
            }
            function finalize(isError, error) {
                WritableStreamDefaultWriterRelease(writer);
                ReadableStreamReaderGenericRelease(reader);
                if (signal !== undefined) {
                    signal.removeEventListener("abort", abortAlgorithm);
                }
                if (isError) {
                    reject(error);
                } else {
                    resolve(undefined);
                }
            }
        });
    }
    /**
     * Allows control of a {@link ReadableStream | readable stream}'s state and internal queue.
     *
     * @public
     */ var ReadableStreamDefaultController = /** @class */ function() {
        function ReadableStreamDefaultController() {
            throw new TypeError("Illegal constructor");
        }
        Object.defineProperty(ReadableStreamDefaultController.prototype, "desiredSize", {
            /**
             * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is
             * over-full. An underlying source ought to use this information to determine when and how to apply backpressure.
             */ get: function() {
                if (!IsReadableStreamDefaultController(this)) {
                    throw defaultControllerBrandCheckException$1("desiredSize");
                }
                return ReadableStreamDefaultControllerGetDesiredSize(this);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from
         * the stream, but once those are read, the stream will become closed.
         */ ReadableStreamDefaultController.prototype.close = function() {
            if (!IsReadableStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException$1("close");
            }
            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
                throw new TypeError("The stream is not in a state that permits close");
            }
            ReadableStreamDefaultControllerClose(this);
        };
        ReadableStreamDefaultController.prototype.enqueue = function(chunk) {
            if (chunk === void 0) {
                chunk = undefined;
            }
            if (!IsReadableStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException$1("enqueue");
            }
            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
                throw new TypeError("The stream is not in a state that permits enqueue");
            }
            return ReadableStreamDefaultControllerEnqueue(this, chunk);
        };
        /**
         * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.
         */ ReadableStreamDefaultController.prototype.error = function(e) {
            if (e === void 0) {
                e = undefined;
            }
            if (!IsReadableStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException$1("error");
            }
            ReadableStreamDefaultControllerError(this, e);
        };
        /** @internal */ ReadableStreamDefaultController.prototype[CancelSteps] = function(reason) {
            ResetQueue(this);
            var result = this._cancelAlgorithm(reason);
            ReadableStreamDefaultControllerClearAlgorithms(this);
            return result;
        };
        /** @internal */ ReadableStreamDefaultController.prototype[PullSteps] = function(readRequest) {
            var stream = this._controlledReadableStream;
            if (this._queue.length > 0) {
                var chunk = DequeueValue(this);
                if (this._closeRequested && this._queue.length === 0) {
                    ReadableStreamDefaultControllerClearAlgorithms(this);
                    ReadableStreamClose(stream);
                } else {
                    ReadableStreamDefaultControllerCallPullIfNeeded(this);
                }
                readRequest._chunkSteps(chunk);
            } else {
                ReadableStreamAddReadRequest(stream, readRequest);
                ReadableStreamDefaultControllerCallPullIfNeeded(this);
            }
        };
        return ReadableStreamDefaultController;
    }();
    Object.defineProperties(ReadableStreamDefaultController.prototype, {
        close: {
            enumerable: true
        },
        enqueue: {
            enumerable: true
        },
        error: {
            enumerable: true
        },
        desiredSize: {
            enumerable: true
        }
    });
    if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ReadableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamDefaultController",
            configurable: true
        });
    }
    // Abstract operations for the ReadableStreamDefaultController.
    function IsReadableStreamDefaultController(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_controlledReadableStream")) {
            return false;
        }
        return x instanceof ReadableStreamDefaultController;
    }
    function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
        var shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);
        if (!shouldPull) {
            return;
        }
        if (controller._pulling) {
            controller._pullAgain = true;
            return;
        }
        controller._pulling = true;
        var pullPromise = controller._pullAlgorithm();
        uponPromise(pullPromise, function() {
            controller._pulling = false;
            if (controller._pullAgain) {
                controller._pullAgain = false;
                ReadableStreamDefaultControllerCallPullIfNeeded(controller);
            }
        }, function(e) {
            ReadableStreamDefaultControllerError(controller, e);
        });
    }
    function ReadableStreamDefaultControllerShouldCallPull(controller) {
        var stream = controller._controlledReadableStream;
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
            return false;
        }
        if (!controller._started) {
            return false;
        }
        if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
            return true;
        }
        var desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
        if (desiredSize > 0) {
            return true;
        }
        return false;
    }
    function ReadableStreamDefaultControllerClearAlgorithms(controller) {
        controller._pullAlgorithm = undefined;
        controller._cancelAlgorithm = undefined;
        controller._strategySizeAlgorithm = undefined;
    }
    // A client of ReadableStreamDefaultController may use these functions directly to bypass state check.
    function ReadableStreamDefaultControllerClose(controller) {
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
            return;
        }
        var stream = controller._controlledReadableStream;
        controller._closeRequested = true;
        if (controller._queue.length === 0) {
            ReadableStreamDefaultControllerClearAlgorithms(controller);
            ReadableStreamClose(stream);
        }
    }
    function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
            return;
        }
        var stream = controller._controlledReadableStream;
        if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
            ReadableStreamFulfillReadRequest(stream, chunk, false);
        } else {
            var chunkSize = void 0;
            try {
                chunkSize = controller._strategySizeAlgorithm(chunk);
            } catch (chunkSizeE) {
                ReadableStreamDefaultControllerError(controller, chunkSizeE);
                throw chunkSizeE;
            }
            try {
                EnqueueValueWithSize(controller, chunk, chunkSize);
            } catch (enqueueE) {
                ReadableStreamDefaultControllerError(controller, enqueueE);
                throw enqueueE;
            }
        }
        ReadableStreamDefaultControllerCallPullIfNeeded(controller);
    }
    function ReadableStreamDefaultControllerError(controller, e) {
        var stream = controller._controlledReadableStream;
        if (stream._state !== "readable") {
            return;
        }
        ResetQueue(controller);
        ReadableStreamDefaultControllerClearAlgorithms(controller);
        ReadableStreamError(stream, e);
    }
    function ReadableStreamDefaultControllerGetDesiredSize(controller) {
        var state = controller._controlledReadableStream._state;
        if (state === "errored") {
            return null;
        }
        if (state === "closed") {
            return 0;
        }
        return controller._strategyHWM - controller._queueTotalSize;
    }
    // This is used in the implementation of TransformStream.
    function ReadableStreamDefaultControllerHasBackpressure(controller) {
        if (ReadableStreamDefaultControllerShouldCallPull(controller)) {
            return false;
        }
        return true;
    }
    function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {
        var state = controller._controlledReadableStream._state;
        if (!controller._closeRequested && state === "readable") {
            return true;
        }
        return false;
    }
    function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
        controller._controlledReadableStream = stream;
        controller._queue = undefined;
        controller._queueTotalSize = undefined;
        ResetQueue(controller);
        controller._started = false;
        controller._closeRequested = false;
        controller._pullAgain = false;
        controller._pulling = false;
        controller._strategySizeAlgorithm = sizeAlgorithm;
        controller._strategyHWM = highWaterMark;
        controller._pullAlgorithm = pullAlgorithm;
        controller._cancelAlgorithm = cancelAlgorithm;
        stream._readableStreamController = controller;
        var startResult = startAlgorithm();
        uponPromise(promiseResolvedWith(startResult), function() {
            controller._started = true;
            ReadableStreamDefaultControllerCallPullIfNeeded(controller);
        }, function(r) {
            ReadableStreamDefaultControllerError(controller, r);
        });
    }
    function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {
        var controller = Object.create(ReadableStreamDefaultController.prototype);
        var startAlgorithm = function() {
            return undefined;
        };
        var pullAlgorithm = function() {
            return promiseResolvedWith(undefined);
        };
        var cancelAlgorithm = function() {
            return promiseResolvedWith(undefined);
        };
        if (underlyingSource.start !== undefined) {
            startAlgorithm = function() {
                return underlyingSource.start(controller);
            };
        }
        if (underlyingSource.pull !== undefined) {
            pullAlgorithm = function() {
                return underlyingSource.pull(controller);
            };
        }
        if (underlyingSource.cancel !== undefined) {
            cancelAlgorithm = function(reason) {
                return underlyingSource.cancel(reason);
            };
        }
        SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
    }
    // Helper functions for the ReadableStreamDefaultController.
    function defaultControllerBrandCheckException$1(name) {
        return new TypeError("ReadableStreamDefaultController.prototype." + name + " can only be used on a ReadableStreamDefaultController");
    }
    function ReadableStreamTee(stream, cloneForBranch2) {
        if (IsReadableByteStreamController(stream._readableStreamController)) {
            return ReadableByteStreamTee(stream);
        }
        return ReadableStreamDefaultTee(stream);
    }
    function ReadableStreamDefaultTee(stream, cloneForBranch2) {
        var reader = AcquireReadableStreamDefaultReader(stream);
        var reading = false;
        var readAgain = false;
        var canceled1 = false;
        var canceled2 = false;
        var reason1;
        var reason2;
        var branch1;
        var branch2;
        var resolveCancelPromise;
        var cancelPromise = newPromise(function(resolve) {
            resolveCancelPromise = resolve;
        });
        function pullAlgorithm() {
            if (reading) {
                readAgain = true;
                return promiseResolvedWith(undefined);
            }
            reading = true;
            var readRequest = {
                _chunkSteps: function(chunk) {
                    // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using
                    // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let
                    // successful synchronously-available reads get ahead of asynchronously-available errors.
                    queueMicrotask(function() {
                        readAgain = false;
                        var chunk1 = chunk;
                        var chunk2 = chunk;
                        // There is no way to access the cloning code right now in the reference implementation.
                        // If we add one then we'll need an implementation for serializable objects.
                        // if (!canceled2 && cloneForBranch2) {
                        //   chunk2 = StructuredDeserialize(StructuredSerialize(chunk2));
                        // }
                        if (!canceled1) {
                            ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);
                        }
                        if (!canceled2) {
                            ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);
                        }
                        reading = false;
                        if (readAgain) {
                            pullAlgorithm();
                        }
                    });
                },
                _closeSteps: function() {
                    reading = false;
                    if (!canceled1) {
                        ReadableStreamDefaultControllerClose(branch1._readableStreamController);
                    }
                    if (!canceled2) {
                        ReadableStreamDefaultControllerClose(branch2._readableStreamController);
                    }
                    if (!canceled1 || !canceled2) {
                        resolveCancelPromise(undefined);
                    }
                },
                _errorSteps: function() {
                    reading = false;
                }
            };
            ReadableStreamDefaultReaderRead(reader, readRequest);
            return promiseResolvedWith(undefined);
        }
        function cancel1Algorithm(reason) {
            canceled1 = true;
            reason1 = reason;
            if (canceled2) {
                var compositeReason = CreateArrayFromList([
                    reason1,
                    reason2
                ]);
                var cancelResult = ReadableStreamCancel(stream, compositeReason);
                resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
        }
        function cancel2Algorithm(reason) {
            canceled2 = true;
            reason2 = reason;
            if (canceled1) {
                var compositeReason = CreateArrayFromList([
                    reason1,
                    reason2
                ]);
                var cancelResult = ReadableStreamCancel(stream, compositeReason);
                resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
        }
        function startAlgorithm() {
        // do nothing
        }
        branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);
        branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);
        uponRejection(reader._closedPromise, function(r) {
            ReadableStreamDefaultControllerError(branch1._readableStreamController, r);
            ReadableStreamDefaultControllerError(branch2._readableStreamController, r);
            if (!canceled1 || !canceled2) {
                resolveCancelPromise(undefined);
            }
        });
        return [
            branch1,
            branch2
        ];
    }
    function ReadableByteStreamTee(stream) {
        var reader = AcquireReadableStreamDefaultReader(stream);
        var reading = false;
        var readAgainForBranch1 = false;
        var readAgainForBranch2 = false;
        var canceled1 = false;
        var canceled2 = false;
        var reason1;
        var reason2;
        var branch1;
        var branch2;
        var resolveCancelPromise;
        var cancelPromise = newPromise(function(resolve) {
            resolveCancelPromise = resolve;
        });
        function forwardReaderError(thisReader) {
            uponRejection(thisReader._closedPromise, function(r) {
                if (thisReader !== reader) {
                    return;
                }
                ReadableByteStreamControllerError(branch1._readableStreamController, r);
                ReadableByteStreamControllerError(branch2._readableStreamController, r);
                if (!canceled1 || !canceled2) {
                    resolveCancelPromise(undefined);
                }
            });
        }
        function pullWithDefaultReader() {
            if (IsReadableStreamBYOBReader(reader)) {
                ReadableStreamReaderGenericRelease(reader);
                reader = AcquireReadableStreamDefaultReader(stream);
                forwardReaderError(reader);
            }
            var readRequest = {
                _chunkSteps: function(chunk) {
                    // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using
                    // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let
                    // successful synchronously-available reads get ahead of asynchronously-available errors.
                    queueMicrotask(function() {
                        readAgainForBranch1 = false;
                        readAgainForBranch2 = false;
                        var chunk1 = chunk;
                        var chunk2 = chunk;
                        if (!canceled1 && !canceled2) {
                            try {
                                chunk2 = CloneAsUint8Array(chunk);
                            } catch (cloneE) {
                                ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);
                                ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);
                                resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                                return;
                            }
                        }
                        if (!canceled1) {
                            ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);
                        }
                        if (!canceled2) {
                            ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);
                        }
                        reading = false;
                        if (readAgainForBranch1) {
                            pull1Algorithm();
                        } else if (readAgainForBranch2) {
                            pull2Algorithm();
                        }
                    });
                },
                _closeSteps: function() {
                    reading = false;
                    if (!canceled1) {
                        ReadableByteStreamControllerClose(branch1._readableStreamController);
                    }
                    if (!canceled2) {
                        ReadableByteStreamControllerClose(branch2._readableStreamController);
                    }
                    if (branch1._readableStreamController._pendingPullIntos.length > 0) {
                        ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);
                    }
                    if (branch2._readableStreamController._pendingPullIntos.length > 0) {
                        ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);
                    }
                    if (!canceled1 || !canceled2) {
                        resolveCancelPromise(undefined);
                    }
                },
                _errorSteps: function() {
                    reading = false;
                }
            };
            ReadableStreamDefaultReaderRead(reader, readRequest);
        }
        function pullWithBYOBReader(view, forBranch2) {
            if (IsReadableStreamDefaultReader(reader)) {
                ReadableStreamReaderGenericRelease(reader);
                reader = AcquireReadableStreamBYOBReader(stream);
                forwardReaderError(reader);
            }
            var byobBranch = forBranch2 ? branch2 : branch1;
            var otherBranch = forBranch2 ? branch1 : branch2;
            var readIntoRequest = {
                _chunkSteps: function(chunk) {
                    // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using
                    // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let
                    // successful synchronously-available reads get ahead of asynchronously-available errors.
                    queueMicrotask(function() {
                        readAgainForBranch1 = false;
                        readAgainForBranch2 = false;
                        var byobCanceled = forBranch2 ? canceled2 : canceled1;
                        var otherCanceled = forBranch2 ? canceled1 : canceled2;
                        if (!otherCanceled) {
                            var clonedChunk = void 0;
                            try {
                                clonedChunk = CloneAsUint8Array(chunk);
                            } catch (cloneE) {
                                ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);
                                ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);
                                resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                                return;
                            }
                            if (!byobCanceled) {
                                ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                            }
                            ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);
                        } else if (!byobCanceled) {
                            ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                        }
                        reading = false;
                        if (readAgainForBranch1) {
                            pull1Algorithm();
                        } else if (readAgainForBranch2) {
                            pull2Algorithm();
                        }
                    });
                },
                _closeSteps: function(chunk) {
                    reading = false;
                    var byobCanceled = forBranch2 ? canceled2 : canceled1;
                    var otherCanceled = forBranch2 ? canceled1 : canceled2;
                    if (!byobCanceled) {
                        ReadableByteStreamControllerClose(byobBranch._readableStreamController);
                    }
                    if (!otherCanceled) {
                        ReadableByteStreamControllerClose(otherBranch._readableStreamController);
                    }
                    if (chunk !== undefined) {
                        if (!byobCanceled) {
                            ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                        }
                        if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {
                            ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);
                        }
                    }
                    if (!byobCanceled || !otherCanceled) {
                        resolveCancelPromise(undefined);
                    }
                },
                _errorSteps: function() {
                    reading = false;
                }
            };
            ReadableStreamBYOBReaderRead(reader, view, readIntoRequest);
        }
        function pull1Algorithm() {
            if (reading) {
                readAgainForBranch1 = true;
                return promiseResolvedWith(undefined);
            }
            reading = true;
            var byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);
            if (byobRequest === null) {
                pullWithDefaultReader();
            } else {
                pullWithBYOBReader(byobRequest._view, false);
            }
            return promiseResolvedWith(undefined);
        }
        function pull2Algorithm() {
            if (reading) {
                readAgainForBranch2 = true;
                return promiseResolvedWith(undefined);
            }
            reading = true;
            var byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);
            if (byobRequest === null) {
                pullWithDefaultReader();
            } else {
                pullWithBYOBReader(byobRequest._view, true);
            }
            return promiseResolvedWith(undefined);
        }
        function cancel1Algorithm(reason) {
            canceled1 = true;
            reason1 = reason;
            if (canceled2) {
                var compositeReason = CreateArrayFromList([
                    reason1,
                    reason2
                ]);
                var cancelResult = ReadableStreamCancel(stream, compositeReason);
                resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
        }
        function cancel2Algorithm(reason) {
            canceled2 = true;
            reason2 = reason;
            if (canceled1) {
                var compositeReason = CreateArrayFromList([
                    reason1,
                    reason2
                ]);
                var cancelResult = ReadableStreamCancel(stream, compositeReason);
                resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
        }
        function startAlgorithm() {
            return;
        }
        branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);
        branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);
        forwardReaderError(reader);
        return [
            branch1,
            branch2
        ];
    }
    function convertUnderlyingDefaultOrByteSource(source, context) {
        assertDictionary(source, context);
        var original = source;
        var autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;
        var cancel = original === null || original === void 0 ? void 0 : original.cancel;
        var pull = original === null || original === void 0 ? void 0 : original.pull;
        var start = original === null || original === void 0 ? void 0 : original.start;
        var type = original === null || original === void 0 ? void 0 : original.type;
        return {
            autoAllocateChunkSize: autoAllocateChunkSize === undefined ? undefined : convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, context + " has member 'autoAllocateChunkSize' that"),
            cancel: cancel === undefined ? undefined : convertUnderlyingSourceCancelCallback(cancel, original, context + " has member 'cancel' that"),
            pull: pull === undefined ? undefined : convertUnderlyingSourcePullCallback(pull, original, context + " has member 'pull' that"),
            start: start === undefined ? undefined : convertUnderlyingSourceStartCallback(start, original, context + " has member 'start' that"),
            type: type === undefined ? undefined : convertReadableStreamType(type, context + " has member 'type' that")
        };
    }
    function convertUnderlyingSourceCancelCallback(fn, original, context) {
        assertFunction(fn, context);
        return function(reason) {
            return promiseCall(fn, original, [
                reason
            ]);
        };
    }
    function convertUnderlyingSourcePullCallback(fn, original, context) {
        assertFunction(fn, context);
        return function(controller) {
            return promiseCall(fn, original, [
                controller
            ]);
        };
    }
    function convertUnderlyingSourceStartCallback(fn, original, context) {
        assertFunction(fn, context);
        return function(controller) {
            return reflectCall(fn, original, [
                controller
            ]);
        };
    }
    function convertReadableStreamType(type, context) {
        type = "" + type;
        if (type !== "bytes") {
            throw new TypeError(context + " '" + type + "' is not a valid enumeration value for ReadableStreamType");
        }
        return type;
    }
    function convertReaderOptions(options, context) {
        assertDictionary(options, context);
        var mode = options === null || options === void 0 ? void 0 : options.mode;
        return {
            mode: mode === undefined ? undefined : convertReadableStreamReaderMode(mode, context + " has member 'mode' that")
        };
    }
    function convertReadableStreamReaderMode(mode, context) {
        mode = "" + mode;
        if (mode !== "byob") {
            throw new TypeError(context + " '" + mode + "' is not a valid enumeration value for ReadableStreamReaderMode");
        }
        return mode;
    }
    function convertIteratorOptions(options, context) {
        assertDictionary(options, context);
        var preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
        return {
            preventCancel: Boolean(preventCancel)
        };
    }
    function convertPipeOptions(options, context) {
        assertDictionary(options, context);
        var preventAbort = options === null || options === void 0 ? void 0 : options.preventAbort;
        var preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
        var preventClose = options === null || options === void 0 ? void 0 : options.preventClose;
        var signal = options === null || options === void 0 ? void 0 : options.signal;
        if (signal !== undefined) {
            assertAbortSignal(signal, context + " has member 'signal' that");
        }
        return {
            preventAbort: Boolean(preventAbort),
            preventCancel: Boolean(preventCancel),
            preventClose: Boolean(preventClose),
            signal: signal
        };
    }
    function assertAbortSignal(signal, context) {
        if (!isAbortSignal(signal)) {
            throw new TypeError(context + " is not an AbortSignal.");
        }
    }
    function convertReadableWritablePair(pair, context) {
        assertDictionary(pair, context);
        var readable = pair === null || pair === void 0 ? void 0 : pair.readable;
        assertRequiredField(readable, "readable", "ReadableWritablePair");
        assertReadableStream(readable, context + " has member 'readable' that");
        var writable = pair === null || pair === void 0 ? void 0 : pair.writable;
        assertRequiredField(writable, "writable", "ReadableWritablePair");
        assertWritableStream(writable, context + " has member 'writable' that");
        return {
            readable: readable,
            writable: writable
        };
    }
    /**
     * A readable stream represents a source of data, from which you can read.
     *
     * @public
     */ var ReadableStream = /** @class */ function() {
        function ReadableStream(rawUnderlyingSource, rawStrategy) {
            if (rawUnderlyingSource === void 0) {
                rawUnderlyingSource = {};
            }
            if (rawStrategy === void 0) {
                rawStrategy = {};
            }
            if (rawUnderlyingSource === undefined) {
                rawUnderlyingSource = null;
            } else {
                assertObject(rawUnderlyingSource, "First parameter");
            }
            var strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
            var underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, "First parameter");
            InitializeReadableStream(this);
            if (underlyingSource.type === "bytes") {
                if (strategy.size !== undefined) {
                    throw new RangeError("The strategy for a byte stream cannot have a size function");
                }
                var highWaterMark = ExtractHighWaterMark(strategy, 0);
                SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);
            } else {
                var sizeAlgorithm = ExtractSizeAlgorithm(strategy);
                var highWaterMark = ExtractHighWaterMark(strategy, 1);
                SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);
            }
        }
        Object.defineProperty(ReadableStream.prototype, "locked", {
            /**
             * Whether or not the readable stream is locked to a {@link ReadableStreamDefaultReader | reader}.
             */ get: function() {
                if (!IsReadableStream(this)) {
                    throw streamBrandCheckException$1("locked");
                }
                return IsReadableStreamLocked(this);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Cancels the stream, signaling a loss of interest in the stream by a consumer.
         *
         * The supplied `reason` argument will be given to the underlying source's {@link UnderlyingSource.cancel | cancel()}
         * method, which might or might not use it.
         */ ReadableStream.prototype.cancel = function(reason) {
            if (reason === void 0) {
                reason = undefined;
            }
            if (!IsReadableStream(this)) {
                return promiseRejectedWith(streamBrandCheckException$1("cancel"));
            }
            if (IsReadableStreamLocked(this)) {
                return promiseRejectedWith(new TypeError("Cannot cancel a stream that already has a reader"));
            }
            return ReadableStreamCancel(this, reason);
        };
        ReadableStream.prototype.getReader = function(rawOptions) {
            if (rawOptions === void 0) {
                rawOptions = undefined;
            }
            if (!IsReadableStream(this)) {
                throw streamBrandCheckException$1("getReader");
            }
            var options = convertReaderOptions(rawOptions, "First parameter");
            if (options.mode === undefined) {
                return AcquireReadableStreamDefaultReader(this);
            }
            return AcquireReadableStreamBYOBReader(this);
        };
        ReadableStream.prototype.pipeThrough = function(rawTransform, rawOptions) {
            if (rawOptions === void 0) {
                rawOptions = {};
            }
            if (!IsReadableStream(this)) {
                throw streamBrandCheckException$1("pipeThrough");
            }
            assertRequiredArgument(rawTransform, 1, "pipeThrough");
            var transform = convertReadableWritablePair(rawTransform, "First parameter");
            var options = convertPipeOptions(rawOptions, "Second parameter");
            if (IsReadableStreamLocked(this)) {
                throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");
            }
            if (IsWritableStreamLocked(transform.writable)) {
                throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");
            }
            var promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
            setPromiseIsHandledToTrue(promise);
            return transform.readable;
        };
        ReadableStream.prototype.pipeTo = function(destination, rawOptions) {
            if (rawOptions === void 0) {
                rawOptions = {};
            }
            if (!IsReadableStream(this)) {
                return promiseRejectedWith(streamBrandCheckException$1("pipeTo"));
            }
            if (destination === undefined) {
                return promiseRejectedWith("Parameter 1 is required in 'pipeTo'.");
            }
            if (!IsWritableStream(destination)) {
                return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));
            }
            var options;
            try {
                options = convertPipeOptions(rawOptions, "Second parameter");
            } catch (e) {
                return promiseRejectedWith(e);
            }
            if (IsReadableStreamLocked(this)) {
                return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream"));
            }
            if (IsWritableStreamLocked(destination)) {
                return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream"));
            }
            return ReadableStreamPipeTo(this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
        };
        /**
         * Tees this readable stream, returning a two-element array containing the two resulting branches as
         * new {@link ReadableStream} instances.
         *
         * Teeing a stream will lock it, preventing any other consumer from acquiring a reader.
         * To cancel the stream, cancel both of the resulting branches; a composite cancellation reason will then be
         * propagated to the stream's underlying source.
         *
         * Note that the chunks seen in each branch will be the same object. If the chunks are not immutable,
         * this could allow interference between the two branches.
         */ ReadableStream.prototype.tee = function() {
            if (!IsReadableStream(this)) {
                throw streamBrandCheckException$1("tee");
            }
            var branches = ReadableStreamTee(this);
            return CreateArrayFromList(branches);
        };
        ReadableStream.prototype.values = function(rawOptions) {
            if (rawOptions === void 0) {
                rawOptions = undefined;
            }
            if (!IsReadableStream(this)) {
                throw streamBrandCheckException$1("values");
            }
            var options = convertIteratorOptions(rawOptions, "First parameter");
            return AcquireReadableStreamAsyncIterator(this, options.preventCancel);
        };
        return ReadableStream;
    }();
    Object.defineProperties(ReadableStream.prototype, {
        cancel: {
            enumerable: true
        },
        getReader: {
            enumerable: true
        },
        pipeThrough: {
            enumerable: true
        },
        pipeTo: {
            enumerable: true
        },
        tee: {
            enumerable: true
        },
        values: {
            enumerable: true
        },
        locked: {
            enumerable: true
        }
    });
    if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ReadableStream.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStream",
            configurable: true
        });
    }
    if (typeof SymbolPolyfill.asyncIterator === "symbol") {
        Object.defineProperty(ReadableStream.prototype, SymbolPolyfill.asyncIterator, {
            value: ReadableStream.prototype.values,
            writable: true,
            configurable: true
        });
    }
    // Abstract operations for the ReadableStream.
    // Throws if and only if startAlgorithm throws.
    function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
        if (highWaterMark === void 0) {
            highWaterMark = 1;
        }
        if (sizeAlgorithm === void 0) {
            sizeAlgorithm = function() {
                return 1;
            };
        }
        var stream = Object.create(ReadableStream.prototype);
        InitializeReadableStream(stream);
        var controller = Object.create(ReadableStreamDefaultController.prototype);
        SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
        return stream;
    }
    // Throws if and only if startAlgorithm throws.
    function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {
        var stream = Object.create(ReadableStream.prototype);
        InitializeReadableStream(stream);
        var controller = Object.create(ReadableByteStreamController.prototype);
        SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, undefined);
        return stream;
    }
    function InitializeReadableStream(stream) {
        stream._state = "readable";
        stream._reader = undefined;
        stream._storedError = undefined;
        stream._disturbed = false;
    }
    function IsReadableStream(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_readableStreamController")) {
            return false;
        }
        return x instanceof ReadableStream;
    }
    function IsReadableStreamLocked(stream) {
        if (stream._reader === undefined) {
            return false;
        }
        return true;
    }
    // ReadableStream API exposed for controllers.
    function ReadableStreamCancel(stream, reason) {
        stream._disturbed = true;
        if (stream._state === "closed") {
            return promiseResolvedWith(undefined);
        }
        if (stream._state === "errored") {
            return promiseRejectedWith(stream._storedError);
        }
        ReadableStreamClose(stream);
        var reader = stream._reader;
        if (reader !== undefined && IsReadableStreamBYOBReader(reader)) {
            reader._readIntoRequests.forEach(function(readIntoRequest) {
                readIntoRequest._closeSteps(undefined);
            });
            reader._readIntoRequests = new SimpleQueue();
        }
        var sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);
        return transformPromiseWith(sourceCancelPromise, noop);
    }
    function ReadableStreamClose(stream) {
        stream._state = "closed";
        var reader = stream._reader;
        if (reader === undefined) {
            return;
        }
        defaultReaderClosedPromiseResolve(reader);
        if (IsReadableStreamDefaultReader(reader)) {
            reader._readRequests.forEach(function(readRequest) {
                readRequest._closeSteps();
            });
            reader._readRequests = new SimpleQueue();
        }
    }
    function ReadableStreamError(stream, e) {
        stream._state = "errored";
        stream._storedError = e;
        var reader = stream._reader;
        if (reader === undefined) {
            return;
        }
        defaultReaderClosedPromiseReject(reader, e);
        if (IsReadableStreamDefaultReader(reader)) {
            reader._readRequests.forEach(function(readRequest) {
                readRequest._errorSteps(e);
            });
            reader._readRequests = new SimpleQueue();
        } else {
            reader._readIntoRequests.forEach(function(readIntoRequest) {
                readIntoRequest._errorSteps(e);
            });
            reader._readIntoRequests = new SimpleQueue();
        }
    }
    // Helper functions for the ReadableStream.
    function streamBrandCheckException$1(name) {
        return new TypeError("ReadableStream.prototype." + name + " can only be used on a ReadableStream");
    }
    function convertQueuingStrategyInit(init, context) {
        assertDictionary(init, context);
        var highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;
        assertRequiredField(highWaterMark, "highWaterMark", "QueuingStrategyInit");
        return {
            highWaterMark: convertUnrestrictedDouble(highWaterMark)
        };
    }
    // The size function must not have a prototype property nor be a constructor
    var byteLengthSizeFunction = function(chunk) {
        return chunk.byteLength;
    };
    try {
        Object.defineProperty(byteLengthSizeFunction, "name", {
            value: "size",
            configurable: true
        });
    } catch (_a) {
    // This property is non-configurable in older browsers, so ignore if this throws.
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name#browser_compatibility
    }
    /**
     * A queuing strategy that counts the number of bytes in each chunk.
     *
     * @public
     */ var ByteLengthQueuingStrategy = /** @class */ function() {
        function ByteLengthQueuingStrategy(options) {
            assertRequiredArgument(options, 1, "ByteLengthQueuingStrategy");
            options = convertQueuingStrategyInit(options, "First parameter");
            this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;
        }
        Object.defineProperty(ByteLengthQueuingStrategy.prototype, "highWaterMark", {
            /**
             * Returns the high water mark provided to the constructor.
             */ get: function() {
                if (!IsByteLengthQueuingStrategy(this)) {
                    throw byteLengthBrandCheckException("highWaterMark");
                }
                return this._byteLengthQueuingStrategyHighWaterMark;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ByteLengthQueuingStrategy.prototype, "size", {
            /**
             * Measures the size of `chunk` by returning the value of its `byteLength` property.
             */ get: function() {
                if (!IsByteLengthQueuingStrategy(this)) {
                    throw byteLengthBrandCheckException("size");
                }
                return byteLengthSizeFunction;
            },
            enumerable: false,
            configurable: true
        });
        return ByteLengthQueuingStrategy;
    }();
    Object.defineProperties(ByteLengthQueuingStrategy.prototype, {
        highWaterMark: {
            enumerable: true
        },
        size: {
            enumerable: true
        }
    });
    if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ByteLengthQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
            value: "ByteLengthQueuingStrategy",
            configurable: true
        });
    }
    // Helper functions for the ByteLengthQueuingStrategy.
    function byteLengthBrandCheckException(name) {
        return new TypeError("ByteLengthQueuingStrategy.prototype." + name + " can only be used on a ByteLengthQueuingStrategy");
    }
    function IsByteLengthQueuingStrategy(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_byteLengthQueuingStrategyHighWaterMark")) {
            return false;
        }
        return x instanceof ByteLengthQueuingStrategy;
    }
    // The size function must not have a prototype property nor be a constructor
    var countSizeFunction = function() {
        return 1;
    };
    try {
        Object.defineProperty(countSizeFunction, "name", {
            value: "size",
            configurable: true
        });
    } catch (_a) {
    // This property is non-configurable in older browsers, so ignore if this throws.
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name#browser_compatibility
    }
    /**
     * A queuing strategy that counts the number of chunks.
     *
     * @public
     */ var CountQueuingStrategy = /** @class */ function() {
        function CountQueuingStrategy(options) {
            assertRequiredArgument(options, 1, "CountQueuingStrategy");
            options = convertQueuingStrategyInit(options, "First parameter");
            this._countQueuingStrategyHighWaterMark = options.highWaterMark;
        }
        Object.defineProperty(CountQueuingStrategy.prototype, "highWaterMark", {
            /**
             * Returns the high water mark provided to the constructor.
             */ get: function() {
                if (!IsCountQueuingStrategy(this)) {
                    throw countBrandCheckException("highWaterMark");
                }
                return this._countQueuingStrategyHighWaterMark;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(CountQueuingStrategy.prototype, "size", {
            /**
             * Measures the size of `chunk` by always returning 1.
             * This ensures that the total queue size is a count of the number of chunks in the queue.
             */ get: function() {
                if (!IsCountQueuingStrategy(this)) {
                    throw countBrandCheckException("size");
                }
                return countSizeFunction;
            },
            enumerable: false,
            configurable: true
        });
        return CountQueuingStrategy;
    }();
    Object.defineProperties(CountQueuingStrategy.prototype, {
        highWaterMark: {
            enumerable: true
        },
        size: {
            enumerable: true
        }
    });
    if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(CountQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
            value: "CountQueuingStrategy",
            configurable: true
        });
    }
    // Helper functions for the CountQueuingStrategy.
    function countBrandCheckException(name) {
        return new TypeError("CountQueuingStrategy.prototype." + name + " can only be used on a CountQueuingStrategy");
    }
    function IsCountQueuingStrategy(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_countQueuingStrategyHighWaterMark")) {
            return false;
        }
        return x instanceof CountQueuingStrategy;
    }
    function convertTransformer(original, context) {
        assertDictionary(original, context);
        var flush = original === null || original === void 0 ? void 0 : original.flush;
        var readableType = original === null || original === void 0 ? void 0 : original.readableType;
        var start = original === null || original === void 0 ? void 0 : original.start;
        var transform = original === null || original === void 0 ? void 0 : original.transform;
        var writableType = original === null || original === void 0 ? void 0 : original.writableType;
        return {
            flush: flush === undefined ? undefined : convertTransformerFlushCallback(flush, original, context + " has member 'flush' that"),
            readableType: readableType,
            start: start === undefined ? undefined : convertTransformerStartCallback(start, original, context + " has member 'start' that"),
            transform: transform === undefined ? undefined : convertTransformerTransformCallback(transform, original, context + " has member 'transform' that"),
            writableType: writableType
        };
    }
    function convertTransformerFlushCallback(fn, original, context) {
        assertFunction(fn, context);
        return function(controller) {
            return promiseCall(fn, original, [
                controller
            ]);
        };
    }
    function convertTransformerStartCallback(fn, original, context) {
        assertFunction(fn, context);
        return function(controller) {
            return reflectCall(fn, original, [
                controller
            ]);
        };
    }
    function convertTransformerTransformCallback(fn, original, context) {
        assertFunction(fn, context);
        return function(chunk, controller) {
            return promiseCall(fn, original, [
                chunk,
                controller
            ]);
        };
    }
    // Class TransformStream
    /**
     * A transform stream consists of a pair of streams: a {@link WritableStream | writable stream},
     * known as its writable side, and a {@link ReadableStream | readable stream}, known as its readable side.
     * In a manner specific to the transform stream in question, writes to the writable side result in new data being
     * made available for reading from the readable side.
     *
     * @public
     */ var TransformStream = /** @class */ function() {
        function TransformStream(rawTransformer, rawWritableStrategy, rawReadableStrategy) {
            if (rawTransformer === void 0) {
                rawTransformer = {};
            }
            if (rawWritableStrategy === void 0) {
                rawWritableStrategy = {};
            }
            if (rawReadableStrategy === void 0) {
                rawReadableStrategy = {};
            }
            if (rawTransformer === undefined) {
                rawTransformer = null;
            }
            var writableStrategy = convertQueuingStrategy(rawWritableStrategy, "Second parameter");
            var readableStrategy = convertQueuingStrategy(rawReadableStrategy, "Third parameter");
            var transformer = convertTransformer(rawTransformer, "First parameter");
            if (transformer.readableType !== undefined) {
                throw new RangeError("Invalid readableType specified");
            }
            if (transformer.writableType !== undefined) {
                throw new RangeError("Invalid writableType specified");
            }
            var readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);
            var readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);
            var writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);
            var writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);
            var startPromise_resolve;
            var startPromise = newPromise(function(resolve) {
                startPromise_resolve = resolve;
            });
            InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
            SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);
            if (transformer.start !== undefined) {
                startPromise_resolve(transformer.start(this._transformStreamController));
            } else {
                startPromise_resolve(undefined);
            }
        }
        Object.defineProperty(TransformStream.prototype, "readable", {
            /**
             * The readable side of the transform stream.
             */ get: function() {
                if (!IsTransformStream(this)) {
                    throw streamBrandCheckException("readable");
                }
                return this._readable;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TransformStream.prototype, "writable", {
            /**
             * The writable side of the transform stream.
             */ get: function() {
                if (!IsTransformStream(this)) {
                    throw streamBrandCheckException("writable");
                }
                return this._writable;
            },
            enumerable: false,
            configurable: true
        });
        return TransformStream;
    }();
    Object.defineProperties(TransformStream.prototype, {
        readable: {
            enumerable: true
        },
        writable: {
            enumerable: true
        }
    });
    if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(TransformStream.prototype, SymbolPolyfill.toStringTag, {
            value: "TransformStream",
            configurable: true
        });
    }
    function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {
        function startAlgorithm() {
            return startPromise;
        }
        function writeAlgorithm(chunk) {
            return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);
        }
        function abortAlgorithm(reason) {
            return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);
        }
        function closeAlgorithm() {
            return TransformStreamDefaultSinkCloseAlgorithm(stream);
        }
        stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);
        function pullAlgorithm() {
            return TransformStreamDefaultSourcePullAlgorithm(stream);
        }
        function cancelAlgorithm(reason) {
            TransformStreamErrorWritableAndUnblockWrite(stream, reason);
            return promiseResolvedWith(undefined);
        }
        stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
        // The [[backpressure]] slot is set to undefined so that it can be initialised by TransformStreamSetBackpressure.
        stream._backpressure = undefined;
        stream._backpressureChangePromise = undefined;
        stream._backpressureChangePromise_resolve = undefined;
        TransformStreamSetBackpressure(stream, true);
        stream._transformStreamController = undefined;
    }
    function IsTransformStream(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_transformStreamController")) {
            return false;
        }
        return x instanceof TransformStream;
    }
    // This is a no-op if both sides are already errored.
    function TransformStreamError(stream, e) {
        ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e);
        TransformStreamErrorWritableAndUnblockWrite(stream, e);
    }
    function TransformStreamErrorWritableAndUnblockWrite(stream, e) {
        TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);
        WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);
        if (stream._backpressure) {
            // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()
            // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time
            // _backpressure is set.
            TransformStreamSetBackpressure(stream, false);
        }
    }
    function TransformStreamSetBackpressure(stream, backpressure) {
        // Passes also when called during construction.
        if (stream._backpressureChangePromise !== undefined) {
            stream._backpressureChangePromise_resolve();
        }
        stream._backpressureChangePromise = newPromise(function(resolve) {
            stream._backpressureChangePromise_resolve = resolve;
        });
        stream._backpressure = backpressure;
    }
    // Class TransformStreamDefaultController
    /**
     * Allows control of the {@link ReadableStream} and {@link WritableStream} of the associated {@link TransformStream}.
     *
     * @public
     */ var TransformStreamDefaultController = /** @class */ function() {
        function TransformStreamDefaultController() {
            throw new TypeError("Illegal constructor");
        }
        Object.defineProperty(TransformStreamDefaultController.prototype, "desiredSize", {
            /**
             * Returns the desired size to fill the readable sides internal queue. It can be negative, if the queue is over-full.
             */ get: function() {
                if (!IsTransformStreamDefaultController(this)) {
                    throw defaultControllerBrandCheckException("desiredSize");
                }
                var readableController = this._controlledTransformStream._readable._readableStreamController;
                return ReadableStreamDefaultControllerGetDesiredSize(readableController);
            },
            enumerable: false,
            configurable: true
        });
        TransformStreamDefaultController.prototype.enqueue = function(chunk) {
            if (chunk === void 0) {
                chunk = undefined;
            }
            if (!IsTransformStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException("enqueue");
            }
            TransformStreamDefaultControllerEnqueue(this, chunk);
        };
        /**
         * Errors both the readable side and the writable side of the controlled transform stream, making all future
         * interactions with it fail with the given error `e`. Any chunks queued for transformation will be discarded.
         */ TransformStreamDefaultController.prototype.error = function(reason) {
            if (reason === void 0) {
                reason = undefined;
            }
            if (!IsTransformStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException("error");
            }
            TransformStreamDefaultControllerError(this, reason);
        };
        /**
         * Closes the readable side and errors the writable side of the controlled transform stream. This is useful when the
         * transformer only needs to consume a portion of the chunks written to the writable side.
         */ TransformStreamDefaultController.prototype.terminate = function() {
            if (!IsTransformStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException("terminate");
            }
            TransformStreamDefaultControllerTerminate(this);
        };
        return TransformStreamDefaultController;
    }();
    Object.defineProperties(TransformStreamDefaultController.prototype, {
        enqueue: {
            enumerable: true
        },
        error: {
            enumerable: true
        },
        terminate: {
            enumerable: true
        },
        desiredSize: {
            enumerable: true
        }
    });
    if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(TransformStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
            value: "TransformStreamDefaultController",
            configurable: true
        });
    }
    // Transform Stream Default Controller Abstract Operations
    function IsTransformStreamDefaultController(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_controlledTransformStream")) {
            return false;
        }
        return x instanceof TransformStreamDefaultController;
    }
    function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {
        controller._controlledTransformStream = stream;
        stream._transformStreamController = controller;
        controller._transformAlgorithm = transformAlgorithm;
        controller._flushAlgorithm = flushAlgorithm;
    }
    function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {
        var controller = Object.create(TransformStreamDefaultController.prototype);
        var transformAlgorithm = function(chunk) {
            try {
                TransformStreamDefaultControllerEnqueue(controller, chunk);
                return promiseResolvedWith(undefined);
            } catch (transformResultE) {
                return promiseRejectedWith(transformResultE);
            }
        };
        var flushAlgorithm = function() {
            return promiseResolvedWith(undefined);
        };
        if (transformer.transform !== undefined) {
            transformAlgorithm = function(chunk) {
                return transformer.transform(chunk, controller);
            };
        }
        if (transformer.flush !== undefined) {
            flushAlgorithm = function() {
                return transformer.flush(controller);
            };
        }
        SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);
    }
    function TransformStreamDefaultControllerClearAlgorithms(controller) {
        controller._transformAlgorithm = undefined;
        controller._flushAlgorithm = undefined;
    }
    function TransformStreamDefaultControllerEnqueue(controller, chunk) {
        var stream = controller._controlledTransformStream;
        var readableController = stream._readable._readableStreamController;
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {
            throw new TypeError("Readable side is not in a state that permits enqueue");
        }
        // We throttle transform invocations based on the backpressure of the ReadableStream, but we still
        // accept TransformStreamDefaultControllerEnqueue() calls.
        try {
            ReadableStreamDefaultControllerEnqueue(readableController, chunk);
        } catch (e) {
            // This happens when readableStrategy.size() throws.
            TransformStreamErrorWritableAndUnblockWrite(stream, e);
            throw stream._readable._storedError;
        }
        var backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);
        if (backpressure !== stream._backpressure) {
            TransformStreamSetBackpressure(stream, true);
        }
    }
    function TransformStreamDefaultControllerError(controller, e) {
        TransformStreamError(controller._controlledTransformStream, e);
    }
    function TransformStreamDefaultControllerPerformTransform(controller, chunk) {
        var transformPromise = controller._transformAlgorithm(chunk);
        return transformPromiseWith(transformPromise, undefined, function(r) {
            TransformStreamError(controller._controlledTransformStream, r);
            throw r;
        });
    }
    function TransformStreamDefaultControllerTerminate(controller) {
        var stream = controller._controlledTransformStream;
        var readableController = stream._readable._readableStreamController;
        ReadableStreamDefaultControllerClose(readableController);
        var error = new TypeError("TransformStream terminated");
        TransformStreamErrorWritableAndUnblockWrite(stream, error);
    }
    // TransformStreamDefaultSink Algorithms
    function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {
        var controller = stream._transformStreamController;
        if (stream._backpressure) {
            var backpressureChangePromise = stream._backpressureChangePromise;
            return transformPromiseWith(backpressureChangePromise, function() {
                var writable = stream._writable;
                var state = writable._state;
                if (state === "erroring") {
                    throw writable._storedError;
                }
                return TransformStreamDefaultControllerPerformTransform(controller, chunk);
            });
        }
        return TransformStreamDefaultControllerPerformTransform(controller, chunk);
    }
    function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {
        // abort() is not called synchronously, so it is possible for abort() to be called when the stream is already
        // errored.
        TransformStreamError(stream, reason);
        return promiseResolvedWith(undefined);
    }
    function TransformStreamDefaultSinkCloseAlgorithm(stream) {
        // stream._readable cannot change after construction, so caching it across a call to user code is safe.
        var readable = stream._readable;
        var controller = stream._transformStreamController;
        var flushPromise = controller._flushAlgorithm();
        TransformStreamDefaultControllerClearAlgorithms(controller);
        // Return a promise that is fulfilled with undefined on success.
        return transformPromiseWith(flushPromise, function() {
            if (readable._state === "errored") {
                throw readable._storedError;
            }
            ReadableStreamDefaultControllerClose(readable._readableStreamController);
        }, function(r) {
            TransformStreamError(stream, r);
            throw readable._storedError;
        });
    }
    // TransformStreamDefaultSource Algorithms
    function TransformStreamDefaultSourcePullAlgorithm(stream) {
        // Invariant. Enforced by the promises returned by start() and pull().
        TransformStreamSetBackpressure(stream, false);
        // Prevent the next pull() call until there is backpressure.
        return stream._backpressureChangePromise;
    }
    // Helper functions for the TransformStreamDefaultController.
    function defaultControllerBrandCheckException(name) {
        return new TypeError("TransformStreamDefaultController.prototype." + name + " can only be used on a TransformStreamDefaultController");
    }
    // Helper functions for the TransformStream.
    function streamBrandCheckException(name) {
        return new TypeError("TransformStream.prototype." + name + " can only be used on a TransformStream");
    }
    exports1.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy;
    exports1.CountQueuingStrategy = CountQueuingStrategy;
    exports1.ReadableByteStreamController = ReadableByteStreamController;
    exports1.ReadableStream = ReadableStream;
    exports1.ReadableStreamBYOBReader = ReadableStreamBYOBReader;
    exports1.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest;
    exports1.ReadableStreamDefaultController = ReadableStreamDefaultController;
    exports1.ReadableStreamDefaultReader = ReadableStreamDefaultReader;
    exports1.TransformStream = TransformStream;
    exports1.TransformStreamDefaultController = TransformStreamDefaultController;
    exports1.WritableStream = WritableStream;
    exports1.WritableStreamDefaultController = WritableStreamDefaultController;
    exports1.WritableStreamDefaultWriter = WritableStreamDefaultWriter;
    Object.defineProperty(exports1, "__esModule", {
        value: true
    });
}); //# sourceMappingURL=ponyfill.js.map


/***/ }),

/***/ 6021:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*!
 Copyright (c) Peculiar Ventures, LLC
*/ 
var pvtsutils = __webpack_require__(480);
var asn1Schema = __webpack_require__(3174);
var tslib = __webpack_require__(4479);
var jsonSchema = __webpack_require__(6066);
var asn1 = __webpack_require__(3457);
function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function(k) {
            if (k !== "default") {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function() {
                        return e[k];
                    }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}
var asn1__namespace = /*#__PURE__*/ _interopNamespaceDefault(asn1);
class CryptoError extends Error {
}
class AlgorithmError extends CryptoError {
}
class UnsupportedOperationError extends CryptoError {
    constructor(methodName){
        super(`Unsupported operation: ${methodName ? `${methodName}` : ""}`);
    }
}
class OperationError extends CryptoError {
}
class RequiredPropertyError extends CryptoError {
    constructor(propName){
        super(`${propName}: Missing required property`);
    }
}
class PemConverter {
    static toArrayBuffer(pem) {
        const base64 = pem.replace(/-{5}(BEGIN|END) .*-{5}/g, "").replace("\r", "").replace("\n", "");
        return pvtsutils.Convert.FromBase64(base64);
    }
    static toUint8Array(pem) {
        const bytes = this.toArrayBuffer(pem);
        return new Uint8Array(bytes);
    }
    static fromBufferSource(buffer, tag) {
        const base64 = pvtsutils.Convert.ToBase64(buffer);
        let sliced;
        let offset = 0;
        const rows = [];
        while(true){
            sliced = base64.slice(offset, offset = offset + 64);
            if (sliced.length) {
                rows.push(sliced);
                if (sliced.length < 64) {
                    break;
                }
            } else {
                break;
            }
        }
        const upperCaseTag = tag.toUpperCase();
        return `-----BEGIN ${upperCaseTag}-----\n${rows.join("\n")}\n-----END ${upperCaseTag}-----`;
    }
    static isPEM(data) {
        return /-----BEGIN .+-----[A-Za-z0-9+\/\+\=\s\n]+-----END .+-----/i.test(data);
    }
    static getTagName(pem) {
        if (!this.isPEM(pem)) {
            throw new Error("Bad parameter. Incoming data is not right PEM");
        }
        const res = /-----BEGIN (.+)-----/.exec(pem);
        if (!res) {
            throw new Error("Cannot get tag from PEM");
        }
        return res[1];
    }
    static hasTagName(pem, tagName) {
        const tag = this.getTagName(pem);
        return tagName.toLowerCase() === tag.toLowerCase();
    }
    static isCertificate(pem) {
        return this.hasTagName(pem, "certificate");
    }
    static isCertificateRequest(pem) {
        return this.hasTagName(pem, "certificate request");
    }
    static isCRL(pem) {
        return this.hasTagName(pem, "x509 crl");
    }
    static isPublicKey(pem) {
        return this.hasTagName(pem, "public key");
    }
}
function isJWK(data) {
    return typeof data === "object" && "kty" in data;
}
class ProviderCrypto {
    async digest(...args) {
        this.checkDigest.apply(this, args);
        return this.onDigest.apply(this, args);
    }
    checkDigest(algorithm, data) {
        this.checkAlgorithmName(algorithm);
    }
    async onDigest(algorithm, data) {
        throw new UnsupportedOperationError("digest");
    }
    async generateKey(...args) {
        this.checkGenerateKey.apply(this, args);
        return this.onGenerateKey.apply(this, args);
    }
    checkGenerateKey(algorithm, extractable, keyUsages, ...args) {
        this.checkAlgorithmName(algorithm);
        this.checkGenerateKeyParams(algorithm);
        if (!(keyUsages && keyUsages.length)) {
            throw new TypeError(`Usages cannot be empty when creating a key.`);
        }
        let allowedUsages;
        if (Array.isArray(this.usages)) {
            allowedUsages = this.usages;
        } else {
            allowedUsages = this.usages.privateKey.concat(this.usages.publicKey);
        }
        this.checkKeyUsages(keyUsages, allowedUsages);
    }
    checkGenerateKeyParams(algorithm) {}
    async onGenerateKey(algorithm, extractable, keyUsages, ...args) {
        throw new UnsupportedOperationError("generateKey");
    }
    async sign(...args) {
        this.checkSign.apply(this, args);
        return this.onSign.apply(this, args);
    }
    checkSign(algorithm, key, data, ...args) {
        this.checkAlgorithmName(algorithm);
        this.checkAlgorithmParams(algorithm);
        this.checkCryptoKey(key, "sign");
    }
    async onSign(algorithm, key, data, ...args) {
        throw new UnsupportedOperationError("sign");
    }
    async verify(...args) {
        this.checkVerify.apply(this, args);
        return this.onVerify.apply(this, args);
    }
    checkVerify(algorithm, key, signature, data, ...args) {
        this.checkAlgorithmName(algorithm);
        this.checkAlgorithmParams(algorithm);
        this.checkCryptoKey(key, "verify");
    }
    async onVerify(algorithm, key, signature, data, ...args) {
        throw new UnsupportedOperationError("verify");
    }
    async encrypt(...args) {
        this.checkEncrypt.apply(this, args);
        return this.onEncrypt.apply(this, args);
    }
    checkEncrypt(algorithm, key, data, options = {}, ...args) {
        this.checkAlgorithmName(algorithm);
        this.checkAlgorithmParams(algorithm);
        this.checkCryptoKey(key, options.keyUsage ? "encrypt" : void 0);
    }
    async onEncrypt(algorithm, key, data, ...args) {
        throw new UnsupportedOperationError("encrypt");
    }
    async decrypt(...args) {
        this.checkDecrypt.apply(this, args);
        return this.onDecrypt.apply(this, args);
    }
    checkDecrypt(algorithm, key, data, options = {}, ...args) {
        this.checkAlgorithmName(algorithm);
        this.checkAlgorithmParams(algorithm);
        this.checkCryptoKey(key, options.keyUsage ? "decrypt" : void 0);
    }
    async onDecrypt(algorithm, key, data, ...args) {
        throw new UnsupportedOperationError("decrypt");
    }
    async deriveBits(...args) {
        this.checkDeriveBits.apply(this, args);
        return this.onDeriveBits.apply(this, args);
    }
    checkDeriveBits(algorithm, baseKey, length, options = {}, ...args) {
        this.checkAlgorithmName(algorithm);
        this.checkAlgorithmParams(algorithm);
        this.checkCryptoKey(baseKey, options.keyUsage ? "deriveBits" : void 0);
        if (length % 8 !== 0) {
            throw new OperationError("length: Is not multiple of 8");
        }
    }
    async onDeriveBits(algorithm, baseKey, length, ...args) {
        throw new UnsupportedOperationError("deriveBits");
    }
    async exportKey(...args) {
        this.checkExportKey.apply(this, args);
        return this.onExportKey.apply(this, args);
    }
    checkExportKey(format, key, ...args) {
        this.checkKeyFormat(format);
        this.checkCryptoKey(key);
        if (!key.extractable) {
            throw new CryptoError("key: Is not extractable");
        }
    }
    async onExportKey(format, key, ...args) {
        throw new UnsupportedOperationError("exportKey");
    }
    async importKey(...args) {
        this.checkImportKey.apply(this, args);
        return this.onImportKey.apply(this, args);
    }
    checkImportKey(format, keyData, algorithm, extractable, keyUsages, ...args) {
        this.checkKeyFormat(format);
        this.checkKeyData(format, keyData);
        this.checkAlgorithmName(algorithm);
        this.checkImportParams(algorithm);
        if (Array.isArray(this.usages)) {
            this.checkKeyUsages(keyUsages, this.usages);
        }
    }
    async onImportKey(format, keyData, algorithm, extractable, keyUsages, ...args) {
        throw new UnsupportedOperationError("importKey");
    }
    checkAlgorithmName(algorithm) {
        if (algorithm.name.toLowerCase() !== this.name.toLowerCase()) {
            throw new AlgorithmError("Unrecognized name");
        }
    }
    checkAlgorithmParams(algorithm) {}
    checkDerivedKeyParams(algorithm) {}
    checkKeyUsages(usages, allowed) {
        for (const usage of usages){
            if (allowed.indexOf(usage) === -1) {
                throw new TypeError("Cannot create a key using the specified key usages");
            }
        }
    }
    checkCryptoKey(key, keyUsage) {
        this.checkAlgorithmName(key.algorithm);
        if (keyUsage && key.usages.indexOf(keyUsage) === -1) {
            throw new CryptoError(`key does not match that of operation`);
        }
    }
    checkRequiredProperty(data, propName) {
        if (!(propName in data)) {
            throw new RequiredPropertyError(propName);
        }
    }
    checkHashAlgorithm(algorithm, hashAlgorithms) {
        for (const item of hashAlgorithms){
            if (item.toLowerCase() === algorithm.name.toLowerCase()) {
                return;
            }
        }
        throw new OperationError(`hash: Must be one of ${hashAlgorithms.join(", ")}`);
    }
    checkImportParams(algorithm) {}
    checkKeyFormat(format) {
        switch(format){
            case "raw":
            case "pkcs8":
            case "spki":
            case "jwk":
                break;
            default:
                throw new TypeError("format: Is invalid value. Must be 'jwk', 'raw', 'spki', or 'pkcs8'");
        }
    }
    checkKeyData(format, keyData) {
        if (!keyData) {
            throw new TypeError("keyData: Cannot be empty on empty on key importing");
        }
        if (format === "jwk") {
            if (!isJWK(keyData)) {
                throw new TypeError("keyData: Is not JsonWebToken");
            }
        } else if (!pvtsutils.BufferSourceConverter.isBufferSource(keyData)) {
            throw new TypeError("keyData: Is not ArrayBufferView or ArrayBuffer");
        }
    }
    prepareData(data) {
        return pvtsutils.BufferSourceConverter.toArrayBuffer(data);
    }
}
class AesProvider extends ProviderCrypto {
    checkGenerateKeyParams(algorithm) {
        this.checkRequiredProperty(algorithm, "length");
        if (typeof algorithm.length !== "number") {
            throw new TypeError("length: Is not of type Number");
        }
        switch(algorithm.length){
            case 128:
            case 192:
            case 256:
                break;
            default:
                throw new TypeError("length: Must be 128, 192, or 256");
        }
    }
    checkDerivedKeyParams(algorithm) {
        this.checkGenerateKeyParams(algorithm);
    }
}
class AesCbcProvider extends AesProvider {
    constructor(){
        super(...arguments);
        this.name = "AES-CBC";
        this.usages = [
            "encrypt",
            "decrypt",
            "wrapKey",
            "unwrapKey"
        ];
    }
    checkAlgorithmParams(algorithm) {
        this.checkRequiredProperty(algorithm, "iv");
        if (!(algorithm.iv instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.iv))) {
            throw new TypeError("iv: Is not of type '(ArrayBuffer or ArrayBufferView)'");
        }
        if (algorithm.iv.byteLength !== 16) {
            throw new TypeError("iv: Must have length 16 bytes");
        }
    }
}
class AesCmacProvider extends AesProvider {
    constructor(){
        super(...arguments);
        this.name = "AES-CMAC";
        this.usages = [
            "sign",
            "verify"
        ];
    }
    checkAlgorithmParams(algorithm) {
        this.checkRequiredProperty(algorithm, "length");
        if (typeof algorithm.length !== "number") {
            throw new TypeError("length: Is not a Number");
        }
        if (algorithm.length < 1) {
            throw new OperationError("length: Must be more than 0");
        }
    }
}
class AesCtrProvider extends AesProvider {
    constructor(){
        super(...arguments);
        this.name = "AES-CTR";
        this.usages = [
            "encrypt",
            "decrypt",
            "wrapKey",
            "unwrapKey"
        ];
    }
    checkAlgorithmParams(algorithm) {
        this.checkRequiredProperty(algorithm, "counter");
        if (!(algorithm.counter instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.counter))) {
            throw new TypeError("counter: Is not of type '(ArrayBuffer or ArrayBufferView)'");
        }
        if (algorithm.counter.byteLength !== 16) {
            throw new TypeError("iv: Must have length 16 bytes");
        }
        this.checkRequiredProperty(algorithm, "length");
        if (typeof algorithm.length !== "number") {
            throw new TypeError("length: Is not a Number");
        }
        if (algorithm.length < 1) {
            throw new OperationError("length: Must be more than 0");
        }
    }
}
class AesEcbProvider extends AesProvider {
    constructor(){
        super(...arguments);
        this.name = "AES-ECB";
        this.usages = [
            "encrypt",
            "decrypt",
            "wrapKey",
            "unwrapKey"
        ];
    }
}
class AesGcmProvider extends AesProvider {
    constructor(){
        super(...arguments);
        this.name = "AES-GCM";
        this.usages = [
            "encrypt",
            "decrypt",
            "wrapKey",
            "unwrapKey"
        ];
    }
    checkAlgorithmParams(algorithm) {
        this.checkRequiredProperty(algorithm, "iv");
        if (!(algorithm.iv instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.iv))) {
            throw new TypeError("iv: Is not of type '(ArrayBuffer or ArrayBufferView)'");
        }
        if (algorithm.iv.byteLength < 1) {
            throw new OperationError("iv: Must have length more than 0 and less than 2^64 - 1");
        }
        if (!("tagLength" in algorithm)) {
            algorithm.tagLength = 128;
        }
        switch(algorithm.tagLength){
            case 32:
            case 64:
            case 96:
            case 104:
            case 112:
            case 120:
            case 128:
                break;
            default:
                throw new OperationError("tagLength: Must be one of 32, 64, 96, 104, 112, 120 or 128");
        }
    }
}
class AesKwProvider extends AesProvider {
    constructor(){
        super(...arguments);
        this.name = "AES-KW";
        this.usages = [
            "wrapKey",
            "unwrapKey"
        ];
    }
}
class DesProvider extends ProviderCrypto {
    constructor(){
        super(...arguments);
        this.usages = [
            "encrypt",
            "decrypt",
            "wrapKey",
            "unwrapKey"
        ];
    }
    checkAlgorithmParams(algorithm) {
        if (this.ivSize) {
            this.checkRequiredProperty(algorithm, "iv");
            if (!(algorithm.iv instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.iv))) {
                throw new TypeError("iv: Is not of type '(ArrayBuffer or ArrayBufferView)'");
            }
            if (algorithm.iv.byteLength !== this.ivSize) {
                throw new TypeError(`iv: Must have length ${this.ivSize} bytes`);
            }
        }
    }
    checkGenerateKeyParams(algorithm) {
        this.checkRequiredProperty(algorithm, "length");
        if (typeof algorithm.length !== "number") {
            throw new TypeError("length: Is not of type Number");
        }
        if (algorithm.length !== this.keySizeBits) {
            throw new OperationError(`algorithm.length: Must be ${this.keySizeBits}`);
        }
    }
    checkDerivedKeyParams(algorithm) {
        this.checkGenerateKeyParams(algorithm);
    }
}
class RsaProvider extends ProviderCrypto {
    constructor(){
        super(...arguments);
        this.hashAlgorithms = [
            "SHA-1",
            "SHA-256",
            "SHA-384",
            "SHA-512"
        ];
    }
    checkGenerateKeyParams(algorithm) {
        this.checkRequiredProperty(algorithm, "hash");
        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);
        this.checkRequiredProperty(algorithm, "publicExponent");
        if (!(algorithm.publicExponent && algorithm.publicExponent instanceof Uint8Array)) {
            throw new TypeError("publicExponent: Missing or not a Uint8Array");
        }
        const publicExponent = pvtsutils.Convert.ToBase64(algorithm.publicExponent);
        if (!(publicExponent === "Aw==" || publicExponent === "AQAB")) {
            throw new TypeError("publicExponent: Must be [3] or [1,0,1]");
        }
        this.checkRequiredProperty(algorithm, "modulusLength");
        if (algorithm.modulusLength % 8 || algorithm.modulusLength < 256 || algorithm.modulusLength > 16384) {
            throw new TypeError("The modulus length must be a multiple of 8 bits and >= 256 and <= 16384");
        }
    }
    checkImportParams(algorithm) {
        this.checkRequiredProperty(algorithm, "hash");
        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);
    }
}
class RsaSsaProvider extends RsaProvider {
    constructor(){
        super(...arguments);
        this.name = "RSASSA-PKCS1-v1_5";
        this.usages = {
            privateKey: [
                "sign"
            ],
            publicKey: [
                "verify"
            ]
        };
    }
}
class RsaPssProvider extends RsaProvider {
    constructor(){
        super(...arguments);
        this.name = "RSA-PSS";
        this.usages = {
            privateKey: [
                "sign"
            ],
            publicKey: [
                "verify"
            ]
        };
    }
    checkAlgorithmParams(algorithm) {
        this.checkRequiredProperty(algorithm, "saltLength");
        if (typeof algorithm.saltLength !== "number") {
            throw new TypeError("saltLength: Is not a Number");
        }
        if (algorithm.saltLength < 0) {
            throw new RangeError("saltLength: Must be positive number");
        }
    }
}
class RsaOaepProvider extends RsaProvider {
    constructor(){
        super(...arguments);
        this.name = "RSA-OAEP";
        this.usages = {
            privateKey: [
                "decrypt",
                "unwrapKey"
            ],
            publicKey: [
                "encrypt",
                "wrapKey"
            ]
        };
    }
    checkAlgorithmParams(algorithm) {
        if (algorithm.label && !(algorithm.label instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.label))) {
            throw new TypeError("label: Is not of type '(ArrayBuffer or ArrayBufferView)'");
        }
    }
}
class EllipticProvider extends ProviderCrypto {
    checkGenerateKeyParams(algorithm) {
        this.checkRequiredProperty(algorithm, "namedCurve");
        this.checkNamedCurve(algorithm.namedCurve);
    }
    checkNamedCurve(namedCurve) {
        for (const item of this.namedCurves){
            if (item.toLowerCase() === namedCurve.toLowerCase()) {
                return;
            }
        }
        throw new OperationError(`namedCurve: Must be one of ${this.namedCurves.join(", ")}`);
    }
}
class EcdsaProvider extends EllipticProvider {
    constructor(){
        super(...arguments);
        this.name = "ECDSA";
        this.hashAlgorithms = [
            "SHA-1",
            "SHA-256",
            "SHA-384",
            "SHA-512"
        ];
        this.usages = {
            privateKey: [
                "sign"
            ],
            publicKey: [
                "verify"
            ]
        };
        this.namedCurves = [
            "P-256",
            "P-384",
            "P-521",
            "K-256"
        ];
    }
    checkAlgorithmParams(algorithm) {
        this.checkRequiredProperty(algorithm, "hash");
        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);
    }
}
const KEY_TYPES = [
    "secret",
    "private",
    "public"
];
class CryptoKey {
    static create(algorithm, type, extractable, usages) {
        const key = new this();
        key.algorithm = algorithm;
        key.type = type;
        key.extractable = extractable;
        key.usages = usages;
        return key;
    }
    static isKeyType(data) {
        return KEY_TYPES.indexOf(data) !== -1;
    }
    get [Symbol.toStringTag]() {
        return "CryptoKey";
    }
}
class EcdhProvider extends EllipticProvider {
    constructor(){
        super(...arguments);
        this.name = "ECDH";
        this.usages = {
            privateKey: [
                "deriveBits",
                "deriveKey"
            ],
            publicKey: []
        };
        this.namedCurves = [
            "P-256",
            "P-384",
            "P-521",
            "K-256"
        ];
    }
    checkAlgorithmParams(algorithm) {
        this.checkRequiredProperty(algorithm, "public");
        if (!(algorithm.public instanceof CryptoKey)) {
            throw new TypeError("public: Is not a CryptoKey");
        }
        if (algorithm.public.type !== "public") {
            throw new OperationError("public: Is not a public key");
        }
        if (algorithm.public.algorithm.name !== this.name) {
            throw new OperationError(`public: Is not ${this.name} key`);
        }
    }
}
class EcdhEsProvider extends EcdhProvider {
    constructor(){
        super(...arguments);
        this.name = "ECDH-ES";
        this.namedCurves = [
            "X25519",
            "X448"
        ];
    }
}
class EdDsaProvider extends EllipticProvider {
    constructor(){
        super(...arguments);
        this.name = "EdDSA";
        this.usages = {
            privateKey: [
                "sign"
            ],
            publicKey: [
                "verify"
            ]
        };
        this.namedCurves = [
            "Ed25519",
            "Ed448"
        ];
    }
}
let ObjectIdentifier = class ObjectIdentifier {
    constructor(value){
        if (value) {
            this.value = value;
        }
    }
};
tslib.__decorate([
    asn1Schema.AsnProp({
        type: asn1Schema.AsnPropTypes.ObjectIdentifier
    })
], ObjectIdentifier.prototype, "value", void 0);
ObjectIdentifier = tslib.__decorate([
    asn1Schema.AsnType({
        type: asn1Schema.AsnTypeTypes.Choice
    })
], ObjectIdentifier);
class AlgorithmIdentifier {
    constructor(params){
        Object.assign(this, params);
    }
}
tslib.__decorate([
    asn1Schema.AsnProp({
        type: asn1Schema.AsnPropTypes.ObjectIdentifier
    })
], AlgorithmIdentifier.prototype, "algorithm", void 0);
tslib.__decorate([
    asn1Schema.AsnProp({
        type: asn1Schema.AsnPropTypes.Any,
        optional: true
    })
], AlgorithmIdentifier.prototype, "parameters", void 0);
class PrivateKeyInfo {
    constructor(){
        this.version = 0;
        this.privateKeyAlgorithm = new AlgorithmIdentifier();
        this.privateKey = new ArrayBuffer(0);
    }
}
tslib.__decorate([
    asn1Schema.AsnProp({
        type: asn1Schema.AsnPropTypes.Integer
    })
], PrivateKeyInfo.prototype, "version", void 0);
tslib.__decorate([
    asn1Schema.AsnProp({
        type: AlgorithmIdentifier
    })
], PrivateKeyInfo.prototype, "privateKeyAlgorithm", void 0);
tslib.__decorate([
    asn1Schema.AsnProp({
        type: asn1Schema.AsnPropTypes.OctetString
    })
], PrivateKeyInfo.prototype, "privateKey", void 0);
tslib.__decorate([
    asn1Schema.AsnProp({
        type: asn1Schema.AsnPropTypes.Any,
        optional: true
    })
], PrivateKeyInfo.prototype, "attributes", void 0);
class PublicKeyInfo {
    constructor(){
        this.publicKeyAlgorithm = new AlgorithmIdentifier();
        this.publicKey = new ArrayBuffer(0);
    }
}
tslib.__decorate([
    asn1Schema.AsnProp({
        type: AlgorithmIdentifier
    })
], PublicKeyInfo.prototype, "publicKeyAlgorithm", void 0);
tslib.__decorate([
    asn1Schema.AsnProp({
        type: asn1Schema.AsnPropTypes.BitString
    })
], PublicKeyInfo.prototype, "publicKey", void 0);
const JsonBase64UrlArrayBufferConverter = {
    fromJSON: (value)=>pvtsutils.Convert.FromBase64Url(value),
    toJSON: (value)=>pvtsutils.Convert.ToBase64Url(new Uint8Array(value))
};
const AsnIntegerArrayBufferConverter = {
    fromASN: (value)=>{
        const valueHex = value.valueBlock.valueHex;
        return !new Uint8Array(valueHex)[0] ? value.valueBlock.valueHex.slice(1) : value.valueBlock.valueHex;
    },
    toASN: (value)=>{
        const valueHex = new Uint8Array(value)[0] > 127 ? pvtsutils.combine(new Uint8Array([
            0
        ]).buffer, value) : value;
        return new asn1__namespace.Integer({
            valueHex
        });
    }
};
var index$3 = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    AsnIntegerArrayBufferConverter: AsnIntegerArrayBufferConverter,
    JsonBase64UrlArrayBufferConverter: JsonBase64UrlArrayBufferConverter
});
class RsaPrivateKey {
    constructor(){
        this.version = 0;
        this.modulus = new ArrayBuffer(0);
        this.publicExponent = new ArrayBuffer(0);
        this.privateExponent = new ArrayBuffer(0);
        this.prime1 = new ArrayBuffer(0);
        this.prime2 = new ArrayBuffer(0);
        this.exponent1 = new ArrayBuffer(0);
        this.exponent2 = new ArrayBuffer(0);
        this.coefficient = new ArrayBuffer(0);
    }
}
tslib.__decorate([
    asn1Schema.AsnProp({
        type: asn1Schema.AsnPropTypes.Integer,
        converter: asn1Schema.AsnIntegerConverter
    })
], RsaPrivateKey.prototype, "version", void 0);
tslib.__decorate([
    asn1Schema.AsnProp({
        type: asn1Schema.AsnPropTypes.Integer,
        converter: AsnIntegerArrayBufferConverter
    }),
    jsonSchema.JsonProp({
        name: "n",
        converter: JsonBase64UrlArrayBufferConverter
    })
], RsaPrivateKey.prototype, "modulus", void 0);
tslib.__decorate([
    asn1Schema.AsnProp({
        type: asn1Schema.AsnPropTypes.Integer,
        converter: AsnIntegerArrayBufferConverter
    }),
    jsonSchema.JsonProp({
        name: "e",
        converter: JsonBase64UrlArrayBufferConverter
    })
], RsaPrivateKey.prototype, "publicExponent", void 0);
tslib.__decorate([
    asn1Schema.AsnProp({
        type: asn1Schema.AsnPropTypes.Integer,
        converter: AsnIntegerArrayBufferConverter
    }),
    jsonSchema.JsonProp({
        name: "d",
        converter: JsonBase64UrlArrayBufferConverter
    })
], RsaPrivateKey.prototype, "privateExponent", void 0);
tslib.__decorate([
    asn1Schema.AsnProp({
        type: asn1Schema.AsnPropTypes.Integer,
        converter: AsnIntegerArrayBufferConverter
    }),
    jsonSchema.JsonProp({
        name: "p",
        converter: JsonBase64UrlArrayBufferConverter
    })
], RsaPrivateKey.prototype, "prime1", void 0);
tslib.__decorate([
    asn1Schema.AsnProp({
        type: asn1Schema.AsnPropTypes.Integer,
        converter: AsnIntegerArrayBufferConverter
    }),
    jsonSchema.JsonProp({
        name: "q",
        converter: JsonBase64UrlArrayBufferConverter
    })
], RsaPrivateKey.prototype, "prime2", void 0);
tslib.__decorate([
    asn1Schema.AsnProp({
        type: asn1Schema.AsnPropTypes.Integer,
        converter: AsnIntegerArrayBufferConverter
    }),
    jsonSchema.JsonProp({
        name: "dp",
        converter: JsonBase64UrlArrayBufferConverter
    })
], RsaPrivateKey.prototype, "exponent1", void 0);
tslib.__decorate([
    asn1Schema.AsnProp({
        type: asn1Schema.AsnPropTypes.Integer,
        converter: AsnIntegerArrayBufferConverter
    }),
    jsonSchema.JsonProp({
        name: "dq",
        converter: JsonBase64UrlArrayBufferConverter
    })
], RsaPrivateKey.prototype, "exponent2", void 0);
tslib.__decorate([
    asn1Schema.AsnProp({
        type: asn1Schema.AsnPropTypes.Integer,
        converter: AsnIntegerArrayBufferConverter
    }),
    jsonSchema.JsonProp({
        name: "qi",
        converter: JsonBase64UrlArrayBufferConverter
    })
], RsaPrivateKey.prototype, "coefficient", void 0);
tslib.__decorate([
    asn1Schema.AsnProp({
        type: asn1Schema.AsnPropTypes.Any,
        optional: true
    })
], RsaPrivateKey.prototype, "otherPrimeInfos", void 0);
class RsaPublicKey {
    constructor(){
        this.modulus = new ArrayBuffer(0);
        this.publicExponent = new ArrayBuffer(0);
    }
}
tslib.__decorate([
    asn1Schema.AsnProp({
        type: asn1Schema.AsnPropTypes.Integer,
        converter: AsnIntegerArrayBufferConverter
    }),
    jsonSchema.JsonProp({
        name: "n",
        converter: JsonBase64UrlArrayBufferConverter
    })
], RsaPublicKey.prototype, "modulus", void 0);
tslib.__decorate([
    asn1Schema.AsnProp({
        type: asn1Schema.AsnPropTypes.Integer,
        converter: AsnIntegerArrayBufferConverter
    }),
    jsonSchema.JsonProp({
        name: "e",
        converter: JsonBase64UrlArrayBufferConverter
    })
], RsaPublicKey.prototype, "publicExponent", void 0);
let EcPublicKey = class EcPublicKey {
    constructor(value){
        this.value = new ArrayBuffer(0);
        if (value) {
            this.value = value;
        }
    }
    toJSON() {
        let bytes = new Uint8Array(this.value);
        if (bytes[0] !== 0x04) {
            throw new CryptoError("Wrong ECPoint. Current version supports only Uncompressed (0x04) point");
        }
        bytes = new Uint8Array(this.value.slice(1));
        const size = bytes.length / 2;
        const offset = 0;
        const json = {
            x: pvtsutils.Convert.ToBase64Url(bytes.buffer.slice(offset, offset + size)),
            y: pvtsutils.Convert.ToBase64Url(bytes.buffer.slice(offset + size, offset + size + size))
        };
        return json;
    }
    fromJSON(json) {
        if (!("x" in json)) {
            throw new Error("x: Missing required property");
        }
        if (!("y" in json)) {
            throw new Error("y: Missing required property");
        }
        const x = pvtsutils.Convert.FromBase64Url(json.x);
        const y = pvtsutils.Convert.FromBase64Url(json.y);
        const value = pvtsutils.combine(new Uint8Array([
            0x04
        ]).buffer, x, y);
        this.value = new Uint8Array(value).buffer;
        return this;
    }
};
tslib.__decorate([
    asn1Schema.AsnProp({
        type: asn1Schema.AsnPropTypes.OctetString
    })
], EcPublicKey.prototype, "value", void 0);
EcPublicKey = tslib.__decorate([
    asn1Schema.AsnType({
        type: asn1Schema.AsnTypeTypes.Choice
    })
], EcPublicKey);
class EcPrivateKey {
    constructor(){
        this.version = 1;
        this.privateKey = new ArrayBuffer(0);
    }
    fromJSON(json) {
        if (!("d" in json)) {
            throw new Error("d: Missing required property");
        }
        this.privateKey = pvtsutils.Convert.FromBase64Url(json.d);
        if ("x" in json) {
            const publicKey = new EcPublicKey();
            publicKey.fromJSON(json);
            const asn = asn1Schema.AsnSerializer.toASN(publicKey);
            if ("valueHex" in asn.valueBlock) {
                this.publicKey = asn.valueBlock.valueHex;
            }
        }
        return this;
    }
    toJSON() {
        const jwk = {};
        jwk.d = pvtsutils.Convert.ToBase64Url(this.privateKey);
        if (this.publicKey) {
            Object.assign(jwk, new EcPublicKey(this.publicKey).toJSON());
        }
        return jwk;
    }
}
tslib.__decorate([
    asn1Schema.AsnProp({
        type: asn1Schema.AsnPropTypes.Integer,
        converter: asn1Schema.AsnIntegerConverter
    })
], EcPrivateKey.prototype, "version", void 0);
tslib.__decorate([
    asn1Schema.AsnProp({
        type: asn1Schema.AsnPropTypes.OctetString
    })
], EcPrivateKey.prototype, "privateKey", void 0);
tslib.__decorate([
    asn1Schema.AsnProp({
        context: 0,
        type: asn1Schema.AsnPropTypes.Any,
        optional: true
    })
], EcPrivateKey.prototype, "parameters", void 0);
tslib.__decorate([
    asn1Schema.AsnProp({
        context: 1,
        type: asn1Schema.AsnPropTypes.BitString,
        optional: true
    })
], EcPrivateKey.prototype, "publicKey", void 0);
const AsnIntegerWithoutPaddingConverter = {
    fromASN: (value)=>{
        const bytes = new Uint8Array(value.valueBlock.valueHex);
        return bytes[0] === 0 ? bytes.buffer.slice(1) : bytes.buffer;
    },
    toASN: (value)=>{
        const bytes = new Uint8Array(value);
        if (bytes[0] > 127) {
            const newValue = new Uint8Array(bytes.length + 1);
            newValue.set(bytes, 1);
            return new asn1__namespace.Integer({
                valueHex: newValue.buffer
            });
        }
        return new asn1__namespace.Integer({
            valueHex: value
        });
    }
};
var index$2 = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    AsnIntegerWithoutPaddingConverter: AsnIntegerWithoutPaddingConverter
});
class EcUtils {
    static decodePoint(data, pointSize) {
        const view = pvtsutils.BufferSourceConverter.toUint8Array(data);
        if (view.length === 0 || view[0] !== 4) {
            throw new Error("Only uncompressed point format supported");
        }
        const n = (view.length - 1) / 2;
        if (n !== Math.ceil(pointSize / 8)) {
            throw new Error("Point does not match field size");
        }
        const xb = view.slice(1, n + 1);
        const yb = view.slice(n + 1, n + 1 + n);
        return {
            x: xb,
            y: yb
        };
    }
    static encodePoint(point, pointSize) {
        const size = Math.ceil(pointSize / 8);
        if (point.x.byteLength !== size || point.y.byteLength !== size) {
            throw new Error("X,Y coordinates don't match point size criteria");
        }
        const x = pvtsutils.BufferSourceConverter.toUint8Array(point.x);
        const y = pvtsutils.BufferSourceConverter.toUint8Array(point.y);
        const res = new Uint8Array(size * 2 + 1);
        res[0] = 4;
        res.set(x, 1);
        res.set(y, size + 1);
        return res;
    }
    static getSize(pointSize) {
        return Math.ceil(pointSize / 8);
    }
    static encodeSignature(signature, pointSize) {
        const size = this.getSize(pointSize);
        const r = pvtsutils.BufferSourceConverter.toUint8Array(signature.r);
        const s = pvtsutils.BufferSourceConverter.toUint8Array(signature.s);
        const res = new Uint8Array(size * 2);
        res.set(this.padStart(r, size));
        res.set(this.padStart(s, size), size);
        return res;
    }
    static decodeSignature(data, pointSize) {
        const size = this.getSize(pointSize);
        const view = pvtsutils.BufferSourceConverter.toUint8Array(data);
        if (view.length !== size * 2) {
            throw new Error("Incorrect size of the signature");
        }
        const r = view.slice(0, size);
        const s = view.slice(size);
        return {
            r: this.trimStart(r),
            s: this.trimStart(s)
        };
    }
    static trimStart(data) {
        let i = 0;
        while(i < data.length - 1 && data[i] === 0){
            i++;
        }
        if (i === 0) {
            return data;
        }
        return data.slice(i, data.length);
    }
    static padStart(data, size) {
        if (size === data.length) {
            return data;
        }
        const res = new Uint8Array(size);
        res.set(data, size - data.length);
        return res;
    }
}
class EcDsaSignature {
    constructor(){
        this.r = new ArrayBuffer(0);
        this.s = new ArrayBuffer(0);
    }
    static fromWebCryptoSignature(value) {
        const pointSize = value.byteLength / 2;
        const point = EcUtils.decodeSignature(value, pointSize * 8);
        const ecSignature = new EcDsaSignature();
        ecSignature.r = pvtsutils.BufferSourceConverter.toArrayBuffer(point.r);
        ecSignature.s = pvtsutils.BufferSourceConverter.toArrayBuffer(point.s);
        return ecSignature;
    }
    toWebCryptoSignature(pointSize) {
        pointSize !== null && pointSize !== void 0 ? pointSize : pointSize = Math.max(this.r.byteLength, this.s.byteLength) * 8;
        const signature = EcUtils.encodeSignature(this, pointSize);
        return signature.buffer;
    }
}
tslib.__decorate([
    asn1Schema.AsnProp({
        type: asn1Schema.AsnPropTypes.Integer,
        converter: AsnIntegerWithoutPaddingConverter
    })
], EcDsaSignature.prototype, "r", void 0);
tslib.__decorate([
    asn1Schema.AsnProp({
        type: asn1Schema.AsnPropTypes.Integer,
        converter: AsnIntegerWithoutPaddingConverter
    })
], EcDsaSignature.prototype, "s", void 0);
class OneAsymmetricKey extends PrivateKeyInfo {
}
tslib.__decorate([
    asn1Schema.AsnProp({
        context: 1,
        implicit: true,
        type: asn1Schema.AsnPropTypes.BitString,
        optional: true
    })
], OneAsymmetricKey.prototype, "publicKey", void 0);
let EdPrivateKey = class EdPrivateKey {
    constructor(){
        this.value = new ArrayBuffer(0);
    }
    fromJSON(json) {
        if (!json.d) {
            throw new Error("d: Missing required property");
        }
        this.value = pvtsutils.Convert.FromBase64Url(json.d);
        return this;
    }
    toJSON() {
        const jwk = {
            d: pvtsutils.Convert.ToBase64Url(this.value)
        };
        return jwk;
    }
};
tslib.__decorate([
    asn1Schema.AsnProp({
        type: asn1Schema.AsnPropTypes.OctetString
    })
], EdPrivateKey.prototype, "value", void 0);
EdPrivateKey = tslib.__decorate([
    asn1Schema.AsnType({
        type: asn1Schema.AsnTypeTypes.Choice
    })
], EdPrivateKey);
let EdPublicKey = class EdPublicKey {
    constructor(value){
        this.value = new ArrayBuffer(0);
        if (value) {
            this.value = value;
        }
    }
    toJSON() {
        const json = {
            x: pvtsutils.Convert.ToBase64Url(this.value)
        };
        return json;
    }
    fromJSON(json) {
        if (!("x" in json)) {
            throw new Error("x: Missing required property");
        }
        this.value = pvtsutils.Convert.FromBase64Url(json.x);
        return this;
    }
};
tslib.__decorate([
    asn1Schema.AsnProp({
        type: asn1Schema.AsnPropTypes.BitString
    })
], EdPublicKey.prototype, "value", void 0);
EdPublicKey = tslib.__decorate([
    asn1Schema.AsnType({
        type: asn1Schema.AsnTypeTypes.Choice
    })
], EdPublicKey);
let CurvePrivateKey = class CurvePrivateKey {
};
tslib.__decorate([
    asn1Schema.AsnProp({
        type: asn1Schema.AsnPropTypes.OctetString
    }),
    jsonSchema.JsonProp({
        type: jsonSchema.JsonPropTypes.String,
        converter: JsonBase64UrlArrayBufferConverter
    })
], CurvePrivateKey.prototype, "d", void 0);
CurvePrivateKey = tslib.__decorate([
    asn1Schema.AsnType({
        type: asn1Schema.AsnTypeTypes.Choice
    })
], CurvePrivateKey);
const idSecp256r1 = "1.2.840.10045.3.1.7";
const idEllipticCurve = "1.3.132.0";
const idSecp384r1 = `${idEllipticCurve}.34`;
const idSecp521r1 = `${idEllipticCurve}.35`;
const idSecp256k1 = `${idEllipticCurve}.10`;
const idVersionOne = "1.3.36.3.3.2.8.1.1";
const idBrainpoolP160r1 = `${idVersionOne}.1`;
const idBrainpoolP160t1 = `${idVersionOne}.2`;
const idBrainpoolP192r1 = `${idVersionOne}.3`;
const idBrainpoolP192t1 = `${idVersionOne}.4`;
const idBrainpoolP224r1 = `${idVersionOne}.5`;
const idBrainpoolP224t1 = `${idVersionOne}.6`;
const idBrainpoolP256r1 = `${idVersionOne}.7`;
const idBrainpoolP256t1 = `${idVersionOne}.8`;
const idBrainpoolP320r1 = `${idVersionOne}.9`;
const idBrainpoolP320t1 = `${idVersionOne}.10`;
const idBrainpoolP384r1 = `${idVersionOne}.11`;
const idBrainpoolP384t1 = `${idVersionOne}.12`;
const idBrainpoolP512r1 = `${idVersionOne}.13`;
const idBrainpoolP512t1 = `${idVersionOne}.14`;
const idX25519 = "1.3.101.110";
const idX448 = "1.3.101.111";
const idEd25519 = "1.3.101.112";
const idEd448 = "1.3.101.113";
var index$1 = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    AlgorithmIdentifier: AlgorithmIdentifier,
    get CurvePrivateKey () {
        return CurvePrivateKey;
    },
    EcDsaSignature: EcDsaSignature,
    EcPrivateKey: EcPrivateKey,
    get EcPublicKey () {
        return EcPublicKey;
    },
    get EdPrivateKey () {
        return EdPrivateKey;
    },
    get EdPublicKey () {
        return EdPublicKey;
    },
    get ObjectIdentifier () {
        return ObjectIdentifier;
    },
    OneAsymmetricKey: OneAsymmetricKey,
    PrivateKeyInfo: PrivateKeyInfo,
    PublicKeyInfo: PublicKeyInfo,
    RsaPrivateKey: RsaPrivateKey,
    RsaPublicKey: RsaPublicKey,
    converters: index$2,
    idBrainpoolP160r1: idBrainpoolP160r1,
    idBrainpoolP160t1: idBrainpoolP160t1,
    idBrainpoolP192r1: idBrainpoolP192r1,
    idBrainpoolP192t1: idBrainpoolP192t1,
    idBrainpoolP224r1: idBrainpoolP224r1,
    idBrainpoolP224t1: idBrainpoolP224t1,
    idBrainpoolP256r1: idBrainpoolP256r1,
    idBrainpoolP256t1: idBrainpoolP256t1,
    idBrainpoolP320r1: idBrainpoolP320r1,
    idBrainpoolP320t1: idBrainpoolP320t1,
    idBrainpoolP384r1: idBrainpoolP384r1,
    idBrainpoolP384t1: idBrainpoolP384t1,
    idBrainpoolP512r1: idBrainpoolP512r1,
    idBrainpoolP512t1: idBrainpoolP512t1,
    idEd25519: idEd25519,
    idEd448: idEd448,
    idEllipticCurve: idEllipticCurve,
    idSecp256k1: idSecp256k1,
    idSecp256r1: idSecp256r1,
    idSecp384r1: idSecp384r1,
    idSecp521r1: idSecp521r1,
    idVersionOne: idVersionOne,
    idX25519: idX25519,
    idX448: idX448
});
class EcCurves {
    constructor(){}
    static register(item) {
        const oid = new ObjectIdentifier();
        oid.value = item.id;
        const raw = asn1Schema.AsnConvert.serialize(oid);
        this.items.push({
            ...item,
            raw
        });
        this.names.push(item.name);
    }
    static find(nameOrId) {
        nameOrId = nameOrId.toUpperCase();
        for (const item of this.items){
            if (item.name.toUpperCase() === nameOrId || item.id.toUpperCase() === nameOrId) {
                return item;
            }
        }
        return null;
    }
    static get(nameOrId) {
        const res = this.find(nameOrId);
        if (!res) {
            throw new Error(`Unsupported EC named curve '${nameOrId}'`);
        }
        return res;
    }
}
EcCurves.items = [];
EcCurves.names = [];
EcCurves.register({
    name: "P-256",
    id: idSecp256r1,
    size: 256
});
EcCurves.register({
    name: "P-384",
    id: idSecp384r1,
    size: 384
});
EcCurves.register({
    name: "P-521",
    id: idSecp521r1,
    size: 521
});
EcCurves.register({
    name: "K-256",
    id: idSecp256k1,
    size: 256
});
EcCurves.register({
    name: "brainpoolP160r1",
    id: idBrainpoolP160r1,
    size: 160
});
EcCurves.register({
    name: "brainpoolP160t1",
    id: idBrainpoolP160t1,
    size: 160
});
EcCurves.register({
    name: "brainpoolP192r1",
    id: idBrainpoolP192r1,
    size: 192
});
EcCurves.register({
    name: "brainpoolP192t1",
    id: idBrainpoolP192t1,
    size: 192
});
EcCurves.register({
    name: "brainpoolP224r1",
    id: idBrainpoolP224r1,
    size: 224
});
EcCurves.register({
    name: "brainpoolP224t1",
    id: idBrainpoolP224t1,
    size: 224
});
EcCurves.register({
    name: "brainpoolP256r1",
    id: idBrainpoolP256r1,
    size: 256
});
EcCurves.register({
    name: "brainpoolP256t1",
    id: idBrainpoolP256t1,
    size: 256
});
EcCurves.register({
    name: "brainpoolP320r1",
    id: idBrainpoolP320r1,
    size: 320
});
EcCurves.register({
    name: "brainpoolP320t1",
    id: idBrainpoolP320t1,
    size: 320
});
EcCurves.register({
    name: "brainpoolP384r1",
    id: idBrainpoolP384r1,
    size: 384
});
EcCurves.register({
    name: "brainpoolP384t1",
    id: idBrainpoolP384t1,
    size: 384
});
EcCurves.register({
    name: "brainpoolP512r1",
    id: idBrainpoolP512r1,
    size: 512
});
EcCurves.register({
    name: "brainpoolP512t1",
    id: idBrainpoolP512t1,
    size: 512
});
class HmacProvider extends ProviderCrypto {
    constructor(){
        super(...arguments);
        this.name = "HMAC";
        this.hashAlgorithms = [
            "SHA-1",
            "SHA-256",
            "SHA-384",
            "SHA-512"
        ];
        this.usages = [
            "sign",
            "verify"
        ];
    }
    getDefaultLength(algName) {
        switch(algName.toUpperCase()){
            case "SHA-1":
            case "SHA-256":
            case "SHA-384":
            case "SHA-512":
                return 512;
            default:
                throw new Error(`Unknown algorithm name '${algName}'`);
        }
    }
    checkGenerateKeyParams(algorithm) {
        this.checkRequiredProperty(algorithm, "hash");
        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);
        if ("length" in algorithm) {
            if (typeof algorithm.length !== "number") {
                throw new TypeError("length: Is not a Number");
            }
            if (algorithm.length < 1) {
                throw new RangeError("length: Number is out of range");
            }
        }
    }
    checkImportParams(algorithm) {
        this.checkRequiredProperty(algorithm, "hash");
        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);
    }
}
class Pbkdf2Provider extends ProviderCrypto {
    constructor(){
        super(...arguments);
        this.name = "PBKDF2";
        this.hashAlgorithms = [
            "SHA-1",
            "SHA-256",
            "SHA-384",
            "SHA-512"
        ];
        this.usages = [
            "deriveBits",
            "deriveKey"
        ];
    }
    checkAlgorithmParams(algorithm) {
        this.checkRequiredProperty(algorithm, "hash");
        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);
        this.checkRequiredProperty(algorithm, "salt");
        if (!(algorithm.salt instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.salt))) {
            throw new TypeError("salt: Is not of type '(ArrayBuffer or ArrayBufferView)'");
        }
        this.checkRequiredProperty(algorithm, "iterations");
        if (typeof algorithm.iterations !== "number") {
            throw new TypeError("iterations: Is not a Number");
        }
        if (algorithm.iterations < 1) {
            throw new TypeError("iterations: Is less than 1");
        }
    }
    checkImportKey(format, keyData, algorithm, extractable, keyUsages, ...args) {
        super.checkImportKey(format, keyData, algorithm, extractable, keyUsages);
        if (extractable) {
            throw new SyntaxError("extractable: Must be 'false'");
        }
    }
}
class HkdfProvider extends ProviderCrypto {
    constructor(){
        super(...arguments);
        this.name = "HKDF";
        this.hashAlgorithms = [
            "SHA-1",
            "SHA-256",
            "SHA-384",
            "SHA-512"
        ];
        this.usages = [
            "deriveKey",
            "deriveBits"
        ];
    }
    checkAlgorithmParams(algorithm) {
        this.checkRequiredProperty(algorithm, "hash");
        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);
        this.checkRequiredProperty(algorithm, "salt");
        if (!pvtsutils.BufferSourceConverter.isBufferSource(algorithm.salt)) {
            throw new TypeError("salt: Is not of type '(ArrayBuffer or ArrayBufferView)'");
        }
        this.checkRequiredProperty(algorithm, "info");
        if (!pvtsutils.BufferSourceConverter.isBufferSource(algorithm.info)) {
            throw new TypeError("salt: Is not of type '(ArrayBuffer or ArrayBufferView)'");
        }
    }
    checkImportKey(format, keyData, algorithm, extractable, keyUsages, ...args) {
        super.checkImportKey(format, keyData, algorithm, extractable, keyUsages);
        if (extractable) {
            throw new SyntaxError("extractable: Must be 'false'");
        }
    }
}
class ShakeProvider extends ProviderCrypto {
    constructor(){
        super(...arguments);
        this.usages = [];
        this.defaultLength = 0;
    }
    digest(...args) {
        args[0] = {
            length: this.defaultLength,
            ...args[0]
        };
        return super.digest.apply(this, args);
    }
    checkDigest(algorithm, data) {
        super.checkDigest(algorithm, data);
        const length = algorithm.length || 0;
        if (typeof length !== "number") {
            throw new TypeError("length: Is not a Number");
        }
        if (length < 0) {
            throw new TypeError("length: Is negative");
        }
    }
}
class Shake128Provider extends ShakeProvider {
    constructor(){
        super(...arguments);
        this.name = "shake128";
        this.defaultLength = 16;
    }
}
class Shake256Provider extends ShakeProvider {
    constructor(){
        super(...arguments);
        this.name = "shake256";
        this.defaultLength = 32;
    }
}
class Crypto {
    get [Symbol.toStringTag]() {
        return "Crypto";
    }
    randomUUID() {
        const b = this.getRandomValues(new Uint8Array(16));
        b[6] = b[6] & 0x0f | 0x40;
        b[8] = b[8] & 0x3f | 0x80;
        const uuid = pvtsutils.Convert.ToHex(b).toLowerCase();
        return `${uuid.substring(0, 8)}-${uuid.substring(8, 12)}-${uuid.substring(12, 16)}-${uuid.substring(16, 20)}-${uuid.substring(20)}`;
    }
}
class ProviderStorage {
    constructor(){
        this.items = {};
    }
    get(algorithmName) {
        return this.items[algorithmName.toLowerCase()] || null;
    }
    set(provider) {
        this.items[provider.name.toLowerCase()] = provider;
    }
    removeAt(algorithmName) {
        const provider = this.get(algorithmName.toLowerCase());
        if (provider) {
            delete this.items[algorithmName];
        }
        return provider;
    }
    has(name) {
        return !!this.get(name);
    }
    get length() {
        return Object.keys(this.items).length;
    }
    get algorithms() {
        const algorithms = [];
        for(const key in this.items){
            const provider = this.items[key];
            algorithms.push(provider.name);
        }
        return algorithms.sort();
    }
}
class SubtleCrypto {
    constructor(){
        this.providers = new ProviderStorage();
    }
    static isHashedAlgorithm(data) {
        return data && typeof data === "object" && "name" in data && "hash" in data ? true : false;
    }
    get [Symbol.toStringTag]() {
        return "SubtleCrypto";
    }
    async digest(...args) {
        this.checkRequiredArguments(args, 2, "digest");
        const [algorithm, data, ...params] = args;
        const preparedAlgorithm = this.prepareAlgorithm(algorithm);
        const preparedData = pvtsutils.BufferSourceConverter.toArrayBuffer(data);
        const provider = this.getProvider(preparedAlgorithm.name);
        const result = await provider.digest(preparedAlgorithm, preparedData, ...params);
        return result;
    }
    async generateKey(...args) {
        this.checkRequiredArguments(args, 3, "generateKey");
        const [algorithm, extractable, keyUsages, ...params] = args;
        const preparedAlgorithm = this.prepareAlgorithm(algorithm);
        const provider = this.getProvider(preparedAlgorithm.name);
        const result = await provider.generateKey({
            ...preparedAlgorithm,
            name: provider.name
        }, extractable, keyUsages, ...params);
        return result;
    }
    async sign(...args) {
        this.checkRequiredArguments(args, 3, "sign");
        const [algorithm, key, data, ...params] = args;
        this.checkCryptoKey(key);
        const preparedAlgorithm = this.prepareAlgorithm(algorithm);
        const preparedData = pvtsutils.BufferSourceConverter.toArrayBuffer(data);
        const provider = this.getProvider(preparedAlgorithm.name);
        const result = await provider.sign({
            ...preparedAlgorithm,
            name: provider.name
        }, key, preparedData, ...params);
        return result;
    }
    async verify(...args) {
        this.checkRequiredArguments(args, 4, "verify");
        const [algorithm, key, signature, data, ...params] = args;
        this.checkCryptoKey(key);
        const preparedAlgorithm = this.prepareAlgorithm(algorithm);
        const preparedData = pvtsutils.BufferSourceConverter.toArrayBuffer(data);
        const preparedSignature = pvtsutils.BufferSourceConverter.toArrayBuffer(signature);
        const provider = this.getProvider(preparedAlgorithm.name);
        const result = await provider.verify({
            ...preparedAlgorithm,
            name: provider.name
        }, key, preparedSignature, preparedData, ...params);
        return result;
    }
    async encrypt(...args) {
        this.checkRequiredArguments(args, 3, "encrypt");
        const [algorithm, key, data, ...params] = args;
        this.checkCryptoKey(key);
        const preparedAlgorithm = this.prepareAlgorithm(algorithm);
        const preparedData = pvtsutils.BufferSourceConverter.toArrayBuffer(data);
        const provider = this.getProvider(preparedAlgorithm.name);
        const result = await provider.encrypt({
            ...preparedAlgorithm,
            name: provider.name
        }, key, preparedData, {
            keyUsage: true
        }, ...params);
        return result;
    }
    async decrypt(...args) {
        this.checkRequiredArguments(args, 3, "decrypt");
        const [algorithm, key, data, ...params] = args;
        this.checkCryptoKey(key);
        const preparedAlgorithm = this.prepareAlgorithm(algorithm);
        const preparedData = pvtsutils.BufferSourceConverter.toArrayBuffer(data);
        const provider = this.getProvider(preparedAlgorithm.name);
        const result = await provider.decrypt({
            ...preparedAlgorithm,
            name: provider.name
        }, key, preparedData, {
            keyUsage: true
        }, ...params);
        return result;
    }
    async deriveBits(...args) {
        this.checkRequiredArguments(args, 3, "deriveBits");
        const [algorithm, baseKey, length, ...params] = args;
        this.checkCryptoKey(baseKey);
        const preparedAlgorithm = this.prepareAlgorithm(algorithm);
        const provider = this.getProvider(preparedAlgorithm.name);
        const result = await provider.deriveBits({
            ...preparedAlgorithm,
            name: provider.name
        }, baseKey, length, {
            keyUsage: true
        }, ...params);
        return result;
    }
    async deriveKey(...args) {
        this.checkRequiredArguments(args, 5, "deriveKey");
        const [algorithm, baseKey, derivedKeyType, extractable, keyUsages, ...params] = args;
        const preparedDerivedKeyType = this.prepareAlgorithm(derivedKeyType);
        const importProvider = this.getProvider(preparedDerivedKeyType.name);
        importProvider.checkDerivedKeyParams(preparedDerivedKeyType);
        const preparedAlgorithm = this.prepareAlgorithm(algorithm);
        const provider = this.getProvider(preparedAlgorithm.name);
        provider.checkCryptoKey(baseKey, "deriveKey");
        const derivedBits = await provider.deriveBits({
            ...preparedAlgorithm,
            name: provider.name
        }, baseKey, derivedKeyType.length || 512, {
            keyUsage: false
        }, ...params);
        return this.importKey("raw", derivedBits, derivedKeyType, extractable, keyUsages, ...params);
    }
    async exportKey(...args) {
        this.checkRequiredArguments(args, 2, "exportKey");
        const [format, key, ...params] = args;
        this.checkCryptoKey(key);
        const provider = this.getProvider(key.algorithm.name);
        const result = await provider.exportKey(format, key, ...params);
        return result;
    }
    async importKey(...args) {
        this.checkRequiredArguments(args, 5, "importKey");
        const [format, keyData, algorithm, extractable, keyUsages, ...params] = args;
        const preparedAlgorithm = this.prepareAlgorithm(algorithm);
        const provider = this.getProvider(preparedAlgorithm.name);
        if ([
            "pkcs8",
            "spki",
            "raw"
        ].indexOf(format) !== -1) {
            const preparedData = pvtsutils.BufferSourceConverter.toArrayBuffer(keyData);
            return provider.importKey(format, preparedData, {
                ...preparedAlgorithm,
                name: provider.name
            }, extractable, keyUsages, ...params);
        } else {
            if (!keyData.kty) {
                throw new TypeError("keyData: Is not JSON");
            }
        }
        return provider.importKey(format, keyData, {
            ...preparedAlgorithm,
            name: provider.name
        }, extractable, keyUsages, ...params);
    }
    async wrapKey(format, key, wrappingKey, wrapAlgorithm, ...args) {
        let keyData = await this.exportKey(format, key, ...args);
        if (format === "jwk") {
            const json = JSON.stringify(keyData);
            keyData = pvtsutils.Convert.FromUtf8String(json);
        }
        const preparedAlgorithm = this.prepareAlgorithm(wrapAlgorithm);
        const preparedData = pvtsutils.BufferSourceConverter.toArrayBuffer(keyData);
        const provider = this.getProvider(preparedAlgorithm.name);
        return provider.encrypt({
            ...preparedAlgorithm,
            name: provider.name
        }, wrappingKey, preparedData, {
            keyUsage: false
        }, ...args);
    }
    async unwrapKey(format, wrappedKey, unwrappingKey, unwrapAlgorithm, unwrappedKeyAlgorithm, extractable, keyUsages, ...args) {
        const preparedAlgorithm = this.prepareAlgorithm(unwrapAlgorithm);
        const preparedData = pvtsutils.BufferSourceConverter.toArrayBuffer(wrappedKey);
        const provider = this.getProvider(preparedAlgorithm.name);
        let keyData = await provider.decrypt({
            ...preparedAlgorithm,
            name: provider.name
        }, unwrappingKey, preparedData, {
            keyUsage: false
        }, ...args);
        if (format === "jwk") {
            try {
                keyData = JSON.parse(pvtsutils.Convert.ToUtf8String(keyData));
            } catch (e) {
                const error = new TypeError("wrappedKey: Is not a JSON");
                error.internal = e;
                throw error;
            }
        }
        return this.importKey(format, keyData, unwrappedKeyAlgorithm, extractable, keyUsages, ...args);
    }
    checkRequiredArguments(args, size, methodName) {
        if (args.length < size) {
            throw new TypeError(`Failed to execute '${methodName}' on 'SubtleCrypto': ${size} arguments required, but only ${args.length} present`);
        }
    }
    prepareAlgorithm(algorithm) {
        if (typeof algorithm === "string") {
            return {
                name: algorithm
            };
        }
        if (SubtleCrypto.isHashedAlgorithm(algorithm)) {
            const preparedAlgorithm = {
                ...algorithm
            };
            preparedAlgorithm.hash = this.prepareAlgorithm(algorithm.hash);
            return preparedAlgorithm;
        }
        return {
            ...algorithm
        };
    }
    getProvider(name) {
        const provider = this.providers.get(name);
        if (!provider) {
            throw new AlgorithmError("Unrecognized name");
        }
        return provider;
    }
    checkCryptoKey(key) {
        if (!(key instanceof CryptoKey)) {
            throw new TypeError(`Key is not of type 'CryptoKey'`);
        }
    }
}
var index = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    converters: index$3
});
const REQUIRED_FIELDS = [
    "crv",
    "e",
    "k",
    "kty",
    "n",
    "x",
    "y"
];
class JwkUtils {
    static async thumbprint(hash, jwk, crypto) {
        const data = this.format(jwk, true);
        return crypto.subtle.digest(hash, pvtsutils.Convert.FromBinary(JSON.stringify(data)));
    }
    static format(jwk, remove = false) {
        let res = Object.entries(jwk);
        if (remove) {
            res = res.filter((o)=>REQUIRED_FIELDS.includes(o[0]));
        }
        res = res.sort(([keyA], [keyB])=>keyA > keyB ? 1 : keyA < keyB ? -1 : 0);
        return Object.fromEntries(res);
    }
}
Object.defineProperty(exports, "BufferSourceConverter", ({
    enumerable: true,
    get: function() {
        return pvtsutils.BufferSourceConverter;
    }
}));
exports.AesCbcProvider = AesCbcProvider;
exports.AesCmacProvider = AesCmacProvider;
exports.AesCtrProvider = AesCtrProvider;
exports.AesEcbProvider = AesEcbProvider;
exports.AesGcmProvider = AesGcmProvider;
exports.AesKwProvider = AesKwProvider;
exports.AesProvider = AesProvider;
exports.AlgorithmError = AlgorithmError;
exports.Crypto = Crypto;
exports.CryptoError = CryptoError;
exports.CryptoKey = CryptoKey;
exports.DesProvider = DesProvider;
exports.EcCurves = EcCurves;
exports.EcUtils = EcUtils;
exports.EcdhEsProvider = EcdhEsProvider;
exports.EcdhProvider = EcdhProvider;
exports.EcdsaProvider = EcdsaProvider;
exports.EdDsaProvider = EdDsaProvider;
exports.EllipticProvider = EllipticProvider;
exports.HkdfProvider = HkdfProvider;
exports.HmacProvider = HmacProvider;
exports.JwkUtils = JwkUtils;
exports.OperationError = OperationError;
exports.Pbkdf2Provider = Pbkdf2Provider;
exports.PemConverter = PemConverter;
exports.ProviderCrypto = ProviderCrypto;
exports.ProviderStorage = ProviderStorage;
exports.RequiredPropertyError = RequiredPropertyError;
exports.RsaOaepProvider = RsaOaepProvider;
exports.RsaProvider = RsaProvider;
exports.RsaPssProvider = RsaPssProvider;
exports.RsaSsaProvider = RsaSsaProvider;
exports.Shake128Provider = Shake128Provider;
exports.Shake256Provider = Shake256Provider;
exports.ShakeProvider = ShakeProvider;
exports.SubtleCrypto = SubtleCrypto;
exports.UnsupportedOperationError = UnsupportedOperationError;
exports.asn1 = index$1;
exports.isJWK = isJWK;
exports.json = index;


/***/ }),

/***/ 6873:
/***/ ((module) => {

"use strict";

module.exports = function(Yallist) {
    Yallist.prototype[Symbol.iterator] = function*() {
        for(let walker = this.head; walker; walker = walker.next){
            yield walker.value;
        }
    };
};


/***/ }),

/***/ 9606:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = Yallist;
Yallist.Node = Node;
Yallist.create = Yallist;
function Yallist(list) {
    var self = this;
    if (!(self instanceof Yallist)) {
        self = new Yallist();
    }
    self.tail = null;
    self.head = null;
    self.length = 0;
    if (list && typeof list.forEach === "function") {
        list.forEach(function(item) {
            self.push(item);
        });
    } else if (arguments.length > 0) {
        for(var i = 0, l = arguments.length; i < l; i++){
            self.push(arguments[i]);
        }
    }
    return self;
}
Yallist.prototype.removeNode = function(node) {
    if (node.list !== this) {
        throw new Error("removing node which does not belong to this list");
    }
    var next = node.next;
    var prev = node.prev;
    if (next) {
        next.prev = prev;
    }
    if (prev) {
        prev.next = next;
    }
    if (node === this.head) {
        this.head = next;
    }
    if (node === this.tail) {
        this.tail = prev;
    }
    node.list.length--;
    node.next = null;
    node.prev = null;
    node.list = null;
    return next;
};
Yallist.prototype.unshiftNode = function(node) {
    if (node === this.head) {
        return;
    }
    if (node.list) {
        node.list.removeNode(node);
    }
    var head = this.head;
    node.list = this;
    node.next = head;
    if (head) {
        head.prev = node;
    }
    this.head = node;
    if (!this.tail) {
        this.tail = node;
    }
    this.length++;
};
Yallist.prototype.pushNode = function(node) {
    if (node === this.tail) {
        return;
    }
    if (node.list) {
        node.list.removeNode(node);
    }
    var tail = this.tail;
    node.list = this;
    node.prev = tail;
    if (tail) {
        tail.next = node;
    }
    this.tail = node;
    if (!this.head) {
        this.head = node;
    }
    this.length++;
};
Yallist.prototype.push = function() {
    for(var i = 0, l = arguments.length; i < l; i++){
        push(this, arguments[i]);
    }
    return this.length;
};
Yallist.prototype.unshift = function() {
    for(var i = 0, l = arguments.length; i < l; i++){
        unshift(this, arguments[i]);
    }
    return this.length;
};
Yallist.prototype.pop = function() {
    if (!this.tail) {
        return undefined;
    }
    var res = this.tail.value;
    this.tail = this.tail.prev;
    if (this.tail) {
        this.tail.next = null;
    } else {
        this.head = null;
    }
    this.length--;
    return res;
};
Yallist.prototype.shift = function() {
    if (!this.head) {
        return undefined;
    }
    var res = this.head.value;
    this.head = this.head.next;
    if (this.head) {
        this.head.prev = null;
    } else {
        this.tail = null;
    }
    this.length--;
    return res;
};
Yallist.prototype.forEach = function(fn, thisp) {
    thisp = thisp || this;
    for(var walker = this.head, i = 0; walker !== null; i++){
        fn.call(thisp, walker.value, i, this);
        walker = walker.next;
    }
};
Yallist.prototype.forEachReverse = function(fn, thisp) {
    thisp = thisp || this;
    for(var walker = this.tail, i = this.length - 1; walker !== null; i--){
        fn.call(thisp, walker.value, i, this);
        walker = walker.prev;
    }
};
Yallist.prototype.get = function(n) {
    for(var i = 0, walker = this.head; walker !== null && i < n; i++){
        // abort out of the list early if we hit a cycle
        walker = walker.next;
    }
    if (i === n && walker !== null) {
        return walker.value;
    }
};
Yallist.prototype.getReverse = function(n) {
    for(var i = 0, walker = this.tail; walker !== null && i < n; i++){
        // abort out of the list early if we hit a cycle
        walker = walker.prev;
    }
    if (i === n && walker !== null) {
        return walker.value;
    }
};
Yallist.prototype.map = function(fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist();
    for(var walker = this.head; walker !== null;){
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.next;
    }
    return res;
};
Yallist.prototype.mapReverse = function(fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist();
    for(var walker = this.tail; walker !== null;){
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.prev;
    }
    return res;
};
Yallist.prototype.reduce = function(fn, initial) {
    var acc;
    var walker = this.head;
    if (arguments.length > 1) {
        acc = initial;
    } else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
    } else {
        throw new TypeError("Reduce of empty list with no initial value");
    }
    for(var i = 0; walker !== null; i++){
        acc = fn(acc, walker.value, i);
        walker = walker.next;
    }
    return acc;
};
Yallist.prototype.reduceReverse = function(fn, initial) {
    var acc;
    var walker = this.tail;
    if (arguments.length > 1) {
        acc = initial;
    } else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
    } else {
        throw new TypeError("Reduce of empty list with no initial value");
    }
    for(var i = this.length - 1; walker !== null; i--){
        acc = fn(acc, walker.value, i);
        walker = walker.prev;
    }
    return acc;
};
Yallist.prototype.toArray = function() {
    var arr = new Array(this.length);
    for(var i = 0, walker = this.head; walker !== null; i++){
        arr[i] = walker.value;
        walker = walker.next;
    }
    return arr;
};
Yallist.prototype.toArrayReverse = function() {
    var arr = new Array(this.length);
    for(var i = 0, walker = this.tail; walker !== null; i++){
        arr[i] = walker.value;
        walker = walker.prev;
    }
    return arr;
};
Yallist.prototype.slice = function(from, to) {
    to = to || this.length;
    if (to < 0) {
        to += this.length;
    }
    from = from || 0;
    if (from < 0) {
        from += this.length;
    }
    var ret = new Yallist();
    if (to < from || to < 0) {
        return ret;
    }
    if (from < 0) {
        from = 0;
    }
    if (to > this.length) {
        to = this.length;
    }
    for(var i = 0, walker = this.head; walker !== null && i < from; i++){
        walker = walker.next;
    }
    for(; walker !== null && i < to; i++, walker = walker.next){
        ret.push(walker.value);
    }
    return ret;
};
Yallist.prototype.sliceReverse = function(from, to) {
    to = to || this.length;
    if (to < 0) {
        to += this.length;
    }
    from = from || 0;
    if (from < 0) {
        from += this.length;
    }
    var ret = new Yallist();
    if (to < from || to < 0) {
        return ret;
    }
    if (from < 0) {
        from = 0;
    }
    if (to > this.length) {
        to = this.length;
    }
    for(var i = this.length, walker = this.tail; walker !== null && i > to; i--){
        walker = walker.prev;
    }
    for(; walker !== null && i > from; i--, walker = walker.prev){
        ret.push(walker.value);
    }
    return ret;
};
Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
    if (start > this.length) {
        start = this.length - 1;
    }
    if (start < 0) {
        start = this.length + start;
    }
    for(var i = 0, walker = this.head; walker !== null && i < start; i++){
        walker = walker.next;
    }
    var ret = [];
    for(var i = 0; walker && i < deleteCount; i++){
        ret.push(walker.value);
        walker = this.removeNode(walker);
    }
    if (walker === null) {
        walker = this.tail;
    }
    if (walker !== this.head && walker !== this.tail) {
        walker = walker.prev;
    }
    for(var i = 0; i < nodes.length; i++){
        walker = insert(this, walker, nodes[i]);
    }
    return ret;
};
Yallist.prototype.reverse = function() {
    var head = this.head;
    var tail = this.tail;
    for(var walker = head; walker !== null; walker = walker.prev){
        var p = walker.prev;
        walker.prev = walker.next;
        walker.next = p;
    }
    this.head = tail;
    this.tail = head;
    return this;
};
function insert(self, node, value) {
    var inserted = node === self.head ? new Node(value, null, node, self) : new Node(value, node, node.next, self);
    if (inserted.next === null) {
        self.tail = inserted;
    }
    if (inserted.prev === null) {
        self.head = inserted;
    }
    self.length++;
    return inserted;
}
function push(self, item) {
    self.tail = new Node(item, self.tail, null, self);
    if (!self.head) {
        self.head = self.tail;
    }
    self.length++;
}
function unshift(self, item) {
    self.head = new Node(item, null, self.head, self);
    if (!self.tail) {
        self.tail = self.head;
    }
    self.length++;
}
function Node(value, prev, next, list) {
    if (!(this instanceof Node)) {
        return new Node(value, prev, next, list);
    }
    this.list = list;
    this.value = value;
    if (prev) {
        prev.next = this;
        this.prev = prev;
    } else {
        this.prev = null;
    }
    if (next) {
        next.prev = this;
        this.next = next;
    } else {
        this.next = null;
    }
}
try {
    // add if support for Symbol.iterator is present
    __webpack_require__(6873)(Yallist);
} catch (er) {}


/***/ }),

/***/ 3456:
/***/ ((module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "createAsyncLocalStorage", ({
    enumerable: true,
    get: function() {
        return createAsyncLocalStorage;
    }
}));
class FakeAsyncLocalStorage {
    disable() {
        throw new Error("Invariant: AsyncLocalStorage accessed in runtime where it is not available");
    }
    getStore() {
        // This fake implementation of AsyncLocalStorage always returns `undefined`.
        return undefined;
    }
    run() {
        throw new Error("Invariant: AsyncLocalStorage accessed in runtime where it is not available");
    }
    exit() {
        throw new Error("Invariant: AsyncLocalStorage accessed in runtime where it is not available");
    }
    enterWith() {
        throw new Error("Invariant: AsyncLocalStorage accessed in runtime where it is not available");
    }
}
function createAsyncLocalStorage() {
    if (globalThis.AsyncLocalStorage) {
        return new globalThis.AsyncLocalStorage();
    }
    return new FakeAsyncLocalStorage();
}
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=async-local-storage.js.map


/***/ }),

/***/ 7358:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "staticGenerationAsyncStorage", ({
    enumerable: true,
    get: function() {
        return staticGenerationAsyncStorage;
    }
}));
const _asynclocalstorage = __webpack_require__(3456);
const staticGenerationAsyncStorage = (0, _asynclocalstorage.createAsyncLocalStorage)();
if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
    Object.defineProperty(exports.default, "__esModule", {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=static-generation-async-storage.js.map


/***/ }),

/***/ 8477:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.envelop = void 0;
const orchestrator_js_1 = __webpack_require__(2113);
function notEmpty(value) {
    return value != null;
}
function envelop(options) {
    const plugins = options.plugins.filter(notEmpty);
    const orchestrator = (0, orchestrator_js_1.createEnvelopOrchestrator)({
        plugins
    });
    const getEnveloped = (initialContext = {})=>{
        const typedOrchestrator = orchestrator;
        typedOrchestrator.init(initialContext);
        return {
            parse: typedOrchestrator.parse(initialContext),
            validate: typedOrchestrator.validate(initialContext),
            contextFactory: typedOrchestrator.contextFactory(initialContext),
            execute: typedOrchestrator.execute,
            subscribe: typedOrchestrator.subscribe,
            schema: typedOrchestrator.getCurrentSchema()
        };
    };
    getEnveloped._plugins = plugins;
    return getEnveloped;
}
exports.envelop = envelop;


/***/ }),

/***/ 686:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(4479);
// eslint-disable-next-line import/export
tslib_1.__exportStar(__webpack_require__(3402), exports);
tslib_1.__exportStar(__webpack_require__(8477), exports);
tslib_1.__exportStar(__webpack_require__(291), exports);
tslib_1.__exportStar(__webpack_require__(8788), exports);
tslib_1.__exportStar(__webpack_require__(5548), exports);
tslib_1.__exportStar(__webpack_require__(5137), exports);
tslib_1.__exportStar(__webpack_require__(5777), exports);
tslib_1.__exportStar(__webpack_require__(4223), exports);
tslib_1.__exportStar(__webpack_require__(748), exports);
tslib_1.__exportStar(__webpack_require__(1784), exports);
tslib_1.__exportStar(__webpack_require__(6711), exports);


/***/ }),

/***/ 2113:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.createEnvelopOrchestrator = void 0;
const utils_js_1 = __webpack_require__(291);
function throwEngineFunctionError(name) {
    throw Error(`No \`${name}\` function found! Register it using "useEngine" plugin.`);
}
function createEnvelopOrchestrator({ plugins  }) {
    let schema = null;
    let initDone = false;
    const parse = ()=>throwEngineFunctionError("parse");
    const validate = ()=>throwEngineFunctionError("validate");
    const execute = ()=>throwEngineFunctionError("execute");
    const subscribe = ()=>throwEngineFunctionError("subscribe");
    // Define the initial method for replacing the GraphQL schema, this is needed in order
    // to allow setting the schema from the onPluginInit callback. We also need to make sure
    // here not to call the same plugin that initiated the schema switch.
    const replaceSchema = (newSchema, ignorePluginIndex = -1)=>{
        schema = newSchema;
        if (initDone) {
            for (const [i, plugin] of plugins.entries()){
                if (i !== ignorePluginIndex) {
                    plugin.onSchemaChange && plugin.onSchemaChange({
                        schema,
                        replaceSchema: (schemaToSet)=>{
                            replaceSchema(schemaToSet, i);
                        }
                    });
                }
            }
        }
    };
    const contextErrorHandlers = [];
    // Iterate all plugins and trigger onPluginInit
    for (const [i, plugin] of plugins.entries()){
        plugin.onPluginInit && plugin.onPluginInit({
            plugins,
            addPlugin: (newPlugin)=>{
                plugins.push(newPlugin);
            },
            setSchema: (modifiedSchema)=>replaceSchema(modifiedSchema, i),
            registerContextErrorHandler: (handler)=>contextErrorHandlers.push(handler)
        });
    }
    // A set of before callbacks defined here in order to allow it to be used later
    const beforeCallbacks = {
        init: [],
        parse: [],
        validate: [],
        subscribe: [],
        execute: [],
        context: []
    };
    for (const { onContextBuilding , onExecute , onParse , onSubscribe , onValidate , onEnveloped  } of plugins){
        onEnveloped && beforeCallbacks.init.push(onEnveloped);
        onContextBuilding && beforeCallbacks.context.push(onContextBuilding);
        onExecute && beforeCallbacks.execute.push(onExecute);
        onParse && beforeCallbacks.parse.push(onParse);
        onSubscribe && beforeCallbacks.subscribe.push(onSubscribe);
        onValidate && beforeCallbacks.validate.push(onValidate);
    }
    const init = (initialContext)=>{
        for (const [i, onEnveloped] of beforeCallbacks.init.entries()){
            onEnveloped({
                context: initialContext,
                extendContext: (extension)=>{
                    if (!initialContext) {
                        return;
                    }
                    Object.assign(initialContext, extension);
                },
                setSchema: (modifiedSchema)=>replaceSchema(modifiedSchema, i)
            });
        }
    };
    const customParse = beforeCallbacks.parse.length ? (initialContext)=>(source, parseOptions)=>{
            let result = null;
            let parseFn = parse;
            const context = initialContext;
            const afterCalls = [];
            for (const onParse of beforeCallbacks.parse){
                const afterFn = onParse({
                    context,
                    extendContext: (extension)=>{
                        Object.assign(context, extension);
                    },
                    params: {
                        source,
                        options: parseOptions
                    },
                    parseFn,
                    setParseFn: (newFn)=>{
                        parseFn = newFn;
                    },
                    setParsedDocument: (newDoc)=>{
                        result = newDoc;
                    }
                });
                afterFn && afterCalls.push(afterFn);
            }
            if (result === null) {
                try {
                    result = parseFn(source, parseOptions);
                } catch (e) {
                    result = e;
                }
            }
            for (const afterCb of afterCalls){
                afterCb({
                    context,
                    extendContext: (extension)=>{
                        Object.assign(context, extension);
                    },
                    replaceParseResult: (newResult)=>{
                        result = newResult;
                    },
                    result
                });
            }
            if (result === null) {
                throw new Error(`Failed to parse document.`);
            }
            if (result instanceof Error) {
                throw result;
            }
            return result;
        } : ()=>parse;
    const customValidate = beforeCallbacks.validate.length ? (initialContext)=>(schema, documentAST, rules, typeInfo, validationOptions)=>{
            let actualRules = rules ? [
                ...rules
            ] : undefined;
            let validateFn = validate;
            let result = null;
            const context = initialContext;
            const afterCalls = [];
            for (const onValidate of beforeCallbacks.validate){
                const afterFn = onValidate({
                    context,
                    extendContext: (extension)=>{
                        Object.assign(context, extension);
                    },
                    params: {
                        schema,
                        documentAST,
                        rules: actualRules,
                        typeInfo,
                        options: validationOptions
                    },
                    validateFn,
                    addValidationRule: (rule)=>{
                        if (!actualRules) {
                            actualRules = [];
                        }
                        actualRules.push(rule);
                    },
                    setValidationFn: (newFn)=>{
                        validateFn = newFn;
                    },
                    setResult: (newResults)=>{
                        result = newResults;
                    }
                });
                afterFn && afterCalls.push(afterFn);
            }
            if (!result) {
                result = validateFn(schema, documentAST, actualRules, typeInfo, validationOptions);
            }
            if (!result) {
                return;
            }
            const valid = result.length === 0;
            for (const afterCb of afterCalls){
                afterCb({
                    valid,
                    result,
                    context,
                    extendContext: (extension)=>{
                        Object.assign(context, extension);
                    },
                    setResult: (newResult)=>{
                        result = newResult;
                    }
                });
            }
            return result;
        } : ()=>validate;
    const customContextFactory = beforeCallbacks.context.length ? (initialContext)=>async (orchestratorCtx)=>{
            const afterCalls = [];
            // In order to have access to the "last working" context object we keep this outside of the try block:
            let context = orchestratorCtx ? {
                ...initialContext,
                ...orchestratorCtx
            } : initialContext;
            try {
                let isBreakingContextBuilding = false;
                for (const onContext of beforeCallbacks.context){
                    const afterHookResult = await onContext({
                        context,
                        extendContext: (extension)=>{
                            context = {
                                ...context,
                                ...extension
                            };
                        },
                        breakContextBuilding: ()=>{
                            isBreakingContextBuilding = true;
                        }
                    });
                    if (typeof afterHookResult === "function") {
                        afterCalls.push(afterHookResult);
                    }
                    if (isBreakingContextBuilding === true) {
                        break;
                    }
                }
                for (const afterCb of afterCalls){
                    afterCb({
                        context,
                        extendContext: (extension)=>{
                            context = {
                                ...context,
                                ...extension
                            };
                        }
                    });
                }
                return context;
            } catch (err) {
                let error = err;
                for (const errorCb of contextErrorHandlers){
                    errorCb({
                        context,
                        error,
                        setError: (err)=>{
                            error = err;
                        }
                    });
                }
                throw error;
            }
        } : (initialContext)=>(orchestratorCtx)=>orchestratorCtx ? {
                ...initialContext,
                ...orchestratorCtx
            } : initialContext;
    const useCustomSubscribe = beforeCallbacks.subscribe.length;
    const customSubscribe = useCustomSubscribe ? (0, utils_js_1.makeSubscribe)(async (args)=>{
        let subscribeFn = subscribe;
        const afterCalls = [];
        const subscribeErrorHandlers = [];
        let context = args.contextValue || {};
        let result;
        for (const onSubscribe of beforeCallbacks.subscribe){
            const after = await onSubscribe({
                subscribeFn,
                setSubscribeFn: (newSubscribeFn)=>{
                    subscribeFn = newSubscribeFn;
                },
                extendContext: (extension)=>{
                    context = {
                        ...context,
                        ...extension
                    };
                },
                args: args,
                setResultAndStopExecution: (stopResult)=>{
                    result = stopResult;
                }
            });
            if (after) {
                if (after.onSubscribeResult) {
                    afterCalls.push(after.onSubscribeResult);
                }
                if (after.onSubscribeError) {
                    subscribeErrorHandlers.push(after.onSubscribeError);
                }
            }
            if (result !== undefined) {
                break;
            }
        }
        if (result === undefined) {
            result = await subscribeFn({
                ...args,
                contextValue: context
            });
        }
        if (!result) {
            return;
        }
        const onNextHandler = [];
        const onEndHandler = [];
        for (const afterCb of afterCalls){
            const hookResult = afterCb({
                args: args,
                result,
                setResult: (newResult)=>{
                    result = newResult;
                }
            });
            if (hookResult) {
                if (hookResult.onNext) {
                    onNextHandler.push(hookResult.onNext);
                }
                if (hookResult.onEnd) {
                    onEndHandler.push(hookResult.onEnd);
                }
            }
        }
        if (onNextHandler.length && (0, utils_js_1.isAsyncIterable)(result)) {
            result = (0, utils_js_1.mapAsyncIterator)(result, async (result)=>{
                for (const onNext of onNextHandler){
                    await onNext({
                        args: args,
                        result,
                        setResult: (newResult)=>result = newResult
                    });
                }
                return result;
            });
        }
        if (onEndHandler.length && (0, utils_js_1.isAsyncIterable)(result)) {
            result = (0, utils_js_1.finalAsyncIterator)(result, ()=>{
                for (const onEnd of onEndHandler){
                    onEnd();
                }
            });
        }
        if (subscribeErrorHandlers.length && (0, utils_js_1.isAsyncIterable)(result)) {
            result = (0, utils_js_1.errorAsyncIterator)(result, (err)=>{
                let error = err;
                for (const handler of subscribeErrorHandlers){
                    handler({
                        error,
                        setError: (err)=>{
                            error = err;
                        }
                    });
                }
                throw error;
            });
        }
        return result;
    }) : (0, utils_js_1.makeSubscribe)(subscribe);
    const useCustomExecute = beforeCallbacks.execute.length;
    const customExecute = useCustomExecute ? (0, utils_js_1.makeExecute)(async (args)=>{
        let executeFn = execute;
        let result;
        const afterCalls = [];
        let context = args.contextValue || {};
        for (const onExecute of beforeCallbacks.execute){
            const after = await onExecute({
                executeFn,
                setExecuteFn: (newExecuteFn)=>{
                    executeFn = newExecuteFn;
                },
                setResultAndStopExecution: (stopResult)=>{
                    result = stopResult;
                },
                extendContext: (extension)=>{
                    if (typeof extension === "object") {
                        context = {
                            ...context,
                            ...extension
                        };
                    } else {
                        throw new Error(`Invalid context extension provided! Expected "object", got: "${JSON.stringify(extension)}" (${typeof extension})`);
                    }
                },
                args: args
            });
            if (after?.onExecuteDone) {
                afterCalls.push(after.onExecuteDone);
            }
            if (result !== undefined) {
                break;
            }
        }
        if (result === undefined) {
            result = await executeFn({
                ...args,
                contextValue: context
            });
        }
        const onNextHandler = [];
        const onEndHandler = [];
        for (const afterCb of afterCalls){
            const hookResult = await afterCb({
                args: args,
                result,
                setResult: (newResult)=>{
                    result = newResult;
                }
            });
            if (hookResult) {
                if (hookResult.onNext) {
                    onNextHandler.push(hookResult.onNext);
                }
                if (hookResult.onEnd) {
                    onEndHandler.push(hookResult.onEnd);
                }
            }
        }
        if (onNextHandler.length && (0, utils_js_1.isAsyncIterable)(result)) {
            result = (0, utils_js_1.mapAsyncIterator)(result, async (result)=>{
                for (const onNext of onNextHandler){
                    await onNext({
                        args: args,
                        result,
                        setResult: (newResult)=>{
                            result = newResult;
                        }
                    });
                }
                return result;
            });
        }
        if (onEndHandler.length && (0, utils_js_1.isAsyncIterable)(result)) {
            result = (0, utils_js_1.finalAsyncIterator)(result, ()=>{
                for (const onEnd of onEndHandler){
                    onEnd();
                }
            });
        }
        return result;
    }) : (0, utils_js_1.makeExecute)(execute);
    initDone = true;
    // This is done in order to trigger the first schema available, to allow plugins that needs the schema
    // eagerly to have it.
    if (schema) {
        for (const [i, plugin] of plugins.entries()){
            plugin.onSchemaChange && plugin.onSchemaChange({
                schema,
                replaceSchema: (modifiedSchema)=>replaceSchema(modifiedSchema, i)
            });
        }
    }
    return {
        getCurrentSchema () {
            return schema;
        },
        init,
        parse: customParse,
        validate: customValidate,
        execute: customExecute,
        subscribe: customSubscribe,
        contextFactory: customContextFactory
    };
}
exports.createEnvelopOrchestrator = createEnvelopOrchestrator;


/***/ }),

/***/ 6711:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useEngine = void 0;
const useEngine = (engine)=>{
    return {
        onExecute: ({ setExecuteFn  })=>{
            if (engine.execute) {
                setExecuteFn(engine.execute);
            }
        },
        onParse: ({ setParseFn  })=>{
            if (engine.parse) {
                setParseFn(engine.parse);
            }
        },
        onValidate: ({ setValidationFn , addValidationRule  })=>{
            if (engine.validate) {
                setValidationFn(engine.validate);
            }
            engine.specifiedRules?.map(addValidationRule);
        },
        onSubscribe: ({ setSubscribeFn  })=>{
            if (engine.subscribe) {
                setSubscribeFn(engine.subscribe);
            }
        }
    };
};
exports.useEngine = useEngine;


/***/ }),

/***/ 8788:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useEnvelop = void 0;
const useEnvelop = (envelop)=>{
    return {
        onPluginInit ({ addPlugin  }) {
            for (const plugin of envelop._plugins){
                addPlugin(plugin);
            }
        }
    };
};
exports.useEnvelop = useEnvelop;


/***/ }),

/***/ 5777:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useErrorHandler = void 0;
const utils_js_1 = __webpack_require__(291);
const use_masked_errors_js_1 = __webpack_require__(1784);
const makeHandleResult = (errorHandler)=>({ result , args  })=>{
        if (result.errors?.length) {
            errorHandler({
                errors: result.errors,
                context: args,
                phase: "execution"
            });
        }
    };
const useErrorHandler = (errorHandler)=>{
    const handleResult = makeHandleResult(errorHandler);
    return {
        onParse () {
            return function onParseEnd({ result , context  }) {
                if (result instanceof Error) {
                    errorHandler({
                        errors: [
                            result
                        ],
                        context,
                        phase: "parse"
                    });
                }
            };
        },
        onValidate () {
            return function onValidateEnd({ valid , result , context  }) {
                if (valid === false && result.length > 0) {
                    errorHandler({
                        errors: result,
                        context,
                        phase: "validate"
                    });
                }
            };
        },
        onPluginInit (context) {
            context.registerContextErrorHandler(({ error  })=>{
                if ((0, use_masked_errors_js_1.isGraphQLError)(error)) {
                    errorHandler({
                        errors: [
                            error
                        ],
                        context,
                        phase: "context"
                    });
                } else {
                    // @ts-expect-error its not an error at this point so we just create a new one - can we handle this better?
                    errorHandler({
                        errors: [
                            new Error(error)
                        ],
                        context,
                        phase: "context"
                    });
                }
            });
        },
        onExecute () {
            return {
                onExecuteDone (payload) {
                    return (0, utils_js_1.handleStreamOrSingleExecutionResult)(payload, handleResult);
                }
            };
        },
        onSubscribe () {
            return {
                onSubscribeResult (payload) {
                    return (0, utils_js_1.handleStreamOrSingleExecutionResult)(payload, handleResult);
                }
            };
        }
    };
};
exports.useErrorHandler = useErrorHandler;


/***/ }),

/***/ 4223:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useExtendContext = void 0;
const useExtendContext = (contextFactory)=>({
        async onContextBuilding ({ context , extendContext  }) {
            extendContext(await contextFactory(context));
        }
    });
exports.useExtendContext = useExtendContext;


/***/ }),

/***/ 5548:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useLogger = void 0;
const utils_js_1 = __webpack_require__(291);
const DEFAULT_OPTIONS = {
    logFn: console.log
};
const useLogger = (rawOptions = DEFAULT_OPTIONS)=>{
    const options = {
        DEFAULT_OPTIONS,
        ...rawOptions
    };
    return {
        onParse ({ extendContext , params  }) {
            if (options.skipIntrospection && (0, utils_js_1.isIntrospectionOperationString)(params.source)) {
                extendContext({
                    [utils_js_1.envelopIsIntrospectionSymbol]: true
                });
            }
        },
        onExecute ({ args  }) {
            if (args.contextValue[utils_js_1.envelopIsIntrospectionSymbol]) {
                return;
            }
            options.logFn("execute-start", {
                args
            });
            return {
                onExecuteDone: ({ result  })=>{
                    options.logFn("execute-end", {
                        args,
                        result
                    });
                }
            };
        },
        onSubscribe ({ args  }) {
            if (args.contextValue[utils_js_1.envelopIsIntrospectionSymbol]) {
                return;
            }
            options.logFn("subscribe-start", {
                args
            });
            return {
                onSubscribeResult: ({ result  })=>{
                    options.logFn("subscribe-end", {
                        args,
                        result
                    });
                }
            };
        }
    };
};
exports.useLogger = useLogger;


/***/ }),

/***/ 1784:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useMaskedErrors = exports.defaultMaskError = exports.createDefaultMaskError = exports.isOriginalGraphQLError = exports.isGraphQLError = exports.DEFAULT_ERROR_MESSAGE = void 0;
const utils_js_1 = __webpack_require__(291);
exports.DEFAULT_ERROR_MESSAGE = "Unexpected error.";
function isGraphQLError(error) {
    return error instanceof Error && error.name === "GraphQLError";
}
exports.isGraphQLError = isGraphQLError;
function isOriginalGraphQLError(error) {
    if (isGraphQLError(error)) {
        if (error.originalError != null) {
            return isOriginalGraphQLError(error.originalError);
        }
        return true;
    }
    return false;
}
exports.isOriginalGraphQLError = isOriginalGraphQLError;
function createSerializableGraphQLError(message, originalError, isDev) {
    const error = new Error(message);
    error.name = "GraphQLError";
    if (isDev) {
        const extensions = originalError instanceof Error ? {
            message: originalError.message,
            stack: originalError.stack
        } : {
            message: String(originalError)
        };
        Object.defineProperty(error, "extensions", {
            get () {
                return extensions;
            }
        });
    }
    Object.defineProperty(error, "toJSON", {
        value () {
            return {
                message: error.message,
                extensions: error.extensions
            };
        }
    });
    return error;
}
const createDefaultMaskError = (isDev)=>(error, message)=>{
        if (isOriginalGraphQLError(error)) {
            return error;
        }
        return createSerializableGraphQLError(message, error, isDev);
    };
exports.createDefaultMaskError = createDefaultMaskError;
const isDev = globalThis.process?.env?.NODE_ENV === "development";
exports.defaultMaskError = (0, exports.createDefaultMaskError)(isDev);
const makeHandleResult = (maskError, message)=>({ result , setResult  })=>{
        if (result.errors != null) {
            setResult({
                ...result,
                errors: result.errors.map((error)=>maskError(error, message))
            });
        }
    };
function useMaskedErrors(opts) {
    const maskError = opts?.maskError ?? exports.defaultMaskError;
    const message = opts?.errorMessage || exports.DEFAULT_ERROR_MESSAGE;
    const handleResult = makeHandleResult(maskError, message);
    return {
        onPluginInit (context) {
            context.registerContextErrorHandler(({ error , setError  })=>{
                setError(maskError(error, message));
            });
        },
        onExecute () {
            return {
                onExecuteDone (payload) {
                    return (0, utils_js_1.handleStreamOrSingleExecutionResult)(payload, handleResult);
                }
            };
        },
        onSubscribe () {
            return {
                onSubscribeResult (payload) {
                    return (0, utils_js_1.handleStreamOrSingleExecutionResult)(payload, handleResult);
                },
                onSubscribeError ({ error , setError  }) {
                    setError(maskError(error, message));
                }
            };
        }
    };
}
exports.useMaskedErrors = useMaskedErrors;


/***/ }),

/***/ 748:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.usePayloadFormatter = void 0;
const utils_js_1 = __webpack_require__(291);
const makeHandleResult = (formatter)=>({ args , result , setResult  })=>{
        const modified = formatter(result, args);
        if (modified !== false) {
            setResult(modified);
        }
    };
const usePayloadFormatter = (formatter)=>({
        onExecute () {
            const handleResult = makeHandleResult(formatter);
            return {
                onExecuteDone (payload) {
                    return (0, utils_js_1.handleStreamOrSingleExecutionResult)(payload, handleResult);
                }
            };
        }
    });
exports.usePayloadFormatter = usePayloadFormatter;


/***/ }),

/***/ 5137:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useSchemaByContext = exports.useSchema = void 0;
const useSchema = (schema)=>{
    return {
        onPluginInit ({ setSchema  }) {
            setSchema(schema);
        }
    };
};
exports.useSchema = useSchema;
const useSchemaByContext = (schemaLoader)=>{
    return {
        onEnveloped ({ setSchema , context  }) {
            setSchema(schemaLoader(context));
        }
    };
};
exports.useSchemaByContext = useSchemaByContext;


/***/ }),

/***/ 291:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.errorAsyncIterator = exports.finalAsyncIterator = exports.handleStreamOrSingleExecutionResult = exports.isAsyncIterable = exports.makeExecute = exports.mapAsyncIterator = exports.makeSubscribe = exports.isIntrospectionOperationString = exports.envelopIsIntrospectionSymbol = void 0;
exports.envelopIsIntrospectionSymbol = Symbol("ENVELOP_IS_INTROSPECTION");
function isIntrospectionOperationString(operation) {
    return (typeof operation === "string" ? operation : operation.body).indexOf("__schema") !== -1;
}
exports.isIntrospectionOperationString = isIntrospectionOperationString;
function getSubscribeArgs(args) {
    return args.length === 1 ? args[0] : {
        schema: args[0],
        document: args[1],
        rootValue: args[2],
        contextValue: args[3],
        variableValues: args[4],
        operationName: args[5],
        fieldResolver: args[6],
        subscribeFieldResolver: args[7]
    };
}
/**
 * Utility function for making a subscribe function that handles polymorphic arguments.
 */ const makeSubscribe = (subscribeFn)=>(...polyArgs)=>subscribeFn(getSubscribeArgs(polyArgs));
exports.makeSubscribe = makeSubscribe;
function mapAsyncIterator(source, mapper) {
    const iterator = source[Symbol.asyncIterator]();
    async function mapResult(result) {
        if (result.done) {
            return result;
        }
        try {
            return {
                value: await mapper(result.value),
                done: false
            };
        } catch (error) {
            try {
                await iterator.return?.();
            } catch (_error) {
            /* ignore error */ }
            throw error;
        }
    }
    const stream = {
        [Symbol.asyncIterator] () {
            return stream;
        },
        async next () {
            return await mapResult(await iterator.next());
        },
        async return () {
            const promise = iterator.return?.();
            return promise ? await mapResult(await promise) : {
                value: undefined,
                done: true
            };
        },
        async throw (error) {
            const promise = iterator.throw?.();
            if (promise) {
                return await mapResult(await promise);
            }
            // if the source has no throw method we just re-throw error
            // usually throw is not called anyways
            throw error;
        }
    };
    return stream;
}
exports.mapAsyncIterator = mapAsyncIterator;
function getExecuteArgs(args) {
    return args.length === 1 ? args[0] : {
        schema: args[0],
        document: args[1],
        rootValue: args[2],
        contextValue: args[3],
        variableValues: args[4],
        operationName: args[5],
        fieldResolver: args[6],
        typeResolver: args[7]
    };
}
/**
 * Utility function for making a execute function that handles polymorphic arguments.
 */ const makeExecute = (executeFn)=>(...polyArgs)=>executeFn(getExecuteArgs(polyArgs));
exports.makeExecute = makeExecute;
/**
 * Returns true if the provided object implements the AsyncIterator protocol via
 * implementing a `Symbol.asyncIterator` method.
 *
 * Source: https://github.com/graphql/graphql-js/blob/main/src/jsutils/isAsyncIterable.ts
 */ function isAsyncIterable(maybeAsyncIterable) {
    return typeof maybeAsyncIterable === "object" && maybeAsyncIterable != null && typeof maybeAsyncIterable[Symbol.asyncIterator] === "function";
}
exports.isAsyncIterable = isAsyncIterable;
/**
 * A utility function for handling `onExecuteDone` hook result, for simplifying the handling of AsyncIterable returned from `execute`.
 *
 * @param payload The payload send to `onExecuteDone` hook function
 * @param fn The handler to be executed on each result
 * @returns a subscription for streamed results, or undefined in case of an non-async
 */ function handleStreamOrSingleExecutionResult(payload, fn) {
    if (isAsyncIterable(payload.result)) {
        return {
            onNext: fn
        };
    }
    fn({
        args: payload.args,
        result: payload.result,
        setResult: payload.setResult
    });
    return undefined;
}
exports.handleStreamOrSingleExecutionResult = handleStreamOrSingleExecutionResult;
function finalAsyncIterator(source, onFinal) {
    const iterator = source[Symbol.asyncIterator]();
    let isDone = false;
    const stream = {
        [Symbol.asyncIterator] () {
            return stream;
        },
        async next () {
            const result = await iterator.next();
            if (result.done && isDone === false) {
                isDone = true;
                onFinal();
            }
            return result;
        },
        async return () {
            const promise = iterator.return?.();
            if (isDone === false) {
                isDone = true;
                onFinal();
            }
            return promise ? await promise : {
                done: true,
                value: undefined
            };
        },
        async throw (error) {
            const promise = iterator.throw?.();
            if (promise) {
                return await promise;
            }
            // if the source has no throw method we just re-throw error
            // usually throw is not called anyways
            throw error;
        }
    };
    return stream;
}
exports.finalAsyncIterator = finalAsyncIterator;
function errorAsyncIterator(source, onError) {
    const iterator = source[Symbol.asyncIterator]();
    const stream = {
        [Symbol.asyncIterator] () {
            return stream;
        },
        async next () {
            try {
                return await iterator.next();
            } catch (error) {
                onError(error);
                return {
                    done: true,
                    value: undefined
                };
            }
        },
        async return () {
            const promise = iterator.return?.();
            return promise ? await promise : {
                done: true,
                value: undefined
            };
        },
        async throw (error) {
            const promise = iterator.throw?.();
            if (promise) {
                return await promise;
            }
            // if the source has no throw method we just re-throw error
            // usually throw is not called anyways
            throw error;
        }
    };
    return stream;
}
exports.errorAsyncIterator = errorAsyncIterator;


/***/ }),

/***/ 1575:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 3710:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 1200:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 4853:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 3402:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(4479);
tslib_1.__exportStar(__webpack_require__(1575), exports);
tslib_1.__exportStar(__webpack_require__(4853), exports);
tslib_1.__exportStar(__webpack_require__(1948), exports);
tslib_1.__exportStar(__webpack_require__(3710), exports);
tslib_1.__exportStar(__webpack_require__(1200), exports);
tslib_1.__exportStar(__webpack_require__(6497), exports);


/***/ }),

/***/ 1948:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 6497:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 6815:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useValidationCache = void 0;
const tslib_1 = __webpack_require__(4479);
const graphql_1 = __webpack_require__(5736);
const fast_json_stable_stringify_1 = tslib_1.__importDefault(__webpack_require__(8054));
const lru_cache_1 = tslib_1.__importDefault(__webpack_require__(7771));
const sha1_es_1 = tslib_1.__importDefault(__webpack_require__(4392));
const DEFAULT_MAX = 1000;
const DEFAULT_TTL = 3600000;
const rawDocumentSymbol = Symbol("rawDocument");
const schemaHashCache = new WeakMap();
function getSchemaHash(schema) {
    let hash = schemaHashCache.get(schema);
    if (hash) {
        return hash;
    }
    const introspection = (0, graphql_1.introspectionFromSchema)(schema);
    hash = sha1_es_1.default.hash((0, fast_json_stable_stringify_1.default)(introspection.__schema));
    schemaHashCache.set(schema, hash);
    return hash;
}
const useValidationCache = (pluginOptions = {})=>{
    const resultCache = typeof pluginOptions.cache !== "undefined" ? pluginOptions.cache : new lru_cache_1.default({
        max: DEFAULT_MAX,
        maxAge: DEFAULT_TTL
    });
    return {
        onParse ({ params , extendContext  }) {
            extendContext({
                [rawDocumentSymbol]: params.source.toString()
            });
        },
        onValidate ({ params , context , setValidationFn , validateFn  }) {
            // We use setValidateFn over accessing params.rules directly, as other plugins in the chain might add more rules.
            // This would cause an issue if we are constructing the cache key here already.
            setValidationFn((...args)=>{
                const schemaHashKey = getSchemaHash(args[0]);
                let ruleKey = "";
                if (Array.isArray(args[2])) {
                    // Note: We could also order them... but that might be too much
                    for (const rule of args[2]){
                        ruleKey = ruleKey + rule.name;
                    }
                }
                const key = schemaHashKey + `|` + ruleKey + `|` + (context[rawDocumentSymbol] ?? (0, graphql_1.print)(params.documentAST));
                const cachedResult = resultCache.get(key);
                if (cachedResult !== undefined) {
                    return cachedResult;
                }
                const result = validateFn(...args);
                resultCache.set(key, result);
                return result;
            });
        }
    };
};
exports.useValidationCache = useValidationCache;


/***/ }),

/***/ 5667:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.isIncrementalResult = exports.getFieldDef = exports.flattenIncrementalResults = exports.subscribe = exports.defaultFieldResolver = exports.defaultTypeResolver = exports.buildResolveInfo = exports.buildExecutionContext = exports.assertValidExecutionArguments = exports.executeSync = exports.execute = void 0;
const graphql_1 = __webpack_require__(5736);
const utils_1 = __webpack_require__(6887);
const values_js_1 = __webpack_require__(2407);
const promiseForObject_js_1 = __webpack_require__(8315);
const flattenAsyncIterable_js_1 = __webpack_require__(4336);
const invariant_js_1 = __webpack_require__(2624);
const value_or_promise_1 = __webpack_require__(8323);
/**
 * A memoized collection of relevant subfields with regard to the return
 * type. Memoizing ensures the subfields are not repeatedly calculated, which
 * saves overhead when resolving lists of values.
 */ const collectSubfields = (0, utils_1.memoize3)((exeContext, returnType, fieldNodes)=>(0, utils_1.collectSubFields)(exeContext.schema, exeContext.fragments, exeContext.variableValues, returnType, fieldNodes));
/**
 * Implements the "Executing requests" section of the GraphQL specification,
 * including `@defer` and `@stream` as proposed in
 * https://github.com/graphql/graphql-spec/pull/742
 *
 * This function returns a Promise of an IncrementalExecutionResults
 * object. This object either consists of a single ExecutionResult, or an
 * object containing an `initialResult` and a stream of `subsequentResults`.
 *
 * If the arguments to this function do not result in a legal execution context,
 * a GraphQLError will be thrown immediately explaining the invalid input.
 */ function execute(args) {
    // If a valid execution context cannot be created due to incorrect arguments,
    // a "Response" with only errors is returned.
    const exeContext = buildExecutionContext(args);
    // Return early errors if execution context failed.
    if (!("schema" in exeContext)) {
        return {
            errors: exeContext.map((e)=>{
                var _a;
                Object.defineProperty(e, "extensions", {
                    value: {
                        ...e.extensions,
                        http: {
                            ...(_a = e.extensions) === null || _a === void 0 ? void 0 : _a["http"],
                            status: 400
                        }
                    }
                });
                return e;
            })
        };
    }
    return executeImpl(exeContext);
}
exports.execute = execute;
function executeImpl(exeContext) {
    // Return a Promise that will eventually resolve to the data described by
    // The "Response" section of the GraphQL specification.
    //
    // If errors are encountered while executing a GraphQL field, only that
    // field and its descendants will be omitted, and sibling fields will still
    // be executed. An execution which encounters errors will still result in a
    // resolved Promise.
    //
    // Errors from sub-fields of a NonNull type may propagate to the top level,
    // at which point we still log the error and null the parent field, which
    // in this case is the entire response.
    return new value_or_promise_1.ValueOrPromise(()=>executeOperation(exeContext)).then((data)=>{
        const initialResult = buildResponse(data, exeContext.errors);
        if (exeContext.subsequentPayloads.size > 0) {
            return {
                initialResult: {
                    ...initialResult,
                    hasNext: true
                },
                subsequentResults: yieldSubsequentPayloads(exeContext)
            };
        }
        return initialResult;
    }, (error)=>{
        exeContext.errors.push(error);
        return buildResponse(null, exeContext.errors);
    }).resolve();
}
/**
 * Also implements the "Executing requests" section of the GraphQL specification.
 * However, it guarantees to complete synchronously (or throw an error) assuming
 * that all field resolvers are also synchronous.
 */ function executeSync(args) {
    const result = execute(args);
    // Assert that the execution was synchronous.
    if ((0, utils_1.isPromise)(result) || "initialResult" in result) {
        throw new Error("GraphQL execution failed to complete synchronously.");
    }
    return result;
}
exports.executeSync = executeSync;
/**
 * Given a completed execution context and data, build the `{ errors, data }`
 * response defined by the "Response" section of the GraphQL specification.
 */ function buildResponse(data, errors) {
    return errors.length === 0 ? {
        data
    } : {
        errors,
        data
    };
}
/**
 * Essential assertions before executing to provide developer feedback for
 * improper use of the GraphQL library.
 *
 * @internal
 */ function assertValidExecutionArguments(schema, document, rawVariableValues) {
    console.assert(!!document, "Must provide document.");
    // If the schema used for execution is invalid, throw an error.
    (0, graphql_1.assertValidSchema)(schema);
    // Variables, if provided, must be an object.
    console.assert(rawVariableValues == null || (0, utils_1.isObjectLike)(rawVariableValues), "Variables must be provided as an Object where each property is a variable value. Perhaps look to see if an unparsed JSON string was provided.");
}
exports.assertValidExecutionArguments = assertValidExecutionArguments;
/**
 * Constructs a ExecutionContext object from the arguments passed to
 * execute, which we will pass throughout the other execution methods.
 *
 * Throws a GraphQLError if a valid execution context cannot be created.
 *
 * TODO: consider no longer exporting this function
 * @internal
 */ function buildExecutionContext(args) {
    var _a, _b;
    const { schema , document , rootValue , contextValue , variableValues: rawVariableValues , operationName , fieldResolver , typeResolver , subscribeFieldResolver  } = args;
    // If the schema used for execution is invalid, throw an error.
    (0, graphql_1.assertValidSchema)(schema);
    let operation;
    const fragments = Object.create(null);
    for (const definition of document.definitions){
        switch(definition.kind){
            case graphql_1.Kind.OPERATION_DEFINITION:
                if (operationName == null) {
                    if (operation !== undefined) {
                        return [
                            (0, utils_1.createGraphQLError)("Must provide operation name if query contains multiple operations.")
                        ];
                    }
                    operation = definition;
                } else if (((_a = definition.name) === null || _a === void 0 ? void 0 : _a.value) === operationName) {
                    operation = definition;
                }
                break;
            case graphql_1.Kind.FRAGMENT_DEFINITION:
                fragments[definition.name.value] = definition;
                break;
            default:
        }
    }
    if (!operation) {
        if (operationName != null) {
            return [
                (0, utils_1.createGraphQLError)(`Unknown operation named "${operationName}".`)
            ];
        }
        return [
            (0, utils_1.createGraphQLError)("Must provide an operation.")
        ];
    }
    // FIXME: https://github.com/graphql/graphql-js/issues/2203
    /* c8 ignore next */ const variableDefinitions = (_b = operation.variableDefinitions) !== null && _b !== void 0 ? _b : [];
    const coercedVariableValues = (0, values_js_1.getVariableValues)(schema, variableDefinitions, rawVariableValues !== null && rawVariableValues !== void 0 ? rawVariableValues : {}, {
        maxErrors: 50
    });
    if (coercedVariableValues.errors) {
        return coercedVariableValues.errors;
    }
    return {
        schema,
        fragments,
        rootValue,
        contextValue,
        operation,
        variableValues: coercedVariableValues.coerced,
        fieldResolver: fieldResolver !== null && fieldResolver !== void 0 ? fieldResolver : exports.defaultFieldResolver,
        typeResolver: typeResolver !== null && typeResolver !== void 0 ? typeResolver : exports.defaultTypeResolver,
        subscribeFieldResolver: subscribeFieldResolver !== null && subscribeFieldResolver !== void 0 ? subscribeFieldResolver : exports.defaultFieldResolver,
        subsequentPayloads: new Set(),
        errors: []
    };
}
exports.buildExecutionContext = buildExecutionContext;
function buildPerEventExecutionContext(exeContext, payload) {
    return {
        ...exeContext,
        rootValue: payload,
        subsequentPayloads: new Set(),
        errors: []
    };
}
/**
 * Implements the "Executing operations" section of the spec.
 */ function executeOperation(exeContext) {
    const { operation , schema , fragments , variableValues , rootValue  } = exeContext;
    const rootType = (0, utils_1.getDefinedRootType)(schema, operation.operation, [
        operation
    ]);
    if (rootType == null) {
        (0, utils_1.createGraphQLError)(`Schema is not configured to execute ${operation.operation} operation.`, {
            nodes: operation
        });
    }
    const { fields: rootFields , patches  } = (0, utils_1.collectFields)(schema, fragments, variableValues, rootType, operation.selectionSet);
    const path = undefined;
    let result;
    if (operation.operation === "mutation") {
        result = executeFieldsSerially(exeContext, rootType, rootValue, path, rootFields);
    } else {
        result = executeFields(exeContext, rootType, rootValue, path, rootFields);
    }
    for (const patch of patches){
        const { label , fields: patchFields  } = patch;
        executeDeferredFragment(exeContext, rootType, rootValue, patchFields, label, path);
    }
    return result;
}
/**
 * Implements the "Executing selection sets" section of the spec
 * for fields that must be executed serially.
 */ function executeFieldsSerially(exeContext, parentType, sourceValue, path, fields) {
    return (0, utils_1.promiseReduce)(fields, (results, [responseName, fieldNodes])=>{
        const fieldPath = (0, utils_1.addPath)(path, responseName, parentType.name);
        return new value_or_promise_1.ValueOrPromise(()=>executeField(exeContext, parentType, sourceValue, fieldNodes, fieldPath)).then((result)=>{
            if (result === undefined) {
                return results;
            }
            results[responseName] = result;
            return results;
        }).resolve();
    }, Object.create(null));
}
/**
 * Implements the "Executing selection sets" section of the spec
 * for fields that may be executed in parallel.
 */ function executeFields(exeContext, parentType, sourceValue, path, fields, asyncPayloadRecord) {
    const results = Object.create(null);
    let containsPromise = false;
    try {
        for (const [responseName, fieldNodes] of fields){
            const fieldPath = (0, utils_1.addPath)(path, responseName, parentType.name);
            const result = executeField(exeContext, parentType, sourceValue, fieldNodes, fieldPath, asyncPayloadRecord);
            if (result !== undefined) {
                results[responseName] = result;
                if ((0, utils_1.isPromise)(result)) {
                    containsPromise = true;
                }
            }
        }
    } catch (error) {
        if (containsPromise) {
            // Ensure that any promises returned by other fields are handled, as they may also reject.
            return (0, promiseForObject_js_1.promiseForObject)(results).finally(()=>{
                throw error;
            });
        }
        throw error;
    }
    // If there are no promises, we can just return the object
    if (!containsPromise) {
        return results;
    }
    // Otherwise, results is a map from field name to the result of resolving that
    // field, which is possibly a promise. Return a promise that will return this
    // same map, but with any promises replaced with the values they resolved to.
    return (0, promiseForObject_js_1.promiseForObject)(results);
}
/**
 * Implements the "Executing fields" section of the spec
 * In particular, this function figures out the value that the field returns by
 * calling its resolve function, then calls completeValue to complete promises,
 * serialize scalars, or execute the sub-selection-set for objects.
 */ function executeField(exeContext, parentType, source, fieldNodes, path, asyncPayloadRecord) {
    var _a, _b;
    const errors = (_a = asyncPayloadRecord === null || asyncPayloadRecord === void 0 ? void 0 : asyncPayloadRecord.errors) !== null && _a !== void 0 ? _a : exeContext.errors;
    const fieldDef = getFieldDef(exeContext.schema, parentType, fieldNodes[0]);
    if (!fieldDef) {
        return;
    }
    const returnType = fieldDef.type;
    const resolveFn = (_b = fieldDef.resolve) !== null && _b !== void 0 ? _b : exeContext.fieldResolver;
    const info = buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path);
    // Get the resolve function, regardless of if its result is normal or abrupt (error).
    try {
        // Build a JS object of arguments from the field.arguments AST, using the
        // variables scope to fulfill any variable references.
        // TODO: find a way to memoize, in case this field is within a List type.
        const args = (0, utils_1.getArgumentValues)(fieldDef, fieldNodes[0], exeContext.variableValues);
        // The resolve function's optional third argument is a context value that
        // is provided to every resolve function within an execution. It is commonly
        // used to represent an authenticated user, or request-specific caches.
        const contextValue = exeContext.contextValue;
        const result = resolveFn(source, args, contextValue, info);
        let completed;
        if ((0, utils_1.isPromise)(result)) {
            completed = result.then((resolved)=>completeValue(exeContext, returnType, fieldNodes, info, path, resolved, asyncPayloadRecord));
        } else {
            completed = completeValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord);
        }
        if ((0, utils_1.isPromise)(completed)) {
            // Note: we don't rely on a `catch` method, but we do expect "thenable"
            // to take a second callback for the error case.
            return completed.then(undefined, (rawError)=>{
                const error = (0, graphql_1.locatedError)(rawError, fieldNodes, (0, utils_1.pathToArray)(path));
                const handledError = handleFieldError(error, returnType, errors);
                filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);
                return handledError;
            });
        }
        return completed;
    } catch (rawError) {
        const error = (0, graphql_1.locatedError)(rawError, fieldNodes, (0, utils_1.pathToArray)(path));
        const handledError = handleFieldError(error, returnType, errors);
        filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);
        return handledError;
    }
}
/**
 * TODO: consider no longer exporting this function
 * @internal
 */ function buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path) {
    // The resolve function's optional fourth argument is a collection of
    // information about the current execution state.
    return {
        fieldName: fieldDef.name,
        fieldNodes,
        returnType: fieldDef.type,
        parentType,
        path,
        schema: exeContext.schema,
        fragments: exeContext.fragments,
        rootValue: exeContext.rootValue,
        operation: exeContext.operation,
        variableValues: exeContext.variableValues
    };
}
exports.buildResolveInfo = buildResolveInfo;
function handleFieldError(error, returnType, errors) {
    // If the field type is non-nullable, then it is resolved without any
    // protection from errors, however it still properly locates the error.
    if ((0, graphql_1.isNonNullType)(returnType)) {
        throw error;
    }
    // Otherwise, error protection is applied, logging the error and resolving
    // a null value for this field if one is encountered.
    errors.push(error);
    return null;
}
/**
 * Implements the instructions for completeValue as defined in the
 * "Value Completion" section of the spec.
 *
 * If the field type is Non-Null, then this recursively completes the value
 * for the inner type. It throws a field error if that completion returns null,
 * as per the "Nullability" section of the spec.
 *
 * If the field type is a List, then this recursively completes the value
 * for the inner type on each item in the list.
 *
 * If the field type is a Scalar or Enum, ensures the completed value is a legal
 * value of the type by calling the `serialize` method of GraphQL type
 * definition.
 *
 * If the field is an abstract type, determine the runtime type of the value
 * and then complete based on that type
 *
 * Otherwise, the field type expects a sub-selection set, and will complete the
 * value by executing all sub-selections.
 */ function completeValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord) {
    // If result is an Error, throw a located error.
    if (result instanceof Error) {
        throw result;
    }
    // If field type is NonNull, complete for inner type, and throw field error
    // if result is null.
    if ((0, graphql_1.isNonNullType)(returnType)) {
        const completed = completeValue(exeContext, returnType.ofType, fieldNodes, info, path, result, asyncPayloadRecord);
        if (completed === null) {
            throw new Error(`Cannot return null for non-nullable field ${info.parentType.name}.${info.fieldName}.`);
        }
        return completed;
    }
    // If result value is null or undefined then return null.
    if (result == null) {
        return null;
    }
    // If field type is List, complete each item in the list with the inner type
    if ((0, graphql_1.isListType)(returnType)) {
        return completeListValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord);
    }
    // If field type is a leaf type, Scalar or Enum, serialize to a valid value,
    // returning null if serialization is not possible.
    if ((0, graphql_1.isLeafType)(returnType)) {
        return completeLeafValue(returnType, result);
    }
    // If field type is an abstract type, Interface or Union, determine the
    // runtime Object type and complete for that type.
    if ((0, graphql_1.isAbstractType)(returnType)) {
        return completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord);
    }
    // If field type is Object, execute and complete all sub-selections.
    if ((0, graphql_1.isObjectType)(returnType)) {
        return completeObjectValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord);
    }
    /* c8 ignore next 6 */ // Not reachable, all possible output types have been considered.
    console.assert(false, "Cannot complete value of unexpected output type: " + (0, utils_1.inspect)(returnType));
}
/**
 * Returns an object containing the `@stream` arguments if a field should be
 * streamed based on the experimental flag, stream directive present and
 * not disabled by the "if" argument.
 */ function getStreamValues(exeContext, fieldNodes, path) {
    // do not stream inner lists of multi-dimensional lists
    if (typeof path.key === "number") {
        return;
    }
    // validation only allows equivalent streams on multiple fields, so it is
    // safe to only check the first fieldNode for the stream directive
    const stream = (0, graphql_1.getDirectiveValues)(utils_1.GraphQLStreamDirective, fieldNodes[0], exeContext.variableValues);
    if (!stream) {
        return;
    }
    if (stream.if === false) {
        return;
    }
    (0, invariant_js_1.invariant)(typeof stream["initialCount"] === "number", "initialCount must be a number");
    (0, invariant_js_1.invariant)(stream["initialCount"] >= 0, "initialCount must be a positive integer");
    return {
        initialCount: stream["initialCount"],
        label: typeof stream["label"] === "string" ? stream["label"] : undefined
    };
}
/**
 * Complete a async iterator value by completing the result and calling
 * recursively until all the results are completed.
 */ async function completeAsyncIteratorValue(exeContext, itemType, fieldNodes, info, path, iterator, asyncPayloadRecord) {
    var _a;
    const errors = (_a = asyncPayloadRecord === null || asyncPayloadRecord === void 0 ? void 0 : asyncPayloadRecord.errors) !== null && _a !== void 0 ? _a : exeContext.errors;
    const stream = getStreamValues(exeContext, fieldNodes, path);
    let containsPromise = false;
    const completedResults = [];
    let index = 0;
    while(true){
        if (stream && typeof stream.initialCount === "number" && index >= stream.initialCount) {
            executeStreamIterator(index, iterator, exeContext, fieldNodes, info, itemType, path, stream.label, asyncPayloadRecord);
            break;
        }
        const itemPath = (0, utils_1.addPath)(path, index, undefined);
        let iteration;
        try {
            iteration = await iterator.next();
            if (iteration.done) {
                break;
            }
        } catch (rawError) {
            const error = (0, graphql_1.locatedError)(rawError, fieldNodes, (0, utils_1.pathToArray)(itemPath));
            completedResults.push(handleFieldError(error, itemType, errors));
            break;
        }
        if (completeListItemValue(iteration.value, completedResults, errors, exeContext, itemType, fieldNodes, info, itemPath, asyncPayloadRecord)) {
            containsPromise = true;
        }
        index += 1;
    }
    return containsPromise ? Promise.all(completedResults) : completedResults;
}
/**
 * Complete a list value by completing each item in the list with the
 * inner type
 */ function completeListValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord) {
    var _a;
    const itemType = returnType.ofType;
    const errors = (_a = asyncPayloadRecord === null || asyncPayloadRecord === void 0 ? void 0 : asyncPayloadRecord.errors) !== null && _a !== void 0 ? _a : exeContext.errors;
    if ((0, utils_1.isAsyncIterable)(result)) {
        const iterator = result[Symbol.asyncIterator]();
        return completeAsyncIteratorValue(exeContext, itemType, fieldNodes, info, path, iterator, asyncPayloadRecord);
    }
    if (!(0, utils_1.isIterableObject)(result)) {
        throw (0, utils_1.createGraphQLError)(`Expected Iterable, but did not find one for field "${info.parentType.name}.${info.fieldName}".`);
    }
    const stream = getStreamValues(exeContext, fieldNodes, path);
    // This is specified as a simple map, however we're optimizing the path
    // where the list contains no Promises by avoiding creating another Promise.
    let containsPromise = false;
    let previousAsyncPayloadRecord = asyncPayloadRecord;
    const completedResults = [];
    let index = 0;
    for (const item of result){
        // No need to modify the info object containing the path,
        // since from here on it is not ever accessed by resolver functions.
        const itemPath = (0, utils_1.addPath)(path, index, undefined);
        if (stream && typeof stream.initialCount === "number" && index >= stream.initialCount) {
            previousAsyncPayloadRecord = executeStreamField(path, itemPath, item, exeContext, fieldNodes, info, itemType, stream.label, previousAsyncPayloadRecord);
            index++;
            continue;
        }
        if (completeListItemValue(item, completedResults, errors, exeContext, itemType, fieldNodes, info, itemPath, asyncPayloadRecord)) {
            containsPromise = true;
        }
        index++;
    }
    return containsPromise ? Promise.all(completedResults) : completedResults;
}
/**
 * Complete a list item value by adding it to the completed results.
 *
 * Returns true if the value is a Promise.
 */ function completeListItemValue(item, completedResults, errors, exeContext, itemType, fieldNodes, info, itemPath, asyncPayloadRecord) {
    try {
        let completedItem;
        if ((0, utils_1.isPromise)(item)) {
            completedItem = item.then((resolved)=>completeValue(exeContext, itemType, fieldNodes, info, itemPath, resolved, asyncPayloadRecord));
        } else {
            completedItem = completeValue(exeContext, itemType, fieldNodes, info, itemPath, item, asyncPayloadRecord);
        }
        if ((0, utils_1.isPromise)(completedItem)) {
            // Note: we don't rely on a `catch` method, but we do expect "thenable"
            // to take a second callback for the error case.
            completedResults.push(completedItem.then(undefined, (rawError)=>{
                const error = (0, graphql_1.locatedError)(rawError, fieldNodes, (0, utils_1.pathToArray)(itemPath));
                const handledError = handleFieldError(error, itemType, errors);
                filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);
                return handledError;
            }));
            return true;
        }
        completedResults.push(completedItem);
    } catch (rawError) {
        const error = (0, graphql_1.locatedError)(rawError, fieldNodes, (0, utils_1.pathToArray)(itemPath));
        const handledError = handleFieldError(error, itemType, errors);
        filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);
        completedResults.push(handledError);
    }
    return false;
}
/**
 * Complete a Scalar or Enum by serializing to a valid value, returning
 * null if serialization is not possible.
 */ function completeLeafValue(returnType, result) {
    const serializedResult = returnType.serialize(result);
    if (serializedResult == null) {
        throw new Error(`Expected \`${(0, utils_1.inspect)(returnType)}.serialize(${(0, utils_1.inspect)(result)})\` to ` + `return non-nullable value, returned: ${(0, utils_1.inspect)(serializedResult)}`);
    }
    return serializedResult;
}
/**
 * Complete a value of an abstract type by determining the runtime object type
 * of that value, then complete the value for that type.
 */ function completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord) {
    var _a;
    const resolveTypeFn = (_a = returnType.resolveType) !== null && _a !== void 0 ? _a : exeContext.typeResolver;
    const contextValue = exeContext.contextValue;
    const runtimeType = resolveTypeFn(result, contextValue, info, returnType);
    if ((0, utils_1.isPromise)(runtimeType)) {
        return runtimeType.then((resolvedRuntimeType)=>completeObjectValue(exeContext, ensureValidRuntimeType(resolvedRuntimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result, asyncPayloadRecord));
    }
    return completeObjectValue(exeContext, ensureValidRuntimeType(runtimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result, asyncPayloadRecord);
}
function ensureValidRuntimeType(runtimeTypeName, exeContext, returnType, fieldNodes, info, result) {
    if (runtimeTypeName == null) {
        throw (0, utils_1.createGraphQLError)(`Abstract type "${returnType.name}" must resolve to an Object type at runtime for field "${info.parentType.name}.${info.fieldName}". Either the "${returnType.name}" type should provide a "resolveType" function or each possible type should provide an "isTypeOf" function.`, {
            nodes: fieldNodes
        });
    }
    // releases before 16.0.0 supported returning `GraphQLObjectType` from `resolveType`
    // TODO: remove in 17.0.0 release
    if ((0, graphql_1.isObjectType)(runtimeTypeName)) {
        throw (0, utils_1.createGraphQLError)("Support for returning GraphQLObjectType from resolveType was removed in graphql-js@16.0.0 please return type name instead.");
    }
    if (typeof runtimeTypeName !== "string") {
        throw (0, utils_1.createGraphQLError)(`Abstract type "${returnType.name}" must resolve to an Object type at runtime for field "${info.parentType.name}.${info.fieldName}" with ` + `value ${(0, utils_1.inspect)(result)}, received "${(0, utils_1.inspect)(runtimeTypeName)}".`);
    }
    const runtimeType = exeContext.schema.getType(runtimeTypeName);
    if (runtimeType == null) {
        throw (0, utils_1.createGraphQLError)(`Abstract type "${returnType.name}" was resolved to a type "${runtimeTypeName}" that does not exist inside the schema.`, {
            nodes: fieldNodes
        });
    }
    if (!(0, graphql_1.isObjectType)(runtimeType)) {
        throw (0, utils_1.createGraphQLError)(`Abstract type "${returnType.name}" was resolved to a non-object type "${runtimeTypeName}".`, {
            nodes: fieldNodes
        });
    }
    if (!exeContext.schema.isSubType(returnType, runtimeType)) {
        throw (0, utils_1.createGraphQLError)(`Runtime Object type "${runtimeType.name}" is not a possible type for "${returnType.name}".`, {
            nodes: fieldNodes
        });
    }
    return runtimeType;
}
/**
 * Complete an Object value by executing all sub-selections.
 */ function completeObjectValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord) {
    // If there is an isTypeOf predicate function, call it with the
    // current result. If isTypeOf returns false, then raise an error rather
    // than continuing execution.
    if (returnType.isTypeOf) {
        const isTypeOf = returnType.isTypeOf(result, exeContext.contextValue, info);
        if ((0, utils_1.isPromise)(isTypeOf)) {
            return isTypeOf.then((resolvedIsTypeOf)=>{
                if (!resolvedIsTypeOf) {
                    throw invalidReturnTypeError(returnType, result, fieldNodes);
                }
                return collectAndExecuteSubfields(exeContext, returnType, fieldNodes, path, result, asyncPayloadRecord);
            });
        }
        if (!isTypeOf) {
            throw invalidReturnTypeError(returnType, result, fieldNodes);
        }
    }
    return collectAndExecuteSubfields(exeContext, returnType, fieldNodes, path, result, asyncPayloadRecord);
}
function invalidReturnTypeError(returnType, result, fieldNodes) {
    return (0, utils_1.createGraphQLError)(`Expected value of type "${returnType.name}" but got: ${(0, utils_1.inspect)(result)}.`, {
        nodes: fieldNodes
    });
}
function collectAndExecuteSubfields(exeContext, returnType, fieldNodes, path, result, asyncPayloadRecord) {
    // Collect sub-fields to execute to complete this value.
    const { fields: subFieldNodes , patches: subPatches  } = collectSubfields(exeContext, returnType, fieldNodes);
    const subFields = executeFields(exeContext, returnType, result, path, subFieldNodes, asyncPayloadRecord);
    for (const subPatch of subPatches){
        const { label , fields: subPatchFieldNodes  } = subPatch;
        executeDeferredFragment(exeContext, returnType, result, subPatchFieldNodes, label, path, asyncPayloadRecord);
    }
    return subFields;
}
/**
 * If a resolveType function is not given, then a default resolve behavior is
 * used which attempts two strategies:
 *
 * First, See if the provided value has a `__typename` field defined, if so, use
 * that value as name of the resolved type.
 *
 * Otherwise, test each possible type for the abstract type by calling
 * isTypeOf for the object being coerced, returning the first type that matches.
 */ const defaultTypeResolver = function(value, contextValue, info, abstractType) {
    // First, look for `__typename`.
    if ((0, utils_1.isObjectLike)(value) && typeof value["__typename"] === "string") {
        return value["__typename"];
    }
    // Otherwise, test each possible type.
    const possibleTypes = info.schema.getPossibleTypes(abstractType);
    const promisedIsTypeOfResults = [];
    for(let i = 0; i < possibleTypes.length; i++){
        const type = possibleTypes[i];
        if (type.isTypeOf) {
            const isTypeOfResult = type.isTypeOf(value, contextValue, info);
            if ((0, utils_1.isPromise)(isTypeOfResult)) {
                promisedIsTypeOfResults[i] = isTypeOfResult;
            } else if (isTypeOfResult) {
                return type.name;
            }
        }
    }
    if (promisedIsTypeOfResults.length) {
        return Promise.all(promisedIsTypeOfResults).then((isTypeOfResults)=>{
            for(let i = 0; i < isTypeOfResults.length; i++){
                if (isTypeOfResults[i]) {
                    return possibleTypes[i].name;
                }
            }
        });
    }
};
exports.defaultTypeResolver = defaultTypeResolver;
/**
 * If a resolve function is not given, then a default resolve behavior is used
 * which takes the property of the source object of the same name as the field
 * and returns it as the result, or if it's a function, returns the result
 * of calling that function while passing along args and context value.
 */ const defaultFieldResolver = function(source, args, contextValue, info) {
    // ensure source is a value for which property access is acceptable.
    if ((0, utils_1.isObjectLike)(source) || typeof source === "function") {
        const property = source[info.fieldName];
        if (typeof property === "function") {
            return source[info.fieldName](args, contextValue, info);
        }
        return property;
    }
};
exports.defaultFieldResolver = defaultFieldResolver;
/**
 * Implements the "Subscribe" algorithm described in the GraphQL specification,
 * including `@defer` and `@stream` as proposed in
 * https://github.com/graphql/graphql-spec/pull/742
 *
 * Returns a Promise which resolves to either an AsyncIterator (if successful)
 * or an ExecutionResult (error). The promise will be rejected if the schema or
 * other arguments to this function are invalid, or if the resolved event stream
 * is not an async iterable.
 *
 * If the client-provided arguments to this function do not result in a
 * compliant subscription, a GraphQL Response (ExecutionResult) with descriptive
 * errors and no data will be returned.
 *
 * If the source stream could not be created due to faulty subscription resolver
 * logic or underlying systems, the promise will resolve to a single
 * ExecutionResult containing `errors` and no `data`.
 *
 * If the operation succeeded, the promise resolves to an AsyncIterator, which
 * yields a stream of result representing the response stream.
 *
 * Each result may be an ExecutionResult with no `hasNext` (if executing the
 * event did not use `@defer` or `@stream`), or an
 * `InitialIncrementalExecutionResult` or `SubsequentIncrementalExecutionResult`
 * (if executing the event used `@defer` or `@stream`). In the case of
 * incremental execution results, each event produces a single
 * `InitialIncrementalExecutionResult` followed by one or more
 * `SubsequentIncrementalExecutionResult`s; all but the last have `hasNext: true`,
 * and the last has `hasNext: false`. There is no interleaving between results
 * generated from the same original event.
 *
 * Accepts an object with named arguments.
 */ function subscribe(args) {
    // If a valid execution context cannot be created due to incorrect arguments,
    // a "Response" with only errors is returned.
    const exeContext = buildExecutionContext(args);
    // Return early errors if execution context failed.
    if (!("schema" in exeContext)) {
        return {
            errors: exeContext.map((e)=>{
                var _a;
                Object.defineProperty(e, "extensions", {
                    value: {
                        ...e.extensions,
                        http: {
                            ...(_a = e.extensions) === null || _a === void 0 ? void 0 : _a["http"],
                            status: 400
                        }
                    }
                });
                return e;
            })
        };
    }
    const resultOrStream = createSourceEventStreamImpl(exeContext);
    if ((0, utils_1.isPromise)(resultOrStream)) {
        return resultOrStream.then((resolvedResultOrStream)=>mapSourceToResponse(exeContext, resolvedResultOrStream));
    }
    return mapSourceToResponse(exeContext, resultOrStream);
}
exports.subscribe = subscribe;
function flattenIncrementalResults(incrementalResults) {
    const subsequentIterator = incrementalResults.subsequentResults;
    let initialResultSent = false;
    let done = false;
    return {
        [Symbol.asyncIterator] () {
            return this;
        },
        async next () {
            if (done) {
                return {
                    value: undefined,
                    done
                };
            }
            if (initialResultSent) {
                return subsequentIterator.next();
            }
            initialResultSent = true;
            return Promise.resolve({
                value: incrementalResults.initialResult,
                done
            });
        },
        return () {
            done = true;
            return subsequentIterator.return();
        },
        throw (error) {
            done = true;
            return subsequentIterator.throw(error);
        }
    };
}
exports.flattenIncrementalResults = flattenIncrementalResults;
async function* ensureAsyncIterable(someExecutionResult) {
    if ("initialResult" in someExecutionResult) {
        yield* flattenIncrementalResults(someExecutionResult);
    } else {
        yield someExecutionResult;
    }
}
function mapSourceToResponse(exeContext, resultOrStream) {
    if (!(0, utils_1.isAsyncIterable)(resultOrStream)) {
        return resultOrStream;
    }
    // For each payload yielded from a subscription, map it over the normal
    // GraphQL `execute` function, with `payload` as the rootValue.
    // This implements the "MapSourceToResponseEvent" algorithm described in
    // the GraphQL specification. The `execute` function provides the
    // "ExecuteSubscriptionEvent" algorithm, as it is nearly identical to the
    // "ExecuteQuery" algorithm, for which `execute` is also used.
    return (0, flattenAsyncIterable_js_1.flattenAsyncIterable)((0, utils_1.mapAsyncIterator)(resultOrStream[Symbol.asyncIterator](), async (payload)=>ensureAsyncIterable(await executeImpl(buildPerEventExecutionContext(exeContext, payload))), async function*(error) {
        const wrappedError = (0, utils_1.createGraphQLError)(error.message, {
            originalError: error,
            nodes: [
                exeContext.operation
            ]
        });
        yield {
            errors: [
                wrappedError
            ]
        };
    }));
}
function createSourceEventStreamImpl(exeContext) {
    try {
        const eventStream = executeSubscription(exeContext);
        if ((0, utils_1.isPromise)(eventStream)) {
            return eventStream.then(undefined, (error)=>({
                    errors: [
                        error
                    ]
                }));
        }
        return eventStream;
    } catch (error) {
        return {
            errors: [
                error
            ]
        };
    }
}
function executeSubscription(exeContext) {
    var _a;
    const { schema , fragments , operation , variableValues , rootValue  } = exeContext;
    const rootType = schema.getSubscriptionType();
    if (rootType == null) {
        throw (0, utils_1.createGraphQLError)("Schema is not configured to execute subscription operation.", {
            nodes: operation
        });
    }
    const { fields: rootFields  } = (0, utils_1.collectFields)(schema, fragments, variableValues, rootType, operation.selectionSet);
    const [responseName, fieldNodes] = [
        ...rootFields.entries()
    ][0];
    const fieldName = fieldNodes[0].name.value;
    const fieldDef = getFieldDef(schema, rootType, fieldNodes[0]);
    if (!fieldDef) {
        throw (0, utils_1.createGraphQLError)(`The subscription field "${fieldName}" is not defined.`, {
            nodes: fieldNodes
        });
    }
    const path = (0, utils_1.addPath)(undefined, responseName, rootType.name);
    const info = buildResolveInfo(exeContext, fieldDef, fieldNodes, rootType, path);
    try {
        // Implements the "ResolveFieldEventStream" algorithm from GraphQL specification.
        // It differs from "ResolveFieldValue" due to providing a different `resolveFn`.
        // Build a JS object of arguments from the field.arguments AST, using the
        // variables scope to fulfill any variable references.
        const args = (0, utils_1.getArgumentValues)(fieldDef, fieldNodes[0], variableValues);
        // The resolve function's optional third argument is a context value that
        // is provided to every resolve function within an execution. It is commonly
        // used to represent an authenticated user, or request-specific caches.
        const contextValue = exeContext.contextValue;
        // Call the `subscribe()` resolver or the default resolver to produce an
        // AsyncIterable yielding raw payloads.
        const resolveFn = (_a = fieldDef.subscribe) !== null && _a !== void 0 ? _a : exeContext.subscribeFieldResolver;
        const result = resolveFn(rootValue, args, contextValue, info);
        if ((0, utils_1.isPromise)(result)) {
            return result.then(assertEventStream).then(undefined, (error)=>{
                throw (0, graphql_1.locatedError)(error, fieldNodes, (0, utils_1.pathToArray)(path));
            });
        }
        return assertEventStream(result);
    } catch (error) {
        throw (0, graphql_1.locatedError)(error, fieldNodes, (0, utils_1.pathToArray)(path));
    }
}
function assertEventStream(result) {
    if (result instanceof Error) {
        throw result;
    }
    // Assert field returned an event stream, otherwise yield an error.
    if (!(0, utils_1.isAsyncIterable)(result)) {
        throw (0, utils_1.createGraphQLError)("Subscription field must return Async Iterable. " + `Received: ${(0, utils_1.inspect)(result)}.`);
    }
    return result;
}
function executeDeferredFragment(exeContext, parentType, sourceValue, fields, label, path, parentContext) {
    const asyncPayloadRecord = new DeferredFragmentRecord({
        label,
        path,
        parentContext,
        exeContext
    });
    let promiseOrData;
    try {
        promiseOrData = executeFields(exeContext, parentType, sourceValue, path, fields, asyncPayloadRecord);
        if ((0, utils_1.isPromise)(promiseOrData)) {
            promiseOrData = promiseOrData.then(null, (e)=>{
                asyncPayloadRecord.errors.push(e);
                return null;
            });
        }
    } catch (e) {
        asyncPayloadRecord.errors.push(e);
        promiseOrData = null;
    }
    asyncPayloadRecord.addData(promiseOrData);
}
function executeStreamField(path, itemPath, item, exeContext, fieldNodes, info, itemType, label, parentContext) {
    const asyncPayloadRecord = new StreamRecord({
        label,
        path: itemPath,
        parentContext,
        exeContext
    });
    let completedItem;
    try {
        try {
            if ((0, utils_1.isPromise)(item)) {
                completedItem = item.then((resolved)=>completeValue(exeContext, itemType, fieldNodes, info, itemPath, resolved, asyncPayloadRecord));
            } else {
                completedItem = completeValue(exeContext, itemType, fieldNodes, info, itemPath, item, asyncPayloadRecord);
            }
            if ((0, utils_1.isPromise)(completedItem)) {
                // Note: we don't rely on a `catch` method, but we do expect "thenable"
                // to take a second callback for the error case.
                completedItem = completedItem.then(undefined, (rawError)=>{
                    const error = (0, graphql_1.locatedError)(rawError, fieldNodes, (0, utils_1.pathToArray)(itemPath));
                    const handledError = handleFieldError(error, itemType, asyncPayloadRecord.errors);
                    filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);
                    return handledError;
                });
            }
        } catch (rawError) {
            const error = (0, graphql_1.locatedError)(rawError, fieldNodes, (0, utils_1.pathToArray)(itemPath));
            completedItem = handleFieldError(error, itemType, asyncPayloadRecord.errors);
            filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);
        }
    } catch (error) {
        asyncPayloadRecord.errors.push(error);
        filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);
        asyncPayloadRecord.addItems(null);
        return asyncPayloadRecord;
    }
    let completedItems;
    if ((0, utils_1.isPromise)(completedItem)) {
        completedItems = completedItem.then((value)=>[
                value
            ], (error)=>{
            asyncPayloadRecord.errors.push(error);
            filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);
            return null;
        });
    } else {
        completedItems = [
            completedItem
        ];
    }
    asyncPayloadRecord.addItems(completedItems);
    return asyncPayloadRecord;
}
async function executeStreamIteratorItem(iterator, exeContext, fieldNodes, info, itemType, asyncPayloadRecord, itemPath) {
    let item;
    try {
        const { value , done  } = await iterator.next();
        if (done) {
            asyncPayloadRecord.setIsCompletedIterator();
            return {
                done,
                value: undefined
            };
        }
        item = value;
    } catch (rawError) {
        const error = (0, graphql_1.locatedError)(rawError, fieldNodes, (0, utils_1.pathToArray)(itemPath));
        const value = handleFieldError(error, itemType, asyncPayloadRecord.errors);
        // don't continue if iterator throws
        return {
            done: true,
            value
        };
    }
    let completedItem;
    try {
        completedItem = completeValue(exeContext, itemType, fieldNodes, info, itemPath, item, asyncPayloadRecord);
        if ((0, utils_1.isPromise)(completedItem)) {
            completedItem = completedItem.then(undefined, (rawError)=>{
                const error = (0, graphql_1.locatedError)(rawError, fieldNodes, (0, utils_1.pathToArray)(itemPath));
                const handledError = handleFieldError(error, itemType, asyncPayloadRecord.errors);
                filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);
                return handledError;
            });
        }
        return {
            done: false,
            value: completedItem
        };
    } catch (rawError) {
        const error = (0, graphql_1.locatedError)(rawError, fieldNodes, (0, utils_1.pathToArray)(itemPath));
        const value = handleFieldError(error, itemType, asyncPayloadRecord.errors);
        filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);
        return {
            done: false,
            value
        };
    }
}
async function executeStreamIterator(initialIndex, iterator, exeContext, fieldNodes, info, itemType, path, label, parentContext) {
    let index = initialIndex;
    let previousAsyncPayloadRecord = parentContext !== null && parentContext !== void 0 ? parentContext : undefined;
    while(true){
        const itemPath = (0, utils_1.addPath)(path, index, undefined);
        const asyncPayloadRecord = new StreamRecord({
            label,
            path: itemPath,
            parentContext: previousAsyncPayloadRecord,
            iterator,
            exeContext
        });
        let iteration;
        try {
            iteration = await executeStreamIteratorItem(iterator, exeContext, fieldNodes, info, itemType, asyncPayloadRecord, itemPath);
        } catch (error) {
            asyncPayloadRecord.errors.push(error);
            filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);
            asyncPayloadRecord.addItems(null);
            // entire stream has errored and bubbled upwards
            if (iterator === null || iterator === void 0 ? void 0 : iterator.return) {
                iterator.return().catch(()=>{
                // ignore errors
                });
            }
            return;
        }
        const { done , value: completedItem  } = iteration;
        let completedItems;
        if ((0, utils_1.isPromise)(completedItem)) {
            completedItems = completedItem.then((value)=>[
                    value
                ], (error)=>{
                asyncPayloadRecord.errors.push(error);
                filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);
                return null;
            });
        } else {
            completedItems = [
                completedItem
            ];
        }
        asyncPayloadRecord.addItems(completedItems);
        if (done) {
            break;
        }
        previousAsyncPayloadRecord = asyncPayloadRecord;
        index++;
    }
}
function filterSubsequentPayloads(exeContext, nullPath, currentAsyncRecord) {
    const nullPathArray = (0, utils_1.pathToArray)(nullPath);
    exeContext.subsequentPayloads.forEach((asyncRecord)=>{
        var _a;
        if (asyncRecord === currentAsyncRecord) {
            // don't remove payload from where error originates
            return;
        }
        for(let i = 0; i < nullPathArray.length; i++){
            if (asyncRecord.path[i] !== nullPathArray[i]) {
                // asyncRecord points to a path unaffected by this payload
                return;
            }
        }
        // asyncRecord path points to nulled error field
        if (isStreamPayload(asyncRecord) && ((_a = asyncRecord.iterator) === null || _a === void 0 ? void 0 : _a.return)) {
            asyncRecord.iterator.return().catch(()=>{
            // ignore error
            });
        }
        exeContext.subsequentPayloads.delete(asyncRecord);
    });
}
function getCompletedIncrementalResults(exeContext) {
    const incrementalResults = [];
    for (const asyncPayloadRecord of exeContext.subsequentPayloads){
        const incrementalResult = {};
        if (!asyncPayloadRecord.isCompleted) {
            continue;
        }
        exeContext.subsequentPayloads.delete(asyncPayloadRecord);
        if (isStreamPayload(asyncPayloadRecord)) {
            const items = asyncPayloadRecord.items;
            if (asyncPayloadRecord.isCompletedIterator) {
                continue;
            }
            incrementalResult.items = items;
        } else {
            const data = asyncPayloadRecord.data;
            incrementalResult.data = data !== null && data !== void 0 ? data : null;
        }
        incrementalResult.path = asyncPayloadRecord.path;
        if (asyncPayloadRecord.label) {
            incrementalResult.label = asyncPayloadRecord.label;
        }
        if (asyncPayloadRecord.errors.length > 0) {
            incrementalResult.errors = asyncPayloadRecord.errors;
        }
        incrementalResults.push(incrementalResult);
    }
    return incrementalResults;
}
function yieldSubsequentPayloads(exeContext) {
    let isDone = false;
    async function next() {
        if (isDone) {
            return {
                value: undefined,
                done: true
            };
        }
        await Promise.race(Array.from(exeContext.subsequentPayloads).map((p)=>p.promise));
        if (isDone) {
            // a different call to next has exhausted all payloads
            return {
                value: undefined,
                done: true
            };
        }
        const incremental = getCompletedIncrementalResults(exeContext);
        const hasNext = exeContext.subsequentPayloads.size > 0;
        if (!incremental.length && hasNext) {
            return next();
        }
        if (!hasNext) {
            isDone = true;
        }
        return {
            value: incremental.length ? {
                incremental,
                hasNext
            } : {
                hasNext
            },
            done: false
        };
    }
    function returnStreamIterators() {
        const promises = [];
        exeContext.subsequentPayloads.forEach((asyncPayloadRecord)=>{
            var _a;
            if (isStreamPayload(asyncPayloadRecord) && ((_a = asyncPayloadRecord.iterator) === null || _a === void 0 ? void 0 : _a.return)) {
                promises.push(asyncPayloadRecord.iterator.return());
            }
        });
        return Promise.all(promises);
    }
    return {
        [Symbol.asyncIterator] () {
            return this;
        },
        next,
        async return () {
            await returnStreamIterators();
            isDone = true;
            return {
                value: undefined,
                done: true
            };
        },
        async throw (error) {
            await returnStreamIterators();
            isDone = true;
            return Promise.reject(error);
        }
    };
}
class DeferredFragmentRecord {
    constructor(opts){
        this.type = "defer";
        this.label = opts.label;
        this.path = (0, utils_1.pathToArray)(opts.path);
        this.parentContext = opts.parentContext;
        this.errors = [];
        this._exeContext = opts.exeContext;
        this._exeContext.subsequentPayloads.add(this);
        this.isCompleted = false;
        this.data = null;
        this.promise = new Promise((resolve)=>{
            this._resolve = (MaybePromise)=>{
                resolve(MaybePromise);
            };
        }).then((data)=>{
            this.data = data;
            this.isCompleted = true;
        });
    }
    addData(data) {
        var _a, _b, _c;
        const parentData = (_a = this.parentContext) === null || _a === void 0 ? void 0 : _a.promise;
        if (parentData) {
            (_b = this._resolve) === null || _b === void 0 ? void 0 : _b.call(this, parentData.then(()=>data));
            return;
        }
        (_c = this._resolve) === null || _c === void 0 ? void 0 : _c.call(this, data);
    }
}
class StreamRecord {
    constructor(opts){
        this.type = "stream";
        this.items = null;
        this.label = opts.label;
        this.path = (0, utils_1.pathToArray)(opts.path);
        this.parentContext = opts.parentContext;
        this.iterator = opts.iterator;
        this.errors = [];
        this._exeContext = opts.exeContext;
        this._exeContext.subsequentPayloads.add(this);
        this.isCompleted = false;
        this.items = null;
        this.promise = new Promise((resolve)=>{
            this._resolve = (MaybePromise)=>{
                resolve(MaybePromise);
            };
        }).then((items)=>{
            this.items = items;
            this.isCompleted = true;
        });
    }
    addItems(items) {
        var _a, _b, _c;
        const parentData = (_a = this.parentContext) === null || _a === void 0 ? void 0 : _a.promise;
        if (parentData) {
            (_b = this._resolve) === null || _b === void 0 ? void 0 : _b.call(this, parentData.then(()=>items));
            return;
        }
        (_c = this._resolve) === null || _c === void 0 ? void 0 : _c.call(this, items);
    }
    setIsCompletedIterator() {
        this.isCompletedIterator = true;
    }
}
function isStreamPayload(asyncPayload) {
    return asyncPayload.type === "stream";
}
/**
 * This method looks up the field on the given type definition.
 * It has special casing for the three introspection fields,
 * __schema, __type and __typename. __typename is special because
 * it can always be queried as a field, even in situations where no
 * other fields are allowed, like on a Union. __schema and __type
 * could get automatically added to the query type, but that would
 * require mutating type definitions, which would cause issues.
 *
 * @internal
 */ function getFieldDef(schema, parentType, fieldNode) {
    const fieldName = fieldNode.name.value;
    if (fieldName === graphql_1.SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {
        return graphql_1.SchemaMetaFieldDef;
    } else if (fieldName === graphql_1.TypeMetaFieldDef.name && schema.getQueryType() === parentType) {
        return graphql_1.TypeMetaFieldDef;
    } else if (fieldName === graphql_1.TypeNameMetaFieldDef.name) {
        return graphql_1.TypeNameMetaFieldDef;
    }
    return parentType.getFields()[fieldName];
}
exports.getFieldDef = getFieldDef;
function isIncrementalResult(result) {
    return "incremental" in result;
}
exports.isIncrementalResult = isIncrementalResult;


/***/ }),

/***/ 4336:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.flattenAsyncIterable = void 0;
/**
 * Given an AsyncIterable of AsyncIterables, flatten all yielded results into a
 * single AsyncIterable.
 */ function flattenAsyncIterable(iterable) {
    // You might think this whole function could be replaced with
    //
    //    async function* flattenAsyncIterable(iterable) {
    //      for await (const subIterator of iterable) {
    //        yield* subIterator;
    //      }
    //    }
    //
    // but calling `.return()` on the iterator it returns won't interrupt the `for await`.
    const topIterator = iterable[Symbol.asyncIterator]();
    let currentNestedIterator;
    let waitForCurrentNestedIterator;
    let done = false;
    async function next() {
        if (done) {
            return {
                value: undefined,
                done: true
            };
        }
        try {
            if (!currentNestedIterator) {
                // Somebody else is getting it already.
                if (waitForCurrentNestedIterator) {
                    await waitForCurrentNestedIterator;
                    return await next();
                }
                // Nobody else is getting it. We should!
                let resolve;
                waitForCurrentNestedIterator = new Promise((r)=>{
                    resolve = r;
                });
                const topIteratorResult = await topIterator.next();
                if (topIteratorResult.done) {
                    // Given that done only ever transitions from false to true,
                    // require-atomic-updates is being unnecessarily cautious.
                    done = true;
                    return await next();
                }
                // eslint is making a reasonable point here, but we've explicitly protected
                // ourself from the race condition by ensuring that only the single call
                // that assigns to waitForCurrentNestedIterator is allowed to assign to
                // currentNestedIterator or waitForCurrentNestedIterator.
                currentNestedIterator = topIteratorResult.value[Symbol.asyncIterator]();
                waitForCurrentNestedIterator = undefined;
                resolve();
                return await next();
            }
            const rememberCurrentNestedIterator = currentNestedIterator;
            const nestedIteratorResult = await currentNestedIterator.next();
            if (!nestedIteratorResult.done) {
                return nestedIteratorResult;
            }
            // The nested iterator is done. If it's still the current one, make it not
            // current. (If it's not the current one, somebody else has made us move on.)
            if (currentNestedIterator === rememberCurrentNestedIterator) {
                currentNestedIterator = undefined;
            }
            return await next();
        } catch (err) {
            done = true;
            throw err;
        }
    }
    return {
        next,
        async return () {
            var _a, _b;
            done = true;
            await Promise.all([
                (_a = currentNestedIterator === null || currentNestedIterator === void 0 ? void 0 : currentNestedIterator.return) === null || _a === void 0 ? void 0 : _a.call(currentNestedIterator),
                (_b = topIterator.return) === null || _b === void 0 ? void 0 : _b.call(topIterator)
            ]);
            return {
                value: undefined,
                done: true
            };
        },
        async throw (error) {
            var _a, _b;
            done = true;
            await Promise.all([
                (_a = currentNestedIterator === null || currentNestedIterator === void 0 ? void 0 : currentNestedIterator.throw) === null || _a === void 0 ? void 0 : _a.call(currentNestedIterator, error),
                (_b = topIterator.throw) === null || _b === void 0 ? void 0 : _b.call(topIterator, error)
            ]);
            /* c8 ignore next */ throw error;
        },
        [Symbol.asyncIterator] () {
            return this;
        }
    };
}
exports.flattenAsyncIterable = flattenAsyncIterable;


/***/ }),

/***/ 2681:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(4479);
tslib_1.__exportStar(__webpack_require__(5667), exports);
tslib_1.__exportStar(__webpack_require__(2407), exports);
tslib_1.__exportStar(__webpack_require__(7142), exports);


/***/ }),

/***/ 2624:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.invariant = void 0;
function invariant(condition, message) {
    if (!condition) {
        throw new Error(message != null ? message : "Unexpected invariant triggered.");
    }
}
exports.invariant = invariant;


/***/ }),

/***/ 7142:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.normalizedExecutor = void 0;
const graphql_1 = __webpack_require__(5736);
const execute_js_1 = __webpack_require__(5667);
const value_or_promise_1 = __webpack_require__(8323);
function normalizedExecutor(args) {
    const operationAST = (0, graphql_1.getOperationAST)(args.document, args.operationName);
    if (operationAST == null) {
        throw new Error("Must provide an operation.");
    }
    if (operationAST.operation === "subscription") {
        return (0, execute_js_1.subscribe)(args);
    }
    return new value_or_promise_1.ValueOrPromise(()=>(0, execute_js_1.execute)(args)).then((result)=>{
        if ("initialResult" in result) {
            return (0, execute_js_1.flattenIncrementalResults)(result);
        }
        return result;
    }).resolve();
}
exports.normalizedExecutor = normalizedExecutor;


/***/ }),

/***/ 8315:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.promiseForObject = void 0;
/**
 * This function transforms a JS object `Record<string, Promise<T>>` into
 * a `Promise<Record<string, T>>`
 *
 * This is akin to bluebird's `Promise.props`, but implemented only using
 * `Promise.all` so it will work with any implementation of ES6 promises.
 */ async function promiseForObject(object) {
    const keys = Object.keys(object);
    const values = Object.values(object);
    const resolvedValues = await Promise.all(values);
    const resolvedObject = Object.create(null);
    for(let i = 0; i < keys.length; ++i){
        resolvedObject[keys[i]] = resolvedValues[i];
    }
    return resolvedObject;
}
exports.promiseForObject = promiseForObject;


/***/ }),

/***/ 2407:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getVariableValues = void 0;
const graphql_1 = __webpack_require__(5736);
const utils_1 = __webpack_require__(6887);
/**
 * Prepares an object map of variableValues of the correct type based on the
 * provided variable definitions and arbitrary input. If the input cannot be
 * parsed to match the variable definitions, a GraphQLError will be thrown.
 *
 * Note: The returned value is a plain Object with a prototype, since it is
 * exposed to user code. Care should be taken to not pull values from the
 * Object prototype.
 */ function getVariableValues(schema, varDefNodes, inputs, options) {
    const errors = [];
    const maxErrors = options === null || options === void 0 ? void 0 : options.maxErrors;
    try {
        const coerced = coerceVariableValues(schema, varDefNodes, inputs, (error)=>{
            if (maxErrors != null && errors.length >= maxErrors) {
                throw (0, utils_1.createGraphQLError)("Too many errors processing variables, error limit reached. Execution aborted.");
            }
            errors.push(error);
        });
        if (errors.length === 0) {
            return {
                coerced
            };
        }
    } catch (error) {
        errors.push(error);
    }
    // @ts-expect-error - We know that errors is an array of GraphQLError.
    return {
        errors
    };
}
exports.getVariableValues = getVariableValues;
function coerceVariableValues(schema, varDefNodes, inputs, onError) {
    const coercedValues = {};
    for (const varDefNode of varDefNodes){
        const varName = varDefNode.variable.name.value;
        const varType = (0, graphql_1.typeFromAST)(schema, varDefNode.type);
        if (!(0, graphql_1.isInputType)(varType)) {
            // Must use input types for variables. This should be caught during
            // validation, however is checked again here for safety.
            const varTypeStr = (0, graphql_1.print)(varDefNode.type);
            onError((0, utils_1.createGraphQLError)(`Variable "$${varName}" expected value of type "${varTypeStr}" which cannot be used as an input type.`, {
                nodes: varDefNode.type
            }));
            continue;
        }
        if (!(0, utils_1.hasOwnProperty)(inputs, varName)) {
            if (varDefNode.defaultValue) {
                coercedValues[varName] = (0, graphql_1.valueFromAST)(varDefNode.defaultValue, varType);
            } else if ((0, graphql_1.isNonNullType)(varType)) {
                const varTypeStr = (0, utils_1.inspect)(varType);
                onError((0, utils_1.createGraphQLError)(`Variable "$${varName}" of required type "${varTypeStr}" was not provided.`, {
                    nodes: varDefNode
                }));
            }
            continue;
        }
        const value = inputs[varName];
        if (value === null && (0, graphql_1.isNonNullType)(varType)) {
            const varTypeStr = (0, utils_1.inspect)(varType);
            onError((0, utils_1.createGraphQLError)(`Variable "$${varName}" of non-null type "${varTypeStr}" must not be null.`, {
                nodes: varDefNode
            }));
            continue;
        }
        coercedValues[varName] = (0, graphql_1.coerceInputValue)(value, varType, (path, invalidValue, error)=>{
            let prefix = `Variable "$${varName}" got invalid value ` + (0, utils_1.inspect)(invalidValue);
            if (path.length > 0) {
                prefix += ` at "${varName}${(0, utils_1.printPathArray)(path)}"`;
            }
            onError((0, utils_1.createGraphQLError)(prefix + "; " + error.message, {
                nodes: varDefNode,
                originalError: error.originalError
            }));
        });
    }
    return coercedValues;
}


/***/ }),

/***/ 2729:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(4479);
tslib_1.__exportStar(__webpack_require__(2681), exports);


/***/ }),

/***/ 5150:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.applyExtensions = exports.mergeExtensions = exports.extractExtensionsFromSchema = void 0;
const utils_1 = __webpack_require__(6887);
var utils_2 = __webpack_require__(6887);
Object.defineProperty(exports, "extractExtensionsFromSchema", ({
    enumerable: true,
    get: function() {
        return utils_2.extractExtensionsFromSchema;
    }
}));
function mergeExtensions(extensions) {
    return (0, utils_1.mergeDeep)(extensions);
}
exports.mergeExtensions = mergeExtensions;
function applyExtensionObject(obj, extensions) {
    if (!obj) {
        return;
    }
    obj.extensions = (0, utils_1.mergeDeep)([
        obj.extensions || {},
        extensions || {}
    ]);
}
function applyExtensions(schema, extensions) {
    applyExtensionObject(schema, extensions.schemaExtensions);
    for (const [typeName, data] of Object.entries(extensions.types || {})){
        const type = schema.getType(typeName);
        if (type) {
            applyExtensionObject(type, data.extensions);
            if (data.type === "object" || data.type === "interface") {
                for (const [fieldName, fieldData] of Object.entries(data.fields)){
                    const field = type.getFields()[fieldName];
                    if (field) {
                        applyExtensionObject(field, fieldData.extensions);
                        for (const [arg, argData] of Object.entries(fieldData.arguments)){
                            applyExtensionObject(field.args.find((a)=>a.name === arg), argData);
                        }
                    }
                }
            } else if (data.type === "input") {
                for (const [fieldName, fieldData] of Object.entries(data.fields)){
                    const field = type.getFields()[fieldName];
                    applyExtensionObject(field, fieldData.extensions);
                }
            } else if (data.type === "enum") {
                for (const [valueName, valueData] of Object.entries(data.values)){
                    const value = type.getValue(valueName);
                    applyExtensionObject(value, valueData);
                }
            }
        }
    }
    return schema;
}
exports.applyExtensions = applyExtensions;


/***/ }),

/***/ 4328:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(4479);
tslib_1.__exportStar(__webpack_require__(8961), exports);
tslib_1.__exportStar(__webpack_require__(5720), exports);
tslib_1.__exportStar(__webpack_require__(5150), exports);


/***/ }),

/***/ 8961:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.mergeResolvers = void 0;
const utils_1 = __webpack_require__(6887);
/**
 * Deep merges multiple resolver definition objects into a single definition.
 * @param resolversDefinitions Resolver definitions to be merged
 * @param options Additional options
 *
 * ```js
 * const { mergeResolvers } = require('@graphql-tools/merge');
 * const clientResolver = require('./clientResolver');
 * const productResolver = require('./productResolver');
 *
 * const resolvers = mergeResolvers([
 *  clientResolver,
 *  productResolver,
 * ]);
 * ```
 *
 * If you don't want to manually create the array of resolver objects, you can
 * also use this function along with loadFiles:
 *
 * ```js
 * const path = require('path');
 * const { mergeResolvers } = require('@graphql-tools/merge');
 * const { loadFilesSync } = require('@graphql-tools/load-files');
 *
 * const resolversArray = loadFilesSync(path.join(__dirname, './resolvers'));
 *
 * const resolvers = mergeResolvers(resolversArray)
 * ```
 */ function mergeResolvers(resolversDefinitions, options) {
    if (!resolversDefinitions || Array.isArray(resolversDefinitions) && resolversDefinitions.length === 0) {
        return {};
    }
    if (!Array.isArray(resolversDefinitions)) {
        return resolversDefinitions;
    }
    if (resolversDefinitions.length === 1) {
        return resolversDefinitions[0] || {};
    }
    const resolvers = new Array();
    for (let resolversDefinition of resolversDefinitions){
        if (Array.isArray(resolversDefinition)) {
            resolversDefinition = mergeResolvers(resolversDefinition);
        }
        if (typeof resolversDefinition === "object" && resolversDefinition) {
            resolvers.push(resolversDefinition);
        }
    }
    const result = (0, utils_1.mergeDeep)(resolvers, true);
    if (options === null || options === void 0 ? void 0 : options.exclusions) {
        for (const exclusion of options.exclusions){
            const [typeName, fieldName] = exclusion.split(".");
            if (!fieldName || fieldName === "*") {
                delete result[typeName];
            } else if (result[typeName]) {
                delete result[typeName][fieldName];
            }
        }
    }
    return result;
}
exports.mergeResolvers = mergeResolvers;


/***/ }),

/***/ 9278:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.mergeArguments = void 0;
const utils_1 = __webpack_require__(6887);
function mergeArguments(args1, args2, config) {
    const result = deduplicateArguments([
        ...args2,
        ...args1
    ].filter(utils_1.isSome), config);
    if (config && config.sort) {
        result.sort(utils_1.compareNodes);
    }
    return result;
}
exports.mergeArguments = mergeArguments;
function deduplicateArguments(args, config) {
    return args.reduce((acc, current)=>{
        const dupIndex = acc.findIndex((arg)=>arg.name.value === current.name.value);
        if (dupIndex === -1) {
            return acc.concat([
                current
            ]);
        } else if (!(config === null || config === void 0 ? void 0 : config.reverseArguments)) {
            acc[dupIndex] = current;
        }
        return acc;
    }, []);
}


/***/ }),

/***/ 9174:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.mergeDirective = exports.mergeDirectives = void 0;
const graphql_1 = __webpack_require__(5736);
const utils_1 = __webpack_require__(6887);
function directiveAlreadyExists(directivesArr, otherDirective) {
    return !!directivesArr.find((directive)=>directive.name.value === otherDirective.name.value);
}
function nameAlreadyExists(name, namesArr) {
    return namesArr.some(({ value  })=>value === name.value);
}
function mergeArguments(a1, a2) {
    const result = [
        ...a2
    ];
    for (const argument of a1){
        const existingIndex = result.findIndex((a)=>a.name.value === argument.name.value);
        if (existingIndex > -1) {
            const existingArg = result[existingIndex];
            if (existingArg.value.kind === "ListValue") {
                const source = existingArg.value.values;
                const target = argument.value.values;
                // merge values of two lists
                existingArg.value.values = deduplicateLists(source, target, (targetVal, source)=>{
                    const value = targetVal.value;
                    return !value || !source.some((sourceVal)=>sourceVal.value === value);
                });
            } else {
                existingArg.value = argument.value;
            }
        } else {
            result.push(argument);
        }
    }
    return result;
}
function deduplicateDirectives(directives) {
    return directives.map((directive, i, all)=>{
        const firstAt = all.findIndex((d)=>d.name.value === directive.name.value);
        if (firstAt !== i) {
            const dup = all[firstAt];
            directive.arguments = mergeArguments(directive.arguments, dup.arguments);
            return null;
        }
        return directive;
    }).filter(utils_1.isSome);
}
function mergeDirectives(d1 = [], d2 = [], config) {
    const reverseOrder = config && config.reverseDirectives;
    const asNext = reverseOrder ? d1 : d2;
    const asFirst = reverseOrder ? d2 : d1;
    const result = deduplicateDirectives([
        ...asNext
    ]);
    for (const directive of asFirst){
        if (directiveAlreadyExists(result, directive)) {
            const existingDirectiveIndex = result.findIndex((d)=>d.name.value === directive.name.value);
            const existingDirective = result[existingDirectiveIndex];
            result[existingDirectiveIndex].arguments = mergeArguments(directive.arguments || [], existingDirective.arguments || []);
        } else {
            result.push(directive);
        }
    }
    return result;
}
exports.mergeDirectives = mergeDirectives;
function validateInputs(node, existingNode) {
    const printedNode = (0, graphql_1.print)({
        ...node,
        description: undefined
    });
    const printedExistingNode = (0, graphql_1.print)({
        ...existingNode,
        description: undefined
    });
    // eslint-disable-next-line
    const leaveInputs = new RegExp("(directive @w*d*)|( on .*$)", "g");
    const sameArguments = printedNode.replace(leaveInputs, "") === printedExistingNode.replace(leaveInputs, "");
    if (!sameArguments) {
        throw new Error(`Unable to merge GraphQL directive "${node.name.value}". \nExisting directive:  \n\t${printedExistingNode} \nReceived directive: \n\t${printedNode}`);
    }
}
function mergeDirective(node, existingNode) {
    if (existingNode) {
        validateInputs(node, existingNode);
        return {
            ...node,
            locations: [
                ...existingNode.locations,
                ...node.locations.filter((name)=>!nameAlreadyExists(name, existingNode.locations))
            ]
        };
    }
    return node;
}
exports.mergeDirective = mergeDirective;
function deduplicateLists(source, target, filterFn) {
    return source.concat(target.filter((val)=>filterFn(val, source)));
}


/***/ }),

/***/ 6967:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.mergeEnumValues = void 0;
const directives_js_1 = __webpack_require__(9174);
const utils_1 = __webpack_require__(6887);
function mergeEnumValues(first, second, config) {
    if (config === null || config === void 0 ? void 0 : config.consistentEnumMerge) {
        const reversed = [];
        if (first) {
            reversed.push(...first);
        }
        first = second;
        second = reversed;
    }
    const enumValueMap = new Map();
    if (first) {
        for (const firstValue of first){
            enumValueMap.set(firstValue.name.value, firstValue);
        }
    }
    if (second) {
        for (const secondValue of second){
            const enumValue = secondValue.name.value;
            if (enumValueMap.has(enumValue)) {
                const firstValue = enumValueMap.get(enumValue);
                firstValue.description = secondValue.description || firstValue.description;
                firstValue.directives = (0, directives_js_1.mergeDirectives)(secondValue.directives, firstValue.directives);
            } else {
                enumValueMap.set(enumValue, secondValue);
            }
        }
    }
    const result = [
        ...enumValueMap.values()
    ];
    if (config && config.sort) {
        result.sort(utils_1.compareNodes);
    }
    return result;
}
exports.mergeEnumValues = mergeEnumValues;


/***/ }),

/***/ 8837:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.mergeEnum = void 0;
const graphql_1 = __webpack_require__(5736);
const directives_js_1 = __webpack_require__(9174);
const enum_values_js_1 = __webpack_require__(6967);
function mergeEnum(e1, e2, config) {
    if (e2) {
        return {
            name: e1.name,
            description: e1["description"] || e2["description"],
            kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || e1.kind === "EnumTypeDefinition" || e2.kind === "EnumTypeDefinition" ? "EnumTypeDefinition" : "EnumTypeExtension",
            loc: e1.loc,
            directives: (0, directives_js_1.mergeDirectives)(e1.directives, e2.directives, config),
            values: (0, enum_values_js_1.mergeEnumValues)(e1.values, e2.values, config)
        };
    }
    return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? {
        ...e1,
        kind: graphql_1.Kind.ENUM_TYPE_DEFINITION
    } : e1;
}
exports.mergeEnum = mergeEnum;


/***/ }),

/***/ 3484:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.mergeFields = void 0;
const utils_js_1 = __webpack_require__(1106);
const directives_js_1 = __webpack_require__(9174);
const utils_1 = __webpack_require__(6887);
const arguments_js_1 = __webpack_require__(9278);
function fieldAlreadyExists(fieldsArr, otherField) {
    const resultIndex = fieldsArr.findIndex((field)=>field.name.value === otherField.name.value);
    return [
        resultIndex > -1 ? fieldsArr[resultIndex] : null,
        resultIndex
    ];
}
function mergeFields(type, f1, f2, config) {
    const result = [];
    if (f2 != null) {
        result.push(...f2);
    }
    if (f1 != null) {
        for (const field of f1){
            const [existing, existingIndex] = fieldAlreadyExists(result, field);
            if (existing && !(config === null || config === void 0 ? void 0 : config.ignoreFieldConflicts)) {
                const newField = (config === null || config === void 0 ? void 0 : config.onFieldTypeConflict) && config.onFieldTypeConflict(existing, field, type, config === null || config === void 0 ? void 0 : config.throwOnConflict) || preventConflicts(type, existing, field, config === null || config === void 0 ? void 0 : config.throwOnConflict);
                newField.arguments = (0, arguments_js_1.mergeArguments)(field["arguments"] || [], existing["arguments"] || [], config);
                newField.directives = (0, directives_js_1.mergeDirectives)(field.directives, existing.directives, config);
                newField.description = field.description || existing.description;
                result[existingIndex] = newField;
            } else {
                result.push(field);
            }
        }
    }
    if (config && config.sort) {
        result.sort(utils_1.compareNodes);
    }
    if (config && config.exclusions) {
        const exclusions = config.exclusions;
        return result.filter((field)=>!exclusions.includes(`${type.name.value}.${field.name.value}`));
    }
    return result;
}
exports.mergeFields = mergeFields;
function preventConflicts(type, a, b, ignoreNullability = false) {
    const aType = (0, utils_js_1.printTypeNode)(a.type);
    const bType = (0, utils_js_1.printTypeNode)(b.type);
    if (aType !== bType) {
        const t1 = (0, utils_js_1.extractType)(a.type);
        const t2 = (0, utils_js_1.extractType)(b.type);
        if (t1.name.value !== t2.name.value) {
            throw new Error(`Field "${b.name.value}" already defined with a different type. Declared as "${t1.name.value}", but you tried to override with "${t2.name.value}"`);
        }
        if (!safeChangeForFieldType(a.type, b.type, !ignoreNullability)) {
            throw new Error(`Field '${type.name.value}.${a.name.value}' changed type from '${aType}' to '${bType}'`);
        }
    }
    if ((0, utils_js_1.isNonNullTypeNode)(b.type) && !(0, utils_js_1.isNonNullTypeNode)(a.type)) {
        a.type = b.type;
    }
    return a;
}
function safeChangeForFieldType(oldType, newType, ignoreNullability = false) {
    // both are named
    if (!(0, utils_js_1.isWrappingTypeNode)(oldType) && !(0, utils_js_1.isWrappingTypeNode)(newType)) {
        return oldType.toString() === newType.toString();
    }
    // new is non-null
    if ((0, utils_js_1.isNonNullTypeNode)(newType)) {
        const ofType = (0, utils_js_1.isNonNullTypeNode)(oldType) ? oldType.type : oldType;
        return safeChangeForFieldType(ofType, newType.type);
    }
    // old is non-null
    if ((0, utils_js_1.isNonNullTypeNode)(oldType)) {
        return safeChangeForFieldType(newType, oldType, ignoreNullability);
    }
    // old is list
    if ((0, utils_js_1.isListTypeNode)(oldType)) {
        return (0, utils_js_1.isListTypeNode)(newType) && safeChangeForFieldType(oldType.type, newType.type) || (0, utils_js_1.isNonNullTypeNode)(newType) && safeChangeForFieldType(oldType, newType["type"]);
    }
    return false;
}


/***/ }),

/***/ 5720:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(4479);
tslib_1.__exportStar(__webpack_require__(9278), exports);
tslib_1.__exportStar(__webpack_require__(9174), exports);
tslib_1.__exportStar(__webpack_require__(6967), exports);
tslib_1.__exportStar(__webpack_require__(8837), exports);
tslib_1.__exportStar(__webpack_require__(3484), exports);
tslib_1.__exportStar(__webpack_require__(9987), exports);
tslib_1.__exportStar(__webpack_require__(7092), exports);
tslib_1.__exportStar(__webpack_require__(9155), exports);
tslib_1.__exportStar(__webpack_require__(1396), exports);
tslib_1.__exportStar(__webpack_require__(3825), exports);
tslib_1.__exportStar(__webpack_require__(8386), exports);
tslib_1.__exportStar(__webpack_require__(4032), exports);
tslib_1.__exportStar(__webpack_require__(9111), exports);
tslib_1.__exportStar(__webpack_require__(1106), exports);


/***/ }),

/***/ 9987:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.mergeInputType = void 0;
const graphql_1 = __webpack_require__(5736);
const fields_js_1 = __webpack_require__(3484);
const directives_js_1 = __webpack_require__(9174);
function mergeInputType(node, existingNode, config) {
    if (existingNode) {
        try {
            return {
                name: node.name,
                description: node["description"] || existingNode["description"],
                kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || node.kind === "InputObjectTypeDefinition" || existingNode.kind === "InputObjectTypeDefinition" ? "InputObjectTypeDefinition" : "InputObjectTypeExtension",
                loc: node.loc,
                fields: (0, fields_js_1.mergeFields)(node, node.fields, existingNode.fields, config),
                directives: (0, directives_js_1.mergeDirectives)(node.directives, existingNode.directives, config)
            };
        } catch (e) {
            throw new Error(`Unable to merge GraphQL input type "${node.name.value}": ${e.message}`);
        }
    }
    return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? {
        ...node,
        kind: graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION
    } : node;
}
exports.mergeInputType = mergeInputType;


/***/ }),

/***/ 7092:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.mergeInterface = void 0;
const graphql_1 = __webpack_require__(5736);
const fields_js_1 = __webpack_require__(3484);
const directives_js_1 = __webpack_require__(9174);
const merge_named_type_array_js_1 = __webpack_require__(9155);
function mergeInterface(node, existingNode, config) {
    if (existingNode) {
        try {
            return {
                name: node.name,
                description: node["description"] || existingNode["description"],
                kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || node.kind === "InterfaceTypeDefinition" || existingNode.kind === "InterfaceTypeDefinition" ? "InterfaceTypeDefinition" : "InterfaceTypeExtension",
                loc: node.loc,
                fields: (0, fields_js_1.mergeFields)(node, node.fields, existingNode.fields, config),
                directives: (0, directives_js_1.mergeDirectives)(node.directives, existingNode.directives, config),
                interfaces: node["interfaces"] ? (0, merge_named_type_array_js_1.mergeNamedTypeArray)(node["interfaces"], existingNode["interfaces"], config) : undefined
            };
        } catch (e) {
            throw new Error(`Unable to merge GraphQL interface "${node.name.value}": ${e.message}`);
        }
    }
    return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? {
        ...node,
        kind: graphql_1.Kind.INTERFACE_TYPE_DEFINITION
    } : node;
}
exports.mergeInterface = mergeInterface;


/***/ }),

/***/ 9155:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.mergeNamedTypeArray = void 0;
const utils_1 = __webpack_require__(6887);
function alreadyExists(arr, other) {
    return !!arr.find((i)=>i.name.value === other.name.value);
}
function mergeNamedTypeArray(first = [], second = [], config = {}) {
    const result = [
        ...second,
        ...first.filter((d)=>!alreadyExists(second, d))
    ];
    if (config && config.sort) {
        result.sort(utils_1.compareNodes);
    }
    return result;
}
exports.mergeNamedTypeArray = mergeNamedTypeArray;


/***/ }),

/***/ 1396:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.mergeGraphQLNodes = exports.isNamedDefinitionNode = exports.schemaDefSymbol = void 0;
const graphql_1 = __webpack_require__(5736);
const type_js_1 = __webpack_require__(4032);
const enum_js_1 = __webpack_require__(8837);
const scalar_js_1 = __webpack_require__(8386);
const union_js_1 = __webpack_require__(9111);
const input_type_js_1 = __webpack_require__(9987);
const interface_js_1 = __webpack_require__(7092);
const directives_js_1 = __webpack_require__(9174);
const schema_def_js_1 = __webpack_require__(6735);
const utils_1 = __webpack_require__(6887);
exports.schemaDefSymbol = "SCHEMA_DEF_SYMBOL";
function isNamedDefinitionNode(definitionNode) {
    return "name" in definitionNode;
}
exports.isNamedDefinitionNode = isNamedDefinitionNode;
function mergeGraphQLNodes(nodes, config) {
    var _a, _b, _c;
    const mergedResultMap = {};
    for (const nodeDefinition of nodes){
        if (isNamedDefinitionNode(nodeDefinition)) {
            const name = (_a = nodeDefinition.name) === null || _a === void 0 ? void 0 : _a.value;
            if (config === null || config === void 0 ? void 0 : config.commentDescriptions) {
                (0, utils_1.collectComment)(nodeDefinition);
            }
            if (name == null) {
                continue;
            }
            if (((_b = config === null || config === void 0 ? void 0 : config.exclusions) === null || _b === void 0 ? void 0 : _b.includes(name + ".*")) || ((_c = config === null || config === void 0 ? void 0 : config.exclusions) === null || _c === void 0 ? void 0 : _c.includes(name))) {
                delete mergedResultMap[name];
            } else {
                switch(nodeDefinition.kind){
                    case graphql_1.Kind.OBJECT_TYPE_DEFINITION:
                    case graphql_1.Kind.OBJECT_TYPE_EXTENSION:
                        mergedResultMap[name] = (0, type_js_1.mergeType)(nodeDefinition, mergedResultMap[name], config);
                        break;
                    case graphql_1.Kind.ENUM_TYPE_DEFINITION:
                    case graphql_1.Kind.ENUM_TYPE_EXTENSION:
                        mergedResultMap[name] = (0, enum_js_1.mergeEnum)(nodeDefinition, mergedResultMap[name], config);
                        break;
                    case graphql_1.Kind.UNION_TYPE_DEFINITION:
                    case graphql_1.Kind.UNION_TYPE_EXTENSION:
                        mergedResultMap[name] = (0, union_js_1.mergeUnion)(nodeDefinition, mergedResultMap[name], config);
                        break;
                    case graphql_1.Kind.SCALAR_TYPE_DEFINITION:
                    case graphql_1.Kind.SCALAR_TYPE_EXTENSION:
                        mergedResultMap[name] = (0, scalar_js_1.mergeScalar)(nodeDefinition, mergedResultMap[name], config);
                        break;
                    case graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION:
                    case graphql_1.Kind.INPUT_OBJECT_TYPE_EXTENSION:
                        mergedResultMap[name] = (0, input_type_js_1.mergeInputType)(nodeDefinition, mergedResultMap[name], config);
                        break;
                    case graphql_1.Kind.INTERFACE_TYPE_DEFINITION:
                    case graphql_1.Kind.INTERFACE_TYPE_EXTENSION:
                        mergedResultMap[name] = (0, interface_js_1.mergeInterface)(nodeDefinition, mergedResultMap[name], config);
                        break;
                    case graphql_1.Kind.DIRECTIVE_DEFINITION:
                        mergedResultMap[name] = (0, directives_js_1.mergeDirective)(nodeDefinition, mergedResultMap[name]);
                        break;
                }
            }
        } else if (nodeDefinition.kind === graphql_1.Kind.SCHEMA_DEFINITION || nodeDefinition.kind === graphql_1.Kind.SCHEMA_EXTENSION) {
            mergedResultMap[exports.schemaDefSymbol] = (0, schema_def_js_1.mergeSchemaDefs)(nodeDefinition, mergedResultMap[exports.schemaDefSymbol], config);
        }
    }
    return mergedResultMap;
}
exports.mergeGraphQLNodes = mergeGraphQLNodes;


/***/ }),

/***/ 3825:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.mergeGraphQLTypes = exports.mergeTypeDefs = void 0;
const graphql_1 = __webpack_require__(5736);
const utils_js_1 = __webpack_require__(1106);
const merge_nodes_js_1 = __webpack_require__(1396);
const utils_1 = __webpack_require__(6887);
const schema_def_js_1 = __webpack_require__(6735);
function mergeTypeDefs(typeSource, config) {
    (0, utils_1.resetComments)();
    const doc = {
        kind: graphql_1.Kind.DOCUMENT,
        definitions: mergeGraphQLTypes(typeSource, {
            useSchemaDefinition: true,
            forceSchemaDefinition: false,
            throwOnConflict: false,
            commentDescriptions: false,
            ...config
        })
    };
    let result;
    if (config === null || config === void 0 ? void 0 : config.commentDescriptions) {
        result = (0, utils_1.printWithComments)(doc);
    } else {
        result = doc;
    }
    (0, utils_1.resetComments)();
    return result;
}
exports.mergeTypeDefs = mergeTypeDefs;
function visitTypeSources(typeSource, options, allNodes = [], visitedTypeSources = new Set()) {
    if (typeSource && !visitedTypeSources.has(typeSource)) {
        visitedTypeSources.add(typeSource);
        if (typeof typeSource === "function") {
            visitTypeSources(typeSource(), options, allNodes, visitedTypeSources);
        } else if (Array.isArray(typeSource)) {
            for (const type of typeSource){
                visitTypeSources(type, options, allNodes, visitedTypeSources);
            }
        } else if ((0, graphql_1.isSchema)(typeSource)) {
            const documentNode = (0, utils_1.getDocumentNodeFromSchema)(typeSource, options);
            visitTypeSources(documentNode.definitions, options, allNodes, visitedTypeSources);
        } else if ((0, utils_js_1.isStringTypes)(typeSource) || (0, utils_js_1.isSourceTypes)(typeSource)) {
            const documentNode = (0, graphql_1.parse)(typeSource, options);
            visitTypeSources(documentNode.definitions, options, allNodes, visitedTypeSources);
        } else if (typeof typeSource === "object" && (0, graphql_1.isDefinitionNode)(typeSource)) {
            allNodes.push(typeSource);
        } else if ((0, utils_1.isDocumentNode)(typeSource)) {
            visitTypeSources(typeSource.definitions, options, allNodes, visitedTypeSources);
        } else {
            throw new Error(`typeDefs must contain only strings, documents, schemas, or functions, got ${typeof typeSource}`);
        }
    }
    return allNodes;
}
function mergeGraphQLTypes(typeSource, config) {
    var _a, _b, _c;
    (0, utils_1.resetComments)();
    const allNodes = visitTypeSources(typeSource, config);
    const mergedNodes = (0, merge_nodes_js_1.mergeGraphQLNodes)(allNodes, config);
    if (config === null || config === void 0 ? void 0 : config.useSchemaDefinition) {
        // XXX: right now we don't handle multiple schema definitions
        const schemaDef = mergedNodes[merge_nodes_js_1.schemaDefSymbol] || {
            kind: graphql_1.Kind.SCHEMA_DEFINITION,
            operationTypes: []
        };
        const operationTypes = schemaDef.operationTypes;
        for(const opTypeDefNodeType in schema_def_js_1.DEFAULT_OPERATION_TYPE_NAME_MAP){
            const opTypeDefNode = operationTypes.find((operationType)=>operationType.operation === opTypeDefNodeType);
            if (!opTypeDefNode) {
                const possibleRootTypeName = schema_def_js_1.DEFAULT_OPERATION_TYPE_NAME_MAP[opTypeDefNodeType];
                const existingPossibleRootType = mergedNodes[possibleRootTypeName];
                if (existingPossibleRootType != null && existingPossibleRootType.name != null) {
                    operationTypes.push({
                        kind: graphql_1.Kind.OPERATION_TYPE_DEFINITION,
                        type: {
                            kind: graphql_1.Kind.NAMED_TYPE,
                            name: existingPossibleRootType.name
                        },
                        operation: opTypeDefNodeType
                    });
                }
            }
        }
        if (((_a = schemaDef === null || schemaDef === void 0 ? void 0 : schemaDef.operationTypes) === null || _a === void 0 ? void 0 : _a.length) != null && schemaDef.operationTypes.length > 0) {
            mergedNodes[merge_nodes_js_1.schemaDefSymbol] = schemaDef;
        }
    }
    if ((config === null || config === void 0 ? void 0 : config.forceSchemaDefinition) && !((_c = (_b = mergedNodes[merge_nodes_js_1.schemaDefSymbol]) === null || _b === void 0 ? void 0 : _b.operationTypes) === null || _c === void 0 ? void 0 : _c.length)) {
        mergedNodes[merge_nodes_js_1.schemaDefSymbol] = {
            kind: graphql_1.Kind.SCHEMA_DEFINITION,
            operationTypes: [
                {
                    kind: graphql_1.Kind.OPERATION_TYPE_DEFINITION,
                    operation: "query",
                    type: {
                        kind: graphql_1.Kind.NAMED_TYPE,
                        name: {
                            kind: graphql_1.Kind.NAME,
                            value: "Query"
                        }
                    }
                }
            ]
        };
    }
    const mergedNodeDefinitions = Object.values(mergedNodes);
    if (config === null || config === void 0 ? void 0 : config.sort) {
        const sortFn = typeof config.sort === "function" ? config.sort : utils_js_1.defaultStringComparator;
        mergedNodeDefinitions.sort((a, b)=>{
            var _a, _b;
            return sortFn((_a = a.name) === null || _a === void 0 ? void 0 : _a.value, (_b = b.name) === null || _b === void 0 ? void 0 : _b.value);
        });
    }
    return mergedNodeDefinitions;
}
exports.mergeGraphQLTypes = mergeGraphQLTypes;


/***/ }),

/***/ 8386:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.mergeScalar = void 0;
const graphql_1 = __webpack_require__(5736);
const directives_js_1 = __webpack_require__(9174);
function mergeScalar(node, existingNode, config) {
    if (existingNode) {
        return {
            name: node.name,
            description: node["description"] || existingNode["description"],
            kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || node.kind === "ScalarTypeDefinition" || existingNode.kind === "ScalarTypeDefinition" ? "ScalarTypeDefinition" : "ScalarTypeExtension",
            loc: node.loc,
            directives: (0, directives_js_1.mergeDirectives)(node.directives, existingNode.directives, config)
        };
    }
    return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? {
        ...node,
        kind: graphql_1.Kind.SCALAR_TYPE_DEFINITION
    } : node;
}
exports.mergeScalar = mergeScalar;


/***/ }),

/***/ 6735:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.mergeSchemaDefs = exports.DEFAULT_OPERATION_TYPE_NAME_MAP = void 0;
const graphql_1 = __webpack_require__(5736);
const directives_js_1 = __webpack_require__(9174);
exports.DEFAULT_OPERATION_TYPE_NAME_MAP = {
    query: "Query",
    mutation: "Mutation",
    subscription: "Subscription"
};
function mergeOperationTypes(opNodeList = [], existingOpNodeList = []) {
    const finalOpNodeList = [];
    for(const opNodeType in exports.DEFAULT_OPERATION_TYPE_NAME_MAP){
        const opNode = opNodeList.find((n)=>n.operation === opNodeType) || existingOpNodeList.find((n)=>n.operation === opNodeType);
        if (opNode) {
            finalOpNodeList.push(opNode);
        }
    }
    return finalOpNodeList;
}
function mergeSchemaDefs(node, existingNode, config) {
    if (existingNode) {
        return {
            kind: node.kind === graphql_1.Kind.SCHEMA_DEFINITION || existingNode.kind === graphql_1.Kind.SCHEMA_DEFINITION ? graphql_1.Kind.SCHEMA_DEFINITION : graphql_1.Kind.SCHEMA_EXTENSION,
            description: node["description"] || existingNode["description"],
            directives: (0, directives_js_1.mergeDirectives)(node.directives, existingNode.directives, config),
            operationTypes: mergeOperationTypes(node.operationTypes, existingNode.operationTypes)
        };
    }
    return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? {
        ...node,
        kind: graphql_1.Kind.SCHEMA_DEFINITION
    } : node;
}
exports.mergeSchemaDefs = mergeSchemaDefs;


/***/ }),

/***/ 4032:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.mergeType = void 0;
const graphql_1 = __webpack_require__(5736);
const fields_js_1 = __webpack_require__(3484);
const directives_js_1 = __webpack_require__(9174);
const merge_named_type_array_js_1 = __webpack_require__(9155);
function mergeType(node, existingNode, config) {
    if (existingNode) {
        try {
            return {
                name: node.name,
                description: node["description"] || existingNode["description"],
                kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || node.kind === "ObjectTypeDefinition" || existingNode.kind === "ObjectTypeDefinition" ? "ObjectTypeDefinition" : "ObjectTypeExtension",
                loc: node.loc,
                fields: (0, fields_js_1.mergeFields)(node, node.fields, existingNode.fields, config),
                directives: (0, directives_js_1.mergeDirectives)(node.directives, existingNode.directives, config),
                interfaces: (0, merge_named_type_array_js_1.mergeNamedTypeArray)(node.interfaces, existingNode.interfaces, config)
            };
        } catch (e) {
            throw new Error(`Unable to merge GraphQL type "${node.name.value}": ${e.message}`);
        }
    }
    return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? {
        ...node,
        kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION
    } : node;
}
exports.mergeType = mergeType;


/***/ }),

/***/ 9111:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.mergeUnion = void 0;
const graphql_1 = __webpack_require__(5736);
const directives_js_1 = __webpack_require__(9174);
const merge_named_type_array_js_1 = __webpack_require__(9155);
function mergeUnion(first, second, config) {
    if (second) {
        return {
            name: first.name,
            description: first["description"] || second["description"],
            // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
            directives: (0, directives_js_1.mergeDirectives)(first.directives, second.directives, config),
            kind: (config === null || config === void 0 ? void 0 : config.convertExtensions) || first.kind === "UnionTypeDefinition" || second.kind === "UnionTypeDefinition" ? graphql_1.Kind.UNION_TYPE_DEFINITION : graphql_1.Kind.UNION_TYPE_EXTENSION,
            loc: first.loc,
            types: (0, merge_named_type_array_js_1.mergeNamedTypeArray)(first.types, second.types, config)
        };
    }
    return (config === null || config === void 0 ? void 0 : config.convertExtensions) ? {
        ...first,
        kind: graphql_1.Kind.UNION_TYPE_DEFINITION
    } : first;
}
exports.mergeUnion = mergeUnion;


/***/ }),

/***/ 1106:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.defaultStringComparator = exports.CompareVal = exports.printTypeNode = exports.isNonNullTypeNode = exports.isListTypeNode = exports.isWrappingTypeNode = exports.extractType = exports.isSourceTypes = exports.isStringTypes = void 0;
const graphql_1 = __webpack_require__(5736);
function isStringTypes(types) {
    return typeof types === "string";
}
exports.isStringTypes = isStringTypes;
function isSourceTypes(types) {
    return types instanceof graphql_1.Source;
}
exports.isSourceTypes = isSourceTypes;
function extractType(type) {
    let visitedType = type;
    while(visitedType.kind === graphql_1.Kind.LIST_TYPE || visitedType.kind === "NonNullType"){
        visitedType = visitedType.type;
    }
    return visitedType;
}
exports.extractType = extractType;
function isWrappingTypeNode(type) {
    return type.kind !== graphql_1.Kind.NAMED_TYPE;
}
exports.isWrappingTypeNode = isWrappingTypeNode;
function isListTypeNode(type) {
    return type.kind === graphql_1.Kind.LIST_TYPE;
}
exports.isListTypeNode = isListTypeNode;
function isNonNullTypeNode(type) {
    return type.kind === graphql_1.Kind.NON_NULL_TYPE;
}
exports.isNonNullTypeNode = isNonNullTypeNode;
function printTypeNode(type) {
    if (isListTypeNode(type)) {
        return `[${printTypeNode(type.type)}]`;
    }
    if (isNonNullTypeNode(type)) {
        return `${printTypeNode(type.type)}!`;
    }
    return type.name.value;
}
exports.printTypeNode = printTypeNode;
var CompareVal;
(function(CompareVal) {
    CompareVal[CompareVal["A_SMALLER_THAN_B"] = -1] = "A_SMALLER_THAN_B";
    CompareVal[CompareVal["A_EQUALS_B"] = 0] = "A_EQUALS_B";
    CompareVal[CompareVal["A_GREATER_THAN_B"] = 1] = "A_GREATER_THAN_B";
})(CompareVal = exports.CompareVal || (exports.CompareVal = {}));
function defaultStringComparator(a, b) {
    if (a == null && b == null) {
        return CompareVal.A_EQUALS_B;
    }
    if (a == null) {
        return CompareVal.A_SMALLER_THAN_B;
    }
    if (b == null) {
        return CompareVal.A_GREATER_THAN_B;
    }
    if (a < b) return CompareVal.A_SMALLER_THAN_B;
    if (a > b) return CompareVal.A_GREATER_THAN_B;
    return CompareVal.A_EQUALS_B;
}
exports.defaultStringComparator = defaultStringComparator;


/***/ }),

/***/ 8090:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.addResolversToSchema = void 0;
const graphql_1 = __webpack_require__(5736);
const utils_1 = __webpack_require__(6887);
const checkForResolveTypeResolver_js_1 = __webpack_require__(1374);
const extendResolversFromInterfaces_js_1 = __webpack_require__(7156);
function addResolversToSchema({ schema , resolvers: inputResolvers , defaultFieldResolver , resolverValidationOptions ={} , inheritResolversFromInterfaces =false , updateResolversInPlace =false  }) {
    const { requireResolversToMatchSchema ="error" , requireResolversForResolveType  } = resolverValidationOptions;
    const resolvers = inheritResolversFromInterfaces ? (0, extendResolversFromInterfaces_js_1.extendResolversFromInterfaces)(schema, inputResolvers) : inputResolvers;
    for(const typeName in resolvers){
        const resolverValue = resolvers[typeName];
        const resolverType = typeof resolverValue;
        if (resolverType !== "object") {
            throw new Error(`"${typeName}" defined in resolvers, but has invalid value "${resolverValue}". The resolver's value must be of type object.`);
        }
        const type = schema.getType(typeName);
        if (type == null) {
            if (requireResolversToMatchSchema === "ignore") {
                continue;
            }
            throw new Error(`"${typeName}" defined in resolvers, but not in schema`);
        } else if ((0, graphql_1.isSpecifiedScalarType)(type)) {
            // allow -- without recommending -- overriding of specified scalar types
            for(const fieldName in resolverValue){
                if (fieldName.startsWith("__")) {
                    type[fieldName.substring(2)] = resolverValue[fieldName];
                } else {
                    type[fieldName] = resolverValue[fieldName];
                }
            }
        } else if ((0, graphql_1.isEnumType)(type)) {
            const values = type.getValues();
            for(const fieldName in resolverValue){
                if (!fieldName.startsWith("__") && !values.some((value)=>value.name === fieldName) && requireResolversToMatchSchema && requireResolversToMatchSchema !== "ignore") {
                    throw new Error(`${type.name}.${fieldName} was defined in resolvers, but not present within ${type.name}`);
                }
            }
        } else if ((0, graphql_1.isUnionType)(type)) {
            for(const fieldName in resolverValue){
                if (!fieldName.startsWith("__") && requireResolversToMatchSchema && requireResolversToMatchSchema !== "ignore") {
                    throw new Error(`${type.name}.${fieldName} was defined in resolvers, but ${type.name} is not an object or interface type`);
                }
            }
        } else if ((0, graphql_1.isObjectType)(type) || (0, graphql_1.isInterfaceType)(type)) {
            for(const fieldName in resolverValue){
                if (!fieldName.startsWith("__")) {
                    const fields = type.getFields();
                    const field = fields[fieldName];
                    if (field == null) {
                        // Field present in resolver but not in schema
                        if (requireResolversToMatchSchema && requireResolversToMatchSchema !== "ignore") {
                            throw new Error(`${typeName}.${fieldName} defined in resolvers, but not in schema`);
                        }
                    } else {
                        // Field present in both the resolver and schema
                        const fieldResolve = resolverValue[fieldName];
                        if (typeof fieldResolve !== "function" && typeof fieldResolve !== "object") {
                            throw new Error(`Resolver ${typeName}.${fieldName} must be object or function`);
                        }
                    }
                }
            }
        }
    }
    schema = updateResolversInPlace ? addResolversToExistingSchema(schema, resolvers, defaultFieldResolver) : createNewSchemaWithResolvers(schema, resolvers, defaultFieldResolver);
    if (requireResolversForResolveType && requireResolversForResolveType !== "ignore") {
        (0, checkForResolveTypeResolver_js_1.checkForResolveTypeResolver)(schema, requireResolversForResolveType);
    }
    return schema;
}
exports.addResolversToSchema = addResolversToSchema;
function addResolversToExistingSchema(schema, resolvers, defaultFieldResolver) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
    const typeMap = schema.getTypeMap();
    for(const typeName in resolvers){
        const type = schema.getType(typeName);
        const resolverValue = resolvers[typeName];
        if ((0, graphql_1.isScalarType)(type)) {
            for(const fieldName in resolverValue){
                if (fieldName.startsWith("__")) {
                    type[fieldName.substring(2)] = resolverValue[fieldName];
                } else if (fieldName === "astNode" && type.astNode != null) {
                    type.astNode = {
                        ...type.astNode,
                        description: (_b = (_a = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.astNode.description,
                        directives: ((_c = type.astNode.directives) !== null && _c !== void 0 ? _c : []).concat((_e = (_d = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _d === void 0 ? void 0 : _d.directives) !== null && _e !== void 0 ? _e : [])
                    };
                } else if (fieldName === "extensionASTNodes" && type.extensionASTNodes != null) {
                    type.extensionASTNodes = type.extensionASTNodes.concat((_f = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _f !== void 0 ? _f : []);
                } else if (fieldName === "extensions" && type.extensions != null && resolverValue.extensions != null) {
                    type.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);
                } else {
                    type[fieldName] = resolverValue[fieldName];
                }
            }
        } else if ((0, graphql_1.isEnumType)(type)) {
            const config = type.toConfig();
            const enumValueConfigMap = config.values;
            for(const fieldName in resolverValue){
                if (fieldName.startsWith("__")) {
                    config[fieldName.substring(2)] = resolverValue[fieldName];
                } else if (fieldName === "astNode" && config.astNode != null) {
                    config.astNode = {
                        ...config.astNode,
                        description: (_h = (_g = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _g === void 0 ? void 0 : _g.description) !== null && _h !== void 0 ? _h : config.astNode.description,
                        directives: ((_j = config.astNode.directives) !== null && _j !== void 0 ? _j : []).concat((_l = (_k = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _k === void 0 ? void 0 : _k.directives) !== null && _l !== void 0 ? _l : [])
                    };
                } else if (fieldName === "extensionASTNodes" && config.extensionASTNodes != null) {
                    config.extensionASTNodes = config.extensionASTNodes.concat((_m = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _m !== void 0 ? _m : []);
                } else if (fieldName === "extensions" && type.extensions != null && resolverValue.extensions != null) {
                    type.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);
                } else if (enumValueConfigMap[fieldName]) {
                    enumValueConfigMap[fieldName].value = resolverValue[fieldName];
                }
            }
            typeMap[typeName] = new graphql_1.GraphQLEnumType(config);
        } else if ((0, graphql_1.isUnionType)(type)) {
            for(const fieldName in resolverValue){
                if (fieldName.startsWith("__")) {
                    type[fieldName.substring(2)] = resolverValue[fieldName];
                }
            }
        } else if ((0, graphql_1.isObjectType)(type) || (0, graphql_1.isInterfaceType)(type)) {
            for(const fieldName in resolverValue){
                if (fieldName.startsWith("__")) {
                    // this is for isTypeOf and resolveType and all the other stuff.
                    type[fieldName.substring(2)] = resolverValue[fieldName];
                    continue;
                }
                const fields = type.getFields();
                const field = fields[fieldName];
                if (field != null) {
                    const fieldResolve = resolverValue[fieldName];
                    if (typeof fieldResolve === "function") {
                        // for convenience. Allows shorter syntax in resolver definition file
                        field.resolve = fieldResolve.bind(resolverValue);
                    } else {
                        setFieldProperties(field, fieldResolve);
                    }
                }
            }
        }
    }
    // serialize all default values prior to healing fields with new scalar/enum types.
    (0, utils_1.forEachDefaultValue)(schema, utils_1.serializeInputValue);
    // schema may have new scalar/enum types that require healing
    (0, utils_1.healSchema)(schema);
    // reparse all default values with new parsing functions.
    (0, utils_1.forEachDefaultValue)(schema, utils_1.parseInputValue);
    if (defaultFieldResolver != null) {
        (0, utils_1.forEachField)(schema, (field)=>{
            if (!field.resolve) {
                field.resolve = defaultFieldResolver;
            }
        });
    }
    return schema;
}
function createNewSchemaWithResolvers(schema, resolvers, defaultFieldResolver) {
    schema = (0, utils_1.mapSchema)(schema, {
        [utils_1.MapperKind.SCALAR_TYPE]: (type)=>{
            var _a, _b, _c, _d, _e, _f;
            const config = type.toConfig();
            const resolverValue = resolvers[type.name];
            if (!(0, graphql_1.isSpecifiedScalarType)(type) && resolverValue != null) {
                for(const fieldName in resolverValue){
                    if (fieldName.startsWith("__")) {
                        config[fieldName.substring(2)] = resolverValue[fieldName];
                    } else if (fieldName === "astNode" && config.astNode != null) {
                        config.astNode = {
                            ...config.astNode,
                            description: (_b = (_a = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : config.astNode.description,
                            directives: ((_c = config.astNode.directives) !== null && _c !== void 0 ? _c : []).concat((_e = (_d = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _d === void 0 ? void 0 : _d.directives) !== null && _e !== void 0 ? _e : [])
                        };
                    } else if (fieldName === "extensionASTNodes" && config.extensionASTNodes != null) {
                        config.extensionASTNodes = config.extensionASTNodes.concat((_f = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _f !== void 0 ? _f : []);
                    } else if (fieldName === "extensions" && config.extensions != null && resolverValue.extensions != null) {
                        config.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);
                    } else {
                        config[fieldName] = resolverValue[fieldName];
                    }
                }
                return new graphql_1.GraphQLScalarType(config);
            }
        },
        [utils_1.MapperKind.ENUM_TYPE]: (type)=>{
            var _a, _b, _c, _d, _e, _f;
            const resolverValue = resolvers[type.name];
            const config = type.toConfig();
            const enumValueConfigMap = config.values;
            if (resolverValue != null) {
                for(const fieldName in resolverValue){
                    if (fieldName.startsWith("__")) {
                        config[fieldName.substring(2)] = resolverValue[fieldName];
                    } else if (fieldName === "astNode" && config.astNode != null) {
                        config.astNode = {
                            ...config.astNode,
                            description: (_b = (_a = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : config.astNode.description,
                            directives: ((_c = config.astNode.directives) !== null && _c !== void 0 ? _c : []).concat((_e = (_d = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _d === void 0 ? void 0 : _d.directives) !== null && _e !== void 0 ? _e : [])
                        };
                    } else if (fieldName === "extensionASTNodes" && config.extensionASTNodes != null) {
                        config.extensionASTNodes = config.extensionASTNodes.concat((_f = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _f !== void 0 ? _f : []);
                    } else if (fieldName === "extensions" && config.extensions != null && resolverValue.extensions != null) {
                        config.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);
                    } else if (enumValueConfigMap[fieldName]) {
                        enumValueConfigMap[fieldName].value = resolverValue[fieldName];
                    }
                }
                return new graphql_1.GraphQLEnumType(config);
            }
        },
        [utils_1.MapperKind.UNION_TYPE]: (type)=>{
            const resolverValue = resolvers[type.name];
            if (resolverValue != null) {
                const config = type.toConfig();
                if (resolverValue["__resolveType"]) {
                    config.resolveType = resolverValue["__resolveType"];
                }
                return new graphql_1.GraphQLUnionType(config);
            }
        },
        [utils_1.MapperKind.OBJECT_TYPE]: (type)=>{
            const resolverValue = resolvers[type.name];
            if (resolverValue != null) {
                const config = type.toConfig();
                if (resolverValue["__isTypeOf"]) {
                    config.isTypeOf = resolverValue["__isTypeOf"];
                }
                return new graphql_1.GraphQLObjectType(config);
            }
        },
        [utils_1.MapperKind.INTERFACE_TYPE]: (type)=>{
            const resolverValue = resolvers[type.name];
            if (resolverValue != null) {
                const config = type.toConfig();
                if (resolverValue["__resolveType"]) {
                    config.resolveType = resolverValue["__resolveType"];
                }
                return new graphql_1.GraphQLInterfaceType(config);
            }
        },
        [utils_1.MapperKind.COMPOSITE_FIELD]: (fieldConfig, fieldName, typeName)=>{
            const resolverValue = resolvers[typeName];
            if (resolverValue != null) {
                const fieldResolve = resolverValue[fieldName];
                if (fieldResolve != null) {
                    const newFieldConfig = {
                        ...fieldConfig
                    };
                    if (typeof fieldResolve === "function") {
                        // for convenience. Allows shorter syntax in resolver definition file
                        newFieldConfig.resolve = fieldResolve.bind(resolverValue);
                    } else {
                        setFieldProperties(newFieldConfig, fieldResolve);
                    }
                    return newFieldConfig;
                }
            }
        }
    });
    if (defaultFieldResolver != null) {
        schema = (0, utils_1.mapSchema)(schema, {
            [utils_1.MapperKind.OBJECT_FIELD]: (fieldConfig)=>({
                    ...fieldConfig,
                    resolve: fieldConfig.resolve != null ? fieldConfig.resolve : defaultFieldResolver
                })
        });
    }
    return schema;
}
function setFieldProperties(field, propertiesObj) {
    for(const propertyName in propertiesObj){
        field[propertyName] = propertiesObj[propertyName];
    }
}


/***/ }),

/***/ 8119:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.assertResolversPresent = void 0;
const graphql_1 = __webpack_require__(5736);
const utils_1 = __webpack_require__(6887);
function assertResolversPresent(schema, resolverValidationOptions = {}) {
    const { requireResolversForArgs , requireResolversForNonScalar , requireResolversForAllFields  } = resolverValidationOptions;
    if (requireResolversForAllFields && (requireResolversForArgs || requireResolversForNonScalar)) {
        throw new TypeError("requireResolversForAllFields takes precedence over the more specific assertions. " + "Please configure either requireResolversForAllFields or requireResolversForArgs / " + "requireResolversForNonScalar, but not a combination of them.");
    }
    (0, utils_1.forEachField)(schema, (field, typeName, fieldName)=>{
        // requires a resolver for *every* field.
        if (requireResolversForAllFields) {
            expectResolver("requireResolversForAllFields", requireResolversForAllFields, field, typeName, fieldName);
        }
        // requires a resolver on every field that has arguments
        if (requireResolversForArgs && field.args.length > 0) {
            expectResolver("requireResolversForArgs", requireResolversForArgs, field, typeName, fieldName);
        }
        // requires a resolver on every field that returns a non-scalar type
        if (requireResolversForNonScalar !== "ignore" && !(0, graphql_1.isScalarType)((0, graphql_1.getNamedType)(field.type))) {
            expectResolver("requireResolversForNonScalar", requireResolversForNonScalar, field, typeName, fieldName);
        }
    });
}
exports.assertResolversPresent = assertResolversPresent;
function expectResolver(validator, behavior, field, typeName, fieldName) {
    if (!field.resolve) {
        const message = `Resolver missing for "${typeName}.${fieldName}".
To disable this validator, use:
  resolverValidationOptions: {
    ${validator}: 'ignore'
  }`;
        if (behavior === "error") {
            throw new Error(message);
        }
        if (behavior === "warn") {
            console.warn(message);
        }
        return;
    }
    if (typeof field.resolve !== "function") {
        throw new Error(`Resolver "${typeName}.${fieldName}" must be a function`);
    }
}


/***/ }),

/***/ 3594:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.chainResolvers = void 0;
const graphql_1 = __webpack_require__(5736);
function chainResolvers(resolvers) {
    return (root, args, ctx, info)=>resolvers.reduce((prev, curResolver)=>{
            if (curResolver != null) {
                return curResolver(prev, args, ctx, info);
            }
            return (0, graphql_1.defaultFieldResolver)(prev, args, ctx, info);
        }, root);
}
exports.chainResolvers = chainResolvers;


/***/ }),

/***/ 1374:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.checkForResolveTypeResolver = void 0;
const utils_1 = __webpack_require__(6887);
// If we have any union or interface types throw if no there is no resolveType resolver
function checkForResolveTypeResolver(schema, requireResolversForResolveType) {
    (0, utils_1.mapSchema)(schema, {
        [utils_1.MapperKind.ABSTRACT_TYPE]: (type)=>{
            if (!type.resolveType) {
                const message = `Type "${type.name}" is missing a "__resolveType" resolver. Pass 'ignore' into ` + '"resolverValidationOptions.requireResolversForResolveType" to disable this error.';
                if (requireResolversForResolveType === "error") {
                    throw new Error(message);
                }
                if (requireResolversForResolveType === "warn") {
                    console.warn(message);
                }
            }
            return undefined;
        }
    });
}
exports.checkForResolveTypeResolver = checkForResolveTypeResolver;


/***/ }),

/***/ 7156:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.extendResolversFromInterfaces = void 0;
function extendResolversFromInterfaces(schema, resolvers) {
    const extendedResolvers = {};
    const typeMap = schema.getTypeMap();
    for(const typeName in typeMap){
        const type = typeMap[typeName];
        if ("getInterfaces" in type) {
            extendedResolvers[typeName] = {};
            for (const iFace of type.getInterfaces()){
                if (resolvers[iFace.name]) {
                    for(const fieldName in resolvers[iFace.name]){
                        if (fieldName === "__isTypeOf" || !fieldName.startsWith("__")) {
                            extendedResolvers[typeName][fieldName] = resolvers[iFace.name][fieldName];
                        }
                    }
                }
            }
            const typeResolvers = resolvers[typeName];
            extendedResolvers[typeName] = {
                ...extendedResolvers[typeName],
                ...typeResolvers
            };
        } else {
            const typeResolvers = resolvers[typeName];
            if (typeResolvers != null) {
                extendedResolvers[typeName] = typeResolvers;
            }
        }
    }
    return extendedResolvers;
}
exports.extendResolversFromInterfaces = extendResolversFromInterfaces;


/***/ }),

/***/ 4372:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.extractExtensionsFromSchema = exports.extendResolversFromInterfaces = exports.checkForResolveTypeResolver = exports.addResolversToSchema = exports.chainResolvers = exports.assertResolversPresent = void 0;
const tslib_1 = __webpack_require__(4479);
var assertResolversPresent_js_1 = __webpack_require__(8119);
Object.defineProperty(exports, "assertResolversPresent", ({
    enumerable: true,
    get: function() {
        return assertResolversPresent_js_1.assertResolversPresent;
    }
}));
var chainResolvers_js_1 = __webpack_require__(3594);
Object.defineProperty(exports, "chainResolvers", ({
    enumerable: true,
    get: function() {
        return chainResolvers_js_1.chainResolvers;
    }
}));
var addResolversToSchema_js_1 = __webpack_require__(8090);
Object.defineProperty(exports, "addResolversToSchema", ({
    enumerable: true,
    get: function() {
        return addResolversToSchema_js_1.addResolversToSchema;
    }
}));
var checkForResolveTypeResolver_js_1 = __webpack_require__(1374);
Object.defineProperty(exports, "checkForResolveTypeResolver", ({
    enumerable: true,
    get: function() {
        return checkForResolveTypeResolver_js_1.checkForResolveTypeResolver;
    }
}));
var extendResolversFromInterfaces_js_1 = __webpack_require__(7156);
Object.defineProperty(exports, "extendResolversFromInterfaces", ({
    enumerable: true,
    get: function() {
        return extendResolversFromInterfaces_js_1.extendResolversFromInterfaces;
    }
}));
tslib_1.__exportStar(__webpack_require__(9441), exports);
tslib_1.__exportStar(__webpack_require__(827), exports);
tslib_1.__exportStar(__webpack_require__(7986), exports);
var utils_1 = __webpack_require__(6887);
Object.defineProperty(exports, "extractExtensionsFromSchema", ({
    enumerable: true,
    get: function() {
        return utils_1.extractExtensionsFromSchema;
    }
}));


/***/ }),

/***/ 9441:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.makeExecutableSchema = void 0;
const graphql_1 = __webpack_require__(5736);
const utils_1 = __webpack_require__(6887);
const addResolversToSchema_js_1 = __webpack_require__(8090);
const assertResolversPresent_js_1 = __webpack_require__(8119);
const merge_1 = __webpack_require__(4328);
/**
 * Builds a schema from the provided type definitions and resolvers.
 *
 * The type definitions are written using Schema Definition Language (SDL). They
 * can be provided as a string, a `DocumentNode`, a function, or an array of any
 * of these. If a function is provided, it will be passed no arguments and
 * should return an array of strings or `DocumentNode`s.
 *
 * Note: You can use GraphQL magic comment provide additional syntax
 * highlighting in your editor (with the appropriate editor plugin).
 *
 * ```js
 * const typeDefs = /* GraphQL *\/ `
 *   type Query {
 *     posts: [Post]
 *     author(id: Int!): Author
 *   }
 * `;
 * ```
 *
 * The `resolvers` object should be a map of type names to nested object, which
 * themselves map the type's fields to their appropriate resolvers.
 * See the [Resolvers](/docs/resolvers) section of the documentation for more details.
 *
 * ```js
 * const resolvers = {
 *   Query: {
 *     posts: (obj, args, ctx, info) => getAllPosts(),
 *     author: (obj, args, ctx, info) => getAuthorById(args.id)
 *   }
 * };
 * ```
 *
 * Once you've defined both the `typeDefs` and `resolvers`, you can create your
 * schema:
 *
 * ```js
 * const schema = makeExecutableSchema({
 *   typeDefs,
 *   resolvers,
 * })
 * ```
 */ function makeExecutableSchema({ typeDefs , resolvers ={} , resolverValidationOptions ={} , inheritResolversFromInterfaces =false , updateResolversInPlace =false , schemaExtensions , ...otherOptions }) {
    // Validate and clean up arguments
    if (typeof resolverValidationOptions !== "object") {
        throw new Error("Expected `resolverValidationOptions` to be an object");
    }
    if (!typeDefs) {
        throw new Error("Must provide typeDefs");
    }
    let schema;
    if ((0, graphql_1.isSchema)(typeDefs)) {
        schema = typeDefs;
    } else if (otherOptions === null || otherOptions === void 0 ? void 0 : otherOptions.commentDescriptions) {
        const mergedTypeDefs = (0, merge_1.mergeTypeDefs)(typeDefs, {
            ...otherOptions,
            commentDescriptions: true
        });
        schema = (0, graphql_1.buildSchema)(mergedTypeDefs, otherOptions);
    } else {
        const mergedTypeDefs = (0, merge_1.mergeTypeDefs)(typeDefs, otherOptions);
        schema = (0, graphql_1.buildASTSchema)(mergedTypeDefs, otherOptions);
    }
    // We allow passing in an array of resolver maps, in which case we merge them
    schema = (0, addResolversToSchema_js_1.addResolversToSchema)({
        schema,
        resolvers: (0, merge_1.mergeResolvers)(resolvers),
        resolverValidationOptions,
        inheritResolversFromInterfaces,
        updateResolversInPlace
    });
    if (Object.keys(resolverValidationOptions).length > 0) {
        (0, assertResolversPresent_js_1.assertResolversPresent)(schema, resolverValidationOptions);
    }
    if (schemaExtensions) {
        schemaExtensions = (0, merge_1.mergeExtensions)((0, utils_1.asArray)(schemaExtensions));
        (0, merge_1.applyExtensions)(schema, schemaExtensions);
    }
    return schema;
}
exports.makeExecutableSchema = makeExecutableSchema;


/***/ }),

/***/ 7986:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.mergeSchemas = void 0;
const utils_1 = __webpack_require__(6887);
const makeExecutableSchema_js_1 = __webpack_require__(9441);
/**
 * Synchronously merges multiple schemas, typeDefinitions and/or resolvers into a single schema.
 * @param config Configuration object
 */ function mergeSchemas(config) {
    const extractedTypeDefs = [];
    const extractedResolvers = [];
    const extractedSchemaExtensions = [];
    if (config.schemas != null) {
        for (const schema of config.schemas){
            extractedTypeDefs.push(schema);
            extractedResolvers.push((0, utils_1.getResolversFromSchema)(schema));
            extractedSchemaExtensions.push((0, utils_1.extractExtensionsFromSchema)(schema));
        }
    }
    if (config.typeDefs != null) {
        extractedTypeDefs.push(config.typeDefs);
    }
    if (config.resolvers != null) {
        const additionalResolvers = (0, utils_1.asArray)(config.resolvers);
        extractedResolvers.push(...additionalResolvers);
    }
    if (config.schemaExtensions != null) {
        const additionalSchemaExtensions = (0, utils_1.asArray)(config.schemaExtensions);
        extractedSchemaExtensions.push(...additionalSchemaExtensions);
    }
    return (0, makeExecutableSchema_js_1.makeExecutableSchema)({
        ...config,
        typeDefs: extractedTypeDefs,
        resolvers: extractedResolvers,
        schemaExtensions: extractedSchemaExtensions
    });
}
exports.mergeSchemas = mergeSchemas;


/***/ }),

/***/ 827:
/***/ (() => {



/***/ }),

/***/ 1926:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.AccumulatorMap = void 0;
/**
 * ES6 Map with additional `add` method to accumulate items.
 */ class AccumulatorMap extends Map {
    get [Symbol.toStringTag]() {
        return "AccumulatorMap";
    }
    add(key, item) {
        const group = this.get(key);
        if (group === undefined) {
            this.set(key, [
                item
            ]);
        } else {
            group.push(item);
        }
    }
}
exports.AccumulatorMap = AccumulatorMap;


/***/ }),

/***/ 3127:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.isAggregateError = exports.AggregateError = void 0;
let AggregateErrorImpl;
exports.AggregateError = AggregateErrorImpl;
if (typeof AggregateError === "undefined") {
    class AggregateErrorClass extends Error {
        constructor(errors, message = ""){
            super(message);
            this.errors = errors;
            this.name = "AggregateError";
            Error.captureStackTrace(this, AggregateErrorClass);
        }
    }
    exports.AggregateError = AggregateErrorImpl = function(errors, message) {
        return new AggregateErrorClass(errors, message);
    };
} else {
    exports.AggregateError = AggregateErrorImpl = AggregateError;
}
function isAggregateError(error) {
    return "errors" in error && Array.isArray(error["errors"]);
}
exports.isAggregateError = isAggregateError;


/***/ }),

/***/ 8395:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.MapperKind = void 0;
var MapperKind;
(function(MapperKind) {
    MapperKind["TYPE"] = "MapperKind.TYPE";
    MapperKind["SCALAR_TYPE"] = "MapperKind.SCALAR_TYPE";
    MapperKind["ENUM_TYPE"] = "MapperKind.ENUM_TYPE";
    MapperKind["COMPOSITE_TYPE"] = "MapperKind.COMPOSITE_TYPE";
    MapperKind["OBJECT_TYPE"] = "MapperKind.OBJECT_TYPE";
    MapperKind["INPUT_OBJECT_TYPE"] = "MapperKind.INPUT_OBJECT_TYPE";
    MapperKind["ABSTRACT_TYPE"] = "MapperKind.ABSTRACT_TYPE";
    MapperKind["UNION_TYPE"] = "MapperKind.UNION_TYPE";
    MapperKind["INTERFACE_TYPE"] = "MapperKind.INTERFACE_TYPE";
    MapperKind["ROOT_OBJECT"] = "MapperKind.ROOT_OBJECT";
    MapperKind["QUERY"] = "MapperKind.QUERY";
    MapperKind["MUTATION"] = "MapperKind.MUTATION";
    MapperKind["SUBSCRIPTION"] = "MapperKind.SUBSCRIPTION";
    MapperKind["DIRECTIVE"] = "MapperKind.DIRECTIVE";
    MapperKind["FIELD"] = "MapperKind.FIELD";
    MapperKind["COMPOSITE_FIELD"] = "MapperKind.COMPOSITE_FIELD";
    MapperKind["OBJECT_FIELD"] = "MapperKind.OBJECT_FIELD";
    MapperKind["ROOT_FIELD"] = "MapperKind.ROOT_FIELD";
    MapperKind["QUERY_ROOT_FIELD"] = "MapperKind.QUERY_ROOT_FIELD";
    MapperKind["MUTATION_ROOT_FIELD"] = "MapperKind.MUTATION_ROOT_FIELD";
    MapperKind["SUBSCRIPTION_ROOT_FIELD"] = "MapperKind.SUBSCRIPTION_ROOT_FIELD";
    MapperKind["INTERFACE_FIELD"] = "MapperKind.INTERFACE_FIELD";
    MapperKind["INPUT_OBJECT_FIELD"] = "MapperKind.INPUT_OBJECT_FIELD";
    MapperKind["ARGUMENT"] = "MapperKind.ARGUMENT";
    MapperKind["ENUM_VALUE"] = "MapperKind.ENUM_VALUE";
})(MapperKind = exports.MapperKind || (exports.MapperKind = {}));


/***/ }),

/***/ 2941:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.printPathArray = exports.pathToArray = exports.addPath = void 0;
/**
 * Given a Path and a key, return a new Path containing the new key.
 */ function addPath(prev, key, typename) {
    return {
        prev,
        key,
        typename
    };
}
exports.addPath = addPath;
/**
 * Given a Path, return an Array of the path keys.
 */ function pathToArray(path) {
    const flattened = [];
    let curr = path;
    while(curr){
        flattened.push(curr.key);
        curr = curr.prev;
    }
    return flattened.reverse();
}
exports.pathToArray = pathToArray;
/**
 * Build a string describing the path.
 */ function printPathArray(path) {
    return path.map((key)=>typeof key === "number" ? "[" + key.toString() + "]" : "." + key).join("");
}
exports.printPathArray = printPathArray;


/***/ }),

/***/ 1561:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// addTypes uses toConfig to create a new schema with a new or replaced
// type or directive. Rewiring is employed so that the replaced type can be
// reconnected with the existing types.
//
// Rewiring is employed even for new types or directives as a convenience, so
// that type references within the new type or directive do not have to be to
// the identical objects within the original schema.
//
// In fact, the type references could even be stub types with entirely different
// fields, as long as the type references share the same name as the desired
// type within the original schema's type map.
//
// This makes it easy to perform simple schema operations (e.g. adding a new
// type with a fiew fields removed from an existing type) that could normally be
// performed by using toConfig directly, but is blocked if any intervening
// more advanced schema operations have caused the types to be recreated via
// rewiring.
//
// Type recreation happens, for example, with every use of mapSchema, as the
// types are always rewired. If fields are selected and removed using
// mapSchema, adding those fields to a new type can no longer be simply done
// by toConfig, as the types are not the identical JavaScript objects, and
// schema creation will fail with errors referencing multiple types with the
// same names.
//
// enhanceSchema can fill this gap by adding an additional round of rewiring.
//
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.addTypes = void 0;
const graphql_1 = __webpack_require__(5736);
const getObjectTypeFromTypeMap_js_1 = __webpack_require__(3359);
const rewire_js_1 = __webpack_require__(1125);
function addTypes(schema, newTypesOrDirectives) {
    const config = schema.toConfig();
    const originalTypeMap = {};
    for (const type of config.types){
        originalTypeMap[type.name] = type;
    }
    const originalDirectiveMap = {};
    for (const directive of config.directives){
        originalDirectiveMap[directive.name] = directive;
    }
    for (const newTypeOrDirective of newTypesOrDirectives){
        if ((0, graphql_1.isNamedType)(newTypeOrDirective)) {
            originalTypeMap[newTypeOrDirective.name] = newTypeOrDirective;
        } else if ((0, graphql_1.isDirective)(newTypeOrDirective)) {
            originalDirectiveMap[newTypeOrDirective.name] = newTypeOrDirective;
        }
    }
    const { typeMap , directives  } = (0, rewire_js_1.rewireTypes)(originalTypeMap, Object.values(originalDirectiveMap));
    return new graphql_1.GraphQLSchema({
        ...config,
        query: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, schema.getQueryType()),
        mutation: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, schema.getMutationType()),
        subscription: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, schema.getSubscriptionType()),
        types: Object.values(typeMap),
        directives
    });
}
exports.addTypes = addTypes;


/***/ }),

/***/ 3742:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.astFromType = void 0;
const graphql_1 = __webpack_require__(5736);
const inspect_js_1 = __webpack_require__(3261);
function astFromType(type) {
    if ((0, graphql_1.isNonNullType)(type)) {
        const innerType = astFromType(type.ofType);
        if (innerType.kind === graphql_1.Kind.NON_NULL_TYPE) {
            throw new Error(`Invalid type node ${(0, inspect_js_1.inspect)(type)}. Inner type of non-null type cannot be a non-null type.`);
        }
        return {
            kind: graphql_1.Kind.NON_NULL_TYPE,
            type: innerType
        };
    } else if ((0, graphql_1.isListType)(type)) {
        return {
            kind: graphql_1.Kind.LIST_TYPE,
            type: astFromType(type.ofType)
        };
    }
    return {
        kind: graphql_1.Kind.NAMED_TYPE,
        name: {
            kind: graphql_1.Kind.NAME,
            value: type.name
        }
    };
}
exports.astFromType = astFromType;


/***/ }),

/***/ 4768:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.astFromValueUntyped = void 0;
const graphql_1 = __webpack_require__(5736);
/**
 * Produces a GraphQL Value AST given a JavaScript object.
 * Function will match JavaScript/JSON values to GraphQL AST schema format
 * by using the following mapping.
 *
 * | JSON Value    | GraphQL Value        |
 * | ------------- | -------------------- |
 * | Object        | Input Object         |
 * | Array         | List                 |
 * | Boolean       | Boolean              |
 * | String        | String               |
 * | Number        | Int / Float          |
 * | null          | NullValue            |
 *
 */ function astFromValueUntyped(value) {
    // only explicit null, not undefined, NaN
    if (value === null) {
        return {
            kind: graphql_1.Kind.NULL
        };
    }
    // undefined
    if (value === undefined) {
        return null;
    }
    // Convert JavaScript array to GraphQL list. If the GraphQLType is a list, but
    // the value is not an array, convert the value using the list's item type.
    if (Array.isArray(value)) {
        const valuesNodes = [];
        for (const item of value){
            const itemNode = astFromValueUntyped(item);
            if (itemNode != null) {
                valuesNodes.push(itemNode);
            }
        }
        return {
            kind: graphql_1.Kind.LIST,
            values: valuesNodes
        };
    }
    if (typeof value === "object") {
        const fieldNodes = [];
        for(const fieldName in value){
            const fieldValue = value[fieldName];
            const ast = astFromValueUntyped(fieldValue);
            if (ast) {
                fieldNodes.push({
                    kind: graphql_1.Kind.OBJECT_FIELD,
                    name: {
                        kind: graphql_1.Kind.NAME,
                        value: fieldName
                    },
                    value: ast
                });
            }
        }
        return {
            kind: graphql_1.Kind.OBJECT,
            fields: fieldNodes
        };
    }
    // Others serialize based on their corresponding JavaScript scalar types.
    if (typeof value === "boolean") {
        return {
            kind: graphql_1.Kind.BOOLEAN,
            value
        };
    }
    // JavaScript numbers can be Int or Float values.
    if (typeof value === "number" && isFinite(value)) {
        const stringNum = String(value);
        return integerStringRegExp.test(stringNum) ? {
            kind: graphql_1.Kind.INT,
            value: stringNum
        } : {
            kind: graphql_1.Kind.FLOAT,
            value: stringNum
        };
    }
    if (typeof value === "string") {
        return {
            kind: graphql_1.Kind.STRING,
            value
        };
    }
    throw new TypeError(`Cannot convert value to AST: ${value}.`);
}
exports.astFromValueUntyped = astFromValueUntyped;
/**
 * IntValue:
 *   - NegativeSign? 0
 *   - NegativeSign? NonZeroDigit ( Digit+ )?
 */ const integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;


/***/ }),

/***/ 5662:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.buildOperationNodeForField = void 0;
const graphql_1 = __webpack_require__(5736);
const rootTypes_js_1 = __webpack_require__(7839);
let operationVariables = [];
let fieldTypeMap = new Map();
function addOperationVariable(variable) {
    operationVariables.push(variable);
}
function resetOperationVariables() {
    operationVariables = [];
}
function resetFieldMap() {
    fieldTypeMap = new Map();
}
function buildOperationNodeForField({ schema , kind , field , models , ignore =[] , depthLimit , circularReferenceDepth , argNames , selectedFields =true  }) {
    resetOperationVariables();
    resetFieldMap();
    const rootTypeNames = (0, rootTypes_js_1.getRootTypeNames)(schema);
    const operationNode = buildOperationAndCollectVariables({
        schema,
        fieldName: field,
        kind,
        models: models || [],
        ignore,
        depthLimit: depthLimit || Infinity,
        circularReferenceDepth: circularReferenceDepth || 1,
        argNames,
        selectedFields,
        rootTypeNames
    });
    // attach variables
    operationNode.variableDefinitions = [
        ...operationVariables
    ];
    resetOperationVariables();
    resetFieldMap();
    return operationNode;
}
exports.buildOperationNodeForField = buildOperationNodeForField;
function buildOperationAndCollectVariables({ schema , fieldName , kind , models , ignore , depthLimit , circularReferenceDepth , argNames , selectedFields , rootTypeNames  }) {
    const type = (0, rootTypes_js_1.getDefinedRootType)(schema, kind);
    const field = type.getFields()[fieldName];
    const operationName = `${fieldName}_${kind}`;
    if (field.args) {
        for (const arg of field.args){
            const argName = arg.name;
            if (!argNames || argNames.includes(argName)) {
                addOperationVariable(resolveVariable(arg, argName));
            }
        }
    }
    return {
        kind: graphql_1.Kind.OPERATION_DEFINITION,
        operation: kind,
        name: {
            kind: graphql_1.Kind.NAME,
            value: operationName
        },
        variableDefinitions: [],
        selectionSet: {
            kind: graphql_1.Kind.SELECTION_SET,
            selections: [
                resolveField({
                    type,
                    field,
                    models,
                    firstCall: true,
                    path: [],
                    ancestors: [],
                    ignore,
                    depthLimit,
                    circularReferenceDepth,
                    schema,
                    depth: 0,
                    argNames,
                    selectedFields,
                    rootTypeNames
                })
            ]
        }
    };
}
function resolveSelectionSet({ parent , type , models , firstCall , path , ancestors , ignore , depthLimit , circularReferenceDepth , schema , depth , argNames , selectedFields , rootTypeNames  }) {
    if (typeof selectedFields === "boolean" && depth > depthLimit) {
        return;
    }
    if ((0, graphql_1.isUnionType)(type)) {
        const types = type.getTypes();
        return {
            kind: graphql_1.Kind.SELECTION_SET,
            selections: types.filter((t)=>!hasCircularRef([
                    ...ancestors,
                    t
                ], {
                    depth: circularReferenceDepth
                })).map((t)=>{
                return {
                    kind: graphql_1.Kind.INLINE_FRAGMENT,
                    typeCondition: {
                        kind: graphql_1.Kind.NAMED_TYPE,
                        name: {
                            kind: graphql_1.Kind.NAME,
                            value: t.name
                        }
                    },
                    selectionSet: resolveSelectionSet({
                        parent: type,
                        type: t,
                        models,
                        path,
                        ancestors,
                        ignore,
                        depthLimit,
                        circularReferenceDepth,
                        schema,
                        depth,
                        argNames,
                        selectedFields,
                        rootTypeNames
                    })
                };
            }).filter((fragmentNode)=>{
                var _a, _b;
                return ((_b = (_a = fragmentNode === null || fragmentNode === void 0 ? void 0 : fragmentNode.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length) > 0;
            })
        };
    }
    if ((0, graphql_1.isInterfaceType)(type)) {
        const types = Object.values(schema.getTypeMap()).filter((t)=>(0, graphql_1.isObjectType)(t) && t.getInterfaces().includes(type));
        return {
            kind: graphql_1.Kind.SELECTION_SET,
            selections: types.filter((t)=>!hasCircularRef([
                    ...ancestors,
                    t
                ], {
                    depth: circularReferenceDepth
                })).map((t)=>{
                return {
                    kind: graphql_1.Kind.INLINE_FRAGMENT,
                    typeCondition: {
                        kind: graphql_1.Kind.NAMED_TYPE,
                        name: {
                            kind: graphql_1.Kind.NAME,
                            value: t.name
                        }
                    },
                    selectionSet: resolveSelectionSet({
                        parent: type,
                        type: t,
                        models,
                        path,
                        ancestors,
                        ignore,
                        depthLimit,
                        circularReferenceDepth,
                        schema,
                        depth,
                        argNames,
                        selectedFields,
                        rootTypeNames
                    })
                };
            }).filter((fragmentNode)=>{
                var _a, _b;
                return ((_b = (_a = fragmentNode === null || fragmentNode === void 0 ? void 0 : fragmentNode.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length) > 0;
            })
        };
    }
    if ((0, graphql_1.isObjectType)(type) && !rootTypeNames.has(type.name)) {
        const isIgnored = ignore.includes(type.name) || ignore.includes(`${parent.name}.${path[path.length - 1]}`);
        const isModel = models.includes(type.name);
        if (!firstCall && isModel && !isIgnored) {
            return {
                kind: graphql_1.Kind.SELECTION_SET,
                selections: [
                    {
                        kind: graphql_1.Kind.FIELD,
                        name: {
                            kind: graphql_1.Kind.NAME,
                            value: "id"
                        }
                    }
                ]
            };
        }
        const fields = type.getFields();
        return {
            kind: graphql_1.Kind.SELECTION_SET,
            selections: Object.keys(fields).filter((fieldName)=>{
                return !hasCircularRef([
                    ...ancestors,
                    (0, graphql_1.getNamedType)(fields[fieldName].type)
                ], {
                    depth: circularReferenceDepth
                });
            }).map((fieldName)=>{
                const selectedSubFields = typeof selectedFields === "object" ? selectedFields[fieldName] : true;
                if (selectedSubFields) {
                    return resolveField({
                        type,
                        field: fields[fieldName],
                        models,
                        path: [
                            ...path,
                            fieldName
                        ],
                        ancestors,
                        ignore,
                        depthLimit,
                        circularReferenceDepth,
                        schema,
                        depth,
                        argNames,
                        selectedFields: selectedSubFields,
                        rootTypeNames
                    });
                }
                return null;
            }).filter((f)=>{
                var _a, _b;
                if (f == null) {
                    return false;
                } else if ("selectionSet" in f) {
                    return !!((_b = (_a = f.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length);
                }
                return true;
            })
        };
    }
}
function resolveVariable(arg, name) {
    function resolveVariableType(type) {
        if ((0, graphql_1.isListType)(type)) {
            return {
                kind: graphql_1.Kind.LIST_TYPE,
                type: resolveVariableType(type.ofType)
            };
        }
        if ((0, graphql_1.isNonNullType)(type)) {
            return {
                kind: graphql_1.Kind.NON_NULL_TYPE,
                // for v16 compatibility
                type: resolveVariableType(type.ofType)
            };
        }
        return {
            kind: graphql_1.Kind.NAMED_TYPE,
            name: {
                kind: graphql_1.Kind.NAME,
                value: type.name
            }
        };
    }
    return {
        kind: graphql_1.Kind.VARIABLE_DEFINITION,
        variable: {
            kind: graphql_1.Kind.VARIABLE,
            name: {
                kind: graphql_1.Kind.NAME,
                value: name || arg.name
            }
        },
        type: resolveVariableType(arg.type)
    };
}
function getArgumentName(name, path) {
    return [
        ...path,
        name
    ].join("_");
}
function resolveField({ type , field , models , firstCall , path , ancestors , ignore , depthLimit , circularReferenceDepth , schema , depth , argNames , selectedFields , rootTypeNames  }) {
    const namedType = (0, graphql_1.getNamedType)(field.type);
    let args = [];
    let removeField = false;
    if (field.args && field.args.length) {
        args = field.args.map((arg)=>{
            const argumentName = getArgumentName(arg.name, path);
            if (argNames && !argNames.includes(argumentName)) {
                if ((0, graphql_1.isNonNullType)(arg.type)) {
                    removeField = true;
                }
                return null;
            }
            if (!firstCall) {
                addOperationVariable(resolveVariable(arg, argumentName));
            }
            return {
                kind: graphql_1.Kind.ARGUMENT,
                name: {
                    kind: graphql_1.Kind.NAME,
                    value: arg.name
                },
                value: {
                    kind: graphql_1.Kind.VARIABLE,
                    name: {
                        kind: graphql_1.Kind.NAME,
                        value: getArgumentName(arg.name, path)
                    }
                }
            };
        }).filter(Boolean);
    }
    if (removeField) {
        return null;
    }
    const fieldPath = [
        ...path,
        field.name
    ];
    const fieldPathStr = fieldPath.join(".");
    let fieldName = field.name;
    if (fieldTypeMap.has(fieldPathStr) && fieldTypeMap.get(fieldPathStr) !== field.type.toString()) {
        fieldName += field.type.toString().replace("!", "NonNull").replace("[", "List").replace("]", "");
    }
    fieldTypeMap.set(fieldPathStr, field.type.toString());
    if (!(0, graphql_1.isScalarType)(namedType) && !(0, graphql_1.isEnumType)(namedType)) {
        return {
            kind: graphql_1.Kind.FIELD,
            name: {
                kind: graphql_1.Kind.NAME,
                value: field.name
            },
            ...fieldName !== field.name && {
                alias: {
                    kind: graphql_1.Kind.NAME,
                    value: fieldName
                }
            },
            selectionSet: resolveSelectionSet({
                parent: type,
                type: namedType,
                models,
                firstCall,
                path: fieldPath,
                ancestors: [
                    ...ancestors,
                    type
                ],
                ignore,
                depthLimit,
                circularReferenceDepth,
                schema,
                depth: depth + 1,
                argNames,
                selectedFields,
                rootTypeNames
            }) || undefined,
            arguments: args
        };
    }
    return {
        kind: graphql_1.Kind.FIELD,
        name: {
            kind: graphql_1.Kind.NAME,
            value: field.name
        },
        ...fieldName !== field.name && {
            alias: {
                kind: graphql_1.Kind.NAME,
                value: fieldName
            }
        },
        arguments: args
    };
}
function hasCircularRef(types, config = {
    depth: 1
}) {
    const type = types[types.length - 1];
    if ((0, graphql_1.isScalarType)(type)) {
        return false;
    }
    const size = types.filter((t)=>t.name === type.name).length;
    return size > config.depth;
}


/***/ }),

/***/ 1036:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.collectSubFields = exports.getDeferValues = exports.getFieldEntryKey = exports.doesFragmentConditionMatch = exports.shouldIncludeNode = exports.collectFields = void 0;
const memoize_js_1 = __webpack_require__(9787);
const graphql_1 = __webpack_require__(5736);
const directives_js_1 = __webpack_require__(4253);
const AccumulatorMap_js_1 = __webpack_require__(1926);
function collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, patches, visitedFragmentNames) {
    for (const selection of selectionSet.selections){
        switch(selection.kind){
            case graphql_1.Kind.FIELD:
                {
                    if (!shouldIncludeNode(variableValues, selection)) {
                        continue;
                    }
                    fields.add(getFieldEntryKey(selection), selection);
                    break;
                }
            case graphql_1.Kind.INLINE_FRAGMENT:
                {
                    if (!shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema, selection, runtimeType)) {
                        continue;
                    }
                    const defer = getDeferValues(variableValues, selection);
                    if (defer) {
                        const patchFields = new AccumulatorMap_js_1.AccumulatorMap();
                        collectFieldsImpl(schema, fragments, variableValues, runtimeType, selection.selectionSet, patchFields, patches, visitedFragmentNames);
                        patches.push({
                            label: defer.label,
                            fields: patchFields
                        });
                    } else {
                        collectFieldsImpl(schema, fragments, variableValues, runtimeType, selection.selectionSet, fields, patches, visitedFragmentNames);
                    }
                    break;
                }
            case graphql_1.Kind.FRAGMENT_SPREAD:
                {
                    const fragName = selection.name.value;
                    if (!shouldIncludeNode(variableValues, selection)) {
                        continue;
                    }
                    const defer = getDeferValues(variableValues, selection);
                    if (visitedFragmentNames.has(fragName) && !defer) {
                        continue;
                    }
                    const fragment = fragments[fragName];
                    if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) {
                        continue;
                    }
                    if (!defer) {
                        visitedFragmentNames.add(fragName);
                    }
                    if (defer) {
                        const patchFields = new AccumulatorMap_js_1.AccumulatorMap();
                        collectFieldsImpl(schema, fragments, variableValues, runtimeType, fragment.selectionSet, patchFields, patches, visitedFragmentNames);
                        patches.push({
                            label: defer.label,
                            fields: patchFields
                        });
                    } else {
                        collectFieldsImpl(schema, fragments, variableValues, runtimeType, fragment.selectionSet, fields, patches, visitedFragmentNames);
                    }
                    break;
                }
        }
    }
}
/**
 * Given a selectionSet, collects all of the fields and returns them.
 *
 * CollectFields requires the "runtime type" of an object. For a field that
 * returns an Interface or Union type, the "runtime type" will be the actual
 * object type returned by that field.
 *
 */ function collectFields(schema, fragments, variableValues, runtimeType, selectionSet) {
    const fields = new AccumulatorMap_js_1.AccumulatorMap();
    const patches = [];
    collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, patches, new Set());
    return {
        fields,
        patches
    };
}
exports.collectFields = collectFields;
/**
 * Determines if a field should be included based on the `@include` and `@skip`
 * directives, where `@skip` has higher precedence than `@include`.
 */ function shouldIncludeNode(variableValues, node) {
    const skip = (0, graphql_1.getDirectiveValues)(graphql_1.GraphQLSkipDirective, node, variableValues);
    if ((skip === null || skip === void 0 ? void 0 : skip["if"]) === true) {
        return false;
    }
    const include = (0, graphql_1.getDirectiveValues)(graphql_1.GraphQLIncludeDirective, node, variableValues);
    if ((include === null || include === void 0 ? void 0 : include["if"]) === false) {
        return false;
    }
    return true;
}
exports.shouldIncludeNode = shouldIncludeNode;
/**
 * Determines if a fragment is applicable to the given type.
 */ function doesFragmentConditionMatch(schema, fragment, type) {
    const typeConditionNode = fragment.typeCondition;
    if (!typeConditionNode) {
        return true;
    }
    const conditionalType = (0, graphql_1.typeFromAST)(schema, typeConditionNode);
    if (conditionalType === type) {
        return true;
    }
    if ((0, graphql_1.isAbstractType)(conditionalType)) {
        const possibleTypes = schema.getPossibleTypes(conditionalType);
        return possibleTypes.includes(type);
    }
    return false;
}
exports.doesFragmentConditionMatch = doesFragmentConditionMatch;
/**
 * Implements the logic to compute the key of a given field's entry
 */ function getFieldEntryKey(node) {
    return node.alias ? node.alias.value : node.name.value;
}
exports.getFieldEntryKey = getFieldEntryKey;
/**
 * Returns an object containing the `@defer` arguments if a field should be
 * deferred based on the experimental flag, defer directive present and
 * not disabled by the "if" argument.
 */ function getDeferValues(variableValues, node) {
    const defer = (0, graphql_1.getDirectiveValues)(directives_js_1.GraphQLDeferDirective, node, variableValues);
    if (!defer) {
        return;
    }
    if (defer["if"] === false) {
        return;
    }
    return {
        label: typeof defer["label"] === "string" ? defer["label"] : undefined
    };
}
exports.getDeferValues = getDeferValues;
/**
 * Given an array of field nodes, collects all of the subfields of the passed
 * in fields, and returns them at the end.
 *
 * CollectSubFields requires the "return type" of an object. For a field that
 * returns an Interface or Union type, the "return type" will be the actual
 * object type returned by that field.
 *
 */ exports.collectSubFields = (0, memoize_js_1.memoize5)(function collectSubfields(schema, fragments, variableValues, returnType, fieldNodes) {
    const subFieldNodes = new AccumulatorMap_js_1.AccumulatorMap();
    const visitedFragmentNames = new Set();
    const subPatches = [];
    const subFieldsAndPatches = {
        fields: subFieldNodes,
        patches: subPatches
    };
    for (const node of fieldNodes){
        if (node.selectionSet) {
            collectFieldsImpl(schema, fragments, variableValues, returnType, node.selectionSet, subFieldNodes, subPatches, visitedFragmentNames);
        }
    }
    return subFieldsAndPatches;
});


/***/ }),

/***/ 8950:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getBlockStringIndentation = exports.dedentBlockStringValue = exports.getLeadingCommentBlock = exports.getComment = exports.getDescription = exports.printWithComments = exports.printComment = exports.pushComment = exports.collectComment = exports.resetComments = void 0;
const graphql_1 = __webpack_require__(5736);
const MAX_LINE_LENGTH = 80;
let commentsRegistry = {};
function resetComments() {
    commentsRegistry = {};
}
exports.resetComments = resetComments;
function collectComment(node) {
    var _a;
    const entityName = (_a = node.name) === null || _a === void 0 ? void 0 : _a.value;
    if (entityName == null) {
        return;
    }
    pushComment(node, entityName);
    switch(node.kind){
        case "EnumTypeDefinition":
            if (node.values) {
                for (const value of node.values){
                    pushComment(value, entityName, value.name.value);
                }
            }
            break;
        case "ObjectTypeDefinition":
        case "InputObjectTypeDefinition":
        case "InterfaceTypeDefinition":
            if (node.fields) {
                for (const field of node.fields){
                    pushComment(field, entityName, field.name.value);
                    if (isFieldDefinitionNode(field) && field.arguments) {
                        for (const arg of field.arguments){
                            pushComment(arg, entityName, field.name.value, arg.name.value);
                        }
                    }
                }
            }
            break;
    }
}
exports.collectComment = collectComment;
function pushComment(node, entity, field, argument) {
    const comment = getComment(node);
    if (typeof comment !== "string" || comment.length === 0) {
        return;
    }
    const keys = [
        entity
    ];
    if (field) {
        keys.push(field);
        if (argument) {
            keys.push(argument);
        }
    }
    const path = keys.join(".");
    if (!commentsRegistry[path]) {
        commentsRegistry[path] = [];
    }
    commentsRegistry[path].push(comment);
}
exports.pushComment = pushComment;
function printComment(comment) {
    return "\n# " + comment.replace(/\n/g, "\n# ");
}
exports.printComment = printComment;
/**
 * Copyright (c) 2015-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ /**
 * NOTE: ==> This file has been modified just to add comments to the printed AST
 * This is a temp measure, we will move to using the original non modified printer.js ASAP.
 */ /**
 * Given maybeArray, print an empty string if it is null or empty, otherwise
 * print all items together separated by separator if provided
 */ function join(maybeArray, separator) {
    return maybeArray ? maybeArray.filter((x)=>x).join(separator || "") : "";
}
function hasMultilineItems(maybeArray) {
    var _a;
    return (_a = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str)=>str.includes("\n"))) !== null && _a !== void 0 ? _a : false;
}
function addDescription(cb) {
    return (node, _key, _parent, path, ancestors)=>{
        var _a;
        const keys = [];
        const parent = path.reduce((prev, key)=>{
            if ([
                "fields",
                "arguments",
                "values"
            ].includes(key) && prev.name) {
                keys.push(prev.name.value);
            }
            return prev[key];
        }, ancestors[0]);
        const key = [
            ...keys,
            (_a = parent === null || parent === void 0 ? void 0 : parent.name) === null || _a === void 0 ? void 0 : _a.value
        ].filter(Boolean).join(".");
        const items = [];
        if (node.kind.includes("Definition") && commentsRegistry[key]) {
            items.push(...commentsRegistry[key]);
        }
        return join([
            ...items.map(printComment),
            node.description,
            cb(node, _key, _parent, path, ancestors)
        ], "\n");
    };
}
function indent(maybeString) {
    return maybeString && `  ${maybeString.replace(/\n/g, "\n  ")}`;
}
/**
 * Given array, print each item on its own line, wrapped in an
 * indented "{ }" block.
 */ function block(array) {
    return array && array.length !== 0 ? `{\n${indent(join(array, "\n"))}\n}` : "";
}
/**
 * If maybeString is not null or empty, then wrap with start and end, otherwise
 * print an empty string.
 */ function wrap(start, maybeString, end) {
    return maybeString ? start + maybeString + (end || "") : "";
}
/**
 * Print a block string in the indented block form by adding a leading and
 * trailing blank line. However, if a block string starts with whitespace and is
 * a single-line, adding a leading blank line would strip that whitespace.
 */ function printBlockString(value, isDescription = false) {
    const escaped = value.replace(/"""/g, '\\"""');
    return (value[0] === " " || value[0] === "	") && value.indexOf("\n") === -1 ? `"""${escaped.replace(/"$/, '"\n')}"""` : `"""\n${isDescription ? escaped : indent(escaped)}\n"""`;
}
const printDocASTReducer = {
    Name: {
        leave: (node)=>node.value
    },
    Variable: {
        leave: (node)=>"$" + node.name
    },
    // Document
    Document: {
        leave: (node)=>join(node.definitions, "\n\n")
    },
    OperationDefinition: {
        leave: (node)=>{
            const varDefs = wrap("(", join(node.variableDefinitions, ", "), ")");
            const prefix = join([
                node.operation,
                join([
                    node.name,
                    varDefs
                ]),
                join(node.directives, " ")
            ], " ");
            // the query short form.
            return prefix + " " + node.selectionSet;
        }
    },
    VariableDefinition: {
        leave: ({ variable , type , defaultValue , directives  })=>variable + ": " + type + wrap(" = ", defaultValue) + wrap(" ", join(directives, " "))
    },
    SelectionSet: {
        leave: ({ selections  })=>block(selections)
    },
    Field: {
        leave ({ alias , name , arguments: args , directives , selectionSet  }) {
            const prefix = wrap("", alias, ": ") + name;
            let argsLine = prefix + wrap("(", join(args, ", "), ")");
            if (argsLine.length > MAX_LINE_LENGTH) {
                argsLine = prefix + wrap("(\n", indent(join(args, "\n")), "\n)");
            }
            return join([
                argsLine,
                join(directives, " "),
                selectionSet
            ], " ");
        }
    },
    Argument: {
        leave: ({ name , value  })=>name + ": " + value
    },
    // Fragments
    FragmentSpread: {
        leave: ({ name , directives  })=>"..." + name + wrap(" ", join(directives, " "))
    },
    InlineFragment: {
        leave: ({ typeCondition , directives , selectionSet  })=>join([
                "...",
                wrap("on ", typeCondition),
                join(directives, " "),
                selectionSet
            ], " ")
    },
    FragmentDefinition: {
        leave: ({ name , typeCondition , variableDefinitions , directives , selectionSet  })=>// Note: fragment variable definitions are experimental and may be changed
            // or removed in the future.
            `fragment ${name}${wrap("(", join(variableDefinitions, ", "), ")")} ` + `on ${typeCondition} ${wrap("", join(directives, " "), " ")}` + selectionSet
    },
    // Value
    IntValue: {
        leave: ({ value  })=>value
    },
    FloatValue: {
        leave: ({ value  })=>value
    },
    StringValue: {
        leave: ({ value , block: isBlockString  })=>{
            if (isBlockString) {
                return printBlockString(value);
            }
            return JSON.stringify(value);
        }
    },
    BooleanValue: {
        leave: ({ value  })=>value ? "true" : "false"
    },
    NullValue: {
        leave: ()=>"null"
    },
    EnumValue: {
        leave: ({ value  })=>value
    },
    ListValue: {
        leave: ({ values  })=>"[" + join(values, ", ") + "]"
    },
    ObjectValue: {
        leave: ({ fields  })=>"{" + join(fields, ", ") + "}"
    },
    ObjectField: {
        leave: ({ name , value  })=>name + ": " + value
    },
    // Directive
    Directive: {
        leave: ({ name , arguments: args  })=>"@" + name + wrap("(", join(args, ", "), ")")
    },
    // Type
    NamedType: {
        leave: ({ name  })=>name
    },
    ListType: {
        leave: ({ type  })=>"[" + type + "]"
    },
    NonNullType: {
        leave: ({ type  })=>type + "!"
    },
    // Type System Definitions
    SchemaDefinition: {
        leave: ({ directives , operationTypes  })=>join([
                "schema",
                join(directives, " "),
                block(operationTypes)
            ], " ")
    },
    OperationTypeDefinition: {
        leave: ({ operation , type  })=>operation + ": " + type
    },
    ScalarTypeDefinition: {
        leave: ({ name , directives  })=>join([
                "scalar",
                name,
                join(directives, " ")
            ], " ")
    },
    ObjectTypeDefinition: {
        leave: ({ name , interfaces , directives , fields  })=>join([
                "type",
                name,
                wrap("implements ", join(interfaces, " & ")),
                join(directives, " "),
                block(fields)
            ], " ")
    },
    FieldDefinition: {
        leave: ({ name , arguments: args , type , directives  })=>name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + ": " + type + wrap(" ", join(directives, " "))
    },
    InputValueDefinition: {
        leave: ({ name , type , defaultValue , directives  })=>join([
                name + ": " + type,
                wrap("= ", defaultValue),
                join(directives, " ")
            ], " ")
    },
    InterfaceTypeDefinition: {
        leave: ({ name , interfaces , directives , fields  })=>join([
                "interface",
                name,
                wrap("implements ", join(interfaces, " & ")),
                join(directives, " "),
                block(fields)
            ], " ")
    },
    UnionTypeDefinition: {
        leave: ({ name , directives , types  })=>join([
                "union",
                name,
                join(directives, " "),
                wrap("= ", join(types, " | "))
            ], " ")
    },
    EnumTypeDefinition: {
        leave: ({ name , directives , values  })=>join([
                "enum",
                name,
                join(directives, " "),
                block(values)
            ], " ")
    },
    EnumValueDefinition: {
        leave: ({ name , directives  })=>join([
                name,
                join(directives, " ")
            ], " ")
    },
    InputObjectTypeDefinition: {
        leave: ({ name , directives , fields  })=>join([
                "input",
                name,
                join(directives, " "),
                block(fields)
            ], " ")
    },
    DirectiveDefinition: {
        leave: ({ name , arguments: args , repeatable , locations  })=>"directive @" + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join(locations, " | ")
    },
    SchemaExtension: {
        leave: ({ directives , operationTypes  })=>join([
                "extend schema",
                join(directives, " "),
                block(operationTypes)
            ], " ")
    },
    ScalarTypeExtension: {
        leave: ({ name , directives  })=>join([
                "extend scalar",
                name,
                join(directives, " ")
            ], " ")
    },
    ObjectTypeExtension: {
        leave: ({ name , interfaces , directives , fields  })=>join([
                "extend type",
                name,
                wrap("implements ", join(interfaces, " & ")),
                join(directives, " "),
                block(fields)
            ], " ")
    },
    InterfaceTypeExtension: {
        leave: ({ name , interfaces , directives , fields  })=>join([
                "extend interface",
                name,
                wrap("implements ", join(interfaces, " & ")),
                join(directives, " "),
                block(fields)
            ], " ")
    },
    UnionTypeExtension: {
        leave: ({ name , directives , types  })=>join([
                "extend union",
                name,
                join(directives, " "),
                wrap("= ", join(types, " | "))
            ], " ")
    },
    EnumTypeExtension: {
        leave: ({ name , directives , values  })=>join([
                "extend enum",
                name,
                join(directives, " "),
                block(values)
            ], " ")
    },
    InputObjectTypeExtension: {
        leave: ({ name , directives , fields  })=>join([
                "extend input",
                name,
                join(directives, " "),
                block(fields)
            ], " ")
    }
};
const printDocASTReducerWithComments = Object.keys(printDocASTReducer).reduce((prev, key)=>({
        ...prev,
        [key]: {
            leave: addDescription(printDocASTReducer[key].leave)
        }
    }), {});
/**
 * Converts an AST into a string, using one set of reasonable
 * formatting rules.
 */ function printWithComments(ast) {
    return (0, graphql_1.visit)(ast, printDocASTReducerWithComments);
}
exports.printWithComments = printWithComments;
function isFieldDefinitionNode(node) {
    return node.kind === "FieldDefinition";
}
// graphql < v13 and > v15 does not export getDescription
function getDescription(node, options) {
    if (node.description != null) {
        return node.description.value;
    }
    if (options === null || options === void 0 ? void 0 : options.commentDescriptions) {
        return getComment(node);
    }
}
exports.getDescription = getDescription;
function getComment(node) {
    const rawValue = getLeadingCommentBlock(node);
    if (rawValue !== undefined) {
        return dedentBlockStringValue(`\n${rawValue}`);
    }
}
exports.getComment = getComment;
function getLeadingCommentBlock(node) {
    const loc = node.loc;
    if (!loc) {
        return;
    }
    const comments = [];
    let token = loc.startToken.prev;
    while(token != null && token.kind === graphql_1.TokenKind.COMMENT && token.next != null && token.prev != null && token.line + 1 === token.next.line && token.line !== token.prev.line){
        const value = String(token.value);
        comments.push(value);
        token = token.prev;
    }
    return comments.length > 0 ? comments.reverse().join("\n") : undefined;
}
exports.getLeadingCommentBlock = getLeadingCommentBlock;
function dedentBlockStringValue(rawString) {
    // Expand a block string's raw value into independent lines.
    const lines = rawString.split(/\r\n|[\n\r]/g);
    // Remove common indentation from all lines but first.
    const commonIndent = getBlockStringIndentation(lines);
    if (commonIndent !== 0) {
        for(let i = 1; i < lines.length; i++){
            lines[i] = lines[i].slice(commonIndent);
        }
    }
    // Remove leading and trailing blank lines.
    while(lines.length > 0 && isBlank(lines[0])){
        lines.shift();
    }
    while(lines.length > 0 && isBlank(lines[lines.length - 1])){
        lines.pop();
    }
    // Return a string of the lines joined with U+000A.
    return lines.join("\n");
}
exports.dedentBlockStringValue = dedentBlockStringValue;
/**
 * @internal
 */ function getBlockStringIndentation(lines) {
    let commonIndent = null;
    for(let i = 1; i < lines.length; i++){
        const line = lines[i];
        const indent = leadingWhitespace(line);
        if (indent === line.length) {
            continue; // skip empty lines
        }
        if (commonIndent === null || indent < commonIndent) {
            commonIndent = indent;
            if (commonIndent === 0) {
                break;
            }
        }
    }
    return commonIndent === null ? 0 : commonIndent;
}
exports.getBlockStringIndentation = getBlockStringIndentation;
function leadingWhitespace(str) {
    let i = 0;
    while(i < str.length && (str[i] === " " || str[i] === "	")){
        i++;
    }
    return i;
}
function isBlank(str) {
    return leadingWhitespace(str) === str.length;
}


/***/ }),

/***/ 4253:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.GraphQLStreamDirective = exports.GraphQLDeferDirective = void 0;
const graphql_1 = __webpack_require__(5736);
/**
 * Used to conditionally defer fragments.
 */ exports.GraphQLDeferDirective = new graphql_1.GraphQLDirective({
    name: "defer",
    description: "Directs the executor to defer this fragment when the `if` argument is true or undefined.",
    locations: [
        graphql_1.DirectiveLocation.FRAGMENT_SPREAD,
        graphql_1.DirectiveLocation.INLINE_FRAGMENT
    ],
    args: {
        if: {
            type: new graphql_1.GraphQLNonNull(graphql_1.GraphQLBoolean),
            description: "Deferred when true or undefined.",
            defaultValue: true
        },
        label: {
            type: graphql_1.GraphQLString,
            description: "Unique name"
        }
    }
});
/**
 * Used to conditionally stream list fields.
 */ exports.GraphQLStreamDirective = new graphql_1.GraphQLDirective({
    name: "stream",
    description: "Directs the executor to stream plural fields when the `if` argument is true or undefined.",
    locations: [
        graphql_1.DirectiveLocation.FIELD
    ],
    args: {
        if: {
            type: new graphql_1.GraphQLNonNull(graphql_1.GraphQLBoolean),
            description: "Stream when true or undefined.",
            defaultValue: true
        },
        label: {
            type: graphql_1.GraphQLString,
            description: "Unique name"
        },
        initialCount: {
            defaultValue: 0,
            type: graphql_1.GraphQLInt,
            description: "Number of items to return immediately"
        }
    }
});


/***/ }),

/***/ 2422:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.relocatedError = exports.createGraphQLError = void 0;
const graphql_1 = __webpack_require__(5736);
function createGraphQLError(message, options) {
    if (graphql_1.versionInfo.major >= 17) {
        return new graphql_1.GraphQLError(message, options);
    }
    return new graphql_1.GraphQLError(message, options === null || options === void 0 ? void 0 : options.nodes, options === null || options === void 0 ? void 0 : options.source, options === null || options === void 0 ? void 0 : options.positions, options === null || options === void 0 ? void 0 : options.path, options === null || options === void 0 ? void 0 : options.originalError, options === null || options === void 0 ? void 0 : options.extensions);
}
exports.createGraphQLError = createGraphQLError;
function relocatedError(originalError, path) {
    return createGraphQLError(originalError.message, {
        nodes: originalError.nodes,
        source: originalError.source,
        positions: originalError.positions,
        path: path == null ? originalError.path : path,
        originalError,
        extensions: originalError.extensions
    });
}
exports.relocatedError = relocatedError;


/***/ }),

/***/ 9573:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 4212:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.extractExtensionsFromSchema = void 0;
const mapSchema_js_1 = __webpack_require__(1061);
const Interfaces_js_1 = __webpack_require__(8395);
function extractExtensionsFromSchema(schema) {
    const result = {
        schemaExtensions: schema.extensions || {},
        types: {}
    };
    (0, mapSchema_js_1.mapSchema)(schema, {
        [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type)=>{
            result.types[type.name] = {
                fields: {},
                type: "object",
                extensions: type.extensions || {}
            };
            return type;
        },
        [Interfaces_js_1.MapperKind.INTERFACE_TYPE]: (type)=>{
            result.types[type.name] = {
                fields: {},
                type: "interface",
                extensions: type.extensions || {}
            };
            return type;
        },
        [Interfaces_js_1.MapperKind.FIELD]: (field, fieldName, typeName)=>{
            result.types[typeName].fields[fieldName] = {
                arguments: {},
                extensions: field.extensions || {}
            };
            const args = field.args;
            if (args != null) {
                for(const argName in args){
                    result.types[typeName].fields[fieldName].arguments[argName] = args[argName].extensions || {};
                }
            }
            return field;
        },
        [Interfaces_js_1.MapperKind.ENUM_TYPE]: (type)=>{
            result.types[type.name] = {
                values: {},
                type: "enum",
                extensions: type.extensions || {}
            };
            return type;
        },
        [Interfaces_js_1.MapperKind.ENUM_VALUE]: (value, typeName, _schema, valueName)=>{
            result.types[typeName].values[valueName] = value.extensions || {};
            return value;
        },
        [Interfaces_js_1.MapperKind.SCALAR_TYPE]: (type)=>{
            result.types[type.name] = {
                type: "scalar",
                extensions: type.extensions || {}
            };
            return type;
        },
        [Interfaces_js_1.MapperKind.UNION_TYPE]: (type)=>{
            result.types[type.name] = {
                type: "union",
                extensions: type.extensions || {}
            };
            return type;
        },
        [Interfaces_js_1.MapperKind.INPUT_OBJECT_TYPE]: (type)=>{
            result.types[type.name] = {
                fields: {},
                type: "input",
                extensions: type.extensions || {}
            };
            return type;
        },
        [Interfaces_js_1.MapperKind.INPUT_OBJECT_FIELD]: (field, fieldName, typeName)=>{
            result.types[typeName].fields[fieldName] = {
                extensions: field.extensions || {}
            };
            return field;
        }
    });
    return result;
}
exports.extractExtensionsFromSchema = extractExtensionsFromSchema;


/***/ }),

/***/ 7841:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.modifyObjectFields = exports.selectObjectFields = exports.removeObjectFields = exports.appendObjectFields = void 0;
const graphql_1 = __webpack_require__(5736);
const Interfaces_js_1 = __webpack_require__(8395);
const mapSchema_js_1 = __webpack_require__(1061);
const addTypes_js_1 = __webpack_require__(1561);
function appendObjectFields(schema, typeName, additionalFields) {
    if (schema.getType(typeName) == null) {
        return (0, addTypes_js_1.addTypes)(schema, [
            new graphql_1.GraphQLObjectType({
                name: typeName,
                fields: additionalFields
            })
        ]);
    }
    return (0, mapSchema_js_1.mapSchema)(schema, {
        [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type)=>{
            if (type.name === typeName) {
                const config = type.toConfig();
                const originalFieldConfigMap = config.fields;
                const newFieldConfigMap = {};
                for(const fieldName in originalFieldConfigMap){
                    newFieldConfigMap[fieldName] = originalFieldConfigMap[fieldName];
                }
                for(const fieldName in additionalFields){
                    newFieldConfigMap[fieldName] = additionalFields[fieldName];
                }
                return (0, mapSchema_js_1.correctASTNodes)(new graphql_1.GraphQLObjectType({
                    ...config,
                    fields: newFieldConfigMap
                }));
            }
        }
    });
}
exports.appendObjectFields = appendObjectFields;
function removeObjectFields(schema, typeName, testFn) {
    const removedFields = {};
    const newSchema = (0, mapSchema_js_1.mapSchema)(schema, {
        [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type)=>{
            if (type.name === typeName) {
                const config = type.toConfig();
                const originalFieldConfigMap = config.fields;
                const newFieldConfigMap = {};
                for(const fieldName in originalFieldConfigMap){
                    const originalFieldConfig = originalFieldConfigMap[fieldName];
                    if (testFn(fieldName, originalFieldConfig)) {
                        removedFields[fieldName] = originalFieldConfig;
                    } else {
                        newFieldConfigMap[fieldName] = originalFieldConfig;
                    }
                }
                return (0, mapSchema_js_1.correctASTNodes)(new graphql_1.GraphQLObjectType({
                    ...config,
                    fields: newFieldConfigMap
                }));
            }
        }
    });
    return [
        newSchema,
        removedFields
    ];
}
exports.removeObjectFields = removeObjectFields;
function selectObjectFields(schema, typeName, testFn) {
    const selectedFields = {};
    (0, mapSchema_js_1.mapSchema)(schema, {
        [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type)=>{
            if (type.name === typeName) {
                const config = type.toConfig();
                const originalFieldConfigMap = config.fields;
                for(const fieldName in originalFieldConfigMap){
                    const originalFieldConfig = originalFieldConfigMap[fieldName];
                    if (testFn(fieldName, originalFieldConfig)) {
                        selectedFields[fieldName] = originalFieldConfig;
                    }
                }
            }
            return undefined;
        }
    });
    return selectedFields;
}
exports.selectObjectFields = selectObjectFields;
function modifyObjectFields(schema, typeName, testFn, newFields) {
    const removedFields = {};
    const newSchema = (0, mapSchema_js_1.mapSchema)(schema, {
        [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type)=>{
            if (type.name === typeName) {
                const config = type.toConfig();
                const originalFieldConfigMap = config.fields;
                const newFieldConfigMap = {};
                for(const fieldName in originalFieldConfigMap){
                    const originalFieldConfig = originalFieldConfigMap[fieldName];
                    if (testFn(fieldName, originalFieldConfig)) {
                        removedFields[fieldName] = originalFieldConfig;
                    } else {
                        newFieldConfigMap[fieldName] = originalFieldConfig;
                    }
                }
                for(const fieldName in newFields){
                    const fieldConfig = newFields[fieldName];
                    newFieldConfigMap[fieldName] = fieldConfig;
                }
                return (0, mapSchema_js_1.correctASTNodes)(new graphql_1.GraphQLObjectType({
                    ...config,
                    fields: newFieldConfigMap
                }));
            }
        }
    });
    return [
        newSchema,
        removedFields
    ];
}
exports.modifyObjectFields = modifyObjectFields;


/***/ }),

/***/ 5857:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.filterSchema = void 0;
const graphql_1 = __webpack_require__(5736);
const Interfaces_js_1 = __webpack_require__(8395);
const mapSchema_js_1 = __webpack_require__(1061);
function filterSchema({ schema , typeFilter =()=>true , fieldFilter =undefined , rootFieldFilter =undefined , objectFieldFilter =undefined , interfaceFieldFilter =undefined , inputObjectFieldFilter =undefined , argumentFilter =undefined  }) {
    const filteredSchema = (0, mapSchema_js_1.mapSchema)(schema, {
        [Interfaces_js_1.MapperKind.QUERY]: (type)=>filterRootFields(type, "Query", rootFieldFilter, argumentFilter),
        [Interfaces_js_1.MapperKind.MUTATION]: (type)=>filterRootFields(type, "Mutation", rootFieldFilter, argumentFilter),
        [Interfaces_js_1.MapperKind.SUBSCRIPTION]: (type)=>filterRootFields(type, "Subscription", rootFieldFilter, argumentFilter),
        [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type)=>typeFilter(type.name, type) ? filterElementFields(graphql_1.GraphQLObjectType, type, objectFieldFilter || fieldFilter, argumentFilter) : null,
        [Interfaces_js_1.MapperKind.INTERFACE_TYPE]: (type)=>typeFilter(type.name, type) ? filterElementFields(graphql_1.GraphQLInterfaceType, type, interfaceFieldFilter || fieldFilter, argumentFilter) : null,
        [Interfaces_js_1.MapperKind.INPUT_OBJECT_TYPE]: (type)=>typeFilter(type.name, type) ? filterElementFields(graphql_1.GraphQLInputObjectType, type, inputObjectFieldFilter || fieldFilter) : null,
        [Interfaces_js_1.MapperKind.UNION_TYPE]: (type)=>typeFilter(type.name, type) ? undefined : null,
        [Interfaces_js_1.MapperKind.ENUM_TYPE]: (type)=>typeFilter(type.name, type) ? undefined : null,
        [Interfaces_js_1.MapperKind.SCALAR_TYPE]: (type)=>typeFilter(type.name, type) ? undefined : null
    });
    return filteredSchema;
}
exports.filterSchema = filterSchema;
function filterRootFields(type, operation, rootFieldFilter, argumentFilter) {
    if (rootFieldFilter || argumentFilter) {
        const config = type.toConfig();
        for(const fieldName in config.fields){
            const field = config.fields[fieldName];
            if (rootFieldFilter && !rootFieldFilter(operation, fieldName, config.fields[fieldName])) {
                delete config.fields[fieldName];
            } else if (argumentFilter && field.args) {
                for(const argName in field.args){
                    if (!argumentFilter(operation, fieldName, argName, field.args[argName])) {
                        delete field.args[argName];
                    }
                }
            }
        }
        return new graphql_1.GraphQLObjectType(config);
    }
    return type;
}
function filterElementFields(ElementConstructor, type, fieldFilter, argumentFilter) {
    if (fieldFilter || argumentFilter) {
        const config = type.toConfig();
        for(const fieldName in config.fields){
            const field = config.fields[fieldName];
            if (fieldFilter && !fieldFilter(type.name, fieldName, config.fields[fieldName])) {
                delete config.fields[fieldName];
            } else if (argumentFilter && "args" in field) {
                for(const argName in field.args){
                    if (!argumentFilter(type.name, fieldName, argName, field.args[argName])) {
                        delete field.args[argName];
                    }
                }
            }
        }
        return new ElementConstructor(config);
    }
}


/***/ }),

/***/ 8134:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.fixSchemaAst = void 0;
const graphql_1 = __webpack_require__(5736);
const print_schema_with_directives_js_1 = __webpack_require__(5471);
function buildFixedSchema(schema, options) {
    const document = (0, print_schema_with_directives_js_1.getDocumentNodeFromSchema)(schema);
    return (0, graphql_1.buildASTSchema)(document, {
        ...options || {}
    });
}
function fixSchemaAst(schema, options) {
    // eslint-disable-next-line no-undef-init
    let schemaWithValidAst = undefined;
    if (!schema.astNode || !schema.extensionASTNodes) {
        schemaWithValidAst = buildFixedSchema(schema, options);
    }
    if (!schema.astNode && (schemaWithValidAst === null || schemaWithValidAst === void 0 ? void 0 : schemaWithValidAst.astNode)) {
        schema.astNode = schemaWithValidAst.astNode;
    }
    if (!schema.extensionASTNodes && (schemaWithValidAst === null || schemaWithValidAst === void 0 ? void 0 : schemaWithValidAst.astNode)) {
        schema.extensionASTNodes = schemaWithValidAst.extensionASTNodes;
    }
    return schema;
}
exports.fixSchemaAst = fixSchemaAst;


/***/ }),

/***/ 1040:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.forEachDefaultValue = void 0;
const graphql_1 = __webpack_require__(5736);
function forEachDefaultValue(schema, fn) {
    const typeMap = schema.getTypeMap();
    for(const typeName in typeMap){
        const type = typeMap[typeName];
        if (!(0, graphql_1.getNamedType)(type).name.startsWith("__")) {
            if ((0, graphql_1.isObjectType)(type)) {
                const fields = type.getFields();
                for(const fieldName in fields){
                    const field = fields[fieldName];
                    for (const arg of field.args){
                        arg.defaultValue = fn(arg.type, arg.defaultValue);
                    }
                }
            } else if ((0, graphql_1.isInputObjectType)(type)) {
                const fields = type.getFields();
                for(const fieldName in fields){
                    const field = fields[fieldName];
                    field.defaultValue = fn(field.type, field.defaultValue);
                }
            }
        }
    }
}
exports.forEachDefaultValue = forEachDefaultValue;


/***/ }),

/***/ 7534:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.forEachField = void 0;
const graphql_1 = __webpack_require__(5736);
function forEachField(schema, fn) {
    const typeMap = schema.getTypeMap();
    for(const typeName in typeMap){
        const type = typeMap[typeName];
        // TODO: maybe have an option to include these?
        if (!(0, graphql_1.getNamedType)(type).name.startsWith("__") && (0, graphql_1.isObjectType)(type)) {
            const fields = type.getFields();
            for(const fieldName in fields){
                const field = fields[fieldName];
                fn(field, typeName, fieldName);
            }
        }
    }
}
exports.forEachField = forEachField;


/***/ }),

/***/ 8815:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getArgumentsWithDirectives = void 0;
const graphql_1 = __webpack_require__(5736);
function isTypeWithFields(t) {
    return t.kind === graphql_1.Kind.OBJECT_TYPE_DEFINITION || t.kind === graphql_1.Kind.OBJECT_TYPE_EXTENSION;
}
function getArgumentsWithDirectives(documentNode) {
    var _a;
    const result = {};
    const allTypes = documentNode.definitions.filter(isTypeWithFields);
    for (const type of allTypes){
        if (type.fields == null) {
            continue;
        }
        for (const field of type.fields){
            const argsWithDirectives = (_a = field.arguments) === null || _a === void 0 ? void 0 : _a.filter((arg)=>{
                var _a;
                return (_a = arg.directives) === null || _a === void 0 ? void 0 : _a.length;
            });
            if (!(argsWithDirectives === null || argsWithDirectives === void 0 ? void 0 : argsWithDirectives.length)) {
                continue;
            }
            const typeFieldResult = result[`${type.name.value}.${field.name.value}`] = {};
            for (const arg of argsWithDirectives){
                const directives = arg.directives.map((d)=>({
                        name: d.name.value,
                        args: (d.arguments || []).reduce((prev, dArg)=>({
                                ...prev,
                                [dArg.name.value]: (0, graphql_1.valueFromASTUntyped)(dArg.value)
                            }), {})
                    }));
                typeFieldResult[arg.name.value] = directives;
            }
        }
    }
    return result;
}
exports.getArgumentsWithDirectives = getArgumentsWithDirectives;


/***/ }),

/***/ 6103:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getDirective = exports.getDirectives = exports.getDirectiveInExtensions = exports.getDirectivesInExtensions = void 0;
const getArgumentValues_js_1 = __webpack_require__(4310);
function getDirectivesInExtensions(node, pathToDirectivesInExtensions = [
    "directives"
]) {
    return pathToDirectivesInExtensions.reduce((acc, pathSegment)=>acc == null ? acc : acc[pathSegment], node === null || node === void 0 ? void 0 : node.extensions);
}
exports.getDirectivesInExtensions = getDirectivesInExtensions;
function _getDirectiveInExtensions(directivesInExtensions, directiveName) {
    const directiveInExtensions = directivesInExtensions.filter((directiveAnnotation)=>directiveAnnotation.name === directiveName);
    if (!directiveInExtensions.length) {
        return undefined;
    }
    return directiveInExtensions.map((directive)=>{
        var _a;
        return (_a = directive.args) !== null && _a !== void 0 ? _a : {};
    });
}
function getDirectiveInExtensions(node, directiveName, pathToDirectivesInExtensions = [
    "directives"
]) {
    const directivesInExtensions = pathToDirectivesInExtensions.reduce((acc, pathSegment)=>acc == null ? acc : acc[pathSegment], node === null || node === void 0 ? void 0 : node.extensions);
    if (directivesInExtensions === undefined) {
        return undefined;
    }
    if (Array.isArray(directivesInExtensions)) {
        return _getDirectiveInExtensions(directivesInExtensions, directiveName);
    }
    // Support condensed format by converting to longer format
    // The condensed format does not preserve ordering of directives when  repeatable directives are used.
    // See https://github.com/ardatan/graphql-tools/issues/2534
    const reformattedDirectivesInExtensions = [];
    for (const [name, argsOrArrayOfArgs] of Object.entries(directivesInExtensions)){
        if (Array.isArray(argsOrArrayOfArgs)) {
            for (const args of argsOrArrayOfArgs){
                reformattedDirectivesInExtensions.push({
                    name,
                    args
                });
            }
        } else {
            reformattedDirectivesInExtensions.push({
                name,
                args: argsOrArrayOfArgs
            });
        }
    }
    return _getDirectiveInExtensions(reformattedDirectivesInExtensions, directiveName);
}
exports.getDirectiveInExtensions = getDirectiveInExtensions;
function getDirectives(schema, node, pathToDirectivesInExtensions = [
    "directives"
]) {
    const directivesInExtensions = getDirectivesInExtensions(node, pathToDirectivesInExtensions);
    if (directivesInExtensions != null && directivesInExtensions.length > 0) {
        return directivesInExtensions;
    }
    const schemaDirectives = schema && schema.getDirectives ? schema.getDirectives() : [];
    const schemaDirectiveMap = schemaDirectives.reduce((schemaDirectiveMap, schemaDirective)=>{
        schemaDirectiveMap[schemaDirective.name] = schemaDirective;
        return schemaDirectiveMap;
    }, {});
    let astNodes = [];
    if (node.astNode) {
        astNodes.push(node.astNode);
    }
    if ("extensionASTNodes" in node && node.extensionASTNodes) {
        astNodes = [
            ...astNodes,
            ...node.extensionASTNodes
        ];
    }
    const result = [];
    for (const astNode of astNodes){
        if (astNode.directives) {
            for (const directiveNode of astNode.directives){
                const schemaDirective = schemaDirectiveMap[directiveNode.name.value];
                if (schemaDirective) {
                    result.push({
                        name: directiveNode.name.value,
                        args: (0, getArgumentValues_js_1.getArgumentValues)(schemaDirective, directiveNode)
                    });
                }
            }
        }
    }
    return result;
}
exports.getDirectives = getDirectives;
function getDirective(schema, node, directiveName, pathToDirectivesInExtensions = [
    "directives"
]) {
    const directiveInExtensions = getDirectiveInExtensions(node, directiveName, pathToDirectivesInExtensions);
    if (directiveInExtensions != null) {
        return directiveInExtensions;
    }
    const schemaDirective = schema && schema.getDirective ? schema.getDirective(directiveName) : undefined;
    if (schemaDirective == null) {
        return undefined;
    }
    let astNodes = [];
    if (node.astNode) {
        astNodes.push(node.astNode);
    }
    if ("extensionASTNodes" in node && node.extensionASTNodes) {
        astNodes = [
            ...astNodes,
            ...node.extensionASTNodes
        ];
    }
    const result = [];
    for (const astNode of astNodes){
        if (astNode.directives) {
            for (const directiveNode of astNode.directives){
                if (directiveNode.name.value === directiveName) {
                    result.push((0, getArgumentValues_js_1.getArgumentValues)(schemaDirective, directiveNode));
                }
            }
        }
    }
    if (!result.length) {
        return undefined;
    }
    return result;
}
exports.getDirective = getDirective;


/***/ }),

/***/ 2047:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getFieldsWithDirectives = void 0;
const graphql_1 = __webpack_require__(5736);
function getFieldsWithDirectives(documentNode, options = {}) {
    const result = {};
    let selected = [
        "ObjectTypeDefinition",
        "ObjectTypeExtension"
    ];
    if (options.includeInputTypes) {
        selected = [
            ...selected,
            "InputObjectTypeDefinition",
            "InputObjectTypeExtension"
        ];
    }
    const allTypes = documentNode.definitions.filter((obj)=>selected.includes(obj.kind));
    for (const type of allTypes){
        const typeName = type.name.value;
        if (type.fields == null) {
            continue;
        }
        for (const field of type.fields){
            if (field.directives && field.directives.length > 0) {
                const fieldName = field.name.value;
                const key = `${typeName}.${fieldName}`;
                const directives = field.directives.map((d)=>({
                        name: d.name.value,
                        args: (d.arguments || []).reduce((prev, arg)=>({
                                ...prev,
                                [arg.name.value]: (0, graphql_1.valueFromASTUntyped)(arg.value)
                            }), {})
                    }));
                result[key] = directives;
            }
        }
    }
    return result;
}
exports.getFieldsWithDirectives = getFieldsWithDirectives;


/***/ }),

/***/ 1730:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getImplementingTypes = void 0;
const graphql_1 = __webpack_require__(5736);
function getImplementingTypes(interfaceName, schema) {
    const allTypesMap = schema.getTypeMap();
    const result = [];
    for(const graphqlTypeName in allTypesMap){
        const graphqlType = allTypesMap[graphqlTypeName];
        if ((0, graphql_1.isObjectType)(graphqlType)) {
            const allInterfaces = graphqlType.getInterfaces();
            if (allInterfaces.find((int)=>int.name === interfaceName)) {
                result.push(graphqlType.name);
            }
        }
    }
    return result;
}
exports.getImplementingTypes = getImplementingTypes;


/***/ }),

/***/ 4310:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getArgumentValues = void 0;
const jsutils_js_1 = __webpack_require__(545);
const graphql_1 = __webpack_require__(5736);
const errors_js_1 = __webpack_require__(2422);
const inspect_js_1 = __webpack_require__(3261);
/**
 * Prepares an object map of argument values given a list of argument
 * definitions and list of argument AST nodes.
 *
 * Note: The returned value is a plain Object with a prototype, since it is
 * exposed to user code. Care should be taken to not pull values from the
 * Object prototype.
 */ function getArgumentValues(def, node, variableValues = {}) {
    var _a;
    const coercedValues = {};
    const argumentNodes = (_a = node.arguments) !== null && _a !== void 0 ? _a : [];
    const argNodeMap = argumentNodes.reduce((prev, arg)=>({
            ...prev,
            [arg.name.value]: arg
        }), {});
    for (const { name , type: argType , defaultValue  } of def.args){
        const argumentNode = argNodeMap[name];
        if (!argumentNode) {
            if (defaultValue !== undefined) {
                coercedValues[name] = defaultValue;
            } else if ((0, graphql_1.isNonNullType)(argType)) {
                throw (0, errors_js_1.createGraphQLError)(`Argument "${name}" of required type "${(0, inspect_js_1.inspect)(argType)}" ` + "was not provided.", {
                    nodes: [
                        node
                    ]
                });
            }
            continue;
        }
        const valueNode = argumentNode.value;
        let isNull = valueNode.kind === graphql_1.Kind.NULL;
        if (valueNode.kind === graphql_1.Kind.VARIABLE) {
            const variableName = valueNode.name.value;
            if (variableValues == null || !(0, jsutils_js_1.hasOwnProperty)(variableValues, variableName)) {
                if (defaultValue !== undefined) {
                    coercedValues[name] = defaultValue;
                } else if ((0, graphql_1.isNonNullType)(argType)) {
                    throw (0, errors_js_1.createGraphQLError)(`Argument "${name}" of required type "${(0, inspect_js_1.inspect)(argType)}" ` + `was provided the variable "$${variableName}" which was not provided a runtime value.`, {
                        nodes: [
                            valueNode
                        ]
                    });
                }
                continue;
            }
            isNull = variableValues[variableName] == null;
        }
        if (isNull && (0, graphql_1.isNonNullType)(argType)) {
            throw (0, errors_js_1.createGraphQLError)(`Argument "${name}" of non-null type "${(0, inspect_js_1.inspect)(argType)}" ` + "must not be null.", {
                nodes: [
                    valueNode
                ]
            });
        }
        const coercedValue = (0, graphql_1.valueFromAST)(valueNode, argType, variableValues);
        if (coercedValue === undefined) {
            // Note: ValuesOfCorrectTypeRule validation should catch this before
            // execution. This is a runtime check to ensure execution does not
            // continue with an invalid argument value.
            throw (0, errors_js_1.createGraphQLError)(`Argument "${name}" has invalid value ${(0, graphql_1.print)(valueNode)}.`, {
                nodes: [
                    valueNode
                ]
            });
        }
        coercedValues[name] = coercedValue;
    }
    return coercedValues;
}
exports.getArgumentValues = getArgumentValues;


/***/ }),

/***/ 3359:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getObjectTypeFromTypeMap = void 0;
const graphql_1 = __webpack_require__(5736);
function getObjectTypeFromTypeMap(typeMap, type) {
    if (type) {
        const maybeObjectType = typeMap[type.name];
        if ((0, graphql_1.isObjectType)(maybeObjectType)) {
            return maybeObjectType;
        }
    }
}
exports.getObjectTypeFromTypeMap = getObjectTypeFromTypeMap;


/***/ }),

/***/ 2325:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getOperationASTFromRequest = exports.getOperationASTFromDocument = void 0;
const graphql_1 = __webpack_require__(5736);
const memoize_js_1 = __webpack_require__(9787);
function getOperationASTFromDocument(documentNode, operationName) {
    const doc = (0, graphql_1.getOperationAST)(documentNode, operationName);
    if (!doc) {
        throw new Error(`Cannot infer operation ${operationName || ""}`);
    }
    return doc;
}
exports.getOperationASTFromDocument = getOperationASTFromDocument;
exports.getOperationASTFromRequest = (0, memoize_js_1.memoize1)(function getOperationASTFromRequest(request) {
    return getOperationASTFromDocument(request.document, request.operationName);
});


/***/ }),

/***/ 5433:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getResolversFromSchema = void 0;
const graphql_1 = __webpack_require__(5736);
function getResolversFromSchema(schema, // Include default merged resolvers
includeDefaultMergedResolver) {
    var _a, _b;
    const resolvers = Object.create(null);
    const typeMap = schema.getTypeMap();
    for(const typeName in typeMap){
        if (!typeName.startsWith("__")) {
            const type = typeMap[typeName];
            if ((0, graphql_1.isScalarType)(type)) {
                if (!(0, graphql_1.isSpecifiedScalarType)(type)) {
                    const config = type.toConfig();
                    delete config.astNode; // avoid AST duplication elsewhere
                    resolvers[typeName] = new graphql_1.GraphQLScalarType(config);
                }
            } else if ((0, graphql_1.isEnumType)(type)) {
                resolvers[typeName] = {};
                const values = type.getValues();
                for (const value of values){
                    resolvers[typeName][value.name] = value.value;
                }
            } else if ((0, graphql_1.isInterfaceType)(type)) {
                if (type.resolveType != null) {
                    resolvers[typeName] = {
                        __resolveType: type.resolveType
                    };
                }
            } else if ((0, graphql_1.isUnionType)(type)) {
                if (type.resolveType != null) {
                    resolvers[typeName] = {
                        __resolveType: type.resolveType
                    };
                }
            } else if ((0, graphql_1.isObjectType)(type)) {
                resolvers[typeName] = {};
                if (type.isTypeOf != null) {
                    resolvers[typeName].__isTypeOf = type.isTypeOf;
                }
                const fields = type.getFields();
                for(const fieldName in fields){
                    const field = fields[fieldName];
                    if (field.subscribe != null) {
                        resolvers[typeName][fieldName] = resolvers[typeName][fieldName] || {};
                        resolvers[typeName][fieldName].subscribe = field.subscribe;
                    }
                    if (field.resolve != null && ((_a = field.resolve) === null || _a === void 0 ? void 0 : _a.name) !== "defaultFieldResolver") {
                        switch((_b = field.resolve) === null || _b === void 0 ? void 0 : _b.name){
                            case "defaultMergedResolver":
                                if (!includeDefaultMergedResolver) {
                                    continue;
                                }
                                break;
                            case "defaultFieldResolver":
                                continue;
                        }
                        resolvers[typeName][fieldName] = resolvers[typeName][fieldName] || {};
                        resolvers[typeName][fieldName].resolve = field.resolve;
                    }
                }
            }
        }
    }
    return resolvers;
}
exports.getResolversFromSchema = getResolversFromSchema;


/***/ }),

/***/ 7265:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getResponseKeyFromInfo = void 0;
/**
 * Get the key under which the result of this resolver will be placed in the response JSON. Basically, just
 * resolves aliases.
 * @param info The info argument to the resolver.
 */ function getResponseKeyFromInfo(info) {
    return info.fieldNodes[0].alias != null ? info.fieldNodes[0].alias.value : info.fieldName;
}
exports.getResponseKeyFromInfo = getResponseKeyFromInfo;


/***/ }),

/***/ 1218:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.healTypes = exports.healSchema = void 0;
const graphql_1 = __webpack_require__(5736);
// Update any references to named schema types that disagree with the named
// types found in schema.getTypeMap().
//
// healSchema and its callers (visitSchema/visitSchemaDirectives) all modify the schema in place.
// Therefore, private variables (such as the stored implementation map and the proper root types)
// are not updated.
//
// If this causes issues, the schema could be more aggressively healed as follows:
//
// healSchema(schema);
// const config = schema.toConfig()
// const healedSchema = new GraphQLSchema({
//   ...config,
//   query: schema.getType('<desired new root query type name>'),
//   mutation: schema.getType('<desired new root mutation type name>'),
//   subscription: schema.getType('<desired new root subscription type name>'),
// });
//
// One can then also -- if necessary --  assign the correct private variables to the initial schema
// as follows:
// Object.assign(schema, healedSchema);
//
// These steps are not taken automatically to preserve backwards compatibility with graphql-tools v4.
// See https://github.com/ardatan/graphql-tools/issues/1462
//
// They were briefly taken in v5, but can now be phased out as they were only required when other
// areas of the codebase were using healSchema and visitSchema more extensively.
//
function healSchema(schema) {
    healTypes(schema.getTypeMap(), schema.getDirectives());
    return schema;
}
exports.healSchema = healSchema;
function healTypes(originalTypeMap, directives) {
    const actualNamedTypeMap = Object.create(null);
    // If any of the .name properties of the GraphQLNamedType objects in
    // schema.getTypeMap() have changed, the keys of the type map need to
    // be updated accordingly.
    for(const typeName in originalTypeMap){
        const namedType = originalTypeMap[typeName];
        if (namedType == null || typeName.startsWith("__")) {
            continue;
        }
        const actualName = namedType.name;
        if (actualName.startsWith("__")) {
            continue;
        }
        if (actualNamedTypeMap[actualName] != null) {
            console.warn(`Duplicate schema type name ${actualName} found; keeping the existing one found in the schema`);
            continue;
        }
        actualNamedTypeMap[actualName] = namedType;
    // Note: we are deliberately leaving namedType in the schema by its
    // original name (which might be different from actualName), so that
    // references by that name can be healed.
    }
    // Now add back every named type by its actual name.
    for(const typeName in actualNamedTypeMap){
        const namedType = actualNamedTypeMap[typeName];
        originalTypeMap[typeName] = namedType;
    }
    // Directive declaration argument types can refer to named types.
    for (const decl of directives){
        decl.args = decl.args.filter((arg)=>{
            arg.type = healType(arg.type);
            return arg.type !== null;
        });
    }
    for(const typeName in originalTypeMap){
        const namedType = originalTypeMap[typeName];
        // Heal all named types, except for dangling references, kept only to redirect.
        if (!typeName.startsWith("__") && typeName in actualNamedTypeMap) {
            if (namedType != null) {
                healNamedType(namedType);
            }
        }
    }
    for(const typeName in originalTypeMap){
        if (!typeName.startsWith("__") && !(typeName in actualNamedTypeMap)) {
            delete originalTypeMap[typeName];
        }
    }
    function healNamedType(type) {
        if ((0, graphql_1.isObjectType)(type)) {
            healFields(type);
            healInterfaces(type);
            return;
        } else if ((0, graphql_1.isInterfaceType)(type)) {
            healFields(type);
            if ("getInterfaces" in type) {
                healInterfaces(type);
            }
            return;
        } else if ((0, graphql_1.isUnionType)(type)) {
            healUnderlyingTypes(type);
            return;
        } else if ((0, graphql_1.isInputObjectType)(type)) {
            healInputFields(type);
            return;
        } else if ((0, graphql_1.isLeafType)(type)) {
            return;
        }
        throw new Error(`Unexpected schema type: ${type}`);
    }
    function healFields(type) {
        const fieldMap = type.getFields();
        for (const [key, field] of Object.entries(fieldMap)){
            field.args.map((arg)=>{
                arg.type = healType(arg.type);
                return arg.type === null ? null : arg;
            }).filter(Boolean);
            field.type = healType(field.type);
            if (field.type === null) {
                delete fieldMap[key];
            }
        }
    }
    function healInterfaces(type) {
        if ("getInterfaces" in type) {
            const interfaces = type.getInterfaces();
            interfaces.push(...interfaces.splice(0).map((iface)=>healType(iface)).filter(Boolean));
        }
    }
    function healInputFields(type) {
        const fieldMap = type.getFields();
        for (const [key, field] of Object.entries(fieldMap)){
            field.type = healType(field.type);
            if (field.type === null) {
                delete fieldMap[key];
            }
        }
    }
    function healUnderlyingTypes(type) {
        const types = type.getTypes();
        types.push(...types.splice(0).map((t)=>healType(t)).filter(Boolean));
    }
    function healType(type) {
        // Unwrap the two known wrapper types
        if ((0, graphql_1.isListType)(type)) {
            const healedType = healType(type.ofType);
            return healedType != null ? new graphql_1.GraphQLList(healedType) : null;
        } else if ((0, graphql_1.isNonNullType)(type)) {
            const healedType = healType(type.ofType);
            return healedType != null ? new graphql_1.GraphQLNonNull(healedType) : null;
        } else if ((0, graphql_1.isNamedType)(type)) {
            // If a type annotation on a field or an argument or a union member is
            // any `GraphQLNamedType` with a `name`, then it must end up identical
            // to `schema.getType(name)`, since `schema.getTypeMap()` is the source
            // of truth for all named schema types.
            // Note that new types can still be simply added by adding a field, as
            // the official type will be undefined, not null.
            const officialType = originalTypeMap[type.name];
            if (officialType && type !== officialType) {
                return officialType;
            }
        }
        return type;
    }
}
exports.healTypes = healTypes;


/***/ }),

/***/ 5551:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.assertSome = exports.isSome = exports.compareNodes = exports.nodeToString = exports.compareStrings = exports.isValidPath = exports.isDocumentString = exports.asArray = void 0;
const graphql_1 = __webpack_require__(5736);
const asArray = (fns)=>Array.isArray(fns) ? fns : fns ? [
        fns
    ] : [];
exports.asArray = asArray;
const invalidDocRegex = /\.[a-z0-9]+$/i;
function isDocumentString(str) {
    if (typeof str !== "string") {
        return false;
    }
    // XXX: is-valid-path or is-glob treat SDL as a valid path
    // (`scalar Date` for example)
    // this why checking the extension is fast enough
    // and prevent from parsing the string in order to find out
    // if the string is a SDL
    if (invalidDocRegex.test(str)) {
        return false;
    }
    try {
        (0, graphql_1.parse)(str);
        return true;
    } catch (e) {}
    return false;
}
exports.isDocumentString = isDocumentString;
const invalidPathRegex = /[!%^<=>`]/;
function isValidPath(str) {
    return typeof str === "string" && !invalidPathRegex.test(str);
}
exports.isValidPath = isValidPath;
function compareStrings(a, b) {
    if (String(a) < String(b)) {
        return -1;
    }
    if (String(a) > String(b)) {
        return 1;
    }
    return 0;
}
exports.compareStrings = compareStrings;
function nodeToString(a) {
    var _a, _b;
    let name;
    if ("alias" in a) {
        name = (_a = a.alias) === null || _a === void 0 ? void 0 : _a.value;
    }
    if (name == null && "name" in a) {
        name = (_b = a.name) === null || _b === void 0 ? void 0 : _b.value;
    }
    if (name == null) {
        name = a.kind;
    }
    return name;
}
exports.nodeToString = nodeToString;
function compareNodes(a, b, customFn) {
    const aStr = nodeToString(a);
    const bStr = nodeToString(b);
    if (typeof customFn === "function") {
        return customFn(aStr, bStr);
    }
    return compareStrings(aStr, bStr);
}
exports.compareNodes = compareNodes;
function isSome(input) {
    return input != null;
}
exports.isSome = isSome;
function assertSome(input, message = "Value should be something") {
    if (input == null) {
        throw new Error(message);
    }
}
exports.assertSome = assertSome;


/***/ }),

/***/ 3982:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.implementsAbstractType = void 0;
const graphql_1 = __webpack_require__(5736);
function implementsAbstractType(schema, typeA, typeB) {
    if (typeB == null || typeA == null) {
        return false;
    } else if (typeA === typeB) {
        return true;
    } else if ((0, graphql_1.isCompositeType)(typeA) && (0, graphql_1.isCompositeType)(typeB)) {
        return (0, graphql_1.doTypesOverlap)(schema, typeA, typeB);
    }
    return false;
}
exports.implementsAbstractType = implementsAbstractType;


/***/ }),

/***/ 6887:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(4479);
tslib_1.__exportStar(__webpack_require__(6871), exports);
tslib_1.__exportStar(__webpack_require__(5551), exports);
tslib_1.__exportStar(__webpack_require__(6103), exports);
tslib_1.__exportStar(__webpack_require__(2047), exports);
tslib_1.__exportStar(__webpack_require__(8815), exports);
tslib_1.__exportStar(__webpack_require__(1730), exports);
tslib_1.__exportStar(__webpack_require__(5471), exports);
tslib_1.__exportStar(__webpack_require__(2047), exports);
tslib_1.__exportStar(__webpack_require__(520), exports);
tslib_1.__exportStar(__webpack_require__(2016), exports);
tslib_1.__exportStar(__webpack_require__(5431), exports);
tslib_1.__exportStar(__webpack_require__(5662), exports);
tslib_1.__exportStar(__webpack_require__(2349), exports);
tslib_1.__exportStar(__webpack_require__(5857), exports);
tslib_1.__exportStar(__webpack_require__(1218), exports);
tslib_1.__exportStar(__webpack_require__(5433), exports);
tslib_1.__exportStar(__webpack_require__(7534), exports);
tslib_1.__exportStar(__webpack_require__(1040), exports);
tslib_1.__exportStar(__webpack_require__(1061), exports);
tslib_1.__exportStar(__webpack_require__(1561), exports);
tslib_1.__exportStar(__webpack_require__(1125), exports);
tslib_1.__exportStar(__webpack_require__(9654), exports);
tslib_1.__exportStar(__webpack_require__(6646), exports);
tslib_1.__exportStar(__webpack_require__(8395), exports);
tslib_1.__exportStar(__webpack_require__(2090), exports);
tslib_1.__exportStar(__webpack_require__(9687), exports);
tslib_1.__exportStar(__webpack_require__(7265), exports);
tslib_1.__exportStar(__webpack_require__(7841), exports);
tslib_1.__exportStar(__webpack_require__(6068), exports);
tslib_1.__exportStar(__webpack_require__(1843), exports);
tslib_1.__exportStar(__webpack_require__(6217), exports);
tslib_1.__exportStar(__webpack_require__(2630), exports);
tslib_1.__exportStar(__webpack_require__(3982), exports);
tslib_1.__exportStar(__webpack_require__(2422), exports);
tslib_1.__exportStar(__webpack_require__(8698), exports);
tslib_1.__exportStar(__webpack_require__(3063), exports);
tslib_1.__exportStar(__webpack_require__(4310), exports);
tslib_1.__exportStar(__webpack_require__(7284), exports);
tslib_1.__exportStar(__webpack_require__(6553), exports);
tslib_1.__exportStar(__webpack_require__(7634), exports);
tslib_1.__exportStar(__webpack_require__(4768), exports);
tslib_1.__exportStar(__webpack_require__(9573), exports);
tslib_1.__exportStar(__webpack_require__(4626), exports);
tslib_1.__exportStar(__webpack_require__(3127), exports);
tslib_1.__exportStar(__webpack_require__(7839), exports);
tslib_1.__exportStar(__webpack_require__(8950), exports);
tslib_1.__exportStar(__webpack_require__(1036), exports);
tslib_1.__exportStar(__webpack_require__(3261), exports);
tslib_1.__exportStar(__webpack_require__(9787), exports);
tslib_1.__exportStar(__webpack_require__(8134), exports);
tslib_1.__exportStar(__webpack_require__(2325), exports);
tslib_1.__exportStar(__webpack_require__(4212), exports);
tslib_1.__exportStar(__webpack_require__(2941), exports);
tslib_1.__exportStar(__webpack_require__(545), exports);
tslib_1.__exportStar(__webpack_require__(4253), exports);


/***/ }),

/***/ 3261:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Taken from graphql-js
// https://github.com/graphql/graphql-js/blob/main/src/jsutils/inspect.ts
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.inspect = void 0;
const graphql_1 = __webpack_require__(5736);
const AggregateError_js_1 = __webpack_require__(3127);
const MAX_RECURSIVE_DEPTH = 3;
/**
 * Used to print values in error messages.
 */ function inspect(value) {
    return formatValue(value, []);
}
exports.inspect = inspect;
function formatValue(value, seenValues) {
    switch(typeof value){
        case "string":
            return JSON.stringify(value);
        case "function":
            return value.name ? `[function ${value.name}]` : "[function]";
        case "object":
            return formatObjectValue(value, seenValues);
        default:
            return String(value);
    }
}
function formatError(value) {
    if (value instanceof graphql_1.GraphQLError) {
        return value.toString();
    }
    return `${value.name}: ${value.message};\n ${value.stack}`;
}
function formatObjectValue(value, previouslySeenValues) {
    if (value === null) {
        return "null";
    }
    if (value instanceof Error) {
        if ((0, AggregateError_js_1.isAggregateError)(value)) {
            return formatError(value) + "\n" + formatArray(value.errors, previouslySeenValues);
        }
        return formatError(value);
    }
    if (previouslySeenValues.includes(value)) {
        return "[Circular]";
    }
    const seenValues = [
        ...previouslySeenValues,
        value
    ];
    if (isJSONable(value)) {
        const jsonValue = value.toJSON();
        // check for infinite recursion
        if (jsonValue !== value) {
            return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
        }
    } else if (Array.isArray(value)) {
        return formatArray(value, seenValues);
    }
    return formatObject(value, seenValues);
}
function isJSONable(value) {
    return typeof value.toJSON === "function";
}
function formatObject(object, seenValues) {
    const entries = Object.entries(object);
    if (entries.length === 0) {
        return "{}";
    }
    if (seenValues.length > MAX_RECURSIVE_DEPTH) {
        return "[" + getObjectTag(object) + "]";
    }
    const properties = entries.map(([key, value])=>key + ": " + formatValue(value, seenValues));
    return "{ " + properties.join(", ") + " }";
}
function formatArray(array, seenValues) {
    if (array.length === 0) {
        return "[]";
    }
    if (seenValues.length > MAX_RECURSIVE_DEPTH) {
        return "[Array]";
    }
    const len = array.length;
    const items = [];
    for(let i = 0; i < len; ++i){
        items.push(formatValue(array[i], seenValues));
    }
    return "[" + items.join(", ") + "]";
}
function getObjectTag(object) {
    const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
    if (tag === "Object" && typeof object.constructor === "function") {
        const name = object.constructor.name;
        if (typeof name === "string" && name !== "") {
            return name;
        }
    }
    return tag;
}


/***/ }),

/***/ 6553:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.isAsyncIterable = void 0;
function isAsyncIterable(value) {
    return typeof value === "object" && value != null && Symbol.asyncIterator in value && typeof value[Symbol.asyncIterator] === "function";
}
exports.isAsyncIterable = isAsyncIterable;


/***/ }),

/***/ 7634:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.isDocumentNode = void 0;
const graphql_1 = __webpack_require__(5736);
function isDocumentNode(object) {
    return object && typeof object === "object" && "kind" in object && object.kind === graphql_1.Kind.DOCUMENT;
}
exports.isDocumentNode = isDocumentNode;


/***/ }),

/***/ 545:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.hasOwnProperty = exports.promiseReduce = exports.isPromise = exports.isObjectLike = exports.isIterableObject = void 0;
function isIterableObject(value) {
    return value != null && typeof value === "object" && Symbol.iterator in value;
}
exports.isIterableObject = isIterableObject;
function isObjectLike(value) {
    return typeof value === "object" && value !== null;
}
exports.isObjectLike = isObjectLike;
function isPromise(value) {
    return isObjectLike(value) && typeof value["then"] === "function";
}
exports.isPromise = isPromise;
function promiseReduce(values, callbackFn, initialValue) {
    let accumulator = initialValue;
    for (const value of values){
        accumulator = isPromise(accumulator) ? accumulator.then((resolved)=>callbackFn(resolved, value)) : callbackFn(accumulator, value);
    }
    return accumulator;
}
exports.promiseReduce = promiseReduce;
function hasOwnProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
}
exports.hasOwnProperty = hasOwnProperty;


/***/ }),

/***/ 6871:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 6217:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.mapAsyncIterator = void 0;
/**
 * Given an AsyncIterable and a callback function, return an AsyncIterator
 * which produces values mapped via calling the callback function.
 */ function mapAsyncIterator(iterator, callback, rejectCallback) {
    let $return;
    let abruptClose;
    if (typeof iterator.return === "function") {
        $return = iterator.return;
        abruptClose = (error)=>{
            const rethrow = ()=>Promise.reject(error);
            return $return.call(iterator).then(rethrow, rethrow);
        };
    }
    function mapResult(result) {
        return result.done ? result : asyncMapValue(result.value, callback).then(iteratorResult, abruptClose);
    }
    let mapReject;
    if (rejectCallback) {
        // Capture rejectCallback to ensure it cannot be null.
        const reject = rejectCallback;
        mapReject = (error)=>asyncMapValue(error, reject).then(iteratorResult, abruptClose);
    }
    return {
        next () {
            return iterator.next().then(mapResult, mapReject);
        },
        return () {
            return $return ? $return.call(iterator).then(mapResult, mapReject) : Promise.resolve({
                value: undefined,
                done: true
            });
        },
        throw (error) {
            if (typeof iterator.throw === "function") {
                return iterator.throw(error).then(mapResult, mapReject);
            }
            return Promise.reject(error).catch(abruptClose);
        },
        [Symbol.asyncIterator] () {
            return this;
        }
    };
}
exports.mapAsyncIterator = mapAsyncIterator;
function asyncMapValue(value, callback) {
    return new Promise((resolve)=>resolve(callback(value)));
}
function iteratorResult(value) {
    return {
        value,
        done: false
    };
}


/***/ }),

/***/ 1061:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.correctASTNodes = exports.mapSchema = void 0;
const graphql_1 = __webpack_require__(5736);
const getObjectTypeFromTypeMap_js_1 = __webpack_require__(3359);
const Interfaces_js_1 = __webpack_require__(8395);
const rewire_js_1 = __webpack_require__(1125);
const transformInputValue_js_1 = __webpack_require__(1843);
function mapSchema(schema, schemaMapper = {}) {
    const newTypeMap = mapArguments(mapFields(mapTypes(mapDefaultValues(mapEnumValues(mapTypes(mapDefaultValues(schema.getTypeMap(), schema, transformInputValue_js_1.serializeInputValue), schema, schemaMapper, (type)=>(0, graphql_1.isLeafType)(type)), schema, schemaMapper), schema, transformInputValue_js_1.parseInputValue), schema, schemaMapper, (type)=>!(0, graphql_1.isLeafType)(type)), schema, schemaMapper), schema, schemaMapper);
    const originalDirectives = schema.getDirectives();
    const newDirectives = mapDirectives(originalDirectives, schema, schemaMapper);
    const { typeMap , directives  } = (0, rewire_js_1.rewireTypes)(newTypeMap, newDirectives);
    return new graphql_1.GraphQLSchema({
        ...schema.toConfig(),
        query: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(newTypeMap, schema.getQueryType())),
        mutation: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(newTypeMap, schema.getMutationType())),
        subscription: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(newTypeMap, schema.getSubscriptionType())),
        types: Object.values(typeMap),
        directives
    });
}
exports.mapSchema = mapSchema;
function mapTypes(originalTypeMap, schema, schemaMapper, testFn = ()=>true) {
    const newTypeMap = {};
    for(const typeName in originalTypeMap){
        if (!typeName.startsWith("__")) {
            const originalType = originalTypeMap[typeName];
            if (originalType == null || !testFn(originalType)) {
                newTypeMap[typeName] = originalType;
                continue;
            }
            const typeMapper = getTypeMapper(schema, schemaMapper, typeName);
            if (typeMapper == null) {
                newTypeMap[typeName] = originalType;
                continue;
            }
            const maybeNewType = typeMapper(originalType, schema);
            if (maybeNewType === undefined) {
                newTypeMap[typeName] = originalType;
                continue;
            }
            newTypeMap[typeName] = maybeNewType;
        }
    }
    return newTypeMap;
}
function mapEnumValues(originalTypeMap, schema, schemaMapper) {
    const enumValueMapper = getEnumValueMapper(schemaMapper);
    if (!enumValueMapper) {
        return originalTypeMap;
    }
    return mapTypes(originalTypeMap, schema, {
        [Interfaces_js_1.MapperKind.ENUM_TYPE]: (type)=>{
            const config = type.toConfig();
            const originalEnumValueConfigMap = config.values;
            const newEnumValueConfigMap = {};
            for(const externalValue in originalEnumValueConfigMap){
                const originalEnumValueConfig = originalEnumValueConfigMap[externalValue];
                const mappedEnumValue = enumValueMapper(originalEnumValueConfig, type.name, schema, externalValue);
                if (mappedEnumValue === undefined) {
                    newEnumValueConfigMap[externalValue] = originalEnumValueConfig;
                } else if (Array.isArray(mappedEnumValue)) {
                    const [newExternalValue, newEnumValueConfig] = mappedEnumValue;
                    newEnumValueConfigMap[newExternalValue] = newEnumValueConfig === undefined ? originalEnumValueConfig : newEnumValueConfig;
                } else if (mappedEnumValue !== null) {
                    newEnumValueConfigMap[externalValue] = mappedEnumValue;
                }
            }
            return correctASTNodes(new graphql_1.GraphQLEnumType({
                ...config,
                values: newEnumValueConfigMap
            }));
        }
    }, (type)=>(0, graphql_1.isEnumType)(type));
}
function mapDefaultValues(originalTypeMap, schema, fn) {
    const newTypeMap = mapArguments(originalTypeMap, schema, {
        [Interfaces_js_1.MapperKind.ARGUMENT]: (argumentConfig)=>{
            if (argumentConfig.defaultValue === undefined) {
                return argumentConfig;
            }
            const maybeNewType = getNewType(originalTypeMap, argumentConfig.type);
            if (maybeNewType != null) {
                return {
                    ...argumentConfig,
                    defaultValue: fn(maybeNewType, argumentConfig.defaultValue)
                };
            }
        }
    });
    return mapFields(newTypeMap, schema, {
        [Interfaces_js_1.MapperKind.INPUT_OBJECT_FIELD]: (inputFieldConfig)=>{
            if (inputFieldConfig.defaultValue === undefined) {
                return inputFieldConfig;
            }
            const maybeNewType = getNewType(newTypeMap, inputFieldConfig.type);
            if (maybeNewType != null) {
                return {
                    ...inputFieldConfig,
                    defaultValue: fn(maybeNewType, inputFieldConfig.defaultValue)
                };
            }
        }
    });
}
function getNewType(newTypeMap, type) {
    if ((0, graphql_1.isListType)(type)) {
        const newType = getNewType(newTypeMap, type.ofType);
        return newType != null ? new graphql_1.GraphQLList(newType) : null;
    } else if ((0, graphql_1.isNonNullType)(type)) {
        const newType = getNewType(newTypeMap, type.ofType);
        return newType != null ? new graphql_1.GraphQLNonNull(newType) : null;
    } else if ((0, graphql_1.isNamedType)(type)) {
        const newType = newTypeMap[type.name];
        return newType != null ? newType : null;
    }
    return null;
}
function mapFields(originalTypeMap, schema, schemaMapper) {
    const newTypeMap = {};
    for(const typeName in originalTypeMap){
        if (!typeName.startsWith("__")) {
            const originalType = originalTypeMap[typeName];
            if (!(0, graphql_1.isObjectType)(originalType) && !(0, graphql_1.isInterfaceType)(originalType) && !(0, graphql_1.isInputObjectType)(originalType)) {
                newTypeMap[typeName] = originalType;
                continue;
            }
            const fieldMapper = getFieldMapper(schema, schemaMapper, typeName);
            if (fieldMapper == null) {
                newTypeMap[typeName] = originalType;
                continue;
            }
            const config = originalType.toConfig();
            const originalFieldConfigMap = config.fields;
            const newFieldConfigMap = {};
            for(const fieldName in originalFieldConfigMap){
                const originalFieldConfig = originalFieldConfigMap[fieldName];
                const mappedField = fieldMapper(originalFieldConfig, fieldName, typeName, schema);
                if (mappedField === undefined) {
                    newFieldConfigMap[fieldName] = originalFieldConfig;
                } else if (Array.isArray(mappedField)) {
                    const [newFieldName, newFieldConfig] = mappedField;
                    if (newFieldConfig.astNode != null) {
                        newFieldConfig.astNode = {
                            ...newFieldConfig.astNode,
                            name: {
                                ...newFieldConfig.astNode.name,
                                value: newFieldName
                            }
                        };
                    }
                    newFieldConfigMap[newFieldName] = newFieldConfig === undefined ? originalFieldConfig : newFieldConfig;
                } else if (mappedField !== null) {
                    newFieldConfigMap[fieldName] = mappedField;
                }
            }
            if ((0, graphql_1.isObjectType)(originalType)) {
                newTypeMap[typeName] = correctASTNodes(new graphql_1.GraphQLObjectType({
                    ...config,
                    fields: newFieldConfigMap
                }));
            } else if ((0, graphql_1.isInterfaceType)(originalType)) {
                newTypeMap[typeName] = correctASTNodes(new graphql_1.GraphQLInterfaceType({
                    ...config,
                    fields: newFieldConfigMap
                }));
            } else {
                newTypeMap[typeName] = correctASTNodes(new graphql_1.GraphQLInputObjectType({
                    ...config,
                    fields: newFieldConfigMap
                }));
            }
        }
    }
    return newTypeMap;
}
function mapArguments(originalTypeMap, schema, schemaMapper) {
    const newTypeMap = {};
    for(const typeName in originalTypeMap){
        if (!typeName.startsWith("__")) {
            const originalType = originalTypeMap[typeName];
            if (!(0, graphql_1.isObjectType)(originalType) && !(0, graphql_1.isInterfaceType)(originalType)) {
                newTypeMap[typeName] = originalType;
                continue;
            }
            const argumentMapper = getArgumentMapper(schemaMapper);
            if (argumentMapper == null) {
                newTypeMap[typeName] = originalType;
                continue;
            }
            const config = originalType.toConfig();
            const originalFieldConfigMap = config.fields;
            const newFieldConfigMap = {};
            for(const fieldName in originalFieldConfigMap){
                const originalFieldConfig = originalFieldConfigMap[fieldName];
                const originalArgumentConfigMap = originalFieldConfig.args;
                if (originalArgumentConfigMap == null) {
                    newFieldConfigMap[fieldName] = originalFieldConfig;
                    continue;
                }
                const argumentNames = Object.keys(originalArgumentConfigMap);
                if (!argumentNames.length) {
                    newFieldConfigMap[fieldName] = originalFieldConfig;
                    continue;
                }
                const newArgumentConfigMap = {};
                for (const argumentName of argumentNames){
                    const originalArgumentConfig = originalArgumentConfigMap[argumentName];
                    const mappedArgument = argumentMapper(originalArgumentConfig, fieldName, typeName, schema);
                    if (mappedArgument === undefined) {
                        newArgumentConfigMap[argumentName] = originalArgumentConfig;
                    } else if (Array.isArray(mappedArgument)) {
                        const [newArgumentName, newArgumentConfig] = mappedArgument;
                        newArgumentConfigMap[newArgumentName] = newArgumentConfig;
                    } else if (mappedArgument !== null) {
                        newArgumentConfigMap[argumentName] = mappedArgument;
                    }
                }
                newFieldConfigMap[fieldName] = {
                    ...originalFieldConfig,
                    args: newArgumentConfigMap
                };
            }
            if ((0, graphql_1.isObjectType)(originalType)) {
                newTypeMap[typeName] = new graphql_1.GraphQLObjectType({
                    ...config,
                    fields: newFieldConfigMap
                });
            } else if ((0, graphql_1.isInterfaceType)(originalType)) {
                newTypeMap[typeName] = new graphql_1.GraphQLInterfaceType({
                    ...config,
                    fields: newFieldConfigMap
                });
            } else {
                newTypeMap[typeName] = new graphql_1.GraphQLInputObjectType({
                    ...config,
                    fields: newFieldConfigMap
                });
            }
        }
    }
    return newTypeMap;
}
function mapDirectives(originalDirectives, schema, schemaMapper) {
    const directiveMapper = getDirectiveMapper(schemaMapper);
    if (directiveMapper == null) {
        return originalDirectives.slice();
    }
    const newDirectives = [];
    for (const directive of originalDirectives){
        const mappedDirective = directiveMapper(directive, schema);
        if (mappedDirective === undefined) {
            newDirectives.push(directive);
        } else if (mappedDirective !== null) {
            newDirectives.push(mappedDirective);
        }
    }
    return newDirectives;
}
function getTypeSpecifiers(schema, typeName) {
    var _a, _b, _c;
    const type = schema.getType(typeName);
    const specifiers = [
        Interfaces_js_1.MapperKind.TYPE
    ];
    if ((0, graphql_1.isObjectType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_TYPE, Interfaces_js_1.MapperKind.OBJECT_TYPE);
        if (typeName === ((_a = schema.getQueryType()) === null || _a === void 0 ? void 0 : _a.name)) {
            specifiers.push(Interfaces_js_1.MapperKind.ROOT_OBJECT, Interfaces_js_1.MapperKind.QUERY);
        } else if (typeName === ((_b = schema.getMutationType()) === null || _b === void 0 ? void 0 : _b.name)) {
            specifiers.push(Interfaces_js_1.MapperKind.ROOT_OBJECT, Interfaces_js_1.MapperKind.MUTATION);
        } else if (typeName === ((_c = schema.getSubscriptionType()) === null || _c === void 0 ? void 0 : _c.name)) {
            specifiers.push(Interfaces_js_1.MapperKind.ROOT_OBJECT, Interfaces_js_1.MapperKind.SUBSCRIPTION);
        }
    } else if ((0, graphql_1.isInputObjectType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.INPUT_OBJECT_TYPE);
    } else if ((0, graphql_1.isInterfaceType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_TYPE, Interfaces_js_1.MapperKind.ABSTRACT_TYPE, Interfaces_js_1.MapperKind.INTERFACE_TYPE);
    } else if ((0, graphql_1.isUnionType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_TYPE, Interfaces_js_1.MapperKind.ABSTRACT_TYPE, Interfaces_js_1.MapperKind.UNION_TYPE);
    } else if ((0, graphql_1.isEnumType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.ENUM_TYPE);
    } else if ((0, graphql_1.isScalarType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.SCALAR_TYPE);
    }
    return specifiers;
}
function getTypeMapper(schema, schemaMapper, typeName) {
    const specifiers = getTypeSpecifiers(schema, typeName);
    let typeMapper;
    const stack = [
        ...specifiers
    ];
    while(!typeMapper && stack.length > 0){
        // It is safe to use the ! operator here as we check the length.
        const next = stack.pop();
        typeMapper = schemaMapper[next];
    }
    return typeMapper != null ? typeMapper : null;
}
function getFieldSpecifiers(schema, typeName) {
    var _a, _b, _c;
    const type = schema.getType(typeName);
    const specifiers = [
        Interfaces_js_1.MapperKind.FIELD
    ];
    if ((0, graphql_1.isObjectType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_FIELD, Interfaces_js_1.MapperKind.OBJECT_FIELD);
        if (typeName === ((_a = schema.getQueryType()) === null || _a === void 0 ? void 0 : _a.name)) {
            specifiers.push(Interfaces_js_1.MapperKind.ROOT_FIELD, Interfaces_js_1.MapperKind.QUERY_ROOT_FIELD);
        } else if (typeName === ((_b = schema.getMutationType()) === null || _b === void 0 ? void 0 : _b.name)) {
            specifiers.push(Interfaces_js_1.MapperKind.ROOT_FIELD, Interfaces_js_1.MapperKind.MUTATION_ROOT_FIELD);
        } else if (typeName === ((_c = schema.getSubscriptionType()) === null || _c === void 0 ? void 0 : _c.name)) {
            specifiers.push(Interfaces_js_1.MapperKind.ROOT_FIELD, Interfaces_js_1.MapperKind.SUBSCRIPTION_ROOT_FIELD);
        }
    } else if ((0, graphql_1.isInterfaceType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_FIELD, Interfaces_js_1.MapperKind.INTERFACE_FIELD);
    } else if ((0, graphql_1.isInputObjectType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.INPUT_OBJECT_FIELD);
    }
    return specifiers;
}
function getFieldMapper(schema, schemaMapper, typeName) {
    const specifiers = getFieldSpecifiers(schema, typeName);
    let fieldMapper;
    const stack = [
        ...specifiers
    ];
    while(!fieldMapper && stack.length > 0){
        // It is safe to use the ! operator here as we check the length.
        const next = stack.pop();
        // TODO: fix this as unknown cast
        fieldMapper = schemaMapper[next];
    }
    return fieldMapper !== null && fieldMapper !== void 0 ? fieldMapper : null;
}
function getArgumentMapper(schemaMapper) {
    const argumentMapper = schemaMapper[Interfaces_js_1.MapperKind.ARGUMENT];
    return argumentMapper != null ? argumentMapper : null;
}
function getDirectiveMapper(schemaMapper) {
    const directiveMapper = schemaMapper[Interfaces_js_1.MapperKind.DIRECTIVE];
    return directiveMapper != null ? directiveMapper : null;
}
function getEnumValueMapper(schemaMapper) {
    const enumValueMapper = schemaMapper[Interfaces_js_1.MapperKind.ENUM_VALUE];
    return enumValueMapper != null ? enumValueMapper : null;
}
function correctASTNodes(type) {
    if ((0, graphql_1.isObjectType)(type)) {
        const config = type.toConfig();
        if (config.astNode != null) {
            const fields = [];
            for(const fieldName in config.fields){
                const fieldConfig = config.fields[fieldName];
                if (fieldConfig.astNode != null) {
                    fields.push(fieldConfig.astNode);
                }
            }
            config.astNode = {
                ...config.astNode,
                kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION,
                fields
            };
        }
        if (config.extensionASTNodes != null) {
            config.extensionASTNodes = config.extensionASTNodes.map((node)=>({
                    ...node,
                    kind: graphql_1.Kind.OBJECT_TYPE_EXTENSION,
                    fields: undefined
                }));
        }
        return new graphql_1.GraphQLObjectType(config);
    } else if ((0, graphql_1.isInterfaceType)(type)) {
        const config = type.toConfig();
        if (config.astNode != null) {
            const fields = [];
            for(const fieldName in config.fields){
                const fieldConfig = config.fields[fieldName];
                if (fieldConfig.astNode != null) {
                    fields.push(fieldConfig.astNode);
                }
            }
            config.astNode = {
                ...config.astNode,
                kind: graphql_1.Kind.INTERFACE_TYPE_DEFINITION,
                fields
            };
        }
        if (config.extensionASTNodes != null) {
            config.extensionASTNodes = config.extensionASTNodes.map((node)=>({
                    ...node,
                    kind: graphql_1.Kind.INTERFACE_TYPE_EXTENSION,
                    fields: undefined
                }));
        }
        return new graphql_1.GraphQLInterfaceType(config);
    } else if ((0, graphql_1.isInputObjectType)(type)) {
        const config = type.toConfig();
        if (config.astNode != null) {
            const fields = [];
            for(const fieldName in config.fields){
                const fieldConfig = config.fields[fieldName];
                if (fieldConfig.astNode != null) {
                    fields.push(fieldConfig.astNode);
                }
            }
            config.astNode = {
                ...config.astNode,
                kind: graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION,
                fields
            };
        }
        if (config.extensionASTNodes != null) {
            config.extensionASTNodes = config.extensionASTNodes.map((node)=>({
                    ...node,
                    kind: graphql_1.Kind.INPUT_OBJECT_TYPE_EXTENSION,
                    fields: undefined
                }));
        }
        return new graphql_1.GraphQLInputObjectType(config);
    } else if ((0, graphql_1.isEnumType)(type)) {
        const config = type.toConfig();
        if (config.astNode != null) {
            const values = [];
            for(const enumKey in config.values){
                const enumValueConfig = config.values[enumKey];
                if (enumValueConfig.astNode != null) {
                    values.push(enumValueConfig.astNode);
                }
            }
            config.astNode = {
                ...config.astNode,
                values
            };
        }
        if (config.extensionASTNodes != null) {
            config.extensionASTNodes = config.extensionASTNodes.map((node)=>({
                    ...node,
                    values: undefined
                }));
        }
        return new graphql_1.GraphQLEnumType(config);
    } else {
        return type;
    }
}
exports.correctASTNodes = correctASTNodes;


/***/ }),

/***/ 9787:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.memoize2of5 = exports.memoize2of4 = exports.memoize5 = exports.memoize4 = exports.memoize3 = exports.memoize2 = exports.memoize1 = void 0;
function memoize1(fn) {
    const memoize1cache = new WeakMap();
    return function memoized(a1) {
        const cachedValue = memoize1cache.get(a1);
        if (cachedValue === undefined) {
            const newValue = fn(a1);
            memoize1cache.set(a1, newValue);
            return newValue;
        }
        return cachedValue;
    };
}
exports.memoize1 = memoize1;
function memoize2(fn) {
    const memoize2cache = new WeakMap();
    return function memoized(a1, a2) {
        let cache2 = memoize2cache.get(a1);
        if (!cache2) {
            cache2 = new WeakMap();
            memoize2cache.set(a1, cache2);
            const newValue = fn(a1, a2);
            cache2.set(a2, newValue);
            return newValue;
        }
        const cachedValue = cache2.get(a2);
        if (cachedValue === undefined) {
            const newValue = fn(a1, a2);
            cache2.set(a2, newValue);
            return newValue;
        }
        return cachedValue;
    };
}
exports.memoize2 = memoize2;
function memoize3(fn) {
    const memoize3Cache = new WeakMap();
    return function memoized(a1, a2, a3) {
        let cache2 = memoize3Cache.get(a1);
        if (!cache2) {
            cache2 = new WeakMap();
            memoize3Cache.set(a1, cache2);
            const cache3 = new WeakMap();
            cache2.set(a2, cache3);
            const newValue = fn(a1, a2, a3);
            cache3.set(a3, newValue);
            return newValue;
        }
        let cache3 = cache2.get(a2);
        if (!cache3) {
            cache3 = new WeakMap();
            cache2.set(a2, cache3);
            const newValue = fn(a1, a2, a3);
            cache3.set(a3, newValue);
            return newValue;
        }
        const cachedValue = cache3.get(a3);
        if (cachedValue === undefined) {
            const newValue = fn(a1, a2, a3);
            cache3.set(a3, newValue);
            return newValue;
        }
        return cachedValue;
    };
}
exports.memoize3 = memoize3;
function memoize4(fn) {
    const memoize4Cache = new WeakMap();
    return function memoized(a1, a2, a3, a4) {
        let cache2 = memoize4Cache.get(a1);
        if (!cache2) {
            cache2 = new WeakMap();
            memoize4Cache.set(a1, cache2);
            const cache3 = new WeakMap();
            cache2.set(a2, cache3);
            const cache4 = new WeakMap();
            cache3.set(a3, cache4);
            const newValue = fn(a1, a2, a3, a4);
            cache4.set(a4, newValue);
            return newValue;
        }
        let cache3 = cache2.get(a2);
        if (!cache3) {
            cache3 = new WeakMap();
            cache2.set(a2, cache3);
            const cache4 = new WeakMap();
            cache3.set(a3, cache4);
            const newValue = fn(a1, a2, a3, a4);
            cache4.set(a4, newValue);
            return newValue;
        }
        const cache4 = cache3.get(a3);
        if (!cache4) {
            const cache4 = new WeakMap();
            cache3.set(a3, cache4);
            const newValue = fn(a1, a2, a3, a4);
            cache4.set(a4, newValue);
            return newValue;
        }
        const cachedValue = cache4.get(a4);
        if (cachedValue === undefined) {
            const newValue = fn(a1, a2, a3, a4);
            cache4.set(a4, newValue);
            return newValue;
        }
        return cachedValue;
    };
}
exports.memoize4 = memoize4;
function memoize5(fn) {
    const memoize5Cache = new WeakMap();
    return function memoized(a1, a2, a3, a4, a5) {
        let cache2 = memoize5Cache.get(a1);
        if (!cache2) {
            cache2 = new WeakMap();
            memoize5Cache.set(a1, cache2);
            const cache3 = new WeakMap();
            cache2.set(a2, cache3);
            const cache4 = new WeakMap();
            cache3.set(a3, cache4);
            const cache5 = new WeakMap();
            cache4.set(a4, cache5);
            const newValue = fn(a1, a2, a3, a4, a5);
            cache5.set(a5, newValue);
            return newValue;
        }
        let cache3 = cache2.get(a2);
        if (!cache3) {
            cache3 = new WeakMap();
            cache2.set(a2, cache3);
            const cache4 = new WeakMap();
            cache3.set(a3, cache4);
            const cache5 = new WeakMap();
            cache4.set(a4, cache5);
            const newValue = fn(a1, a2, a3, a4, a5);
            cache5.set(a5, newValue);
            return newValue;
        }
        let cache4 = cache3.get(a3);
        if (!cache4) {
            cache4 = new WeakMap();
            cache3.set(a3, cache4);
            const cache5 = new WeakMap();
            cache4.set(a4, cache5);
            const newValue = fn(a1, a2, a3, a4, a5);
            cache5.set(a5, newValue);
            return newValue;
        }
        let cache5 = cache4.get(a4);
        if (!cache5) {
            cache5 = new WeakMap();
            cache4.set(a4, cache5);
            const newValue = fn(a1, a2, a3, a4, a5);
            cache5.set(a5, newValue);
            return newValue;
        }
        const cachedValue = cache5.get(a5);
        if (cachedValue === undefined) {
            const newValue = fn(a1, a2, a3, a4, a5);
            cache5.set(a5, newValue);
            return newValue;
        }
        return cachedValue;
    };
}
exports.memoize5 = memoize5;
function memoize2of4(fn) {
    const memoize2of4cache = new WeakMap();
    return function memoized(a1, a2, a3, a4) {
        let cache2 = memoize2of4cache.get(a1);
        if (!cache2) {
            cache2 = new WeakMap();
            memoize2of4cache.set(a1, cache2);
            const newValue = fn(a1, a2, a3, a4);
            cache2.set(a2, newValue);
            return newValue;
        }
        const cachedValue = cache2.get(a2);
        if (cachedValue === undefined) {
            const newValue = fn(a1, a2, a3, a4);
            cache2.set(a2, newValue);
            return newValue;
        }
        return cachedValue;
    };
}
exports.memoize2of4 = memoize2of4;
function memoize2of5(fn) {
    const memoize2of4cache = new WeakMap();
    return function memoized(a1, a2, a3, a4, a5) {
        let cache2 = memoize2of4cache.get(a1);
        if (!cache2) {
            cache2 = new WeakMap();
            memoize2of4cache.set(a1, cache2);
            const newValue = fn(a1, a2, a3, a4, a5);
            cache2.set(a2, newValue);
            return newValue;
        }
        const cachedValue = cache2.get(a2);
        if (cachedValue === undefined) {
            const newValue = fn(a1, a2, a3, a4, a5);
            cache2.set(a2, newValue);
            return newValue;
        }
        return cachedValue;
    };
}
exports.memoize2of5 = memoize2of5;


/***/ }),

/***/ 6646:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.mergeDeep = void 0;
const helpers_js_1 = __webpack_require__(5551);
function mergeDeep(sources, respectPrototype = false) {
    const target = sources[0] || {};
    const output = {};
    if (respectPrototype) {
        Object.setPrototypeOf(output, Object.create(Object.getPrototypeOf(target)));
    }
    for (const source of sources){
        if (isObject(target) && isObject(source)) {
            if (respectPrototype) {
                const outputPrototype = Object.getPrototypeOf(output);
                const sourcePrototype = Object.getPrototypeOf(source);
                if (sourcePrototype) {
                    for (const key of Object.getOwnPropertyNames(sourcePrototype)){
                        const descriptor = Object.getOwnPropertyDescriptor(sourcePrototype, key);
                        if ((0, helpers_js_1.isSome)(descriptor)) {
                            Object.defineProperty(outputPrototype, key, descriptor);
                        }
                    }
                }
            }
            for(const key in source){
                if (isObject(source[key])) {
                    if (!(key in output)) {
                        Object.assign(output, {
                            [key]: source[key]
                        });
                    } else {
                        output[key] = mergeDeep([
                            output[key],
                            source[key]
                        ], respectPrototype);
                    }
                } else {
                    Object.assign(output, {
                        [key]: source[key]
                    });
                }
            }
        }
    }
    return output;
}
exports.mergeDeep = mergeDeep;
function isObject(item) {
    return item && typeof item === "object" && !Array.isArray(item);
}


/***/ }),

/***/ 8698:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.observableToAsyncIterable = void 0;
function observableToAsyncIterable(observable) {
    const pullQueue = [];
    const pushQueue = [];
    let listening = true;
    const pushValue = (value)=>{
        if (pullQueue.length !== 0) {
            // It is safe to use the ! operator here as we check the length.
            pullQueue.shift()({
                value,
                done: false
            });
        } else {
            pushQueue.push({
                value,
                done: false
            });
        }
    };
    const pushError = (error)=>{
        if (pullQueue.length !== 0) {
            // It is safe to use the ! operator here as we check the length.
            pullQueue.shift()({
                value: {
                    errors: [
                        error
                    ]
                },
                done: false
            });
        } else {
            pushQueue.push({
                value: {
                    errors: [
                        error
                    ]
                },
                done: false
            });
        }
    };
    const pushDone = ()=>{
        if (pullQueue.length !== 0) {
            // It is safe to use the ! operator here as we check the length.
            pullQueue.shift()({
                done: true
            });
        } else {
            pushQueue.push({
                done: true
            });
        }
    };
    const pullValue = ()=>new Promise((resolve)=>{
            if (pushQueue.length !== 0) {
                const element = pushQueue.shift();
                // either {value: {errors: [...]}} or {value: ...}
                resolve(element);
            } else {
                pullQueue.push(resolve);
            }
        });
    const subscription = observable.subscribe({
        next (value) {
            pushValue(value);
        },
        error (err) {
            pushError(err);
        },
        complete () {
            pushDone();
        }
    });
    const emptyQueue = ()=>{
        if (listening) {
            listening = false;
            subscription.unsubscribe();
            for (const resolve of pullQueue){
                resolve({
                    value: undefined,
                    done: true
                });
            }
            pullQueue.length = 0;
            pushQueue.length = 0;
        }
    };
    return {
        next () {
            // return is a defined method, so it is safe to call it.
            return listening ? pullValue() : this.return();
        },
        return () {
            emptyQueue();
            return Promise.resolve({
                value: undefined,
                done: true
            });
        },
        throw (error) {
            emptyQueue();
            return Promise.reject(error);
        },
        [Symbol.asyncIterator] () {
            return this;
        }
    };
}
exports.observableToAsyncIterable = observableToAsyncIterable;


/***/ }),

/***/ 2016:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.parseGraphQLJSON = void 0;
const graphql_1 = __webpack_require__(5736);
function stripBOM(content) {
    content = content.toString();
    // Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
    // because the buffer-to-string conversion in `fs.readFileSync()`
    // translates it to FEFF, the UTF-16 BOM.
    if (content.charCodeAt(0) === 0xfeff) {
        content = content.slice(1);
    }
    return content;
}
function parseBOM(content) {
    return JSON.parse(stripBOM(content));
}
function parseGraphQLJSON(location, jsonContent, options) {
    let parsedJson = parseBOM(jsonContent);
    if (parsedJson.data) {
        parsedJson = parsedJson.data;
    }
    if (parsedJson.kind === "Document") {
        return {
            location,
            document: parsedJson
        };
    } else if (parsedJson.__schema) {
        const schema = (0, graphql_1.buildClientSchema)(parsedJson, options);
        return {
            location,
            schema
        };
    } else if (typeof parsedJson === "string") {
        return {
            location,
            rawSDL: parsedJson
        };
    }
    throw new Error(`Not valid JSON content`);
}
exports.parseGraphQLJSON = parseGraphQLJSON;


/***/ }),

/***/ 5431:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.isDescribable = exports.transformCommentsToDescriptions = exports.parseGraphQLSDL = void 0;
const graphql_1 = __webpack_require__(5736);
const comments_js_1 = __webpack_require__(8950);
function parseGraphQLSDL(location, rawSDL, options = {}) {
    let document;
    try {
        if (options.commentDescriptions && rawSDL.includes("#")) {
            document = transformCommentsToDescriptions(rawSDL, options);
            // If noLocation=true, we need to make sure to print and parse it again, to remove locations,
            // since `transformCommentsToDescriptions` must have locations set in order to transform the comments
            // into descriptions.
            if (options.noLocation) {
                document = (0, graphql_1.parse)((0, graphql_1.print)(document), options);
            }
        } else {
            document = (0, graphql_1.parse)(new graphql_1.Source(rawSDL, location), options);
        }
    } catch (e) {
        if (e.message.includes("EOF") && rawSDL.replace(/(\#[^*]*)/g, "").trim() === "") {
            document = {
                kind: graphql_1.Kind.DOCUMENT,
                definitions: []
            };
        } else {
            throw e;
        }
    }
    return {
        location,
        document
    };
}
exports.parseGraphQLSDL = parseGraphQLSDL;
function transformCommentsToDescriptions(sourceSdl, options = {}) {
    const parsedDoc = (0, graphql_1.parse)(sourceSdl, {
        ...options,
        noLocation: false
    });
    const modifiedDoc = (0, graphql_1.visit)(parsedDoc, {
        leave: (node)=>{
            if (isDescribable(node)) {
                const rawValue = (0, comments_js_1.getLeadingCommentBlock)(node);
                if (rawValue !== undefined) {
                    const commentsBlock = (0, comments_js_1.dedentBlockStringValue)("\n" + rawValue);
                    const isBlock = commentsBlock.includes("\n");
                    if (!node.description) {
                        return {
                            ...node,
                            description: {
                                kind: graphql_1.Kind.STRING,
                                value: commentsBlock,
                                block: isBlock
                            }
                        };
                    } else {
                        return {
                            ...node,
                            description: {
                                ...node.description,
                                value: node.description.value + "\n" + commentsBlock,
                                block: true
                            }
                        };
                    }
                }
            }
        }
    });
    return modifiedDoc;
}
exports.transformCommentsToDescriptions = transformCommentsToDescriptions;
function isDescribable(node) {
    return (0, graphql_1.isTypeSystemDefinitionNode)(node) || node.kind === graphql_1.Kind.FIELD_DEFINITION || node.kind === graphql_1.Kind.INPUT_VALUE_DEFINITION || node.kind === graphql_1.Kind.ENUM_VALUE_DEFINITION;
}
exports.isDescribable = isDescribable;


/***/ }),

/***/ 5471:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.makeDirectiveNodes = exports.makeDirectiveNode = exports.makeDeprecatedDirective = exports.astFromEnumValue = exports.astFromInputField = exports.astFromField = exports.astFromScalarType = exports.astFromEnumType = exports.astFromInputObjectType = exports.astFromUnionType = exports.astFromInterfaceType = exports.astFromObjectType = exports.astFromArg = exports.getDeprecatableDirectiveNodes = exports.getDirectiveNodes = exports.astFromDirective = exports.astFromSchema = exports.printSchemaWithDirectives = exports.getDocumentNodeFromSchema = void 0;
const graphql_1 = __webpack_require__(5736);
const astFromType_js_1 = __webpack_require__(3742);
const get_directives_js_1 = __webpack_require__(6103);
const astFromValueUntyped_js_1 = __webpack_require__(4768);
const helpers_js_1 = __webpack_require__(5551);
const rootTypes_js_1 = __webpack_require__(7839);
function getDocumentNodeFromSchema(schema, options = {}) {
    const pathToDirectivesInExtensions = options.pathToDirectivesInExtensions;
    const typesMap = schema.getTypeMap();
    const schemaNode = astFromSchema(schema, pathToDirectivesInExtensions);
    const definitions = schemaNode != null ? [
        schemaNode
    ] : [];
    const directives = schema.getDirectives();
    for (const directive of directives){
        if ((0, graphql_1.isSpecifiedDirective)(directive)) {
            continue;
        }
        definitions.push(astFromDirective(directive, schema, pathToDirectivesInExtensions));
    }
    for(const typeName in typesMap){
        const type = typesMap[typeName];
        const isPredefinedScalar = (0, graphql_1.isSpecifiedScalarType)(type);
        const isIntrospection = (0, graphql_1.isIntrospectionType)(type);
        if (isPredefinedScalar || isIntrospection) {
            continue;
        }
        if ((0, graphql_1.isObjectType)(type)) {
            definitions.push(astFromObjectType(type, schema, pathToDirectivesInExtensions));
        } else if ((0, graphql_1.isInterfaceType)(type)) {
            definitions.push(astFromInterfaceType(type, schema, pathToDirectivesInExtensions));
        } else if ((0, graphql_1.isUnionType)(type)) {
            definitions.push(astFromUnionType(type, schema, pathToDirectivesInExtensions));
        } else if ((0, graphql_1.isInputObjectType)(type)) {
            definitions.push(astFromInputObjectType(type, schema, pathToDirectivesInExtensions));
        } else if ((0, graphql_1.isEnumType)(type)) {
            definitions.push(astFromEnumType(type, schema, pathToDirectivesInExtensions));
        } else if ((0, graphql_1.isScalarType)(type)) {
            definitions.push(astFromScalarType(type, schema, pathToDirectivesInExtensions));
        } else {
            throw new Error(`Unknown type ${type}.`);
        }
    }
    return {
        kind: graphql_1.Kind.DOCUMENT,
        definitions
    };
}
exports.getDocumentNodeFromSchema = getDocumentNodeFromSchema;
// this approach uses the default schema printer rather than a custom solution, so may be more backwards compatible
// currently does not allow customization of printSchema options having to do with comments.
function printSchemaWithDirectives(schema, options = {}) {
    const documentNode = getDocumentNodeFromSchema(schema, options);
    return (0, graphql_1.print)(documentNode);
}
exports.printSchemaWithDirectives = printSchemaWithDirectives;
function astFromSchema(schema, pathToDirectivesInExtensions) {
    var _a, _b;
    const operationTypeMap = new Map([
        [
            "query",
            undefined
        ],
        [
            "mutation",
            undefined
        ],
        [
            "subscription",
            undefined
        ]
    ]);
    const nodes = [];
    if (schema.astNode != null) {
        nodes.push(schema.astNode);
    }
    if (schema.extensionASTNodes != null) {
        for (const extensionASTNode of schema.extensionASTNodes){
            nodes.push(extensionASTNode);
        }
    }
    for (const node of nodes){
        if (node.operationTypes) {
            for (const operationTypeDefinitionNode of node.operationTypes){
                operationTypeMap.set(operationTypeDefinitionNode.operation, operationTypeDefinitionNode);
            }
        }
    }
    const rootTypeMap = (0, rootTypes_js_1.getRootTypeMap)(schema);
    for (const [operationTypeNode, operationTypeDefinitionNode] of operationTypeMap){
        const rootType = rootTypeMap.get(operationTypeNode);
        if (rootType != null) {
            const rootTypeAST = (0, astFromType_js_1.astFromType)(rootType);
            if (operationTypeDefinitionNode != null) {
                operationTypeDefinitionNode.type = rootTypeAST;
            } else {
                operationTypeMap.set(operationTypeNode, {
                    kind: graphql_1.Kind.OPERATION_TYPE_DEFINITION,
                    operation: operationTypeNode,
                    type: rootTypeAST
                });
            }
        }
    }
    const operationTypes = [
        ...operationTypeMap.values()
    ].filter(helpers_js_1.isSome);
    const directives = getDirectiveNodes(schema, schema, pathToDirectivesInExtensions);
    if (!operationTypes.length && !directives.length) {
        return null;
    }
    const schemaNode = {
        kind: operationTypes != null ? graphql_1.Kind.SCHEMA_DEFINITION : graphql_1.Kind.SCHEMA_EXTENSION,
        operationTypes,
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: directives
    };
    // This code is so weird because it needs to support GraphQL.js 14
    // In GraphQL.js 14 there is no `description` value on schemaNode
    schemaNode.description = ((_b = (_a = schema.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : schema.description != null) ? {
        kind: graphql_1.Kind.STRING,
        value: schema.description,
        block: true
    } : undefined;
    return schemaNode;
}
exports.astFromSchema = astFromSchema;
function astFromDirective(directive, schema, pathToDirectivesInExtensions) {
    var _a, _b, _c, _d;
    return {
        kind: graphql_1.Kind.DIRECTIVE_DEFINITION,
        description: (_b = (_a = directive.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : directive.description ? {
            kind: graphql_1.Kind.STRING,
            value: directive.description
        } : undefined,
        name: {
            kind: graphql_1.Kind.NAME,
            value: directive.name
        },
        arguments: (_c = directive.args) === null || _c === void 0 ? void 0 : _c.map((arg)=>astFromArg(arg, schema, pathToDirectivesInExtensions)),
        repeatable: directive.isRepeatable,
        locations: ((_d = directive.locations) === null || _d === void 0 ? void 0 : _d.map((location)=>({
                kind: graphql_1.Kind.NAME,
                value: location
            }))) || []
    };
}
exports.astFromDirective = astFromDirective;
function getDirectiveNodes(entity, schema, pathToDirectivesInExtensions) {
    const directivesInExtensions = (0, get_directives_js_1.getDirectivesInExtensions)(entity, pathToDirectivesInExtensions);
    let nodes = [];
    if (entity.astNode != null) {
        nodes.push(entity.astNode);
    }
    if ("extensionASTNodes" in entity && entity.extensionASTNodes != null) {
        nodes = nodes.concat(entity.extensionASTNodes);
    }
    let directives;
    if (directivesInExtensions != null) {
        directives = makeDirectiveNodes(schema, directivesInExtensions);
    } else {
        directives = [];
        for (const node of nodes){
            if (node.directives) {
                directives.push(...node.directives);
            }
        }
    }
    return directives;
}
exports.getDirectiveNodes = getDirectiveNodes;
function getDeprecatableDirectiveNodes(entity, schema, pathToDirectivesInExtensions) {
    var _a, _b;
    let directiveNodesBesidesDeprecated = [];
    let deprecatedDirectiveNode = null;
    const directivesInExtensions = (0, get_directives_js_1.getDirectivesInExtensions)(entity, pathToDirectivesInExtensions);
    let directives;
    if (directivesInExtensions != null) {
        directives = makeDirectiveNodes(schema, directivesInExtensions);
    } else {
        directives = (_a = entity.astNode) === null || _a === void 0 ? void 0 : _a.directives;
    }
    if (directives != null) {
        directiveNodesBesidesDeprecated = directives.filter((directive)=>directive.name.value !== "deprecated");
        if (entity.deprecationReason != null) {
            deprecatedDirectiveNode = (_b = directives.filter((directive)=>directive.name.value === "deprecated")) === null || _b === void 0 ? void 0 : _b[0];
        }
    }
    if (entity.deprecationReason != null && deprecatedDirectiveNode == null) {
        deprecatedDirectiveNode = makeDeprecatedDirective(entity.deprecationReason);
    }
    return deprecatedDirectiveNode == null ? directiveNodesBesidesDeprecated : [
        deprecatedDirectiveNode
    ].concat(directiveNodesBesidesDeprecated);
}
exports.getDeprecatableDirectiveNodes = getDeprecatableDirectiveNodes;
function astFromArg(arg, schema, pathToDirectivesInExtensions) {
    var _a, _b, _c;
    return {
        kind: graphql_1.Kind.INPUT_VALUE_DEFINITION,
        description: (_b = (_a = arg.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : arg.description ? {
            kind: graphql_1.Kind.STRING,
            value: arg.description,
            block: true
        } : undefined,
        name: {
            kind: graphql_1.Kind.NAME,
            value: arg.name
        },
        type: (0, astFromType_js_1.astFromType)(arg.type),
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        defaultValue: arg.defaultValue !== undefined ? (_c = (0, graphql_1.astFromValue)(arg.defaultValue, arg.type)) !== null && _c !== void 0 ? _c : undefined : undefined,
        directives: getDeprecatableDirectiveNodes(arg, schema, pathToDirectivesInExtensions)
    };
}
exports.astFromArg = astFromArg;
function astFromObjectType(type, schema, pathToDirectivesInExtensions) {
    var _a, _b;
    return {
        kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION,
        description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description ? {
            kind: graphql_1.Kind.STRING,
            value: type.description,
            block: true
        } : undefined,
        name: {
            kind: graphql_1.Kind.NAME,
            value: type.name
        },
        fields: Object.values(type.getFields()).map((field)=>astFromField(field, schema, pathToDirectivesInExtensions)),
        interfaces: Object.values(type.getInterfaces()).map((iFace)=>(0, astFromType_js_1.astFromType)(iFace)),
        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)
    };
}
exports.astFromObjectType = astFromObjectType;
function astFromInterfaceType(type, schema, pathToDirectivesInExtensions) {
    var _a, _b;
    const node = {
        kind: graphql_1.Kind.INTERFACE_TYPE_DEFINITION,
        description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description ? {
            kind: graphql_1.Kind.STRING,
            value: type.description,
            block: true
        } : undefined,
        name: {
            kind: graphql_1.Kind.NAME,
            value: type.name
        },
        fields: Object.values(type.getFields()).map((field)=>astFromField(field, schema, pathToDirectivesInExtensions)),
        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)
    };
    if ("getInterfaces" in type) {
        node.interfaces = Object.values(type.getInterfaces()).map((iFace)=>(0, astFromType_js_1.astFromType)(iFace));
    }
    return node;
}
exports.astFromInterfaceType = astFromInterfaceType;
function astFromUnionType(type, schema, pathToDirectivesInExtensions) {
    var _a, _b;
    return {
        kind: graphql_1.Kind.UNION_TYPE_DEFINITION,
        description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description ? {
            kind: graphql_1.Kind.STRING,
            value: type.description,
            block: true
        } : undefined,
        name: {
            kind: graphql_1.Kind.NAME,
            value: type.name
        },
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions),
        types: type.getTypes().map((type)=>(0, astFromType_js_1.astFromType)(type))
    };
}
exports.astFromUnionType = astFromUnionType;
function astFromInputObjectType(type, schema, pathToDirectivesInExtensions) {
    var _a, _b;
    return {
        kind: graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION,
        description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description ? {
            kind: graphql_1.Kind.STRING,
            value: type.description,
            block: true
        } : undefined,
        name: {
            kind: graphql_1.Kind.NAME,
            value: type.name
        },
        fields: Object.values(type.getFields()).map((field)=>astFromInputField(field, schema, pathToDirectivesInExtensions)),
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)
    };
}
exports.astFromInputObjectType = astFromInputObjectType;
function astFromEnumType(type, schema, pathToDirectivesInExtensions) {
    var _a, _b;
    return {
        kind: graphql_1.Kind.ENUM_TYPE_DEFINITION,
        description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description ? {
            kind: graphql_1.Kind.STRING,
            value: type.description,
            block: true
        } : undefined,
        name: {
            kind: graphql_1.Kind.NAME,
            value: type.name
        },
        values: Object.values(type.getValues()).map((value)=>astFromEnumValue(value, schema, pathToDirectivesInExtensions)),
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)
    };
}
exports.astFromEnumType = astFromEnumType;
function astFromScalarType(type, schema, pathToDirectivesInExtensions) {
    var _a, _b, _c;
    const directivesInExtensions = (0, get_directives_js_1.getDirectivesInExtensions)(type, pathToDirectivesInExtensions);
    const directives = directivesInExtensions ? makeDirectiveNodes(schema, directivesInExtensions) : ((_a = type.astNode) === null || _a === void 0 ? void 0 : _a.directives) || [];
    const specifiedByValue = type["specifiedByUrl"] || type["specifiedByURL"];
    if (specifiedByValue && !directives.some((directiveNode)=>directiveNode.name.value === "specifiedBy")) {
        const specifiedByArgs = {
            url: specifiedByValue
        };
        directives.push(makeDirectiveNode("specifiedBy", specifiedByArgs));
    }
    return {
        kind: graphql_1.Kind.SCALAR_TYPE_DEFINITION,
        description: (_c = (_b = type.astNode) === null || _b === void 0 ? void 0 : _b.description) !== null && _c !== void 0 ? _c : type.description ? {
            kind: graphql_1.Kind.STRING,
            value: type.description,
            block: true
        } : undefined,
        name: {
            kind: graphql_1.Kind.NAME,
            value: type.name
        },
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: directives
    };
}
exports.astFromScalarType = astFromScalarType;
function astFromField(field, schema, pathToDirectivesInExtensions) {
    var _a, _b;
    return {
        kind: graphql_1.Kind.FIELD_DEFINITION,
        description: (_b = (_a = field.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : field.description ? {
            kind: graphql_1.Kind.STRING,
            value: field.description,
            block: true
        } : undefined,
        name: {
            kind: graphql_1.Kind.NAME,
            value: field.name
        },
        arguments: field.args.map((arg)=>astFromArg(arg, schema, pathToDirectivesInExtensions)),
        type: (0, astFromType_js_1.astFromType)(field.type),
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDeprecatableDirectiveNodes(field, schema, pathToDirectivesInExtensions)
    };
}
exports.astFromField = astFromField;
function astFromInputField(field, schema, pathToDirectivesInExtensions) {
    var _a, _b, _c;
    return {
        kind: graphql_1.Kind.INPUT_VALUE_DEFINITION,
        description: (_b = (_a = field.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : field.description ? {
            kind: graphql_1.Kind.STRING,
            value: field.description,
            block: true
        } : undefined,
        name: {
            kind: graphql_1.Kind.NAME,
            value: field.name
        },
        type: (0, astFromType_js_1.astFromType)(field.type),
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDeprecatableDirectiveNodes(field, schema, pathToDirectivesInExtensions),
        defaultValue: (_c = (0, graphql_1.astFromValue)(field.defaultValue, field.type)) !== null && _c !== void 0 ? _c : undefined
    };
}
exports.astFromInputField = astFromInputField;
function astFromEnumValue(value, schema, pathToDirectivesInExtensions) {
    var _a, _b;
    return {
        kind: graphql_1.Kind.ENUM_VALUE_DEFINITION,
        description: (_b = (_a = value.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : value.description ? {
            kind: graphql_1.Kind.STRING,
            value: value.description,
            block: true
        } : undefined,
        name: {
            kind: graphql_1.Kind.NAME,
            value: value.name
        },
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDeprecatableDirectiveNodes(value, schema, pathToDirectivesInExtensions)
    };
}
exports.astFromEnumValue = astFromEnumValue;
function makeDeprecatedDirective(deprecationReason) {
    return makeDirectiveNode("deprecated", {
        reason: deprecationReason
    }, graphql_1.GraphQLDeprecatedDirective);
}
exports.makeDeprecatedDirective = makeDeprecatedDirective;
function makeDirectiveNode(name, args, directive) {
    const directiveArguments = [];
    if (directive != null) {
        for (const arg of directive.args){
            const argName = arg.name;
            const argValue = args[argName];
            if (argValue !== undefined) {
                const value = (0, graphql_1.astFromValue)(argValue, arg.type);
                if (value) {
                    directiveArguments.push({
                        kind: graphql_1.Kind.ARGUMENT,
                        name: {
                            kind: graphql_1.Kind.NAME,
                            value: argName
                        },
                        value
                    });
                }
            }
        }
    } else {
        for(const argName in args){
            const argValue = args[argName];
            const value = (0, astFromValueUntyped_js_1.astFromValueUntyped)(argValue);
            if (value) {
                directiveArguments.push({
                    kind: graphql_1.Kind.ARGUMENT,
                    name: {
                        kind: graphql_1.Kind.NAME,
                        value: argName
                    },
                    value
                });
            }
        }
    }
    return {
        kind: graphql_1.Kind.DIRECTIVE,
        name: {
            kind: graphql_1.Kind.NAME,
            value: name
        },
        arguments: directiveArguments
    };
}
exports.makeDirectiveNode = makeDirectiveNode;
function makeDirectiveNodes(schema, directiveValues) {
    const directiveNodes = [];
    for(const directiveName in directiveValues){
        const arrayOrSingleValue = directiveValues[directiveName];
        const directive = schema === null || schema === void 0 ? void 0 : schema.getDirective(directiveName);
        if (Array.isArray(arrayOrSingleValue)) {
            for (const value of arrayOrSingleValue){
                directiveNodes.push(makeDirectiveNode(directiveName, value, directive));
            }
        } else {
            directiveNodes.push(makeDirectiveNode(directiveName, arrayOrSingleValue, directive));
        }
    }
    return directiveNodes;
}
exports.makeDirectiveNodes = makeDirectiveNodes;


/***/ }),

/***/ 9654:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.pruneSchema = void 0;
const graphql_1 = __webpack_require__(5736);
const mapSchema_js_1 = __webpack_require__(1061);
const Interfaces_js_1 = __webpack_require__(8395);
const rootTypes_js_1 = __webpack_require__(7839);
const get_implementing_types_js_1 = __webpack_require__(1730);
/**
 * Prunes the provided schema, removing unused and empty types
 * @param schema The schema to prune
 * @param options Additional options for removing unused types from the schema
 */ function pruneSchema(schema, options = {}) {
    const { skipEmptyCompositeTypePruning , skipEmptyUnionPruning , skipPruning , skipUnimplementedInterfacesPruning , skipUnusedTypesPruning  } = options;
    let prunedTypes = []; // Pruned types during mapping
    let prunedSchema = schema;
    do {
        let visited = visitSchema(prunedSchema);
        // Custom pruning  was defined, so we need to pre-emptively revisit the schema accounting for this
        if (skipPruning) {
            const revisit = [];
            for(const typeName in prunedSchema.getTypeMap()){
                if (typeName.startsWith("__")) {
                    continue;
                }
                const type = prunedSchema.getType(typeName);
                // if we want to skip pruning for this type, add it to the list of types to revisit
                if (type && skipPruning(type)) {
                    revisit.push(typeName);
                }
            }
            visited = visitQueue(revisit, prunedSchema, visited); // visit again
        }
        prunedTypes = [];
        prunedSchema = (0, mapSchema_js_1.mapSchema)(prunedSchema, {
            [Interfaces_js_1.MapperKind.TYPE]: (type)=>{
                if (!visited.has(type.name) && !(0, graphql_1.isSpecifiedScalarType)(type)) {
                    if ((0, graphql_1.isUnionType)(type) || (0, graphql_1.isInputObjectType)(type) || (0, graphql_1.isInterfaceType)(type) || (0, graphql_1.isObjectType)(type) || (0, graphql_1.isScalarType)(type)) {
                        // skipUnusedTypesPruning: skip pruning unused types
                        if (skipUnusedTypesPruning) {
                            return type;
                        }
                        // skipEmptyUnionPruning: skip pruning empty unions
                        if ((0, graphql_1.isUnionType)(type) && skipEmptyUnionPruning && !Object.keys(type.getTypes()).length) {
                            return type;
                        }
                        if ((0, graphql_1.isInputObjectType)(type) || (0, graphql_1.isInterfaceType)(type) || (0, graphql_1.isObjectType)(type)) {
                            // skipEmptyCompositeTypePruning: skip pruning object types or interfaces with no fields
                            if (skipEmptyCompositeTypePruning && !Object.keys(type.getFields()).length) {
                                return type;
                            }
                        }
                        // skipUnimplementedInterfacesPruning: skip pruning interfaces that are not implemented by any other types
                        if ((0, graphql_1.isInterfaceType)(type) && skipUnimplementedInterfacesPruning) {
                            return type;
                        }
                    }
                    prunedTypes.push(type.name);
                    visited.delete(type.name);
                    return null;
                }
                return type;
            }
        });
    }while (prunedTypes.length); // Might have empty types and need to prune again
    return prunedSchema;
}
exports.pruneSchema = pruneSchema;
function visitSchema(schema) {
    const queue = []; // queue of nodes to visit
    // Grab the root types and start there
    for (const type of (0, rootTypes_js_1.getRootTypes)(schema)){
        queue.push(type.name);
    }
    return visitQueue(queue, schema);
}
function visitQueue(queue, schema, visited = new Set()) {
    // Interfaces encountered that are field return types need to be revisited to add their implementations
    const revisit = new Map();
    // Navigate all types starting with pre-queued types (root types)
    while(queue.length){
        const typeName = queue.pop();
        // Skip types we already visited unless it is an interface type that needs revisiting
        if (visited.has(typeName) && revisit[typeName] !== true) {
            continue;
        }
        const type = schema.getType(typeName);
        if (type) {
            // Get types for union
            if ((0, graphql_1.isUnionType)(type)) {
                queue.push(...type.getTypes().map((type)=>type.name));
            }
            // If it is an interface and it is a returned type, grab all implementations so we can use proper __typename in fragments
            if ((0, graphql_1.isInterfaceType)(type) && revisit[typeName] === true) {
                queue.push(...(0, get_implementing_types_js_1.getImplementingTypes)(type.name, schema));
                // No need to revisit this interface again
                revisit[typeName] = false;
            }
            if ((0, graphql_1.isEnumType)(type)) {
                // Visit enum values directives argument types
                queue.push(...type.getValues().flatMap((value)=>{
                    if (value.astNode) {
                        return getDirectivesArgumentsTypeNames(schema, value.astNode);
                    }
                    return [];
                }));
            }
            // Visit interfaces this type is implementing if they haven't been visited yet
            if ("getInterfaces" in type) {
                // Only pushes to queue to visit but not return types
                queue.push(...type.getInterfaces().map((iface)=>iface.name));
            }
            // If the type has fields visit those field types
            if ("getFields" in type) {
                const fields = type.getFields();
                const entries = Object.entries(fields);
                if (!entries.length) {
                    continue;
                }
                for (const [, field] of entries){
                    if ((0, graphql_1.isObjectType)(type)) {
                        // Visit arg types and arg directives arguments types
                        queue.push(...field.args.flatMap((arg)=>{
                            const typeNames = [
                                (0, graphql_1.getNamedType)(arg.type).name
                            ];
                            if (arg.astNode) {
                                typeNames.push(...getDirectivesArgumentsTypeNames(schema, arg.astNode));
                            }
                            return typeNames;
                        }));
                    }
                    const namedType = (0, graphql_1.getNamedType)(field.type);
                    queue.push(namedType.name);
                    if (field.astNode) {
                        queue.push(...getDirectivesArgumentsTypeNames(schema, field.astNode));
                    }
                    // Interfaces returned on fields need to be revisited to add their implementations
                    if ((0, graphql_1.isInterfaceType)(namedType) && !(namedType.name in revisit)) {
                        revisit[namedType.name] = true;
                    }
                }
            }
            if (type.astNode) {
                queue.push(...getDirectivesArgumentsTypeNames(schema, type.astNode));
            }
            visited.add(typeName); // Mark as visited (and therefore it is used and should be kept)
        }
    }
    return visited;
}
function getDirectivesArgumentsTypeNames(schema, astNode) {
    var _a;
    return ((_a = astNode.directives) !== null && _a !== void 0 ? _a : []).flatMap((directive)=>{
        var _a, _b;
        return (_b = (_a = schema.getDirective(directive.name.value)) === null || _a === void 0 ? void 0 : _a.args.map((arg)=>(0, graphql_1.getNamedType)(arg.type).name)) !== null && _b !== void 0 ? _b : [];
    });
}


/***/ }),

/***/ 6068:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.renameType = void 0;
const graphql_1 = __webpack_require__(5736);
function renameType(type, newTypeName) {
    if ((0, graphql_1.isObjectType)(type)) {
        return new graphql_1.GraphQLObjectType({
            ...type.toConfig(),
            name: newTypeName,
            astNode: type.astNode == null ? type.astNode : {
                ...type.astNode,
                name: {
                    ...type.astNode.name,
                    value: newTypeName
                }
            },
            extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node)=>({
                    ...node,
                    name: {
                        ...node.name,
                        value: newTypeName
                    }
                }))
        });
    } else if ((0, graphql_1.isInterfaceType)(type)) {
        return new graphql_1.GraphQLInterfaceType({
            ...type.toConfig(),
            name: newTypeName,
            astNode: type.astNode == null ? type.astNode : {
                ...type.astNode,
                name: {
                    ...type.astNode.name,
                    value: newTypeName
                }
            },
            extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node)=>({
                    ...node,
                    name: {
                        ...node.name,
                        value: newTypeName
                    }
                }))
        });
    } else if ((0, graphql_1.isUnionType)(type)) {
        return new graphql_1.GraphQLUnionType({
            ...type.toConfig(),
            name: newTypeName,
            astNode: type.astNode == null ? type.astNode : {
                ...type.astNode,
                name: {
                    ...type.astNode.name,
                    value: newTypeName
                }
            },
            extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node)=>({
                    ...node,
                    name: {
                        ...node.name,
                        value: newTypeName
                    }
                }))
        });
    } else if ((0, graphql_1.isInputObjectType)(type)) {
        return new graphql_1.GraphQLInputObjectType({
            ...type.toConfig(),
            name: newTypeName,
            astNode: type.astNode == null ? type.astNode : {
                ...type.astNode,
                name: {
                    ...type.astNode.name,
                    value: newTypeName
                }
            },
            extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node)=>({
                    ...node,
                    name: {
                        ...node.name,
                        value: newTypeName
                    }
                }))
        });
    } else if ((0, graphql_1.isEnumType)(type)) {
        return new graphql_1.GraphQLEnumType({
            ...type.toConfig(),
            name: newTypeName,
            astNode: type.astNode == null ? type.astNode : {
                ...type.astNode,
                name: {
                    ...type.astNode.name,
                    value: newTypeName
                }
            },
            extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node)=>({
                    ...node,
                    name: {
                        ...node.name,
                        value: newTypeName
                    }
                }))
        });
    } else if ((0, graphql_1.isScalarType)(type)) {
        return new graphql_1.GraphQLScalarType({
            ...type.toConfig(),
            name: newTypeName,
            astNode: type.astNode == null ? type.astNode : {
                ...type.astNode,
                name: {
                    ...type.astNode.name,
                    value: newTypeName
                }
            },
            extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node)=>({
                    ...node,
                    name: {
                        ...node.name,
                        value: newTypeName
                    }
                }))
        });
    }
    throw new Error(`Unknown type ${type}.`);
}
exports.renameType = renameType;


/***/ }),

/***/ 1125:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.rewireTypes = void 0;
const graphql_1 = __webpack_require__(5736);
const stub_js_1 = __webpack_require__(2090);
function rewireTypes(originalTypeMap, directives) {
    const referenceTypeMap = Object.create(null);
    for(const typeName in originalTypeMap){
        referenceTypeMap[typeName] = originalTypeMap[typeName];
    }
    const newTypeMap = Object.create(null);
    for(const typeName in referenceTypeMap){
        const namedType = referenceTypeMap[typeName];
        if (namedType == null || typeName.startsWith("__")) {
            continue;
        }
        const newName = namedType.name;
        if (newName.startsWith("__")) {
            continue;
        }
        if (newTypeMap[newName] != null) {
            console.warn(`Duplicate schema type name ${newName} found; keeping the existing one found in the schema`);
            continue;
        }
        newTypeMap[newName] = namedType;
    }
    for(const typeName in newTypeMap){
        newTypeMap[typeName] = rewireNamedType(newTypeMap[typeName]);
    }
    const newDirectives = directives.map((directive)=>rewireDirective(directive));
    return {
        typeMap: newTypeMap,
        directives: newDirectives
    };
    function rewireDirective(directive) {
        if ((0, graphql_1.isSpecifiedDirective)(directive)) {
            return directive;
        }
        const directiveConfig = directive.toConfig();
        directiveConfig.args = rewireArgs(directiveConfig.args);
        return new graphql_1.GraphQLDirective(directiveConfig);
    }
    function rewireArgs(args) {
        const rewiredArgs = {};
        for(const argName in args){
            const arg = args[argName];
            const rewiredArgType = rewireType(arg.type);
            if (rewiredArgType != null) {
                arg.type = rewiredArgType;
                rewiredArgs[argName] = arg;
            }
        }
        return rewiredArgs;
    }
    function rewireNamedType(type) {
        if ((0, graphql_1.isObjectType)(type)) {
            const config = type.toConfig();
            const newConfig = {
                ...config,
                fields: ()=>rewireFields(config.fields),
                interfaces: ()=>rewireNamedTypes(config.interfaces)
            };
            return new graphql_1.GraphQLObjectType(newConfig);
        } else if ((0, graphql_1.isInterfaceType)(type)) {
            const config = type.toConfig();
            const newConfig = {
                ...config,
                fields: ()=>rewireFields(config.fields)
            };
            if ("interfaces" in newConfig) {
                newConfig.interfaces = ()=>rewireNamedTypes(config.interfaces);
            }
            return new graphql_1.GraphQLInterfaceType(newConfig);
        } else if ((0, graphql_1.isUnionType)(type)) {
            const config = type.toConfig();
            const newConfig = {
                ...config,
                types: ()=>rewireNamedTypes(config.types)
            };
            return new graphql_1.GraphQLUnionType(newConfig);
        } else if ((0, graphql_1.isInputObjectType)(type)) {
            const config = type.toConfig();
            const newConfig = {
                ...config,
                fields: ()=>rewireInputFields(config.fields)
            };
            return new graphql_1.GraphQLInputObjectType(newConfig);
        } else if ((0, graphql_1.isEnumType)(type)) {
            const enumConfig = type.toConfig();
            return new graphql_1.GraphQLEnumType(enumConfig);
        } else if ((0, graphql_1.isScalarType)(type)) {
            if ((0, graphql_1.isSpecifiedScalarType)(type)) {
                return type;
            }
            const scalarConfig = type.toConfig();
            return new graphql_1.GraphQLScalarType(scalarConfig);
        }
        throw new Error(`Unexpected schema type: ${type}`);
    }
    function rewireFields(fields) {
        const rewiredFields = {};
        for(const fieldName in fields){
            const field = fields[fieldName];
            const rewiredFieldType = rewireType(field.type);
            if (rewiredFieldType != null && field.args) {
                field.type = rewiredFieldType;
                field.args = rewireArgs(field.args);
                rewiredFields[fieldName] = field;
            }
        }
        return rewiredFields;
    }
    function rewireInputFields(fields) {
        const rewiredFields = {};
        for(const fieldName in fields){
            const field = fields[fieldName];
            const rewiredFieldType = rewireType(field.type);
            if (rewiredFieldType != null) {
                field.type = rewiredFieldType;
                rewiredFields[fieldName] = field;
            }
        }
        return rewiredFields;
    }
    function rewireNamedTypes(namedTypes) {
        const rewiredTypes = [];
        for (const namedType of namedTypes){
            const rewiredType = rewireType(namedType);
            if (rewiredType != null) {
                rewiredTypes.push(rewiredType);
            }
        }
        return rewiredTypes;
    }
    function rewireType(type) {
        if ((0, graphql_1.isListType)(type)) {
            const rewiredType = rewireType(type.ofType);
            return rewiredType != null ? new graphql_1.GraphQLList(rewiredType) : null;
        } else if ((0, graphql_1.isNonNullType)(type)) {
            const rewiredType = rewireType(type.ofType);
            return rewiredType != null ? new graphql_1.GraphQLNonNull(rewiredType) : null;
        } else if ((0, graphql_1.isNamedType)(type)) {
            let rewiredType = referenceTypeMap[type.name];
            if (rewiredType === undefined) {
                rewiredType = (0, stub_js_1.isNamedStub)(type) ? (0, stub_js_1.getBuiltInForStub)(type) : rewireNamedType(type);
                newTypeMap[rewiredType.name] = referenceTypeMap[type.name] = rewiredType;
            }
            return rewiredType != null ? newTypeMap[rewiredType.name] : null;
        }
        return null;
    }
}
exports.rewireTypes = rewireTypes;


/***/ }),

/***/ 7839:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getRootTypeMap = exports.getRootTypes = exports.getRootTypeNames = exports.getDefinedRootType = void 0;
const errors_js_1 = __webpack_require__(2422);
const memoize_js_1 = __webpack_require__(9787);
function getDefinedRootType(schema, operation, nodes) {
    const rootTypeMap = (0, exports.getRootTypeMap)(schema);
    const rootType = rootTypeMap.get(operation);
    if (rootType == null) {
        throw (0, errors_js_1.createGraphQLError)(`Schema is not configured to execute ${operation} operation.`, {
            nodes
        });
    }
    return rootType;
}
exports.getDefinedRootType = getDefinedRootType;
exports.getRootTypeNames = (0, memoize_js_1.memoize1)(function getRootTypeNames(schema) {
    const rootTypes = (0, exports.getRootTypes)(schema);
    return new Set([
        ...rootTypes
    ].map((type)=>type.name));
});
exports.getRootTypes = (0, memoize_js_1.memoize1)(function getRootTypes(schema) {
    const rootTypeMap = (0, exports.getRootTypeMap)(schema);
    return new Set(rootTypeMap.values());
});
exports.getRootTypeMap = (0, memoize_js_1.memoize1)(function getRootTypeMap(schema) {
    const rootTypeMap = new Map();
    const queryType = schema.getQueryType();
    if (queryType) {
        rootTypeMap.set("query", queryType);
    }
    const mutationType = schema.getMutationType();
    if (mutationType) {
        rootTypeMap.set("mutation", mutationType);
    }
    const subscriptionType = schema.getSubscriptionType();
    if (subscriptionType) {
        rootTypeMap.set("subscription", subscriptionType);
    }
    return rootTypeMap;
});


/***/ }),

/***/ 9687:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.parseSelectionSet = void 0;
const graphql_1 = __webpack_require__(5736);
function parseSelectionSet(selectionSet, options) {
    const query = (0, graphql_1.parse)(selectionSet, options).definitions[0];
    return query.selectionSet;
}
exports.parseSelectionSet = parseSelectionSet;


/***/ }),

/***/ 2090:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getBuiltInForStub = exports.isNamedStub = exports.createStub = exports.createNamedStub = void 0;
const graphql_1 = __webpack_require__(5736);
function createNamedStub(name, type) {
    let constructor;
    if (type === "object") {
        constructor = graphql_1.GraphQLObjectType;
    } else if (type === "interface") {
        constructor = graphql_1.GraphQLInterfaceType;
    } else {
        constructor = graphql_1.GraphQLInputObjectType;
    }
    return new constructor({
        name,
        fields: {
            _fake: {
                type: graphql_1.GraphQLString
            }
        }
    });
}
exports.createNamedStub = createNamedStub;
function createStub(node, type) {
    switch(node.kind){
        case graphql_1.Kind.LIST_TYPE:
            return new graphql_1.GraphQLList(createStub(node.type, type));
        case graphql_1.Kind.NON_NULL_TYPE:
            return new graphql_1.GraphQLNonNull(createStub(node.type, type));
        default:
            if (type === "output") {
                return createNamedStub(node.name.value, "object");
            }
            return createNamedStub(node.name.value, "input");
    }
}
exports.createStub = createStub;
function isNamedStub(type) {
    if ("getFields" in type) {
        const fields = type.getFields();
        // eslint-disable-next-line no-unreachable-loop
        for(const fieldName in fields){
            const field = fields[fieldName];
            return field.name === "_fake";
        }
    }
    return false;
}
exports.isNamedStub = isNamedStub;
function getBuiltInForStub(type) {
    switch(type.name){
        case graphql_1.GraphQLInt.name:
            return graphql_1.GraphQLInt;
        case graphql_1.GraphQLFloat.name:
            return graphql_1.GraphQLFloat;
        case graphql_1.GraphQLString.name:
            return graphql_1.GraphQLString;
        case graphql_1.GraphQLBoolean.name:
            return graphql_1.GraphQLBoolean;
        case graphql_1.GraphQLID.name:
            return graphql_1.GraphQLID;
        default:
            return type;
    }
}
exports.getBuiltInForStub = getBuiltInForStub;


/***/ }),

/***/ 1843:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.parseInputValueLiteral = exports.parseInputValue = exports.serializeInputValue = exports.transformInputValue = void 0;
const graphql_1 = __webpack_require__(5736);
const helpers_js_1 = __webpack_require__(5551);
function transformInputValue(type, value, inputLeafValueTransformer = null, inputObjectValueTransformer = null) {
    if (value == null) {
        return value;
    }
    const nullableType = (0, graphql_1.getNullableType)(type);
    if ((0, graphql_1.isLeafType)(nullableType)) {
        return inputLeafValueTransformer != null ? inputLeafValueTransformer(nullableType, value) : value;
    } else if ((0, graphql_1.isListType)(nullableType)) {
        return (0, helpers_js_1.asArray)(value).map((listMember)=>transformInputValue(nullableType.ofType, listMember, inputLeafValueTransformer, inputObjectValueTransformer));
    } else if ((0, graphql_1.isInputObjectType)(nullableType)) {
        const fields = nullableType.getFields();
        const newValue = {};
        for(const key in value){
            const field = fields[key];
            if (field != null) {
                newValue[key] = transformInputValue(field.type, value[key], inputLeafValueTransformer, inputObjectValueTransformer);
            }
        }
        return inputObjectValueTransformer != null ? inputObjectValueTransformer(nullableType, newValue) : newValue;
    }
// unreachable, no other possible return value
}
exports.transformInputValue = transformInputValue;
function serializeInputValue(type, value) {
    return transformInputValue(type, value, (t, v)=>{
        try {
            return t.serialize(v);
        } catch (_a) {
            return v;
        }
    });
}
exports.serializeInputValue = serializeInputValue;
function parseInputValue(type, value) {
    return transformInputValue(type, value, (t, v)=>{
        try {
            return t.parseValue(v);
        } catch (_a) {
            return v;
        }
    });
}
exports.parseInputValue = parseInputValue;
function parseInputValueLiteral(type, value) {
    return transformInputValue(type, value, (t, v)=>t.parseLiteral(v, {}));
}
exports.parseInputValueLiteral = parseInputValueLiteral;


/***/ }),

/***/ 2349:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.DirectiveLocation = void 0;
var DirectiveLocation;
(function(DirectiveLocation) {
    /** Request Definitions */ DirectiveLocation["QUERY"] = "QUERY";
    DirectiveLocation["MUTATION"] = "MUTATION";
    DirectiveLocation["SUBSCRIPTION"] = "SUBSCRIPTION";
    DirectiveLocation["FIELD"] = "FIELD";
    DirectiveLocation["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
    DirectiveLocation["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
    DirectiveLocation["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
    DirectiveLocation["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
    /** Type System Definitions */ DirectiveLocation["SCHEMA"] = "SCHEMA";
    DirectiveLocation["SCALAR"] = "SCALAR";
    DirectiveLocation["OBJECT"] = "OBJECT";
    DirectiveLocation["FIELD_DEFINITION"] = "FIELD_DEFINITION";
    DirectiveLocation["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
    DirectiveLocation["INTERFACE"] = "INTERFACE";
    DirectiveLocation["UNION"] = "UNION";
    DirectiveLocation["ENUM"] = "ENUM";
    DirectiveLocation["ENUM_VALUE"] = "ENUM_VALUE";
    DirectiveLocation["INPUT_OBJECT"] = "INPUT_OBJECT";
    DirectiveLocation["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
})(DirectiveLocation = exports.DirectiveLocation || (exports.DirectiveLocation = {}));


/***/ }),

/***/ 2630:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.createVariableNameGenerator = exports.updateArgument = void 0;
const graphql_1 = __webpack_require__(5736);
const astFromType_js_1 = __webpack_require__(3742);
function updateArgument(argumentNodes, variableDefinitionsMap, variableValues, argName, varName, type, value) {
    argumentNodes[argName] = {
        kind: graphql_1.Kind.ARGUMENT,
        name: {
            kind: graphql_1.Kind.NAME,
            value: argName
        },
        value: {
            kind: graphql_1.Kind.VARIABLE,
            name: {
                kind: graphql_1.Kind.NAME,
                value: varName
            }
        }
    };
    variableDefinitionsMap[varName] = {
        kind: graphql_1.Kind.VARIABLE_DEFINITION,
        variable: {
            kind: graphql_1.Kind.VARIABLE,
            name: {
                kind: graphql_1.Kind.NAME,
                value: varName
            }
        },
        type: (0, astFromType_js_1.astFromType)(type)
    };
    if (value !== undefined) {
        variableValues[varName] = value;
        return;
    }
    // including the variable in the map with value of `undefined`
    // will actually be translated by graphql-js into `null`
    // see https://github.com/graphql/graphql-js/issues/2533
    if (varName in variableValues) {
        delete variableValues[varName];
    }
}
exports.updateArgument = updateArgument;
function createVariableNameGenerator(variableDefinitionMap) {
    let varCounter = 0;
    return (argName)=>{
        let varName;
        do {
            varName = `_v${(varCounter++).toString()}_${argName}`;
        }while (varName in variableDefinitionMap);
        return varName;
    };
}
exports.createVariableNameGenerator = createVariableNameGenerator;


/***/ }),

/***/ 520:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.createDefaultRules = exports.validateGraphQlDocuments = void 0;
const graphql_1 = __webpack_require__(5736);
function validateGraphQlDocuments(schema, documents, rules = createDefaultRules()) {
    var _a;
    const definitionMap = new Map();
    for (const document of documents){
        for (const docDefinition of document.definitions){
            if ("name" in docDefinition && docDefinition.name) {
                definitionMap.set(`${docDefinition.kind}_${docDefinition.name.value}`, docDefinition);
            } else {
                definitionMap.set(Date.now().toString(), docDefinition);
            }
        }
    }
    const fullAST = {
        kind: graphql_1.Kind.DOCUMENT,
        definitions: Array.from(definitionMap.values())
    };
    const errors = (0, graphql_1.validate)(schema, fullAST, rules);
    for (const error of errors){
        error.stack = error.message;
        if (error.locations) {
            for (const location of error.locations){
                error.stack += `\n    at ${(_a = error.source) === null || _a === void 0 ? void 0 : _a.name}:${location.line}:${location.column}`;
            }
        }
    }
    return errors;
}
exports.validateGraphQlDocuments = validateGraphQlDocuments;
function createDefaultRules() {
    let ignored = [
        "NoUnusedFragmentsRule",
        "NoUnusedVariablesRule",
        "KnownDirectivesRule"
    ];
    if (graphql_1.versionInfo.major < 15) {
        ignored = ignored.map((rule)=>rule.replace(/Rule$/, ""));
    }
    return graphql_1.specifiedRules.filter((f)=>!ignored.includes(f.name));
}
exports.createDefaultRules = createDefaultRules;


/***/ }),

/***/ 7284:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.valueMatchesCriteria = void 0;
function valueMatchesCriteria(value, criteria) {
    if (value == null) {
        return value === criteria;
    } else if (Array.isArray(value)) {
        return Array.isArray(criteria) && value.every((val, index)=>valueMatchesCriteria(val, criteria[index]));
    } else if (typeof value === "object") {
        return typeof criteria === "object" && criteria && Object.keys(criteria).every((propertyName)=>valueMatchesCriteria(value[propertyName], criteria[propertyName]));
    } else if (criteria instanceof RegExp) {
        return criteria.test(value);
    }
    return value === criteria;
}
exports.valueMatchesCriteria = valueMatchesCriteria;


/***/ }),

/***/ 3063:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.visitResult = exports.visitErrors = exports.visitData = void 0;
const getOperationASTFromRequest_js_1 = __webpack_require__(2325);
const graphql_1 = __webpack_require__(5736);
const collectFields_js_1 = __webpack_require__(1036);
function visitData(data, enter, leave) {
    if (Array.isArray(data)) {
        return data.map((value)=>visitData(value, enter, leave));
    } else if (typeof data === "object") {
        const newData = enter != null ? enter(data) : data;
        if (newData != null) {
            for(const key in newData){
                const value = newData[key];
                Object.defineProperty(newData, key, {
                    value: visitData(value, enter, leave)
                });
            }
        }
        return leave != null ? leave(newData) : newData;
    }
    return data;
}
exports.visitData = visitData;
function visitErrors(errors, visitor) {
    return errors.map((error)=>visitor(error));
}
exports.visitErrors = visitErrors;
function visitResult(result, request, schema, resultVisitorMap, errorVisitorMap) {
    const fragments = request.document.definitions.reduce((acc, def)=>{
        if (def.kind === graphql_1.Kind.FRAGMENT_DEFINITION) {
            acc[def.name.value] = def;
        }
        return acc;
    }, {});
    const variableValues = request.variables || {};
    const errorInfo = {
        segmentInfoMap: new Map(),
        unpathedErrors: new Set()
    };
    const data = result.data;
    const errors = result.errors;
    const visitingErrors = errors != null && errorVisitorMap != null;
    const operationDocumentNode = (0, getOperationASTFromRequest_js_1.getOperationASTFromRequest)(request);
    if (data != null && operationDocumentNode != null) {
        result.data = visitRoot(data, operationDocumentNode, schema, fragments, variableValues, resultVisitorMap, visitingErrors ? errors : undefined, errorInfo);
    }
    if (errors != null && errorVisitorMap) {
        result.errors = visitErrorsByType(errors, errorVisitorMap, errorInfo);
    }
    return result;
}
exports.visitResult = visitResult;
function visitErrorsByType(errors, errorVisitorMap, errorInfo) {
    const segmentInfoMap = errorInfo.segmentInfoMap;
    const unpathedErrors = errorInfo.unpathedErrors;
    const unpathedErrorVisitor = errorVisitorMap["__unpathed"];
    return errors.map((originalError)=>{
        const pathSegmentsInfo = segmentInfoMap.get(originalError);
        const newError = pathSegmentsInfo == null ? originalError : pathSegmentsInfo.reduceRight((acc, segmentInfo)=>{
            const typeName = segmentInfo.type.name;
            const typeVisitorMap = errorVisitorMap[typeName];
            if (typeVisitorMap == null) {
                return acc;
            }
            const errorVisitor = typeVisitorMap[segmentInfo.fieldName];
            return errorVisitor == null ? acc : errorVisitor(acc, segmentInfo.pathIndex);
        }, originalError);
        if (unpathedErrorVisitor && unpathedErrors.has(originalError)) {
            return unpathedErrorVisitor(newError);
        }
        return newError;
    });
}
function getOperationRootType(schema, operationDef) {
    switch(operationDef.operation){
        case "query":
            return schema.getQueryType();
        case "mutation":
            return schema.getMutationType();
        case "subscription":
            return schema.getSubscriptionType();
    }
}
function visitRoot(root, operation, schema, fragments, variableValues, resultVisitorMap, errors, errorInfo) {
    const operationRootType = getOperationRootType(schema, operation);
    const { fields: collectedFields  } = (0, collectFields_js_1.collectFields)(schema, fragments, variableValues, operationRootType, operation.selectionSet);
    return visitObjectValue(root, operationRootType, collectedFields, schema, fragments, variableValues, resultVisitorMap, 0, errors, errorInfo);
}
function visitObjectValue(object, type, fieldNodeMap, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo) {
    var _a;
    const fieldMap = type.getFields();
    const typeVisitorMap = resultVisitorMap === null || resultVisitorMap === void 0 ? void 0 : resultVisitorMap[type.name];
    const enterObject = typeVisitorMap === null || typeVisitorMap === void 0 ? void 0 : typeVisitorMap.__enter;
    const newObject = enterObject != null ? enterObject(object) : object;
    let sortedErrors;
    let errorMap = null;
    if (errors != null) {
        sortedErrors = sortErrorsByPathSegment(errors, pathIndex);
        errorMap = sortedErrors.errorMap;
        for (const error of sortedErrors.unpathedErrors){
            errorInfo.unpathedErrors.add(error);
        }
    }
    for (const [responseKey, subFieldNodes] of fieldNodeMap){
        const fieldName = subFieldNodes[0].name.value;
        let fieldType = (_a = fieldMap[fieldName]) === null || _a === void 0 ? void 0 : _a.type;
        if (fieldType == null) {
            switch(fieldName){
                case "__typename":
                    fieldType = graphql_1.TypeNameMetaFieldDef.type;
                    break;
                case "__schema":
                    fieldType = graphql_1.SchemaMetaFieldDef.type;
                    break;
                case "__type":
                    fieldType = graphql_1.TypeMetaFieldDef.type;
                    break;
            }
        }
        const newPathIndex = pathIndex + 1;
        let fieldErrors;
        if (errorMap) {
            fieldErrors = errorMap[responseKey];
            if (fieldErrors != null) {
                delete errorMap[responseKey];
            }
            addPathSegmentInfo(type, fieldName, newPathIndex, fieldErrors, errorInfo);
        }
        const newValue = visitFieldValue(object[responseKey], fieldType, subFieldNodes, schema, fragments, variableValues, resultVisitorMap, newPathIndex, fieldErrors, errorInfo);
        updateObject(newObject, responseKey, newValue, typeVisitorMap, fieldName);
    }
    const oldTypename = newObject.__typename;
    if (oldTypename != null) {
        updateObject(newObject, "__typename", oldTypename, typeVisitorMap, "__typename");
    }
    if (errorMap) {
        for(const errorsKey in errorMap){
            const errors = errorMap[errorsKey];
            for (const error of errors){
                errorInfo.unpathedErrors.add(error);
            }
        }
    }
    const leaveObject = typeVisitorMap === null || typeVisitorMap === void 0 ? void 0 : typeVisitorMap.__leave;
    return leaveObject != null ? leaveObject(newObject) : newObject;
}
function updateObject(object, responseKey, newValue, typeVisitorMap, fieldName) {
    if (typeVisitorMap == null) {
        object[responseKey] = newValue;
        return;
    }
    const fieldVisitor = typeVisitorMap[fieldName];
    if (fieldVisitor == null) {
        object[responseKey] = newValue;
        return;
    }
    const visitedValue = fieldVisitor(newValue);
    if (visitedValue === undefined) {
        delete object[responseKey];
        return;
    }
    object[responseKey] = visitedValue;
}
function visitListValue(list, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo) {
    return list.map((listMember)=>visitFieldValue(listMember, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex + 1, errors, errorInfo));
}
function visitFieldValue(value, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors = [], errorInfo) {
    if (value == null) {
        return value;
    }
    const nullableType = (0, graphql_1.getNullableType)(returnType);
    if ((0, graphql_1.isListType)(nullableType)) {
        return visitListValue(value, nullableType.ofType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);
    } else if ((0, graphql_1.isAbstractType)(nullableType)) {
        const finalType = schema.getType(value.__typename);
        const { fields: collectedFields  } = (0, collectFields_js_1.collectSubFields)(schema, fragments, variableValues, finalType, fieldNodes);
        return visitObjectValue(value, finalType, collectedFields, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);
    } else if ((0, graphql_1.isObjectType)(nullableType)) {
        const { fields: collectedFields  } = (0, collectFields_js_1.collectSubFields)(schema, fragments, variableValues, nullableType, fieldNodes);
        return visitObjectValue(value, nullableType, collectedFields, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);
    }
    const typeVisitorMap = resultVisitorMap === null || resultVisitorMap === void 0 ? void 0 : resultVisitorMap[nullableType.name];
    if (typeVisitorMap == null) {
        return value;
    }
    const visitedValue = typeVisitorMap(value);
    return visitedValue === undefined ? value : visitedValue;
}
function sortErrorsByPathSegment(errors, pathIndex) {
    var _a;
    const errorMap = Object.create(null);
    const unpathedErrors = new Set();
    for (const error of errors){
        const pathSegment = (_a = error.path) === null || _a === void 0 ? void 0 : _a[pathIndex];
        if (pathSegment == null) {
            unpathedErrors.add(error);
            continue;
        }
        if (pathSegment in errorMap) {
            errorMap[pathSegment].push(error);
        } else {
            errorMap[pathSegment] = [
                error
            ];
        }
    }
    return {
        errorMap,
        unpathedErrors
    };
}
function addPathSegmentInfo(type, fieldName, pathIndex, errors = [], errorInfo) {
    for (const error of errors){
        const segmentInfo = {
            type,
            fieldName,
            pathIndex
        };
        const pathSegmentsInfo = errorInfo.segmentInfoMap.get(error);
        if (pathSegmentsInfo == null) {
            errorInfo.segmentInfoMap.set(error, [
                segmentInfo
            ]);
        } else {
            pathSegmentsInfo.push(segmentInfo);
        }
    }
}


/***/ }),

/***/ 4626:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.withCancel = exports.getAsyncIterableWithCancel = exports.getAsyncIteratorWithCancel = void 0;
const memoize_js_1 = __webpack_require__(9787);
async function defaultAsyncIteratorReturn(value) {
    return {
        value,
        done: true
    };
}
const proxyMethodFactory = (0, memoize_js_1.memoize2)(function proxyMethodFactory(target, targetMethod) {
    return function proxyMethod(...args) {
        return Reflect.apply(targetMethod, target, args);
    };
});
function getAsyncIteratorWithCancel(asyncIterator, onCancel) {
    return new Proxy(asyncIterator, {
        has (asyncIterator, prop) {
            if (prop === "return") {
                return true;
            }
            return Reflect.has(asyncIterator, prop);
        },
        get (asyncIterator, prop, receiver) {
            const existingPropValue = Reflect.get(asyncIterator, prop, receiver);
            if (prop === "return") {
                const existingReturn = existingPropValue || defaultAsyncIteratorReturn;
                return async function returnWithCancel(value) {
                    const returnValue = await onCancel(value);
                    return Reflect.apply(existingReturn, asyncIterator, [
                        returnValue
                    ]);
                };
            } else if (typeof existingPropValue === "function") {
                return proxyMethodFactory(asyncIterator, existingPropValue);
            }
            return existingPropValue;
        }
    });
}
exports.getAsyncIteratorWithCancel = getAsyncIteratorWithCancel;
function getAsyncIterableWithCancel(asyncIterable, onCancel) {
    return new Proxy(asyncIterable, {
        get (asyncIterable, prop, receiver) {
            const existingPropValue = Reflect.get(asyncIterable, prop, receiver);
            if (Symbol.asyncIterator === prop) {
                return function asyncIteratorFactory() {
                    const asyncIterator = Reflect.apply(existingPropValue, asyncIterable, []);
                    return getAsyncIteratorWithCancel(asyncIterator, onCancel);
                };
            } else if (typeof existingPropValue === "function") {
                return proxyMethodFactory(asyncIterable, existingPropValue);
            }
            return existingPropValue;
        }
    });
}
exports.getAsyncIterableWithCancel = getAsyncIterableWithCancel;
exports.withCancel = getAsyncIterableWithCancel;


/***/ }),

/***/ 4521:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/* eslint-disable @typescript-eslint/no-explicit-any */ /* eslint-disable no-console */ Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.createLogger = exports.debugPrefix = exports.errorPrefix = exports.infoPrefix = exports.warnPrefix = void 0;
const ansiCodes = {
    red: "\x1b[31m",
    yellow: "\x1b[33m",
    magenta: "\x1b[35m",
    cyan: "\x1b[36m",
    reset: "\x1b[0m"
};
exports.warnPrefix = ansiCodes.yellow + "WARN" + ansiCodes.reset;
exports.infoPrefix = ansiCodes.cyan + "INFO" + ansiCodes.reset;
exports.errorPrefix = ansiCodes.red + "ERR" + ansiCodes.reset;
exports.debugPrefix = ansiCodes.magenta + "DEBUG" + ansiCodes.reset;
const logLevelScores = {
    debug: 0,
    info: 1,
    warn: 2,
    error: 3,
    silent: 4
};
// eslint-disable-next-line @typescript-eslint/no-empty-function
const noop = ()=>{};
const consoleLog = (prefix)=>(...args)=>console.log(prefix, ...args);
const debugLog = console.debug ? (...args)=>console.debug(exports.debugPrefix, ...args) : consoleLog(exports.debugPrefix);
const infoLog = console.info ? (...args)=>console.info(exports.infoPrefix, ...args) : consoleLog(exports.infoPrefix);
const warnLog = console.warn ? (...args)=>console.warn(exports.warnPrefix, ...args) : consoleLog(exports.warnPrefix);
const errorLog = console.error ? (...args)=>console.error(exports.errorPrefix, ...args) : consoleLog(exports.errorPrefix);
const createLogger = (logLevel = globalThis.process?.env["DEBUG"] === "1" ? "debug" : "info")=>{
    const score = logLevelScores[logLevel];
    return {
        debug: score > logLevelScores.debug ? noop : debugLog,
        info: score > logLevelScores.info ? noop : infoLog,
        warn: score > logLevelScores.warn ? noop : warnLog,
        error: score > logLevelScores.error ? noop : errorLog
    };
};
exports.createLogger = createLogger;


/***/ }),

/***/ 6077:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.createPubSub = void 0;
const repeater_1 = __webpack_require__(1963);
const events_1 = __webpack_require__(1919);
/**
 * Utility for publishing and subscribing to events.
 */ const createPubSub = (config)=>{
    const target = config?.eventTarget ?? new events_1.EventTarget();
    return {
        publish (routingKey, ...args) {
            const payload = args[1] ?? args[0];
            const topic = args[1] === undefined ? routingKey : `${routingKey}:${args[0]}`;
            const event = new events_1.CustomEvent(topic, {
                detail: payload
            });
            target.dispatchEvent(event);
        },
        subscribe (...[routingKey, id]) {
            const topic = id === undefined ? routingKey : `${routingKey}:${id}`;
            return new repeater_1.Repeater(function subscriptionRepeater(next, stop) {
                stop.then(function subscriptionRepeaterStopHandler() {
                    target.removeEventListener(topic, pubsubEventListener);
                });
                target.addEventListener(topic, pubsubEventListener);
                function pubsubEventListener(event) {
                    next(event.detail);
                }
            });
        }
    };
};
exports.createPubSub = createPubSub;


/***/ }),

/***/ 7047:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.Repeater = exports.pipe = exports.map = exports.filter = exports.createPubSub = void 0;
var create_pub_sub_js_1 = __webpack_require__(6077);
Object.defineProperty(exports, "createPubSub", ({
    enumerable: true,
    get: function() {
        return create_pub_sub_js_1.createPubSub;
    }
}));
var filter_js_1 = __webpack_require__(7130);
Object.defineProperty(exports, "filter", ({
    enumerable: true,
    get: function() {
        return filter_js_1.filter;
    }
}));
var map_js_1 = __webpack_require__(2432);
Object.defineProperty(exports, "map", ({
    enumerable: true,
    get: function() {
        return map_js_1.map;
    }
}));
var pipe_js_1 = __webpack_require__(2091);
Object.defineProperty(exports, "pipe", ({
    enumerable: true,
    get: function() {
        return pipe_js_1.pipe;
    }
}));
var repeater_1 = __webpack_require__(1963);
Object.defineProperty(exports, "Repeater", ({
    enumerable: true,
    get: function() {
        return repeater_1.Repeater;
    }
}));


/***/ }),

/***/ 7130:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.filter = void 0;
const repeater_1 = __webpack_require__(1963);
function filter(filter) {
    return (source)=>new repeater_1.Repeater(async (push, stop)=>{
            const iterable = source[Symbol.asyncIterator]();
            stop.then(()=>{
                iterable.return?.();
            });
            let latest;
            while((latest = await iterable.next()).done === false){
                if (await filter(latest.value)) {
                    await push(latest.value);
                }
            }
            stop();
        });
}
exports.filter = filter;


/***/ }),

/***/ 2432:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.map = void 0;
const repeater_1 = __webpack_require__(1963);
/**
 * Utility for mapping an event stream.
 */ const map = (mapper)=>(source)=>new repeater_1.Repeater(async (push, stop)=>{
            const iterable = source[Symbol.asyncIterator]();
            stop.then(()=>{
                iterable.return?.();
            });
            let latest;
            while((latest = await iterable.next()).done === false){
                await push(await mapper(latest.value));
            }
            stop();
        });
exports.map = map;


/***/ }),

/***/ 2091:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.pipe = void 0;
function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {
    switch(arguments.length){
        case 1:
            return a;
        case 2:
            return ab(a);
        case 3:
            return bc(ab(a));
        case 4:
            return cd(bc(ab(a)));
        case 5:
            return de(cd(bc(ab(a))));
        case 6:
            return ef(de(cd(bc(ab(a)))));
        case 7:
            return fg(ef(de(cd(bc(ab(a))))));
        case 8:
            return gh(fg(ef(de(cd(bc(ab(a)))))));
        case 9:
            return hi(gh(fg(ef(de(cd(bc(ab(a))))))));
        default:
            // eslint-disable-next-line no-case-declarations, prefer-rest-params
            let ret = arguments[0];
            for(let i = 1; i < arguments.length; i++){
                // eslint-disable-next-line prefer-rest-params
                ret = arguments[i](ret);
            }
            return ret;
    }
}
exports.pipe = pipe;


/***/ }),

/***/ 1963:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */ /* global Reflect, Promise */ var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || ({
        __proto__: []
    }) instanceof Array && function(d, b) {
        d.__proto__ = b;
    } || function(d, b) {
        for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
    };
    return extendStatics(d, b);
};
function __extends(d, b) {
    extendStatics(d, b);
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}
function __generator(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
}
function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
    }, i;
    function verb(n) {
        if (g[n]) i[n] = function(v) {
            return new Promise(function(a, b) {
                q.push([
                    n,
                    v,
                    a,
                    b
                ]) > 1 || resume(n, v);
            });
        };
    }
    function resume(n, v) {
        try {
            step(g[n](v));
        } catch (e) {
            settle(q[0][3], e);
        }
    }
    function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
        resume("next", value);
    }
    function reject(value) {
        resume("throw", value);
    }
    function settle(f, v) {
        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
    }
}
/** An error subclass which is thrown when there are too many pending push or next operations on a single repeater. */ var RepeaterOverflowError = /** @class */ function(_super) {
    __extends(RepeaterOverflowError, _super);
    function RepeaterOverflowError(message) {
        var _this = _super.call(this, message) || this;
        Object.defineProperty(_this, "name", {
            value: "RepeaterOverflowError",
            enumerable: false
        });
        if (typeof Object.setPrototypeOf === "function") {
            Object.setPrototypeOf(_this, _this.constructor.prototype);
        } else {
            _this.__proto__ = _this.constructor.prototype;
        }
        if (typeof Error.captureStackTrace === "function") {
            Error.captureStackTrace(_this, _this.constructor);
        }
        return _this;
    }
    return RepeaterOverflowError;
}(Error);
/** A buffer which allows you to push a set amount of values to the repeater without pushes waiting or throwing errors. */ var FixedBuffer = /** @class */ function() {
    function FixedBuffer(capacity) {
        if (capacity < 0) {
            throw new RangeError("Capacity may not be less than 0");
        }
        this._c = capacity;
        this._q = [];
    }
    Object.defineProperty(FixedBuffer.prototype, "empty", {
        get: function() {
            return this._q.length === 0;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FixedBuffer.prototype, "full", {
        get: function() {
            return this._q.length >= this._c;
        },
        enumerable: false,
        configurable: true
    });
    FixedBuffer.prototype.add = function(value) {
        if (this.full) {
            throw new Error("Buffer full");
        } else {
            this._q.push(value);
        }
    };
    FixedBuffer.prototype.remove = function() {
        if (this.empty) {
            throw new Error("Buffer empty");
        }
        return this._q.shift();
    };
    return FixedBuffer;
}();
// TODO: Use a circular buffer here.
/** Sliding buffers allow you to push a set amount of values to the repeater without pushes waiting or throwing errors. If the number of values exceeds the capacity set in the constructor, the buffer will discard the earliest values added. */ var SlidingBuffer = /** @class */ function() {
    function SlidingBuffer(capacity) {
        if (capacity < 1) {
            throw new RangeError("Capacity may not be less than 1");
        }
        this._c = capacity;
        this._q = [];
    }
    Object.defineProperty(SlidingBuffer.prototype, "empty", {
        get: function() {
            return this._q.length === 0;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SlidingBuffer.prototype, "full", {
        get: function() {
            return false;
        },
        enumerable: false,
        configurable: true
    });
    SlidingBuffer.prototype.add = function(value) {
        while(this._q.length >= this._c){
            this._q.shift();
        }
        this._q.push(value);
    };
    SlidingBuffer.prototype.remove = function() {
        if (this.empty) {
            throw new Error("Buffer empty");
        }
        return this._q.shift();
    };
    return SlidingBuffer;
}();
/** Dropping buffers allow you to push a set amount of values to the repeater without the push function waiting or throwing errors. If the number of values exceeds the capacity set in the constructor, the buffer will discard the latest values added. */ var DroppingBuffer = /** @class */ function() {
    function DroppingBuffer(capacity) {
        if (capacity < 1) {
            throw new RangeError("Capacity may not be less than 1");
        }
        this._c = capacity;
        this._q = [];
    }
    Object.defineProperty(DroppingBuffer.prototype, "empty", {
        get: function() {
            return this._q.length === 0;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DroppingBuffer.prototype, "full", {
        get: function() {
            return false;
        },
        enumerable: false,
        configurable: true
    });
    DroppingBuffer.prototype.add = function(value) {
        if (this._q.length < this._c) {
            this._q.push(value);
        }
    };
    DroppingBuffer.prototype.remove = function() {
        if (this.empty) {
            throw new Error("Buffer empty");
        }
        return this._q.shift();
    };
    return DroppingBuffer;
}();
/** Makes sure promise-likes dont cause unhandled rejections. */ function swallow(value) {
    if (value != null && typeof value.then === "function") {
        value.then(NOOP, NOOP);
    }
}
/*** REPEATER STATES ***/ /** The following is an enumeration of all possible repeater states. These states are ordered, and a repeater may only advance to higher states. */ /** The initial state of the repeater. */ var Initial = 0;
/** Repeaters advance to this state the first time the next method is called on the repeater. */ var Started = 1;
/** Repeaters advance to this state when the stop function is called. */ var Stopped = 2;
/** Repeaters advance to this state when there are no values left to be pulled from the repeater. */ var Done = 3;
/** Repeaters advance to this state if an error is thrown into the repeater. */ var Rejected = 4;
/** The maximum number of push or next operations which may exist on a single repeater. */ var MAX_QUEUE_LENGTH = 1024;
var NOOP = function() {};
/** A helper function used to mimic the behavior of async generators where the final iteration is consumed. */ function consumeExecution(r) {
    var err = r.err;
    var execution = Promise.resolve(r.execution).then(function(value) {
        if (err != null) {
            throw err;
        }
        return value;
    });
    r.err = undefined;
    r.execution = execution.then(function() {
        return undefined;
    }, function() {
        return undefined;
    });
    return r.pending === undefined ? execution : r.pending.then(function() {
        return execution;
    });
}
/** A helper function for building iterations from values. Promises are unwrapped, so that iterations never have their value property set to a promise. */ function createIteration(r, value) {
    var done = r.state >= Done;
    return Promise.resolve(value).then(function(value) {
        if (!done && r.state >= Rejected) {
            return consumeExecution(r).then(function(value) {
                return {
                    value: value,
                    done: true
                };
            });
        }
        return {
            value: value,
            done: done
        };
    });
}
/**
 * This function is bound and passed to the executor as the stop argument.
 *
 * Advances state to Stopped.
 */ function stop(r, err) {
    var e_1, _a;
    if (r.state >= Stopped) {
        return;
    }
    r.state = Stopped;
    r.onnext();
    r.onstop();
    if (r.err == null) {
        r.err = err;
    }
    if (r.pushes.length === 0 && (typeof r.buffer === "undefined" || r.buffer.empty)) {
        finish(r);
    } else {
        try {
            for(var _b = __values(r.pushes), _d = _b.next(); !_d.done; _d = _b.next()){
                var push_1 = _d.value;
                push_1.resolve();
            }
        } catch (e_1_1) {
            e_1 = {
                error: e_1_1
            };
        } finally{
            try {
                if (_d && !_d.done && (_a = _b.return)) _a.call(_b);
            } finally{
                if (e_1) throw e_1.error;
            }
        }
    }
}
/**
 * The difference between stopping a repeater vs finishing a repeater is that stopping a repeater allows next to continue to drain values from the push queue and buffer, while finishing a repeater will clear all pending values and end iteration immediately. Once, a repeater is finished, all iterations will have the done property set to true.
 *
 * Advances state to Done.
 */ function finish(r) {
    var e_2, _a;
    if (r.state >= Done) {
        return;
    }
    if (r.state < Stopped) {
        stop(r);
    }
    r.state = Done;
    r.buffer = undefined;
    try {
        for(var _b = __values(r.nexts), _d = _b.next(); !_d.done; _d = _b.next()){
            var next = _d.value;
            var execution = r.pending === undefined ? consumeExecution(r) : r.pending.then(function() {
                return consumeExecution(r);
            });
            next.resolve(createIteration(r, execution));
        }
    } catch (e_2_1) {
        e_2 = {
            error: e_2_1
        };
    } finally{
        try {
            if (_d && !_d.done && (_a = _b.return)) _a.call(_b);
        } finally{
            if (e_2) throw e_2.error;
        }
    }
    r.pushes = [];
    r.nexts = [];
}
/**
 * Called when a promise passed to push rejects, or when a push call is unhandled.
 *
 * Advances state to Rejected.
 */ function reject(r) {
    if (r.state >= Rejected) {
        return;
    }
    if (r.state < Done) {
        finish(r);
    }
    r.state = Rejected;
}
/** This function is bound and passed to the executor as the push argument. */ function push(r, value) {
    swallow(value);
    if (r.pushes.length >= MAX_QUEUE_LENGTH) {
        throw new RepeaterOverflowError("No more than " + MAX_QUEUE_LENGTH + " pending calls to push are allowed on a single repeater.");
    } else if (r.state >= Stopped) {
        return Promise.resolve(undefined);
    }
    var valueP = r.pending === undefined ? Promise.resolve(value) : r.pending.then(function() {
        return value;
    });
    valueP = valueP.catch(function(err) {
        if (r.state < Stopped) {
            r.err = err;
        }
        reject(r);
        return undefined; // void :(
    });
    var nextP;
    if (r.nexts.length) {
        var next_1 = r.nexts.shift();
        next_1.resolve(createIteration(r, valueP));
        if (r.nexts.length) {
            nextP = Promise.resolve(r.nexts[0].value);
        } else {
            nextP = new Promise(function(resolve) {
                return r.onnext = resolve;
            });
        }
    } else if (typeof r.buffer !== "undefined" && !r.buffer.full) {
        r.buffer.add(valueP);
        nextP = Promise.resolve(undefined);
    } else {
        nextP = new Promise(function(resolve) {
            return r.pushes.push({
                resolve: resolve,
                value: valueP
            });
        });
    }
    // If an error is thrown into the repeater via the next or throw methods, we give the repeater a chance to handle this by rejecting the promise returned from push. If the push call is not immediately handled we throw the next iteration of the repeater.
    // To check that the promise returned from push is floating, we modify the then and catch methods of the returned promise so that they flip the floating flag. The push function actually does not return a promise, because modern engines do not call the then and catch methods on native promises. By making next a plain old javascript object, we ensure that the then and catch methods will be called.
    var floating = true;
    var next = {};
    var unhandled = nextP.catch(function(err) {
        if (floating) {
            throw err;
        }
        return undefined; // void :(
    });
    next.then = function(onfulfilled, onrejected) {
        floating = false;
        return Promise.prototype.then.call(nextP, onfulfilled, onrejected);
    };
    next.catch = function(onrejected) {
        floating = false;
        return Promise.prototype.catch.call(nextP, onrejected);
    };
    next.finally = nextP.finally.bind(nextP);
    r.pending = valueP.then(function() {
        return unhandled;
    }).catch(function(err) {
        r.err = err;
        reject(r);
    });
    return next;
}
/**
 * Creates the stop callable promise which is passed to the executor
 */ function createStop(r) {
    var stop1 = stop.bind(null, r);
    var stopP = new Promise(function(resolve) {
        return r.onstop = resolve;
    });
    stop1.then = stopP.then.bind(stopP);
    stop1.catch = stopP.catch.bind(stopP);
    stop1.finally = stopP.finally.bind(stopP);
    return stop1;
}
/**
 * Calls the executor passed into the constructor. This function is called the first time the next method is called on the repeater.
 *
 * Advances state to Started.
 */ function execute(r) {
    if (r.state >= Started) {
        return;
    }
    r.state = Started;
    var push1 = push.bind(null, r);
    var stop1 = createStop(r);
    r.execution = new Promise(function(resolve) {
        return resolve(r.executor(push1, stop1));
    });
    // TODO: We should consider stopping all repeaters when the executor settles.
    r.execution.catch(function() {
        return stop(r);
    });
}
var records = new WeakMap();
// NOTE: While repeaters implement and are assignable to the AsyncGenerator interface, and you can use the types interchangeably, we dont use typescripts implements syntax here because this would make supporting earlier versions of typescript trickier. This is because TypeScript version 3.6 changed the iterator types by adding the TReturn and TNext type parameters.
var Repeater = /** @class */ function() {
    function Repeater(executor, buffer) {
        records.set(this, {
            executor: executor,
            buffer: buffer,
            err: undefined,
            state: Initial,
            pushes: [],
            nexts: [],
            pending: undefined,
            execution: undefined,
            onnext: NOOP,
            onstop: NOOP
        });
    }
    Repeater.prototype.next = function(value) {
        swallow(value);
        var r = records.get(this);
        if (r === undefined) {
            throw new Error("WeakMap error");
        }
        if (r.nexts.length >= MAX_QUEUE_LENGTH) {
            throw new RepeaterOverflowError("No more than " + MAX_QUEUE_LENGTH + " pending calls to next are allowed on a single repeater.");
        }
        if (r.state <= Initial) {
            execute(r);
        }
        r.onnext(value);
        if (typeof r.buffer !== "undefined" && !r.buffer.empty) {
            var result = createIteration(r, r.buffer.remove());
            if (r.pushes.length) {
                var push_2 = r.pushes.shift();
                r.buffer.add(push_2.value);
                r.onnext = push_2.resolve;
            }
            return result;
        } else if (r.pushes.length) {
            var push_3 = r.pushes.shift();
            r.onnext = push_3.resolve;
            return createIteration(r, push_3.value);
        } else if (r.state >= Stopped) {
            finish(r);
            return createIteration(r, consumeExecution(r));
        }
        return new Promise(function(resolve) {
            return r.nexts.push({
                resolve: resolve,
                value: value
            });
        });
    };
    Repeater.prototype.return = function(value) {
        swallow(value);
        var r = records.get(this);
        if (r === undefined) {
            throw new Error("WeakMap error");
        }
        finish(r);
        // We override the execution because return should always return the value passed in.
        r.execution = Promise.resolve(r.execution).then(function() {
            return value;
        });
        return createIteration(r, consumeExecution(r));
    };
    Repeater.prototype.throw = function(err) {
        var r = records.get(this);
        if (r === undefined) {
            throw new Error("WeakMap error");
        }
        if (r.state <= Initial || r.state >= Stopped || typeof r.buffer !== "undefined" && !r.buffer.empty) {
            finish(r);
            // If r.err is already set, that mean the repeater has already produced an error, so we throw that error rather than the error passed in, because doing so might be more informative for the caller.
            if (r.err == null) {
                r.err = err;
            }
            return createIteration(r, consumeExecution(r));
        }
        return this.next(Promise.reject(err));
    };
    Repeater.prototype[Symbol.asyncIterator] = function() {
        return this;
    };
    // TODO: Remove these static methods from the class.
    Repeater.race = race;
    Repeater.merge = merge;
    Repeater.zip = zip;
    Repeater.latest = latest;
    return Repeater;
}();
/*** COMBINATOR FUNCTIONS ***/ // TODO: move these combinators to their own file.
function getIterators(values, options) {
    var e_3, _a;
    var iters = [];
    var _loop_1 = function(value) {
        if (value != null && typeof value[Symbol.asyncIterator] === "function") {
            iters.push(value[Symbol.asyncIterator]());
        } else if (value != null && typeof value[Symbol.iterator] === "function") {
            iters.push(value[Symbol.iterator]());
        } else {
            iters.push(function valueToAsyncIterator() {
                return __asyncGenerator(this, arguments, function valueToAsyncIterator_1() {
                    return __generator(this, function(_a) {
                        switch(_a.label){
                            case 0:
                                if (!options.yieldValues) return [
                                    3 /*break*/ ,
                                    3
                                ];
                                return [
                                    4 /*yield*/ ,
                                    __await(value)
                                ];
                            case 1:
                                return [
                                    4 /*yield*/ ,
                                    _a.sent()
                                ];
                            case 2:
                                _a.sent();
                                _a.label = 3;
                            case 3:
                                if (!options.returnValues) return [
                                    3 /*break*/ ,
                                    5
                                ];
                                return [
                                    4 /*yield*/ ,
                                    __await(value)
                                ];
                            case 4:
                                return [
                                    2 /*return*/ ,
                                    _a.sent()
                                ];
                            case 5:
                                return [
                                    2 /*return*/ 
                                ];
                        }
                    });
                });
            }());
        }
    };
    try {
        for(var values_1 = __values(values), values_1_1 = values_1.next(); !values_1_1.done; values_1_1 = values_1.next()){
            var value = values_1_1.value;
            _loop_1(value);
        }
    } catch (e_3_1) {
        e_3 = {
            error: e_3_1
        };
    } finally{
        try {
            if (values_1_1 && !values_1_1.done && (_a = values_1.return)) _a.call(values_1);
        } finally{
            if (e_3) throw e_3.error;
        }
    }
    return iters;
}
// NOTE: whenever you see any variables called `advance` or `advances`, know that it is a hack to get around the fact that `Promise.race` leaks memory. These variables are intended to be set to the resolve function of a promise which is constructed and awaited as an alternative to Promise.race. For more information, see this comment in the Node.js issue tracker: https://github.com/nodejs/node/issues/17469#issuecomment-685216777.
function race(contenders) {
    var _this = this;
    var iters = getIterators(contenders, {
        returnValues: true
    });
    return new Repeater(function(push, stop) {
        return __awaiter(_this, void 0, void 0, function() {
            var advance, stopped, finalIteration, iteration, i_1, _loop_2;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        if (!iters.length) {
                            stop();
                            return [
                                2 /*return*/ 
                            ];
                        }
                        stopped = false;
                        stop.then(function() {
                            advance();
                            stopped = true;
                        });
                        _a.label = 1;
                    case 1:
                        _a.trys.push([
                            1,
                            ,
                            5,
                            7
                        ]);
                        iteration = void 0;
                        i_1 = 0;
                        _loop_2 = function() {
                            var j, iters_1, iters_1_1, iter;
                            var e_4, _a;
                            return __generator(this, function(_b) {
                                switch(_b.label){
                                    case 0:
                                        j = i_1;
                                        try {
                                            for(iters_1 = (e_4 = void 0, __values(iters)), iters_1_1 = iters_1.next(); !iters_1_1.done; iters_1_1 = iters_1.next()){
                                                iter = iters_1_1.value;
                                                Promise.resolve(iter.next()).then(function(iteration) {
                                                    if (iteration.done) {
                                                        stop();
                                                        if (finalIteration === undefined) {
                                                            finalIteration = iteration;
                                                        }
                                                    } else if (i_1 === j) {
                                                        // This iterator has won, advance i and resolve the promise.
                                                        i_1++;
                                                        advance(iteration);
                                                    }
                                                }, function(err) {
                                                    return stop(err);
                                                });
                                            }
                                        } catch (e_4_1) {
                                            e_4 = {
                                                error: e_4_1
                                            };
                                        } finally{
                                            try {
                                                if (iters_1_1 && !iters_1_1.done && (_a = iters_1.return)) _a.call(iters_1);
                                            } finally{
                                                if (e_4) throw e_4.error;
                                            }
                                        }
                                        return [
                                            4 /*yield*/ ,
                                            new Promise(function(resolve) {
                                                return advance = resolve;
                                            })
                                        ];
                                    case 1:
                                        iteration = _b.sent();
                                        if (!(iteration !== undefined)) return [
                                            3 /*break*/ ,
                                            3
                                        ];
                                        return [
                                            4 /*yield*/ ,
                                            push(iteration.value)
                                        ];
                                    case 2:
                                        _b.sent();
                                        _b.label = 3;
                                    case 3:
                                        return [
                                            2 /*return*/ 
                                        ];
                                }
                            });
                        };
                        _a.label = 2;
                    case 2:
                        if (!!stopped) return [
                            3 /*break*/ ,
                            4
                        ];
                        return [
                            5 /*yield**/ ,
                            _loop_2()
                        ];
                    case 3:
                        _a.sent();
                        return [
                            3 /*break*/ ,
                            2
                        ];
                    case 4:
                        return [
                            2 /*return*/ ,
                            finalIteration && finalIteration.value
                        ];
                    case 5:
                        stop();
                        return [
                            4 /*yield*/ ,
                            Promise.race(iters.map(function(iter) {
                                return iter.return && iter.return();
                            }))
                        ];
                    case 6:
                        _a.sent();
                        return [
                            7 /*endfinally*/ 
                        ];
                    case 7:
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    });
}
function merge(contenders) {
    var _this = this;
    var iters = getIterators(contenders, {
        yieldValues: true
    });
    return new Repeater(function(push, stop) {
        return __awaiter(_this, void 0, void 0, function() {
            var advances, stopped, finalIteration;
            var _this = this;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        if (!iters.length) {
                            stop();
                            return [
                                2 /*return*/ 
                            ];
                        }
                        advances = [];
                        stopped = false;
                        stop.then(function() {
                            var e_5, _a;
                            stopped = true;
                            try {
                                for(var advances_1 = __values(advances), advances_1_1 = advances_1.next(); !advances_1_1.done; advances_1_1 = advances_1.next()){
                                    var advance = advances_1_1.value;
                                    advance();
                                }
                            } catch (e_5_1) {
                                e_5 = {
                                    error: e_5_1
                                };
                            } finally{
                                try {
                                    if (advances_1_1 && !advances_1_1.done && (_a = advances_1.return)) _a.call(advances_1);
                                } finally{
                                    if (e_5) throw e_5.error;
                                }
                            }
                        });
                        _a.label = 1;
                    case 1:
                        _a.trys.push([
                            1,
                            ,
                            3,
                            4
                        ]);
                        return [
                            4 /*yield*/ ,
                            Promise.all(iters.map(function(iter, i) {
                                return __awaiter(_this, void 0, void 0, function() {
                                    var iteration, _a;
                                    return __generator(this, function(_b) {
                                        switch(_b.label){
                                            case 0:
                                                _b.trys.push([
                                                    0,
                                                    ,
                                                    6,
                                                    9
                                                ]);
                                                _b.label = 1;
                                            case 1:
                                                if (!!stopped) return [
                                                    3 /*break*/ ,
                                                    5
                                                ];
                                                Promise.resolve(iter.next()).then(function(iteration) {
                                                    return advances[i](iteration);
                                                }, function(err) {
                                                    return stop(err);
                                                });
                                                return [
                                                    4 /*yield*/ ,
                                                    new Promise(function(resolve) {
                                                        advances[i] = resolve;
                                                    })
                                                ];
                                            case 2:
                                                iteration = _b.sent();
                                                if (!(iteration !== undefined)) return [
                                                    3 /*break*/ ,
                                                    4
                                                ];
                                                if (iteration.done) {
                                                    finalIteration = iteration;
                                                    return [
                                                        2 /*return*/ 
                                                    ];
                                                }
                                                return [
                                                    4 /*yield*/ ,
                                                    push(iteration.value)
                                                ];
                                            case 3:
                                                _b.sent();
                                                _b.label = 4;
                                            case 4:
                                                return [
                                                    3 /*break*/ ,
                                                    1
                                                ];
                                            case 5:
                                                return [
                                                    3 /*break*/ ,
                                                    9
                                                ];
                                            case 6:
                                                _a = iter.return;
                                                if (!_a) return [
                                                    3 /*break*/ ,
                                                    8
                                                ];
                                                return [
                                                    4 /*yield*/ ,
                                                    iter.return()
                                                ];
                                            case 7:
                                                _a = _b.sent();
                                                _b.label = 8;
                                            case 8:
                                                return [
                                                    7 /*endfinally*/ 
                                                ];
                                            case 9:
                                                return [
                                                    2 /*return*/ 
                                                ];
                                        }
                                    });
                                });
                            }))
                        ];
                    case 2:
                        _a.sent();
                        return [
                            2 /*return*/ ,
                            finalIteration && finalIteration.value
                        ];
                    case 3:
                        stop();
                        return [
                            7 /*endfinally*/ 
                        ];
                    case 4:
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    });
}
function zip(contenders) {
    var _this = this;
    var iters = getIterators(contenders, {
        returnValues: true
    });
    return new Repeater(function(push, stop) {
        return __awaiter(_this, void 0, void 0, function() {
            var advance, stopped, iterations, values;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        if (!iters.length) {
                            stop();
                            return [
                                2 /*return*/ ,
                                []
                            ];
                        }
                        stopped = false;
                        stop.then(function() {
                            advance();
                            stopped = true;
                        });
                        _a.label = 1;
                    case 1:
                        _a.trys.push([
                            1,
                            ,
                            6,
                            8
                        ]);
                        _a.label = 2;
                    case 2:
                        if (!!stopped) return [
                            3 /*break*/ ,
                            5
                        ];
                        Promise.all(iters.map(function(iter) {
                            return iter.next();
                        })).then(function(iterations) {
                            return advance(iterations);
                        }, function(err) {
                            return stop(err);
                        });
                        return [
                            4 /*yield*/ ,
                            new Promise(function(resolve) {
                                return advance = resolve;
                            })
                        ];
                    case 3:
                        iterations = _a.sent();
                        if (iterations === undefined) {
                            return [
                                2 /*return*/ 
                            ];
                        }
                        values = iterations.map(function(iteration) {
                            return iteration.value;
                        });
                        if (iterations.some(function(iteration) {
                            return iteration.done;
                        })) {
                            return [
                                2 /*return*/ ,
                                values
                            ];
                        }
                        return [
                            4 /*yield*/ ,
                            push(values)
                        ];
                    case 4:
                        _a.sent();
                        return [
                            3 /*break*/ ,
                            2
                        ];
                    case 5:
                        return [
                            3 /*break*/ ,
                            8
                        ];
                    case 6:
                        stop();
                        return [
                            4 /*yield*/ ,
                            Promise.all(iters.map(function(iter) {
                                return iter.return && iter.return();
                            }))
                        ];
                    case 7:
                        _a.sent();
                        return [
                            7 /*endfinally*/ 
                        ];
                    case 8:
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    });
}
function latest(contenders) {
    var _this = this;
    var iters = getIterators(contenders, {
        yieldValues: true,
        returnValues: true
    });
    return new Repeater(function(push, stop) {
        return __awaiter(_this, void 0, void 0, function() {
            var advance, advances, stopped, iterations_1, values_2;
            var _this = this;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        if (!iters.length) {
                            stop();
                            return [
                                2 /*return*/ ,
                                []
                            ];
                        }
                        advances = [];
                        stopped = false;
                        stop.then(function() {
                            var e_6, _a;
                            advance();
                            try {
                                for(var advances_2 = __values(advances), advances_2_1 = advances_2.next(); !advances_2_1.done; advances_2_1 = advances_2.next()){
                                    var advance1 = advances_2_1.value;
                                    advance1();
                                }
                            } catch (e_6_1) {
                                e_6 = {
                                    error: e_6_1
                                };
                            } finally{
                                try {
                                    if (advances_2_1 && !advances_2_1.done && (_a = advances_2.return)) _a.call(advances_2);
                                } finally{
                                    if (e_6) throw e_6.error;
                                }
                            }
                            stopped = true;
                        });
                        _a.label = 1;
                    case 1:
                        _a.trys.push([
                            1,
                            ,
                            5,
                            7
                        ]);
                        Promise.all(iters.map(function(iter) {
                            return iter.next();
                        })).then(function(iterations) {
                            return advance(iterations);
                        }, function(err) {
                            return stop(err);
                        });
                        return [
                            4 /*yield*/ ,
                            new Promise(function(resolve) {
                                return advance = resolve;
                            })
                        ];
                    case 2:
                        iterations_1 = _a.sent();
                        if (iterations_1 === undefined) {
                            return [
                                2 /*return*/ 
                            ];
                        }
                        values_2 = iterations_1.map(function(iteration) {
                            return iteration.value;
                        });
                        if (iterations_1.every(function(iteration) {
                            return iteration.done;
                        })) {
                            return [
                                2 /*return*/ ,
                                values_2
                            ];
                        }
                        // We continuously yield and mutate the same values array so we shallow copy it each time it is pushed.
                        return [
                            4 /*yield*/ ,
                            push(values_2.slice())
                        ];
                    case 3:
                        // We continuously yield and mutate the same values array so we shallow copy it each time it is pushed.
                        _a.sent();
                        return [
                            4 /*yield*/ ,
                            Promise.all(iters.map(function(iter, i) {
                                return __awaiter(_this, void 0, void 0, function() {
                                    var iteration;
                                    return __generator(this, function(_a) {
                                        switch(_a.label){
                                            case 0:
                                                if (iterations_1[i].done) {
                                                    return [
                                                        2 /*return*/ ,
                                                        iterations_1[i].value
                                                    ];
                                                }
                                                _a.label = 1;
                                            case 1:
                                                if (!!stopped) return [
                                                    3 /*break*/ ,
                                                    4
                                                ];
                                                Promise.resolve(iter.next()).then(function(iteration) {
                                                    return advances[i](iteration);
                                                }, function(err) {
                                                    return stop(err);
                                                });
                                                return [
                                                    4 /*yield*/ ,
                                                    new Promise(function(resolve) {
                                                        return advances[i] = resolve;
                                                    })
                                                ];
                                            case 2:
                                                iteration = _a.sent();
                                                if (iteration === undefined) {
                                                    return [
                                                        2 /*return*/ ,
                                                        iterations_1[i].value
                                                    ];
                                                } else if (iteration.done) {
                                                    return [
                                                        2 /*return*/ ,
                                                        iteration.value
                                                    ];
                                                }
                                                values_2[i] = iteration.value;
                                                return [
                                                    4 /*yield*/ ,
                                                    push(values_2.slice())
                                                ];
                                            case 3:
                                                _a.sent();
                                                return [
                                                    3 /*break*/ ,
                                                    1
                                                ];
                                            case 4:
                                                return [
                                                    2 /*return*/ 
                                                ];
                                        }
                                    });
                                });
                            }))
                        ];
                    case 4:
                        return [
                            2 /*return*/ ,
                            _a.sent()
                        ];
                    case 5:
                        stop();
                        return [
                            4 /*yield*/ ,
                            Promise.all(iters.map(function(iter) {
                                return iter.return && iter.return();
                            }))
                        ];
                    case 6:
                        _a.sent();
                        return [
                            7 /*endfinally*/ 
                        ];
                    case 7:
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    });
}
exports.DroppingBuffer = DroppingBuffer;
exports.FixedBuffer = FixedBuffer;
exports.MAX_QUEUE_LENGTH = MAX_QUEUE_LENGTH;
exports.Repeater = Repeater;
exports.RepeaterOverflowError = RepeaterOverflowError;
exports.SlidingBuffer = SlidingBuffer; //# sourceMappingURL=repeater.js.map


/***/ }),

/***/ 2492:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.PonyfillAbortController = void 0;
const AbortSignal_js_1 = __webpack_require__(3442);
// Will be removed after v14 reaches EOL
class PonyfillAbortController {
    constructor(){
        this.signal = new AbortSignal_js_1.PonyfillAbortSignal();
    }
    abort(reason) {
        this.signal.abort(reason);
    }
}
exports.PonyfillAbortController = PonyfillAbortController;


/***/ }),

/***/ 7920:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.PonyfillAbortError = void 0;
// Will be removed after v14 reaches EOL
class PonyfillAbortError extends Error {
    constructor(reason){
        let message = "The operation was aborted.";
        if (reason) {
            message += ` reason: ${reason}`;
        }
        super(message, {
            cause: reason
        });
        this.name = "AbortError";
    }
    get reason() {
        return this.cause;
    }
}
exports.PonyfillAbortError = PonyfillAbortError;


/***/ }),

/***/ 3442:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.PonyfillAbortSignal = void 0;
// Will be removed after v14 reaches EOL
const events_1 = __webpack_require__(1919);
const AbortError_js_1 = __webpack_require__(7920);
class PonyfillAbortSignal extends events_1.EventTarget {
    constructor(){
        super(...arguments);
        this.aborted = false;
        this._onabort = null;
    }
    throwIfAborted() {
        if (this.aborted) {
            throw new AbortError_js_1.PonyfillAbortError();
        }
    }
    get onabort() {
        return this._onabort;
    }
    set onabort(value) {
        if (this._onabort) {
            this.removeEventListener("abort", this._onabort);
        }
        this.addEventListener("abort", value);
    }
    abort(reason) {
        const abortEvent = new events_1.CustomEvent("abort", {
            detail: reason
        });
        this.dispatchEvent(abortEvent);
    }
    static timeout(milliseconds) {
        const signal = new PonyfillAbortSignal();
        setTimeout(()=>signal.abort(`timeout in ${milliseconds} ms`), milliseconds);
        return signal;
    }
}
exports.PonyfillAbortSignal = PonyfillAbortSignal;


/***/ }),

/***/ 2586:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.PonyfillBlob = void 0;
const ReadableStream_js_1 = __webpack_require__(633);
const utils_js_1 = __webpack_require__(9876);
function getBlobPartAsBuffer(blobPart) {
    if (typeof blobPart === "string") {
        return Buffer.from(blobPart);
    } else if (Buffer.isBuffer(blobPart)) {
        return blobPart;
    } else if (blobPart instanceof Uint8Array) {
        return Buffer.from(blobPart);
    } else if ("buffer" in blobPart) {
        return Buffer.from(blobPart.buffer, blobPart.byteOffset, blobPart.byteLength);
    } else {
        return Buffer.from(blobPart);
    }
}
function isBlob(obj) {
    return obj != null && typeof obj === "object" && obj.arrayBuffer != null;
}
// Will be removed after v14 reaches EOL
// Needed because v14 doesn't have .stream() implemented
class PonyfillBlob {
    constructor(blobParts, options){
        this.blobParts = blobParts;
        this.type = (options === null || options === void 0 ? void 0 : options.type) || "application/octet-stream";
        this.encoding = (options === null || options === void 0 ? void 0 : options.encoding) || "utf8";
    }
    async buffer() {
        const bufferChunks = [];
        for (const blobPart of this.blobParts){
            if (isBlob(blobPart)) {
                const arrayBuf = await blobPart.arrayBuffer();
                const buf = Buffer.from(arrayBuf, undefined, blobPart.size);
                bufferChunks.push(buf);
            } else {
                const buf = getBlobPartAsBuffer(blobPart);
                bufferChunks.push(buf);
            }
        }
        return Buffer.concat(bufferChunks);
    }
    async arrayBuffer() {
        const buffer = await this.buffer();
        return (0, utils_js_1.uint8ArrayToArrayBuffer)(buffer);
    }
    async text() {
        let text = "";
        for (const blobPart of this.blobParts){
            if (typeof blobPart === "string") {
                text += blobPart;
            } else if ("text" in blobPart) {
                text += await blobPart.text();
            } else {
                const buf = getBlobPartAsBuffer(blobPart);
                text += buf.toString(this.encoding);
            }
        }
        return text;
    }
    get size() {
        let size = 0;
        for (const blobPart of this.blobParts){
            if (typeof blobPart === "string") {
                size += Buffer.byteLength(blobPart);
            } else if (isBlob(blobPart)) {
                size += blobPart.size;
            } else if ("length" in blobPart) {
                size += blobPart.length;
            } else if ("byteLength" in blobPart) {
                size += blobPart.byteLength;
            }
        }
        return size;
    }
    stream() {
        let partQueue = [];
        return new ReadableStream_js_1.PonyfillReadableStream({
            start: (controller)=>{
                partQueue = [
                    ...this.blobParts
                ];
                if (partQueue.length === 0) {
                    controller.close();
                }
            },
            pull: async (controller)=>{
                const blobPart = partQueue.pop();
                if (blobPart) {
                    if (isBlob(blobPart)) {
                        const arrayBuffer = await blobPart.arrayBuffer();
                        const buf = Buffer.from(arrayBuffer, undefined, blobPart.size);
                        controller.enqueue(buf);
                    } else {
                        const buf = getBlobPartAsBuffer(blobPart);
                        controller.enqueue(buf);
                    }
                } else {
                    controller.close();
                }
            }
        });
    }
    slice() {
        throw new Error("Not implemented");
    }
}
exports.PonyfillBlob = PonyfillBlob;


/***/ }),

/***/ 9597:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.PonyfillBody = void 0;
const tslib_1 = __webpack_require__(4479);
const stream_1 = __webpack_require__(2781);
const busboy_1 = tslib_1.__importDefault(__webpack_require__(637));
const Blob_js_1 = __webpack_require__(2586);
const File_js_1 = __webpack_require__(9541);
const FormData_js_1 = __webpack_require__(9690);
const ReadableStream_js_1 = __webpack_require__(633);
const utils_js_1 = __webpack_require__(9876);
var BodyInitType;
(function(BodyInitType) {
    BodyInitType["ReadableStream"] = "ReadableStream";
    BodyInitType["Blob"] = "Blob";
    BodyInitType["FormData"] = "FormData";
    BodyInitType["ArrayBuffer"] = "ArrayBuffer";
    BodyInitType["String"] = "String";
    BodyInitType["Readable"] = "Readable";
    BodyInitType["Buffer"] = "Buffer";
    BodyInitType["Uint8Array"] = "Uint8Array";
})(BodyInitType || (BodyInitType = {}));
class PonyfillBody {
    constructor(bodyInit, options = {}){
        this.bodyInit = bodyInit;
        this.options = options;
        this.bodyUsed = false;
        this.contentType = null;
        this.contentLength = null;
        this._bodyFactory = ()=>null;
        this._generatedBody = null;
        const { bodyFactory , contentType , contentLength , bodyType  } = processBodyInit(bodyInit);
        this._bodyFactory = bodyFactory;
        this.contentType = contentType;
        this.contentLength = contentLength;
        this.bodyType = bodyType;
    }
    generateBody() {
        if (this._generatedBody) {
            return this._generatedBody;
        }
        const body = this._bodyFactory();
        this._generatedBody = body;
        return body;
    }
    get body() {
        const _body = this.generateBody();
        if (_body != null) {
            const ponyfillReadableStream = _body;
            const readable = _body.readable;
            return new Proxy(_body.readable, {
                get (_, prop) {
                    if (prop in ponyfillReadableStream) {
                        const ponyfillReadableStreamProp = ponyfillReadableStream[prop];
                        if (typeof ponyfillReadableStreamProp === "function") {
                            return ponyfillReadableStreamProp.bind(ponyfillReadableStream);
                        }
                        return ponyfillReadableStreamProp;
                    }
                    if (prop in readable) {
                        const readableProp = readable[prop];
                        if (typeof readableProp === "function") {
                            return readableProp.bind(readable);
                        }
                        return readableProp;
                    }
                }
            });
        }
        return null;
    }
    async arrayBuffer() {
        if (this.bodyType === BodyInitType.ArrayBuffer) {
            return this.bodyInit;
        }
        if (this.bodyType === BodyInitType.Uint8Array || this.bodyType === BodyInitType.Buffer) {
            const typedBodyInit = this.bodyInit;
            return (0, utils_js_1.uint8ArrayToArrayBuffer)(typedBodyInit);
        }
        if (this.bodyType === BodyInitType.String) {
            const buffer = Buffer.from(this.bodyInit);
            return (0, utils_js_1.uint8ArrayToArrayBuffer)(buffer);
        }
        if (this.bodyType === BodyInitType.Blob) {
            const blob = this.bodyInit;
            const arrayBuffer = await blob.arrayBuffer();
            return arrayBuffer;
        }
        const blob = await this.blob();
        return blob.arrayBuffer();
    }
    async _collectChunksFromReadable() {
        const chunks = [];
        const _body = this.generateBody();
        if (_body) {
            for await (const chunk of _body.readable){
                chunks.push(chunk);
            }
        }
        return chunks;
    }
    async blob() {
        if (this.bodyType === BodyInitType.Blob) {
            return this.bodyInit;
        }
        if (this.bodyType === BodyInitType.String || this.bodyType === BodyInitType.Buffer || this.bodyType === BodyInitType.Uint8Array) {
            const bodyInitTyped = this.bodyInit;
            return new Blob_js_1.PonyfillBlob([
                bodyInitTyped
            ], {
                type: this.contentType || ""
            });
        }
        if (this.bodyType === BodyInitType.ArrayBuffer) {
            const bodyInitTyped = this.bodyInit;
            const buf = Buffer.from(bodyInitTyped, undefined, bodyInitTyped.byteLength);
            return new Blob_js_1.PonyfillBlob([
                buf
            ], {
                type: this.contentType || ""
            });
        }
        const chunks = await this._collectChunksFromReadable();
        return new Blob_js_1.PonyfillBlob(chunks, {
            type: this.contentType || ""
        });
    }
    formData(opts) {
        if (this.bodyType === BodyInitType.FormData) {
            return Promise.resolve(this.bodyInit);
        }
        const formData = new FormData_js_1.PonyfillFormData();
        const _body = this.generateBody();
        if (_body == null) {
            return Promise.resolve(formData);
        }
        const formDataLimits = {
            ...this.options.formDataLimits,
            ...opts === null || opts === void 0 ? void 0 : opts.formDataLimits
        };
        return new Promise((resolve, reject)=>{
            const bb = (0, busboy_1.default)({
                headers: {
                    "content-type": this.contentType || ""
                },
                limits: formDataLimits,
                defParamCharset: "utf-8"
            });
            bb.on("field", (name, value, { nameTruncated , valueTruncated  })=>{
                if (nameTruncated) {
                    reject(new Error(`Field name size exceeded: ${formDataLimits === null || formDataLimits === void 0 ? void 0 : formDataLimits.fieldNameSize} bytes`));
                }
                if (valueTruncated) {
                    reject(new Error(`Field value size exceeded: ${formDataLimits === null || formDataLimits === void 0 ? void 0 : formDataLimits.fieldSize} bytes`));
                }
                formData.set(name, value);
            });
            bb.on("fieldsLimit", ()=>{
                reject(new Error(`Fields limit exceeded: ${formDataLimits === null || formDataLimits === void 0 ? void 0 : formDataLimits.fields}`));
            });
            bb.on("file", (name, fileStream, { filename , mimeType  })=>{
                const chunks = [];
                fileStream.on("limit", ()=>{
                    reject(new Error(`File size limit exceeded: ${formDataLimits === null || formDataLimits === void 0 ? void 0 : formDataLimits.fileSize} bytes`));
                });
                fileStream.on("data", (chunk)=>{
                    chunks.push(Buffer.from(chunk));
                });
                fileStream.on("close", ()=>{
                    if (fileStream.truncated) {
                        reject(new Error(`File size limit exceeded: ${formDataLimits === null || formDataLimits === void 0 ? void 0 : formDataLimits.fileSize} bytes`));
                    }
                    const file = new File_js_1.PonyfillFile(chunks, filename, {
                        type: mimeType
                    });
                    formData.set(name, file);
                });
            });
            bb.on("filesLimit", ()=>{
                reject(new Error(`Files limit exceeded: ${formDataLimits === null || formDataLimits === void 0 ? void 0 : formDataLimits.files}`));
            });
            bb.on("partsLimit", ()=>{
                reject(new Error(`Parts limit exceeded: ${formDataLimits === null || formDataLimits === void 0 ? void 0 : formDataLimits.parts}`));
            });
            bb.on("close", ()=>{
                resolve(formData);
            });
            bb.on("error", (err)=>{
                reject(err);
            });
            _body === null || _body === void 0 ? void 0 : _body.readable.pipe(bb);
        });
    }
    async buffer() {
        if (this.bodyType === BodyInitType.Buffer) {
            return this.bodyInit;
        }
        if (this.bodyType === BodyInitType.String) {
            return Buffer.from(this.bodyInit);
        }
        if (this.bodyType === BodyInitType.Uint8Array || this.bodyType === BodyInitType.ArrayBuffer) {
            const bodyInitTyped = this.bodyInit;
            const buffer = Buffer.from(bodyInitTyped, "byteOffset" in bodyInitTyped ? bodyInitTyped.byteOffset : undefined, bodyInitTyped.byteLength);
            return buffer;
        }
        if (this.bodyType === BodyInitType.Blob) {
            if (this.bodyInit instanceof Blob_js_1.PonyfillBlob) {
                return this.bodyInit.buffer();
            }
            const bodyInitTyped = this.bodyInit;
            const buffer = Buffer.from(await bodyInitTyped.arrayBuffer(), undefined, bodyInitTyped.size);
            return buffer;
        }
        const chunks = await this._collectChunksFromReadable();
        return Buffer.concat(chunks);
    }
    async json() {
        const text = await this.text();
        return JSON.parse(text);
    }
    async text() {
        if (this.bodyType === BodyInitType.String) {
            return this.bodyInit;
        }
        const buffer = await this.buffer();
        return buffer.toString("utf-8");
    }
}
exports.PonyfillBody = PonyfillBody;
function processBodyInit(bodyInit) {
    if (bodyInit == null) {
        return {
            bodyFactory: ()=>null,
            contentType: null,
            contentLength: null
        };
    }
    if (typeof bodyInit === "string") {
        return {
            bodyType: BodyInitType.String,
            contentType: "text/plain;charset=UTF-8",
            contentLength: Buffer.byteLength(bodyInit),
            bodyFactory () {
                const readable = stream_1.Readable.from(bodyInit);
                return new ReadableStream_js_1.PonyfillReadableStream(readable);
            }
        };
    }
    if (bodyInit instanceof ReadableStream_js_1.PonyfillReadableStream) {
        return {
            bodyType: BodyInitType.ReadableStream,
            bodyFactory: ()=>bodyInit,
            contentType: null,
            contentLength: null
        };
    }
    if (bodyInit instanceof Blob_js_1.PonyfillBlob) {
        return {
            bodyType: BodyInitType.Blob,
            contentType: bodyInit.type,
            contentLength: bodyInit.size,
            bodyFactory () {
                return bodyInit.stream();
            }
        };
    }
    if (bodyInit instanceof Buffer) {
        const contentLength = bodyInit.length;
        return {
            bodyType: BodyInitType.Buffer,
            contentLength,
            contentType: null,
            bodyFactory () {
                const readable = stream_1.Readable.from(bodyInit);
                const body = new ReadableStream_js_1.PonyfillReadableStream(readable);
                return body;
            }
        };
    }
    if (bodyInit instanceof Uint8Array) {
        const contentLength = bodyInit.byteLength;
        return {
            bodyType: BodyInitType.Uint8Array,
            contentLength,
            contentType: null,
            bodyFactory () {
                const readable = stream_1.Readable.from(bodyInit);
                const body = new ReadableStream_js_1.PonyfillReadableStream(readable);
                return body;
            }
        };
    }
    if ("buffer" in bodyInit) {
        const contentLength = bodyInit.byteLength;
        return {
            contentLength,
            contentType: null,
            bodyFactory () {
                const buffer = Buffer.from(bodyInit);
                const readable = stream_1.Readable.from(buffer);
                const body = new ReadableStream_js_1.PonyfillReadableStream(readable);
                return body;
            }
        };
    }
    if (bodyInit instanceof ArrayBuffer) {
        const contentLength = bodyInit.byteLength;
        return {
            bodyType: BodyInitType.ArrayBuffer,
            contentType: null,
            contentLength,
            bodyFactory () {
                const buffer = Buffer.from(bodyInit, undefined, bodyInit.byteLength);
                const readable = stream_1.Readable.from(buffer);
                const body = new ReadableStream_js_1.PonyfillReadableStream(readable);
                return body;
            }
        };
    }
    if (bodyInit instanceof stream_1.Readable) {
        return {
            bodyType: BodyInitType.Readable,
            contentType: null,
            contentLength: null,
            bodyFactory () {
                const body = new ReadableStream_js_1.PonyfillReadableStream(bodyInit);
                return body;
            }
        };
    }
    if ("stream" in bodyInit) {
        return {
            contentType: bodyInit.type,
            contentLength: bodyInit.size,
            bodyFactory () {
                const bodyStream = bodyInit.stream();
                const body = new ReadableStream_js_1.PonyfillReadableStream(bodyStream);
                return body;
            }
        };
    }
    if ("sort" in bodyInit) {
        const contentType = "application/x-www-form-urlencoded;charset=UTF-8";
        return {
            bodyType: BodyInitType.String,
            contentType,
            contentLength: null,
            bodyFactory () {
                const body = new ReadableStream_js_1.PonyfillReadableStream(stream_1.Readable.from(bodyInit.toString()));
                return body;
            }
        };
    }
    if ("forEach" in bodyInit) {
        const boundary = Math.random().toString(36).substr(2);
        const contentType = `multipart/form-data; boundary=${boundary}`;
        return {
            contentType,
            contentLength: null,
            bodyFactory () {
                return (0, FormData_js_1.getStreamFromFormData)(bodyInit, boundary);
            }
        };
    }
    if (bodyInit[Symbol.iterator] || bodyInit[Symbol.asyncIterator]) {
        return {
            contentType: null,
            contentLength: null,
            bodyFactory () {
                const readable = stream_1.Readable.from(bodyInit);
                return new ReadableStream_js_1.PonyfillReadableStream(readable);
            }
        };
    }
    throw new Error("Unknown body type");
}


/***/ }),

/***/ 9541:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.PonyfillFile = void 0;
const Blob_js_1 = __webpack_require__(2586);
class PonyfillFile extends Blob_js_1.PonyfillBlob {
    constructor(fileBits, name, options){
        super(fileBits, options);
        this.name = name;
        this.webkitRelativePath = "";
        this.lastModified = (options === null || options === void 0 ? void 0 : options.lastModified) || Date.now();
    }
}
exports.PonyfillFile = PonyfillFile;


/***/ }),

/***/ 9690:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getStreamFromFormData = exports.PonyfillFormData = void 0;
const File_js_1 = __webpack_require__(9541);
const ReadableStream_js_1 = __webpack_require__(633);
class PonyfillFormData {
    constructor(){
        this.map = new Map();
    }
    append(name, value, fileName) {
        let values = this.map.get(name);
        if (!values) {
            values = [];
            this.map.set(name, values);
        }
        const entry = isBlob(value) ? getNormalizedFile(name, value, fileName) : value;
        values.push(entry);
    }
    delete(name) {
        this.map.delete(name);
    }
    get(name) {
        const values = this.map.get(name);
        return values ? values[0] : null;
    }
    getAll(name) {
        return this.map.get(name) || [];
    }
    has(name) {
        return this.map.has(name);
    }
    set(name, value, fileName) {
        const entry = isBlob(value) ? getNormalizedFile(name, value, fileName) : value;
        this.map.set(name, [
            entry
        ]);
    }
    *[Symbol.iterator]() {
        for (const [key, values] of this.map){
            for (const value of values){
                yield [
                    key,
                    value
                ];
            }
        }
    }
    entries() {
        return this[Symbol.iterator]();
    }
    keys() {
        return this.map.keys();
    }
    *values() {
        for (const values of this.map.values()){
            for (const value of values){
                yield value;
            }
        }
    }
    forEach(callback) {
        for (const [key, value] of this){
            callback(value, key, this);
        }
    }
}
exports.PonyfillFormData = PonyfillFormData;
function getStreamFromFormData(formData, boundary = "---") {
    const entries = [];
    let sentInitialHeader = false;
    return new ReadableStream_js_1.PonyfillReadableStream({
        start: (controller)=>{
            formData.forEach((value, key)=>{
                if (!sentInitialHeader) {
                    controller.enqueue(Buffer.from(`--${boundary}\r\n`));
                    sentInitialHeader = true;
                }
                entries.push([
                    key,
                    value
                ]);
            });
            if (!sentInitialHeader) {
                controller.enqueue(Buffer.from(`--${boundary}--\r\n`));
                controller.close();
            }
        },
        pull: async (controller)=>{
            const entry = entries.shift();
            if (entry) {
                const [key, value] = entry;
                if (typeof value === "string") {
                    controller.enqueue(Buffer.from(`Content-Disposition: form-data; name="${key}"\r\n\r\n`));
                    controller.enqueue(Buffer.from(value));
                } else {
                    let filenamePart = "";
                    if (value.name) {
                        filenamePart = `; filename="${value.name}"`;
                    }
                    controller.enqueue(Buffer.from(`Content-Disposition: form-data; name="${key}"${filenamePart}\r\n`));
                    controller.enqueue(Buffer.from(`Content-Type: ${value.type || "application/octet-stream"}\r\n\r\n`));
                    const entryStream = value.stream();
                    for await (const chunk of entryStream){
                        controller.enqueue(chunk);
                    }
                }
                if (entries.length === 0) {
                    controller.enqueue(Buffer.from(`\r\n--${boundary}--\r\n`));
                    controller.close();
                } else {
                    controller.enqueue(Buffer.from(`\r\n--${boundary}\r\n`));
                }
            } else {
                controller.enqueue(Buffer.from(`\r\n--${boundary}--\r\n`));
                controller.close();
            }
        }
    });
}
exports.getStreamFromFormData = getStreamFromFormData;
function getNormalizedFile(name, blob, fileName) {
    if (blob instanceof File_js_1.PonyfillFile) {
        if (fileName != null) {
            return new File_js_1.PonyfillFile([
                blob
            ], fileName, {
                type: blob.type,
                lastModified: blob.lastModified
            });
        }
        return blob;
    }
    return new File_js_1.PonyfillFile([
        blob
    ], fileName || name, {
        type: blob.type
    });
}
function isBlob(value) {
    return value != null && typeof value === "object" && typeof value.arrayBuffer === "function";
}


/***/ }),

/***/ 2926:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.PonyfillHeaders = void 0;
function isHeadersLike(headers) {
    return headers && typeof headers.get === "function";
}
class PonyfillHeaders {
    constructor(headersInit){
        this.headersInit = headersInit;
        this.map = new Map();
        this.mapIsBuilt = false;
        this.objectNormalizedKeysOfHeadersInit = [];
        this.objectOriginalKeysOfHeadersInit = [];
    }
    // perf: we don't need to build `this.map` for Requests, as we can access the headers directly
    _get(key) {
        // If the map is built, reuse it
        if (this.mapIsBuilt) {
            return this.map.get(key.toLowerCase()) || null;
        }
        // If the map is not built, try to get the value from the this.headersInit
        if (this.headersInit == null) {
            return null;
        }
        const normalized = key.toLowerCase();
        if (Array.isArray(this.headersInit)) {
            return this.headersInit.find((header)=>header[0] === normalized);
        } else if (isHeadersLike(this.headersInit)) {
            return this.headersInit.get(normalized);
        } else {
            const initValue = this.headersInit[key] || this.headersInit[normalized];
            if (initValue != null) {
                return initValue;
            }
            if (!this.objectNormalizedKeysOfHeadersInit.length) {
                Object.keys(this.headersInit).forEach((k)=>{
                    this.objectOriginalKeysOfHeadersInit.push(k);
                    this.objectNormalizedKeysOfHeadersInit.push(k.toLowerCase());
                });
            }
            const index = this.objectNormalizedKeysOfHeadersInit.indexOf(normalized);
            if (index === -1) {
                return null;
            }
            const originalKey = this.objectOriginalKeysOfHeadersInit[index];
            return this.headersInit[originalKey];
        }
    }
    // perf: Build the map of headers lazily, only when we need to access all headers or write to it.
    // I could do a getter here, but I'm too lazy to type `getter`.
    getMap() {
        if (this.mapIsBuilt) {
            return this.map;
        }
        if (this.headersInit != null) {
            if (Array.isArray(this.headersInit)) {
                this.map = new Map(this.headersInit);
            } else if (isHeadersLike(this.headersInit)) {
                this.headersInit.forEach((value, key)=>{
                    this.map.set(key, value);
                });
            } else {
                for(const initKey in this.headersInit){
                    const initValue = this.headersInit[initKey];
                    if (initValue != null) {
                        const normalizedValue = Array.isArray(initValue) ? initValue.join(", ") : initValue;
                        const normalizedKey = initKey.toLowerCase();
                        this.map.set(normalizedKey, normalizedValue);
                    }
                }
            }
        }
        this.mapIsBuilt = true;
        return this.map;
    }
    append(name, value) {
        const key = name.toLowerCase();
        const existingValue = this.getMap().get(key);
        const finalValue = existingValue ? `${existingValue}, ${value}` : value;
        this.getMap().set(key, finalValue);
    }
    get(name) {
        const key = name.toLowerCase();
        const value = this._get(key);
        if (value == null) {
            return null;
        }
        if (Array.isArray(value)) {
            return value.join(", ");
        }
        return value;
    }
    has(name) {
        const key = name.toLowerCase();
        return !!this._get(key); // we might need to check if header exists and not just check if it's not nullable
    }
    set(name, value) {
        const key = name.toLowerCase();
        this.getMap().set(key, value);
    }
    delete(name) {
        const key = name.toLowerCase();
        this.getMap().delete(key);
    }
    forEach(callback) {
        this.getMap().forEach((value, key)=>{
            callback(value, key, this);
        });
    }
    keys() {
        return this.getMap().keys();
    }
    values() {
        return this.getMap().values();
    }
    entries() {
        return this.getMap().entries();
    }
    [Symbol.iterator]() {
        return this.getMap().entries();
    }
}
exports.PonyfillHeaders = PonyfillHeaders;


/***/ }),

/***/ 633:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.PonyfillReadableStream = void 0;
const stream_1 = __webpack_require__(2781);
function createController(desiredSize, readable) {
    let chunks = [];
    let _closed = false;
    let flushed = false;
    return {
        desiredSize,
        enqueue (chunk) {
            const buf = typeof chunk === "string" ? Buffer.from(chunk) : chunk;
            if (!flushed) {
                chunks.push(buf);
            } else {
                readable.push(buf);
            }
        },
        close () {
            if (chunks.length > 0) {
                this._flush();
            }
            readable.push(null);
            _closed = true;
        },
        error (error) {
            if (chunks.length > 0) {
                this._flush();
            }
            readable.destroy(error);
        },
        get _closed () {
            return _closed;
        },
        _flush () {
            flushed = true;
            if (chunks.length > 0) {
                const concatenated = Buffer.concat(chunks);
                readable.push(concatenated);
                chunks = [];
            }
        }
    };
}
class PonyfillReadableStream {
    constructor(underlyingSource){
        this.locked = false;
        if (underlyingSource instanceof PonyfillReadableStream) {
            this.readable = underlyingSource.readable;
        } else if (underlyingSource && "read" in underlyingSource) {
            this.readable = underlyingSource;
        } else if (underlyingSource && "getReader" in underlyingSource) {
            let reader;
            let started = false;
            this.readable = new stream_1.Readable({
                read () {
                    if (!started) {
                        started = true;
                        reader = underlyingSource.getReader();
                    }
                    reader.read().then(({ value , done  })=>{
                        if (done) {
                            this.push(null);
                        } else {
                            this.push(value);
                        }
                    }).catch((err)=>{
                        this.destroy(err);
                    });
                },
                destroy (err, callback) {
                    reader.cancel(err).then(()=>callback(err), callback);
                }
            });
        } else {
            let started = false;
            let ongoing = false;
            this.readable = new stream_1.Readable({
                read (desiredSize) {
                    if (ongoing) {
                        return;
                    }
                    ongoing = true;
                    return Promise.resolve().then(async ()=>{
                        var _a, _b;
                        if (!started) {
                            const controller = createController(desiredSize, this);
                            started = true;
                            await ((_a = underlyingSource === null || underlyingSource === void 0 ? void 0 : underlyingSource.start) === null || _a === void 0 ? void 0 : _a.call(underlyingSource, controller));
                            controller._flush();
                            if (controller._closed) {
                                return;
                            }
                        }
                        const controller = createController(desiredSize, this);
                        await ((_b = underlyingSource === null || underlyingSource === void 0 ? void 0 : underlyingSource.pull) === null || _b === void 0 ? void 0 : _b.call(underlyingSource, controller));
                        controller._flush();
                        ongoing = false;
                    });
                },
                async destroy (err, callback) {
                    var _a;
                    try {
                        await ((_a = underlyingSource === null || underlyingSource === void 0 ? void 0 : underlyingSource.cancel) === null || _a === void 0 ? void 0 : _a.call(underlyingSource, err));
                        callback(null);
                    } catch (err) {
                        callback(err);
                    }
                }
            });
        }
    }
    cancel(reason) {
        this.readable.destroy(reason);
        return Promise.resolve();
    }
    getReader(_options) {
        const iterator = this.readable[Symbol.asyncIterator]();
        this.locked = true;
        return {
            read () {
                return iterator.next();
            },
            releaseLock: ()=>{
                var _a;
                (_a = iterator.return) === null || _a === void 0 ? void 0 : _a.call(iterator);
                this.locked = false;
            },
            cancel: async (reason)=>{
                var _a;
                await ((_a = iterator.return) === null || _a === void 0 ? void 0 : _a.call(iterator, reason));
                this.locked = false;
            },
            closed: new Promise((resolve, reject)=>{
                this.readable.once("end", resolve);
                this.readable.once("error", reject);
            })
        };
    }
    [Symbol.asyncIterator]() {
        return this.readable[Symbol.asyncIterator]();
    }
    tee() {
        throw new Error("Not implemented");
    }
    async pipeTo(destination) {
        const writer = destination.getWriter();
        await writer.ready;
        for await (const chunk of this.readable){
            await writer.write(chunk);
        }
        await writer.ready;
        return writer.close();
    }
    pipeThrough({ writable , readable  }) {
        this.pipeTo(writable);
        return readable;
    }
    static [Symbol.hasInstance](instance) {
        return instance != null && typeof instance === "object" && "getReader" in instance;
    }
}
exports.PonyfillReadableStream = PonyfillReadableStream;


/***/ }),

/***/ 563:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.PonyfillRequest = void 0;
const AbortController_js_1 = __webpack_require__(2492);
const Body_js_1 = __webpack_require__(9597);
const Headers_js_1 = __webpack_require__(2926);
function isRequest(input) {
    return input[Symbol.toStringTag] === "Request";
}
class PonyfillRequest extends Body_js_1.PonyfillBody {
    constructor(input, options){
        var _a;
        let url;
        let bodyInit = null;
        let requestInit;
        if (typeof input === "string") {
            url = input;
        } else if ("href" in input) {
            url = input.toString();
        } else if (isRequest(input)) {
            url = input.url;
            bodyInit = input.body;
            requestInit = input;
        }
        if (options != null) {
            bodyInit = options.body || null;
            requestInit = options;
        }
        super(bodyInit, options);
        this.destination = "";
        this.priority = "auto";
        this.cache = (requestInit === null || requestInit === void 0 ? void 0 : requestInit.cache) || "default";
        this.credentials = (requestInit === null || requestInit === void 0 ? void 0 : requestInit.credentials) || "same-origin";
        this.headers = new Headers_js_1.PonyfillHeaders(requestInit === null || requestInit === void 0 ? void 0 : requestInit.headers);
        this.integrity = (requestInit === null || requestInit === void 0 ? void 0 : requestInit.integrity) || "";
        this.keepalive = (requestInit === null || requestInit === void 0 ? void 0 : requestInit.keepalive) != null ? requestInit === null || requestInit === void 0 ? void 0 : requestInit.keepalive : false;
        this.method = ((_a = requestInit === null || requestInit === void 0 ? void 0 : requestInit.method) === null || _a === void 0 ? void 0 : _a.toUpperCase()) || "GET";
        this.mode = (requestInit === null || requestInit === void 0 ? void 0 : requestInit.mode) || "cors";
        this.redirect = (requestInit === null || requestInit === void 0 ? void 0 : requestInit.redirect) || "follow";
        this.referrer = (requestInit === null || requestInit === void 0 ? void 0 : requestInit.referrer) || "about:client";
        this.referrerPolicy = (requestInit === null || requestInit === void 0 ? void 0 : requestInit.referrerPolicy) || "no-referrer";
        this.signal = (requestInit === null || requestInit === void 0 ? void 0 : requestInit.signal) || new AbortController_js_1.PonyfillAbortController().signal;
        this.url = url || "";
        const contentTypeInHeaders = this.headers.get("content-type");
        if (!contentTypeInHeaders) {
            if (this.contentType) {
                this.headers.set("content-type", this.contentType);
            }
        } else {
            this.contentType = contentTypeInHeaders;
        }
        const contentLengthInHeaders = this.headers.get("content-length");
        if (!contentLengthInHeaders) {
            if (this.contentLength) {
                this.headers.set("content-length", this.contentLength.toString());
            }
        } else {
            this.contentLength = parseInt(contentLengthInHeaders, 10);
        }
    }
    clone() {
        return new Request(this);
    }
}
exports.PonyfillRequest = PonyfillRequest;


/***/ }),

/***/ 7811:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.PonyfillResponse = void 0;
const http_1 = __webpack_require__(3685);
const Body_js_1 = __webpack_require__(9597);
const Headers_js_1 = __webpack_require__(2926);
class PonyfillResponse extends Body_js_1.PonyfillBody {
    constructor(body, init){
        super(body || null, init);
        this.headers = new Headers_js_1.PonyfillHeaders();
        this.status = 200;
        this.statusText = "OK";
        this.url = "";
        this.redirected = false;
        this.type = "default";
        if (init) {
            this.headers = new Headers_js_1.PonyfillHeaders(init.headers);
            this.status = init.status || 200;
            this.statusText = init.statusText || http_1.STATUS_CODES[this.status] || "OK";
            this.url = init.url || "";
            this.redirected = init.redirected || false;
            this.type = init.type || "default";
        }
        const contentTypeInHeaders = this.headers.get("content-type");
        if (!contentTypeInHeaders) {
            if (this.contentType) {
                this.headers.set("content-type", this.contentType);
            }
        } else {
            this.contentType = contentTypeInHeaders;
        }
        const contentLengthInHeaders = this.headers.get("content-length");
        if (!contentLengthInHeaders) {
            if (this.contentLength) {
                this.headers.set("content-length", this.contentLength.toString());
            }
        } else {
            this.contentLength = parseInt(contentLengthInHeaders, 10);
        }
    }
    get ok() {
        return this.status >= 200 && this.status < 300;
    }
    clone() {
        return new PonyfillResponse(this.body, this);
    }
    static error() {
        return new PonyfillResponse(null, {
            status: 500,
            statusText: "Internal Server Error"
        });
    }
    static redirect(url, status = 301) {
        if (status < 300 || status > 399) {
            throw new RangeError("Invalid status code");
        }
        return new PonyfillResponse(null, {
            headers: {
                location: url
            },
            status
        });
    }
    static json(data, init = {}) {
        return new PonyfillResponse(JSON.stringify(data), {
            ...init,
            headers: {
                "Content-Type": "application/json",
                ...init === null || init === void 0 ? void 0 : init.headers
            }
        });
    }
}
exports.PonyfillResponse = PonyfillResponse;


/***/ }),

/***/ 8926:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.PonyfillBtoa = exports.PonyfillTextDecoder = exports.PonyfillTextEncoder = void 0;
class PonyfillTextEncoder {
    constructor(encoding = "utf-8"){
        this.encoding = encoding;
    }
    encode(input) {
        return Buffer.from(input, this.encoding);
    }
    encodeInto(source, destination) {
        const buffer = this.encode(source);
        const copied = buffer.copy(destination);
        return {
            read: copied,
            written: copied
        };
    }
}
exports.PonyfillTextEncoder = PonyfillTextEncoder;
class PonyfillTextDecoder {
    constructor(encoding = "utf-8", options){
        this.encoding = encoding;
        this.fatal = false;
        this.ignoreBOM = false;
        if (options) {
            this.fatal = options.fatal || false;
            this.ignoreBOM = options.ignoreBOM || false;
        }
    }
    decode(input) {
        return Buffer.from(input).toString(this.encoding);
    }
}
exports.PonyfillTextDecoder = PonyfillTextDecoder;
function PonyfillBtoa(input) {
    return Buffer.from(input, "binary").toString("base64");
}
exports.PonyfillBtoa = PonyfillBtoa;


/***/ }),

/***/ 8952:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.PonyfillURL = void 0;
const tslib_1 = __webpack_require__(4479);
const fast_querystring_1 = tslib_1.__importDefault(__webpack_require__(1663));
const fast_url_parser_1 = tslib_1.__importDefault(__webpack_require__(5544));
const URLSearchParams_js_1 = __webpack_require__(1897);
fast_url_parser_1.default.queryString = fast_querystring_1.default;
class PonyfillURL extends fast_url_parser_1.default {
    constructor(url, base){
        super();
        if (url.startsWith("data:")) {
            this.protocol = "data:";
            this.pathname = url.slice("data:".length);
            return;
        }
        this.parse(url, false);
        if (base) {
            const baseParsed = typeof base === "string" ? new PonyfillURL(base) : base;
            this.protocol = this.protocol || baseParsed.protocol;
            this.host = this.host || baseParsed.host;
            this.pathname = this.pathname || baseParsed.pathname;
        }
    }
    get origin() {
        return `${this.protocol}//${this.host}`;
    }
    get searchParams() {
        if (!this._searchParams) {
            this._searchParams = new URLSearchParams_js_1.PonyfillURLSearchParams(this.query);
        }
        return this._searchParams;
    }
    get username() {
        var _a;
        return ((_a = this.auth) === null || _a === void 0 ? void 0 : _a.split(":")[0]) || "";
    }
    set username(value) {
        this.auth = `${value}:${this.password}`;
    }
    get password() {
        var _a;
        return ((_a = this.auth) === null || _a === void 0 ? void 0 : _a.split(":")[1]) || "";
    }
    set password(value) {
        this.auth = `${this.username}:${value}`;
    }
    toString() {
        return this.format();
    }
    toJSON() {
        return this.toString();
    }
}
exports.PonyfillURL = PonyfillURL;


/***/ }),

/***/ 1897:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.PonyfillURLSearchParams = void 0;
const tslib_1 = __webpack_require__(4479);
const fast_querystring_1 = tslib_1.__importDefault(__webpack_require__(1663));
class PonyfillURLSearchParams {
    constructor(init){
        if (init) {
            if (typeof init === "string") {
                this.params = fast_querystring_1.default.parse(init);
            } else if (Array.isArray(init)) {
                this.params = {};
                for (const [key, value] of init){
                    this.params[key] = value;
                }
            } else if ("entries" in init) {
                this.params = {};
                for (const [key, value] of init.entries()){
                    this.params[key] = value;
                }
            } else {
                this.params = init;
            }
        } else {
            this.params = {};
        }
    }
    append(name, value) {
        const existingValue = this.params[name];
        const finalValue = existingValue ? `${existingValue},${value}` : value;
        this.params[name] = finalValue;
    }
    delete(name) {
        delete this.params[name];
    }
    get(name) {
        const value = this.params[name];
        if (Array.isArray(value)) {
            return value[0] || null;
        }
        return value || null;
    }
    getAll(name) {
        const value = this.params[name];
        if (!Array.isArray(value)) {
            return value ? [
                value
            ] : [];
        }
        return value;
    }
    has(name) {
        return name in this.params;
    }
    set(name, value) {
        this.params[name] = value;
    }
    sort() {
        const sortedKeys = Object.keys(this.params).sort();
        const sortedParams = {};
        for (const key of sortedKeys){
            sortedParams[key] = this.params[key];
        }
        this.params = sortedParams;
    }
    toString() {
        return fast_querystring_1.default.stringify(this.params);
    }
    *keys() {
        for(const key in this.params){
            yield key;
        }
    }
    *entries() {
        for (const key of this.keys()){
            const value = this.params[key];
            if (Array.isArray(value)) {
                for (const item of value){
                    yield [
                        key,
                        item
                    ];
                }
            } else {
                yield [
                    key,
                    value
                ];
            }
        }
    }
    *values() {
        for (const [, value] of this){
            yield value;
        }
    }
    [Symbol.iterator]() {
        return this.entries();
    }
    forEach(callback) {
        for (const [key, value] of this){
            callback(value, key, this);
        }
    }
}
exports.PonyfillURLSearchParams = PonyfillURLSearchParams;


/***/ }),

/***/ 345:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.fetchPonyfill = void 0;
const fs_1 = __webpack_require__(7147);
const http_1 = __webpack_require__(3685);
const https_1 = __webpack_require__(5687);
const stream_1 = __webpack_require__(2781);
const url_1 = __webpack_require__(7310);
const zlib_1 = __webpack_require__(9796);
const AbortError_js_1 = __webpack_require__(7920);
const Blob_js_1 = __webpack_require__(2586);
const Request_js_1 = __webpack_require__(563);
const Response_js_1 = __webpack_require__(7811);
const URL_js_1 = __webpack_require__(8952);
const utils_js_1 = __webpack_require__(9876);
function getResponseForFile(url) {
    const path = (0, url_1.fileURLToPath)(url);
    const readable = (0, fs_1.createReadStream)(path);
    return new Response_js_1.PonyfillResponse(readable);
}
function getRequestFnForProtocol(protocol) {
    switch(protocol){
        case "http:":
            return http_1.request;
        case "https:":
            return https_1.request;
    }
    throw new Error(`Unsupported protocol: ${protocol}`);
}
const BASE64_SUFFIX = ";base64";
function fetchPonyfill(info, init) {
    if (typeof info === "string" || "href" in info) {
        const ponyfillRequest = new Request_js_1.PonyfillRequest(info, init);
        return fetchPonyfill(ponyfillRequest);
    }
    const fetchRequest = info;
    return new Promise((resolve, reject)=>{
        try {
            const url = new URL_js_1.PonyfillURL(fetchRequest.url, "http://localhost");
            if (url.protocol === "data:") {
                const [mimeType = "text/plain", ...datas] = url.pathname.split(",");
                const data = decodeURIComponent(datas.join(","));
                if (mimeType.endsWith(BASE64_SUFFIX)) {
                    const buffer = Buffer.from(data, "base64url");
                    const realMimeType = mimeType.slice(0, -BASE64_SUFFIX.length);
                    const file = new Blob_js_1.PonyfillBlob([
                        buffer
                    ], {
                        type: realMimeType
                    });
                    const response = new Response_js_1.PonyfillResponse(file, {
                        status: 200,
                        statusText: "OK"
                    });
                    resolve(response);
                    return;
                }
                const response = new Response_js_1.PonyfillResponse(data, {
                    status: 200,
                    statusText: "OK",
                    headers: {
                        "content-type": mimeType
                    }
                });
                resolve(response);
                return;
            }
            if (url.protocol === "file:") {
                const response = getResponseForFile(fetchRequest.url);
                resolve(response);
                return;
            }
            const requestFn = getRequestFnForProtocol(url.protocol);
            const nodeReadable = fetchRequest.body != null ? "pipe" in fetchRequest.body ? fetchRequest.body : stream_1.Readable.from(fetchRequest.body) : null;
            const nodeHeaders = (0, utils_js_1.getHeadersObj)(fetchRequest.headers);
            const abortListener = function abortListener(event) {
                nodeRequest.destroy();
                const reason = event.detail;
                reject(new AbortError_js_1.PonyfillAbortError(reason));
            };
            fetchRequest.signal.addEventListener("abort", abortListener);
            const nodeRequest = requestFn(fetchRequest.url, {
                // signal: fetchRequest.signal will be added when v14 reaches EOL
                method: fetchRequest.method,
                headers: nodeHeaders
            });
            nodeRequest.once("response", (nodeResponse)=>{
                let responseBody = nodeResponse;
                const contentEncoding = nodeResponse.headers["content-encoding"];
                switch(contentEncoding){
                    case "x-gzip":
                    case "gzip":
                        responseBody = nodeResponse.pipe((0, zlib_1.createGunzip)());
                        break;
                    case "x-deflate":
                    case "deflate":
                        responseBody = nodeResponse.pipe((0, zlib_1.createInflate)());
                        break;
                    case "br":
                        responseBody = nodeResponse.pipe((0, zlib_1.createBrotliDecompress)());
                        break;
                }
                if (nodeResponse.headers.location) {
                    if (fetchRequest.redirect === "error") {
                        const redirectError = new Error("Redirects are not allowed");
                        reject(redirectError);
                        nodeResponse.resume();
                        return;
                    }
                    if (fetchRequest.redirect === "follow") {
                        const redirectedUrl = new URL_js_1.PonyfillURL(nodeResponse.headers.location, url);
                        const redirectResponse$ = fetchPonyfill(redirectedUrl, info);
                        resolve(redirectResponse$.then((redirectResponse)=>{
                            redirectResponse.redirected = true;
                            return redirectResponse;
                        }));
                        nodeResponse.resume();
                        return;
                    }
                }
                const responseHeaders = nodeResponse.headers;
                const ponyfillResponse = new Response_js_1.PonyfillResponse(responseBody, {
                    status: nodeResponse.statusCode,
                    statusText: nodeResponse.statusMessage,
                    headers: responseHeaders,
                    url: info.url
                });
                resolve(ponyfillResponse);
            });
            nodeRequest.once("error", reject);
            if (nodeReadable) {
                nodeReadable.pipe(nodeRequest);
            } else {
                nodeRequest.end();
            }
        } catch (e) {
            reject(e);
        }
    });
}
exports.fetchPonyfill = fetchPonyfill;


/***/ }),

/***/ 985:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.URLSearchParams = exports.URL = exports.btoa = exports.TextDecoder = exports.TextEncoder = exports.Blob = exports.AbortError = exports.AbortSignal = exports.AbortController = exports.FormData = exports.File = exports.ReadableStream = exports.Response = exports.Request = exports.Body = exports.Headers = exports.fetch = void 0;
var fetch_js_1 = __webpack_require__(345);
Object.defineProperty(exports, "fetch", ({
    enumerable: true,
    get: function() {
        return fetch_js_1.fetchPonyfill;
    }
}));
var Headers_js_1 = __webpack_require__(2926);
Object.defineProperty(exports, "Headers", ({
    enumerable: true,
    get: function() {
        return Headers_js_1.PonyfillHeaders;
    }
}));
var Body_js_1 = __webpack_require__(9597);
Object.defineProperty(exports, "Body", ({
    enumerable: true,
    get: function() {
        return Body_js_1.PonyfillBody;
    }
}));
var Request_js_1 = __webpack_require__(563);
Object.defineProperty(exports, "Request", ({
    enumerable: true,
    get: function() {
        return Request_js_1.PonyfillRequest;
    }
}));
var Response_js_1 = __webpack_require__(7811);
Object.defineProperty(exports, "Response", ({
    enumerable: true,
    get: function() {
        return Response_js_1.PonyfillResponse;
    }
}));
var ReadableStream_js_1 = __webpack_require__(633);
Object.defineProperty(exports, "ReadableStream", ({
    enumerable: true,
    get: function() {
        return ReadableStream_js_1.PonyfillReadableStream;
    }
}));
var File_js_1 = __webpack_require__(9541);
Object.defineProperty(exports, "File", ({
    enumerable: true,
    get: function() {
        return File_js_1.PonyfillFile;
    }
}));
var FormData_js_1 = __webpack_require__(9690);
Object.defineProperty(exports, "FormData", ({
    enumerable: true,
    get: function() {
        return FormData_js_1.PonyfillFormData;
    }
}));
var AbortController_js_1 = __webpack_require__(2492);
Object.defineProperty(exports, "AbortController", ({
    enumerable: true,
    get: function() {
        return AbortController_js_1.PonyfillAbortController;
    }
}));
var AbortSignal_js_1 = __webpack_require__(3442);
Object.defineProperty(exports, "AbortSignal", ({
    enumerable: true,
    get: function() {
        return AbortSignal_js_1.PonyfillAbortSignal;
    }
}));
var AbortError_js_1 = __webpack_require__(7920);
Object.defineProperty(exports, "AbortError", ({
    enumerable: true,
    get: function() {
        return AbortError_js_1.PonyfillAbortError;
    }
}));
var Blob_js_1 = __webpack_require__(2586);
Object.defineProperty(exports, "Blob", ({
    enumerable: true,
    get: function() {
        return Blob_js_1.PonyfillBlob;
    }
}));
var TextEncoderDecoder_js_1 = __webpack_require__(8926);
Object.defineProperty(exports, "TextEncoder", ({
    enumerable: true,
    get: function() {
        return TextEncoderDecoder_js_1.PonyfillTextEncoder;
    }
}));
Object.defineProperty(exports, "TextDecoder", ({
    enumerable: true,
    get: function() {
        return TextEncoderDecoder_js_1.PonyfillTextDecoder;
    }
}));
Object.defineProperty(exports, "btoa", ({
    enumerable: true,
    get: function() {
        return TextEncoderDecoder_js_1.PonyfillBtoa;
    }
}));
var URL_js_1 = __webpack_require__(8952);
Object.defineProperty(exports, "URL", ({
    enumerable: true,
    get: function() {
        return URL_js_1.PonyfillURL;
    }
}));
var URLSearchParams_js_1 = __webpack_require__(1897);
Object.defineProperty(exports, "URLSearchParams", ({
    enumerable: true,
    get: function() {
        return URLSearchParams_js_1.PonyfillURLSearchParams;
    }
}));


/***/ }),

/***/ 9876:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.uint8ArrayToArrayBuffer = exports.getHeadersObj = void 0;
function getHeadersObj(headers) {
    if (headers == null || !("forEach" in headers)) {
        return headers;
    }
    const obj = {};
    headers.forEach((value, key)=>{
        obj[key] = value;
    });
    return obj;
}
exports.getHeadersObj = getHeadersObj;
function uint8ArrayToArrayBuffer(uint8array) {
    return uint8array.buffer.slice(uint8array.byteOffset, uint8array.byteOffset + uint8array.byteLength);
}
exports.uint8ArrayToArrayBuffer = uint8ArrayToArrayBuffer;


/***/ }),

/***/ 9663:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.createServerAdapter = void 0;
const tslib_1 = __webpack_require__(4479);
/* eslint-disable @typescript-eslint/ban-types */ const DefaultFetchAPI = tslib_1.__importStar(__webpack_require__(8130));
const utils_js_1 = __webpack_require__(3334);
async function handleWaitUntils(waitUntilPromises) {
    const waitUntils = await Promise.allSettled(waitUntilPromises);
    waitUntils.forEach((waitUntil)=>{
        if (waitUntil.status === "rejected") {
            console.error(waitUntil.reason);
        }
    });
}
// Required for envs like nextjs edge runtime
function isRequestAccessible(serverContext) {
    try {
        return !!(serverContext === null || serverContext === void 0 ? void 0 : serverContext.request);
    } catch (_a) {
        return false;
    }
}
function createServerAdapter(serverAdapterBaseObject, options) {
    const fetchAPI = {
        ...DefaultFetchAPI,
        ...options === null || options === void 0 ? void 0 : options.fetchAPI
    };
    const givenHandleRequest = typeof serverAdapterBaseObject === "function" ? serverAdapterBaseObject : serverAdapterBaseObject.handle;
    const onRequestHooks = [];
    const onResponseHooks = [];
    if ((options === null || options === void 0 ? void 0 : options.plugins) != null) {
        for (const plugin of options.plugins){
            if (plugin.onRequest) {
                onRequestHooks.push(plugin.onRequest);
            }
            if (plugin.onResponse) {
                onResponseHooks.push(plugin.onResponse);
            }
        }
    }
    async function handleRequest(request, serverContext) {
        let url = new Proxy({}, {
            get: (_target, prop, _receiver)=>{
                url = new fetchAPI.URL(request.url, "http://localhost");
                return Reflect.get(url, prop, url);
            }
        });
        let requestHandler = givenHandleRequest;
        let response;
        for (const onRequestHook of onRequestHooks){
            await onRequestHook({
                request,
                serverContext,
                fetchAPI,
                url,
                requestHandler,
                setRequestHandler (newRequestHandler) {
                    requestHandler = newRequestHandler;
                },
                endResponse (newResponse) {
                    response = newResponse;
                }
            });
            if (response) {
                break;
            }
        }
        if (!response) {
            response = await requestHandler(request, serverContext);
        }
        for (const onResponseHook of onResponseHooks){
            await onResponseHook({
                request,
                response,
                serverContext
            });
        }
        return response;
    }
    function handleNodeRequest(nodeRequest, ...ctx) {
        const serverContext = ctx.length > 1 ? completeAssign({}, ...ctx) : ctx[0];
        const request = (0, utils_js_1.normalizeNodeRequest)(nodeRequest, fetchAPI.Request);
        return handleRequest(request, serverContext);
    }
    async function requestListener(nodeRequest, serverResponse, ...ctx) {
        const waitUntilPromises = [];
        const defaultServerContext = {
            req: nodeRequest,
            res: serverResponse,
            waitUntil (promise) {
                if (promise != null) {
                    waitUntilPromises.push(promise);
                }
            }
        };
        const response = await handleNodeRequest(nodeRequest, defaultServerContext, ...ctx);
        if (response) {
            await (0, utils_js_1.sendNodeResponse)(response, serverResponse, nodeRequest);
        } else {
            await new Promise((resolve)=>{
                serverResponse.statusCode = 404;
                serverResponse.once("end", resolve);
                serverResponse.end();
            });
        }
        if (waitUntilPromises.length > 0) {
            await handleWaitUntils(waitUntilPromises);
        }
    }
    function handleEvent(event, ...ctx) {
        if (!event.respondWith || !event.request) {
            throw new TypeError(`Expected FetchEvent, got ${event}`);
        }
        const serverContext = ctx.length > 0 ? Object.assign({}, event, ...ctx) : event;
        const response$ = handleRequest(event.request, serverContext);
        event.respondWith(response$);
    }
    function handleRequestWithWaitUntil(request, ...ctx) {
        const serverContext = ctx.length > 1 ? completeAssign({}, ...ctx) : ctx[0] || {};
        if (!("waitUntil" in serverContext)) {
            const waitUntilPromises = [];
            const response$ = handleRequest(request, {
                ...serverContext,
                waitUntil (promise) {
                    if (promise != null) {
                        waitUntilPromises.push(promise);
                    }
                }
            });
            if (waitUntilPromises.length > 0) {
                return handleWaitUntils(waitUntilPromises).then(()=>response$);
            }
            return response$;
        }
        return handleRequest(request, serverContext);
    }
    const fetchFn = (input, ...maybeCtx)=>{
        if (typeof input === "string" || "href" in input) {
            const [initOrCtx, ...restOfCtx] = maybeCtx;
            if ((0, utils_js_1.isRequestInit)(initOrCtx)) {
                return handleRequestWithWaitUntil(new fetchAPI.Request(input, initOrCtx), ...restOfCtx);
            }
            return handleRequestWithWaitUntil(new fetchAPI.Request(input), ...maybeCtx);
        }
        return handleRequestWithWaitUntil(input, ...maybeCtx);
    };
    const genericRequestHandler = (input, ...maybeCtx)=>{
        // If it is a Node request
        const [initOrCtxOrRes, ...restOfCtx] = maybeCtx;
        if ((0, utils_js_1.isNodeRequest)(input)) {
            if (!(0, utils_js_1.isServerResponse)(initOrCtxOrRes)) {
                throw new TypeError(`Expected ServerResponse, got ${initOrCtxOrRes}`);
            }
            return requestListener(input, initOrCtxOrRes, ...restOfCtx);
        }
        if ((0, utils_js_1.isServerResponse)(initOrCtxOrRes)) {
            throw new TypeError("Got Node response without Node request");
        }
        // Is input a container object over Request?
        if (isRequestAccessible(input)) {
            // Is it FetchEvent?
            if ((0, utils_js_1.isFetchEvent)(input)) {
                return handleEvent(input, ...maybeCtx);
            }
            // In this input is also the context
            return handleRequestWithWaitUntil(input.request, input, ...maybeCtx);
        }
        // Or is it Request itself?
        // Then ctx is present and it is the context
        return fetchFn(input, ...maybeCtx);
    };
    const adapterObj = {
        handleRequest,
        fetch: fetchFn,
        handleNodeRequest,
        requestListener,
        handleEvent,
        handle: genericRequestHandler
    };
    const serverAdapter = new Proxy(genericRequestHandler, {
        // It should have all the attributes of the handler function and the server instance
        has: (_, prop)=>{
            return prop in adapterObj || prop in genericRequestHandler || serverAdapterBaseObject && prop in serverAdapterBaseObject;
        },
        get: (_, prop)=>{
            const adapterProp = adapterObj[prop];
            if (adapterProp) {
                if (adapterProp.bind) {
                    return adapterProp.bind(adapterObj);
                }
                return adapterProp;
            }
            const handleProp = genericRequestHandler[prop];
            if (handleProp) {
                if (handleProp.bind) {
                    return handleProp.bind(genericRequestHandler);
                }
                return handleProp;
            }
            if (serverAdapterBaseObject) {
                const serverAdapterBaseObjectProp = serverAdapterBaseObject[prop];
                if (serverAdapterBaseObjectProp) {
                    if (serverAdapterBaseObjectProp.bind) {
                        return function(...args) {
                            const returnedVal = serverAdapterBaseObject[prop](...args);
                            if (returnedVal === serverAdapterBaseObject) {
                                return serverAdapter;
                            }
                            return returnedVal;
                        };
                    }
                    return serverAdapterBaseObjectProp;
                }
            }
        },
        apply (_, __, args) {
            return genericRequestHandler(...args);
        }
    });
    return serverAdapter;
}
exports.createServerAdapter = createServerAdapter;
// from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#copying_accessors
function completeAssign(target, ...sources) {
    sources.forEach((source)=>{
        if (source != null && typeof source === "object") {
            // modified Object.keys to Object.getOwnPropertyNames
            // because Object.keys only returns enumerable properties
            const descriptors = Object.getOwnPropertyNames(source).reduce((descriptors, key)=>{
                descriptors[key] = Object.getOwnPropertyDescriptor(source, key);
                return descriptors;
            }, {});
            // By default, Object.assign copies enumerable Symbols, too
            Object.getOwnPropertySymbols(source).forEach((sym)=>{
                const descriptor = Object.getOwnPropertyDescriptor(source, sym);
                if (descriptor.enumerable) {
                    descriptors[sym] = descriptor;
                }
            });
            Object.defineProperties(target, descriptors);
        }
    });
    return target;
}


/***/ }),

/***/ 9862:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.Response = void 0;
const tslib_1 = __webpack_require__(4479);
tslib_1.__exportStar(__webpack_require__(9663), exports);
tslib_1.__exportStar(__webpack_require__(2461), exports);
tslib_1.__exportStar(__webpack_require__(3334), exports);
tslib_1.__exportStar(__webpack_require__(5446), exports);
tslib_1.__exportStar(__webpack_require__(3827), exports);
tslib_1.__exportStar(__webpack_require__(6779), exports);
var fetch_1 = __webpack_require__(8130);
Object.defineProperty(exports, "Response", ({
    enumerable: true,
    get: function() {
        return fetch_1.Response;
    }
}));


/***/ }),

/***/ 5446:
/***/ (() => {



/***/ }),

/***/ 3827:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useCORS = exports.getCORSHeadersByRequestAndOptions = void 0;
function getCORSHeadersByRequestAndOptions(request, corsOptions) {
    var _a, _b;
    const currentOrigin = request.headers.get("origin");
    if (corsOptions === false || currentOrigin == null) {
        return null;
    }
    const headers = {};
    // If defined origins have '*' or undefined by any means, we should allow all origins
    if (corsOptions.origin == null || corsOptions.origin.length === 0 || corsOptions.origin.includes("*")) {
        headers["Access-Control-Allow-Origin"] = currentOrigin;
        // Vary by origin because there are multiple origins
        headers["Vary"] = "Origin";
    } else if (typeof corsOptions.origin === "string") {
        // If there is one specific origin is specified, use it directly
        headers["Access-Control-Allow-Origin"] = corsOptions.origin;
    } else if (Array.isArray(corsOptions.origin)) {
        // If there is only one origin defined in the array, consider it as a single one
        if (corsOptions.origin.length === 1) {
            headers["Access-Control-Allow-Origin"] = corsOptions.origin[0];
        } else if (corsOptions.origin.includes(currentOrigin)) {
            // If origin is available in the headers, use it
            headers["Access-Control-Allow-Origin"] = currentOrigin;
            // Vary by origin because there are multiple origins
            headers["Vary"] = "Origin";
        } else {
            // There is no origin found in the headers, so we should return null
            headers["Access-Control-Allow-Origin"] = "null";
        }
    }
    if ((_a = corsOptions.methods) === null || _a === void 0 ? void 0 : _a.length) {
        headers["Access-Control-Allow-Methods"] = corsOptions.methods.join(", ");
    } else {
        const requestMethod = request.headers.get("access-control-request-method");
        if (requestMethod) {
            headers["Access-Control-Allow-Methods"] = requestMethod;
        }
    }
    if ((_b = corsOptions.allowedHeaders) === null || _b === void 0 ? void 0 : _b.length) {
        headers["Access-Control-Allow-Headers"] = corsOptions.allowedHeaders.join(", ");
    } else {
        const requestHeaders = request.headers.get("access-control-request-headers");
        if (requestHeaders) {
            headers["Access-Control-Allow-Headers"] = requestHeaders;
            if (headers["Vary"]) {
                headers["Vary"] += ", Access-Control-Request-Headers";
            }
            headers["Vary"] = "Access-Control-Request-Headers";
        }
    }
    if (corsOptions.credentials != null) {
        if (corsOptions.credentials === true) {
            headers["Access-Control-Allow-Credentials"] = "true";
        }
    } else if (headers["Access-Control-Allow-Origin"] !== "*") {
        headers["Access-Control-Allow-Credentials"] = "true";
    }
    if (corsOptions.exposedHeaders) {
        headers["Access-Control-Expose-Headers"] = corsOptions.exposedHeaders.join(", ");
    }
    if (corsOptions.maxAge) {
        headers["Access-Control-Max-Age"] = corsOptions.maxAge.toString();
    }
    return headers;
}
exports.getCORSHeadersByRequestAndOptions = getCORSHeadersByRequestAndOptions;
async function getCORSResponseHeaders(request, corsOptionsFactory, serverContext) {
    const corsOptions = await corsOptionsFactory(request, serverContext);
    return getCORSHeadersByRequestAndOptions(request, corsOptions);
}
function useCORS(options) {
    let corsOptionsFactory = ()=>({});
    if (options != null) {
        if (typeof options === "function") {
            corsOptionsFactory = options;
        } else if (typeof options === "object") {
            const corsOptions = {
                ...options
            };
            corsOptionsFactory = ()=>corsOptions;
        } else if (options === false) {
            corsOptionsFactory = ()=>false;
        }
    }
    return {
        onRequest ({ request , fetchAPI , endResponse  }) {
            if (request.method.toUpperCase() === "OPTIONS") {
                const response = new fetchAPI.Response(null, {
                    status: 204,
                    // Safari (and potentially other browsers) need content-length 0,
                    // for 204 or they just hang waiting for a body
                    // see: https://github.com/expressjs/cors/blob/master/lib/index.js#L176
                    headers: {
                        "Content-Length": "0"
                    }
                });
                endResponse(response);
            }
        },
        async onResponse ({ request , serverContext , response  }) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const headers = await getCORSResponseHeaders(request, corsOptionsFactory, serverContext);
            if (headers != null) {
                for(const headerName in headers){
                    response.headers.set(headerName, headers[headerName]);
                }
            }
        }
    };
}
exports.useCORS = useCORS;


/***/ }),

/***/ 6779:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useErrorHandling = exports.HTTPError = exports.createDefaultErrorHandler = void 0;
const fetch_1 = __webpack_require__(8130);
function createDefaultErrorHandler(ResponseCtor = fetch_1.Response) {
    return function defaultErrorHandler(e) {
        return new ResponseCtor(typeof e.details === "object" ? JSON.stringify(e.details) : e.stack || e.message || e.toString(), {
            status: e.statusCode || e.status || 500,
            headers: e.headers || {}
        });
    };
}
exports.createDefaultErrorHandler = createDefaultErrorHandler;
class HTTPError extends Error {
    constructor(status, message, headers = {}, details){
        super(message);
        this.status = status;
        this.message = message;
        this.headers = headers;
        this.details = details;
        Error.captureStackTrace(this, HTTPError);
    }
}
exports.HTTPError = HTTPError;
function useErrorHandling(onError) {
    return {
        onRequest ({ requestHandler , setRequestHandler , fetchAPI  }) {
            const errorHandler = onError || createDefaultErrorHandler(fetchAPI.Response);
            setRequestHandler(async function handlerWithErrorHandling(request, serverContext) {
                try {
                    const response = await requestHandler(request, serverContext);
                    return response;
                } catch (e) {
                    const response = await errorHandler(e, request, serverContext);
                    return response;
                }
            });
        }
    };
}
exports.useErrorHandling = useErrorHandling;


/***/ }),

/***/ 2461:
/***/ (() => {



/***/ }),

/***/ 3334:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.isRequestInit = exports.sendNodeResponse = exports.getHeadersObj = exports.isFetchEvent = exports.isReadableStream = exports.isServerResponse = exports.isNodeRequest = exports.isReadable = exports.normalizeNodeRequest = exports.isAsyncIterable = void 0;
const fetch_1 = __webpack_require__(8130);
function isAsyncIterable(body) {
    return body != null && typeof body === "object" && typeof body[Symbol.asyncIterator] === "function";
}
exports.isAsyncIterable = isAsyncIterable;
function getPort(nodeRequest) {
    var _a, _b, _c, _d, _e;
    if ((_a = nodeRequest.socket) === null || _a === void 0 ? void 0 : _a.localPort) {
        return (_b = nodeRequest.socket) === null || _b === void 0 ? void 0 : _b.localPort;
    }
    const hostInHeader = ((_c = nodeRequest.headers) === null || _c === void 0 ? void 0 : _c[":authority"]) || ((_d = nodeRequest.headers) === null || _d === void 0 ? void 0 : _d.host);
    const portInHeader = (_e = hostInHeader === null || hostInHeader === void 0 ? void 0 : hostInHeader.split(":")) === null || _e === void 0 ? void 0 : _e[1];
    if (portInHeader) {
        return portInHeader;
    }
    return 80;
}
function getHostnameWithPort(nodeRequest) {
    var _a, _b, _c, _d, _e;
    if ((_a = nodeRequest.headers) === null || _a === void 0 ? void 0 : _a[":authority"]) {
        return (_b = nodeRequest.headers) === null || _b === void 0 ? void 0 : _b[":authority"];
    }
    if ((_c = nodeRequest.headers) === null || _c === void 0 ? void 0 : _c.host) {
        return (_d = nodeRequest.headers) === null || _d === void 0 ? void 0 : _d.host;
    }
    const port = getPort(nodeRequest);
    if (nodeRequest.hostname) {
        return nodeRequest.hostname + ":" + port;
    }
    const localIp = (_e = nodeRequest.socket) === null || _e === void 0 ? void 0 : _e.localAddress;
    if (localIp && !(localIp === null || localIp === void 0 ? void 0 : localIp.includes("::")) && !(localIp === null || localIp === void 0 ? void 0 : localIp.includes("ffff"))) {
        return `${localIp}:${port}`;
    }
    return "localhost";
}
function buildFullUrl(nodeRequest) {
    const hostnameWithPort = getHostnameWithPort(nodeRequest);
    const protocol = nodeRequest.protocol || "http";
    const endpoint = nodeRequest.originalUrl || nodeRequest.url || "/graphql";
    return `${protocol}://${hostnameWithPort}${endpoint}`;
}
function isRequestBody(body) {
    const stringTag = body[Symbol.toStringTag];
    if (typeof body === "string" || stringTag === "Uint8Array" || stringTag === "Blob" || stringTag === "FormData" || stringTag === "URLSearchParams" || isAsyncIterable(body)) {
        return true;
    }
    return false;
}
function normalizeNodeRequest(nodeRequest, RequestCtor) {
    var _a;
    const rawRequest = nodeRequest.raw || nodeRequest.req || nodeRequest;
    let fullUrl = buildFullUrl(rawRequest);
    if (nodeRequest.query) {
        const url = new fetch_1.URL(fullUrl);
        for(const key in nodeRequest.query){
            url.searchParams.set(key, nodeRequest.query[key]);
        }
        fullUrl = url.toString();
    }
    if (nodeRequest.method === "GET" || nodeRequest.method === "HEAD") {
        return new RequestCtor(fullUrl, {
            method: nodeRequest.method,
            headers: nodeRequest.headers
        });
    }
    /**
     * Some Node server frameworks like Serverless Express sends a dummy object with body but as a Buffer not string
     * so we do those checks to see is there something we can use directly as BodyInit
     * because the presence of body means the request stream is already consumed and,
     * rawRequest cannot be used as BodyInit/ReadableStream by Fetch API in this case.
     */ const maybeParsedBody = nodeRequest.body;
    if (maybeParsedBody != null && Object.keys(maybeParsedBody).length > 0) {
        if (isRequestBody(maybeParsedBody)) {
            return new RequestCtor(fullUrl, {
                method: nodeRequest.method,
                headers: nodeRequest.headers,
                body: maybeParsedBody
            });
        }
        const request = new RequestCtor(fullUrl, {
            method: nodeRequest.method,
            headers: nodeRequest.headers
        });
        if (!((_a = request.headers.get("content-type")) === null || _a === void 0 ? void 0 : _a.includes("json"))) {
            request.headers.set("content-type", "application/json");
        }
        return new Proxy(request, {
            get: (target, prop, receiver)=>{
                switch(prop){
                    case "json":
                        return async ()=>maybeParsedBody;
                    case "text":
                        return async ()=>JSON.stringify(maybeParsedBody);
                    default:
                        return Reflect.get(target, prop, receiver);
                }
            }
        });
    }
    // perf: instead of spreading the object, we can just pass it as is and it performs better
    return new RequestCtor(fullUrl, {
        method: nodeRequest.method,
        headers: nodeRequest.headers,
        body: rawRequest
    });
}
exports.normalizeNodeRequest = normalizeNodeRequest;
function isReadable(stream) {
    return stream.read != null;
}
exports.isReadable = isReadable;
function isNodeRequest(request) {
    return isReadable(request);
}
exports.isNodeRequest = isNodeRequest;
function isServerResponse(stream) {
    // Check all used functions are defined
    return stream != null && stream.setHeader != null && stream.end != null && stream.once != null && stream.write != null;
}
exports.isServerResponse = isServerResponse;
function isReadableStream(stream) {
    return stream != null && stream.getReader != null;
}
exports.isReadableStream = isReadableStream;
function isFetchEvent(event) {
    return event != null && event.request != null && event.respondWith != null;
}
exports.isFetchEvent = isFetchEvent;
function configureSocket(rawRequest) {
    var _a, _b, _c, _d, _e, _f;
    (_b = (_a = rawRequest === null || rawRequest === void 0 ? void 0 : rawRequest.socket) === null || _a === void 0 ? void 0 : _a.setTimeout) === null || _b === void 0 ? void 0 : _b.call(_a, 0);
    (_d = (_c = rawRequest === null || rawRequest === void 0 ? void 0 : rawRequest.socket) === null || _c === void 0 ? void 0 : _c.setNoDelay) === null || _d === void 0 ? void 0 : _d.call(_c, true);
    (_f = (_e = rawRequest === null || rawRequest === void 0 ? void 0 : rawRequest.socket) === null || _e === void 0 ? void 0 : _e.setKeepAlive) === null || _f === void 0 ? void 0 : _f.call(_e, true);
}
function endResponse(serverResponse) {
    // @ts-expect-error Avoid arguments adaptor trampoline https://v8.dev/blog/adaptor-frame
    serverResponse.end(null, null, null);
}
function getHeadersObj(headers) {
    return new Proxy({}, {
        get (_target, prop) {
            return headers.get(prop) || undefined;
        },
        set (_target, prop, value) {
            headers.set(prop, value);
            return true;
        },
        has (_target, prop) {
            return headers.has(prop);
        },
        deleteProperty (_target, prop) {
            headers.delete(prop);
            return true;
        },
        ownKeys () {
            const keys = [];
            headers.forEach((_, key)=>keys.push(key));
            return keys;
        },
        getOwnPropertyDescriptor () {
            return {
                enumerable: true,
                configurable: true
            };
        }
    });
}
exports.getHeadersObj = getHeadersObj;
async function sendNodeResponse(fetchResponse, serverResponse, nodeRequest) {
    const headersObj = getHeadersObj(fetchResponse.headers);
    serverResponse.writeHead(fetchResponse.status, fetchResponse.statusText, headersObj);
    // eslint-disable-next-line no-async-promise-executor
    return new Promise(async (resolve)=>{
        serverResponse.once("close", resolve);
        // Our Node-fetch enhancements
        if ("bodyType" in fetchResponse && fetchResponse.bodyType != null && (fetchResponse.bodyType === "String" || fetchResponse.bodyType === "Uint8Array")) {
            // @ts-expect-error http and http2 writes are actually compatible
            serverResponse.write(fetchResponse.bodyInit);
            endResponse(serverResponse);
            return;
        }
        // Other fetch implementations
        const fetchBody = fetchResponse.body;
        if (fetchBody == null) {
            endResponse(serverResponse);
            return;
        }
        if (fetchBody[Symbol.toStringTag] === "Uint8Array") {
            serverResponse// @ts-expect-error http and http2 writes are actually compatible
            .write(fetchBody);
            endResponse(serverResponse);
            return;
        }
        configureSocket(nodeRequest);
        if (isReadable(fetchBody)) {
            serverResponse.once("close", ()=>{
                fetchBody.destroy();
            });
            fetchBody.pipe(serverResponse);
            return;
        }
        if (isAsyncIterable(fetchBody)) {
            for await (const chunk of fetchBody){
                if (!serverResponse// @ts-expect-error http and http2 writes are actually compatible
                .write(chunk)) {
                    break;
                }
            }
            endResponse(serverResponse);
        }
    });
}
exports.sendNodeResponse = sendNodeResponse;
function isRequestInit(val) {
    return val != null && typeof val === "object" && ("body" in val || "cache" in val || "credentials" in val || "headers" in val || "integrity" in val || "keepalive" in val || "method" in val || "mode" in val || "redirect" in val || "referrer" in val || "referrerPolicy" in val || "signal" in val || "window" in val);
}
exports.isRequestInit = isRequestInit;


/***/ }),

/***/ 2497:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.areGraphQLErrors = exports.getResponseInitByRespectingErrors = exports.handleError = exports.isOriginalGraphQLError = exports.isGraphQLError = exports.createGraphQLError = void 0;
const graphql_1 = __webpack_require__(5736);
const utils_1 = __webpack_require__(6887);
Object.defineProperty(exports, "createGraphQLError", ({
    enumerable: true,
    get: function() {
        return utils_1.createGraphQLError;
    }
}));
function isAggregateError(obj) {
    return obj != null && typeof obj === "object" && "errors" in obj;
}
function hasToString(obj) {
    return obj != null && typeof obj.toString === "function";
}
function isGraphQLError(val) {
    return val instanceof graphql_1.GraphQLError;
}
exports.isGraphQLError = isGraphQLError;
function isOriginalGraphQLError(val) {
    if (val instanceof graphql_1.GraphQLError) {
        if (val.originalError != null) {
            return isOriginalGraphQLError(val.originalError);
        }
        return true;
    }
    return false;
}
exports.isOriginalGraphQLError = isOriginalGraphQLError;
function handleError(error, maskedErrorsOpts, logger) {
    const errors = new Set();
    if (isAggregateError(error)) {
        for (const singleError of error.errors){
            const handledErrors = handleError(singleError, maskedErrorsOpts, logger);
            for (const handledError of handledErrors){
                errors.add(handledError);
            }
        }
    } else if (maskedErrorsOpts) {
        const maskedError = maskedErrorsOpts.maskError(error, maskedErrorsOpts.errorMessage, maskedErrorsOpts.isDev);
        if (maskedError !== error) {
            logger.error(error);
        }
        errors.add(isGraphQLError(maskedError) ? maskedError : (0, utils_1.createGraphQLError)(maskedError.message, {
            originalError: maskedError
        }));
    } else if (isGraphQLError(error)) {
        errors.add(error);
    } else if (error instanceof Error) {
        errors.add((0, utils_1.createGraphQLError)(error.message, {
            originalError: error
        }));
    } else if (typeof error === "string") {
        errors.add((0, utils_1.createGraphQLError)(error, {
            extensions: {
                unexpected: true
            }
        }));
    } else if (hasToString(error)) {
        errors.add((0, utils_1.createGraphQLError)(error.toString(), {
            extensions: {
                unexpected: true
            }
        }));
    } else {
        logger.error(error);
        errors.add((0, utils_1.createGraphQLError)("Unexpected error.", {
            extensions: {
                http: {
                    unexpected: true
                }
            }
        }));
    }
    return Array.from(errors);
}
exports.handleError = handleError;
function getResponseInitByRespectingErrors(result, headers = {}, isApplicationJson = false) {
    let status;
    let unexpectedErrorExists = false;
    if ("extensions" in result && result.extensions?.http) {
        if (result.extensions.http.headers) {
            Object.assign(headers, result.extensions.http.headers);
        }
        if (result.extensions.http.status) {
            status = result.extensions.http.status;
        }
    }
    if ("errors" in result && result.errors?.length) {
        for (const error of result.errors){
            if (error.extensions?.http) {
                if (error.extensions.http.headers) {
                    Object.assign(headers, error.extensions.http.headers);
                }
                if (isApplicationJson && error.extensions.http.spec) {
                    continue;
                }
                if (error.extensions.http.status && (!status || error.extensions.http.status > status)) {
                    status = error.extensions.http.status;
                }
            } else if (!isOriginalGraphQLError(error) || error.extensions?.unexpected) {
                unexpectedErrorExists = true;
            }
        }
    } else {
        status || (status = 200);
    }
    if (!status) {
        if (unexpectedErrorExists && !("data" in result)) {
            status = 500;
        } else {
            status = 200;
        }
    }
    return {
        status,
        headers
    };
}
exports.getResponseInitByRespectingErrors = getResponseInitByRespectingErrors;
function areGraphQLErrors(obj) {
    return Array.isArray(obj) && obj.length > 0 && // if one item in the array is a GraphQLError, we're good
    obj.some(isGraphQLError);
}
exports.areGraphQLErrors = areGraphQLErrors;


/***/ }),

/***/ 4403:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = '<!DOCTYPE html><html lang=en><head><meta charset=utf-8><title>__TITLE__</title><link rel=icon href=https://raw.githubusercontent.com/dotansimha/graphql-yoga/main/website/public/favicon.ico><link rel=stylesheet href=https://unpkg.com/@graphql-yoga/graphiql@3.0.12/dist/style.css></head><body id=body class=no-focus-outline><noscript>You need to enable JavaScript to run this app.</noscript><div id=root></div><script type=module>import{renderYogaGraphiQL}from"https://unpkg.com/@graphql-yoga/graphiql@3.0.12/dist/yoga-graphiql.es.js";renderYogaGraphiQL(root,__OPTS__)</script></body></html>';


/***/ }),

/***/ 1011:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.usePayloadFormatter = exports.useLogger = exports.useExtendContext = exports.useErrorHandler = exports.useEnvelop = exports.mapAsyncIterator = exports.makeSubscribe = exports.makeExecute = exports.isIntrospectionOperationString = exports.isAsyncIterable = exports.handleStreamOrSingleExecutionResult = exports.finalAsyncIterator = exports.errorAsyncIterator = exports.envelop = exports.maskError = exports.useSchema = exports.useReadinessCheck = exports.shouldRenderGraphiQL = exports.renderGraphiQL = exports.createGraphQLError = void 0;
const tslib_1 = __webpack_require__(4479);
var error_js_1 = __webpack_require__(2497);
Object.defineProperty(exports, "createGraphQLError", ({
    enumerable: true,
    get: function() {
        return error_js_1.createGraphQLError;
    }
}));
tslib_1.__exportStar(__webpack_require__(4521), exports);
var useGraphiQL_js_1 = __webpack_require__(1879);
Object.defineProperty(exports, "renderGraphiQL", ({
    enumerable: true,
    get: function() {
        return useGraphiQL_js_1.renderGraphiQL;
    }
}));
Object.defineProperty(exports, "shouldRenderGraphiQL", ({
    enumerable: true,
    get: function() {
        return useGraphiQL_js_1.shouldRenderGraphiQL;
    }
}));
var useReadinessCheck_js_1 = __webpack_require__(8613);
Object.defineProperty(exports, "useReadinessCheck", ({
    enumerable: true,
    get: function() {
        return useReadinessCheck_js_1.useReadinessCheck;
    }
}));
var useSchema_js_1 = __webpack_require__(3838);
Object.defineProperty(exports, "useSchema", ({
    enumerable: true,
    get: function() {
        return useSchema_js_1.useSchema;
    }
}));
tslib_1.__exportStar(__webpack_require__(2481), exports);
tslib_1.__exportStar(__webpack_require__(3689), exports);
tslib_1.__exportStar(__webpack_require__(9456), exports);
tslib_1.__exportStar(__webpack_require__(8929), exports);
var mask_error_js_1 = __webpack_require__(5984);
Object.defineProperty(exports, "maskError", ({
    enumerable: true,
    get: function() {
        return mask_error_js_1.maskError;
    }
}));
var core_1 = __webpack_require__(686);
// useful for anyone creating a new envelop instance
Object.defineProperty(exports, "envelop", ({
    enumerable: true,
    get: function() {
        return core_1.envelop;
    }
}));
Object.defineProperty(exports, "errorAsyncIterator", ({
    enumerable: true,
    get: function() {
        return core_1.errorAsyncIterator;
    }
}));
Object.defineProperty(exports, "finalAsyncIterator", ({
    enumerable: true,
    get: function() {
        return core_1.finalAsyncIterator;
    }
}));
Object.defineProperty(exports, "handleStreamOrSingleExecutionResult", ({
    enumerable: true,
    get: function() {
        return core_1.handleStreamOrSingleExecutionResult;
    }
}));
Object.defineProperty(exports, "isAsyncIterable", ({
    enumerable: true,
    get: function() {
        return core_1.isAsyncIterable;
    }
}));
// useful helpers
Object.defineProperty(exports, "isIntrospectionOperationString", ({
    enumerable: true,
    get: function() {
        return core_1.isIntrospectionOperationString;
    }
}));
Object.defineProperty(exports, "makeExecute", ({
    enumerable: true,
    get: function() {
        return core_1.makeExecute;
    }
}));
Object.defineProperty(exports, "makeSubscribe", ({
    enumerable: true,
    get: function() {
        return core_1.makeSubscribe;
    }
}));
Object.defineProperty(exports, "mapAsyncIterator", ({
    enumerable: true,
    get: function() {
        return core_1.mapAsyncIterator;
    }
}));
// Default plugins
Object.defineProperty(exports, "useEnvelop", ({
    enumerable: true,
    get: function() {
        return core_1.useEnvelop;
    }
}));
Object.defineProperty(exports, "useErrorHandler", ({
    enumerable: true,
    get: function() {
        return core_1.useErrorHandler;
    }
}));
Object.defineProperty(exports, "useExtendContext", ({
    enumerable: true,
    get: function() {
        return core_1.useExtendContext;
    }
}));
Object.defineProperty(exports, "useLogger", ({
    enumerable: true,
    get: function() {
        return core_1.useLogger;
    }
}));
Object.defineProperty(exports, "usePayloadFormatter", ({
    enumerable: true,
    get: function() {
        return core_1.usePayloadFormatter;
    }
}));


/***/ }),

/***/ 4139:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = '<!DOCTYPE html><html lang=en><head><meta charset=utf-8><title>Welcome to GraphQL Yoga</title><link rel=icon href=https://raw.githubusercontent.com/dotansimha/graphql-yoga/v3/website/public/favicon.ico><style>body,html{padding:0;margin:0;height:100%;font-family:Inter,-apple-system,BlinkMacSystemFont,\'Segoe UI\',Roboto,Oxygen,Ubuntu,Cantarell,\'Fira Sans\',\'Droid Sans\',\'Helvetica Neue\',sans-serif;color:#fff;background-color:#000}main>section.hero{display:flex;height:90vh;justify-content:center;align-items:center;flex-direction:column}.logo{display:flex;align-items:center}.buttons{margin-top:24px}h1{font-size:80px}h2{color:#888;max-width:50%;margin-top:0;text-align:center}a{color:#fff;text-decoration:none;margin-left:10px;margin-right:10px;font-weight:700;transition:color .3s ease;padding:4px;overflow:visible}a.graphiql:hover{color:rgba(255,0,255,.7)}a.docs:hover{color:rgba(28,200,238,.7)}a.tutorial:hover{color:rgba(125,85,245,.7)}svg{margin-right:24px}.not-what-your-looking-for{margin-top:5vh}.not-what-your-looking-for>*{margin-left:auto;margin-right:auto}.not-what-your-looking-for>p{text-align:center}.not-what-your-looking-for>h2{color:#464646}.not-what-your-looking-for>p{max-width:600px;line-height:1.3em}.not-what-your-looking-for>pre{max-width:300px}</style></head><body id=body><main><section class=hero><div class=logo><div><svg xmlns=http://www.w3.org/2000/svg viewBox="-0.41 0.445 472.812 499.811" height=150><defs><linearGradient id=paint0_linear_1677_11483 x1=16 y1=14 x2=87.2132 y2=44.5982 gradientUnits=userSpaceOnUse gradientTransform="matrix(8.139854, 0, 0, 8.139854, -130.346407, -113.25101)"><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><linearGradient id=paint1_linear_1677_11483 x1=16 y1=14 x2=87.2132 y2=44.5982 gradientUnits=userSpaceOnUse gradientTransform="matrix(8.139854, 0, 0, 8.139854, -130.346407, -113.25101)"><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><linearGradient id=paint2_linear_1677_11483 x1=16 y1=14 x2=87.2132 y2=44.5982 gradientUnits=userSpaceOnUse gradientTransform="matrix(8.139854, 0, 0, 8.139854, -130.346407, -113.25101)"><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><linearGradient id=paint3_linear_1677_11483 x1=16 y1=14 x2=87.2132 y2=44.5982 gradientUnits=userSpaceOnUse><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><linearGradient id=paint4_linear_1677_11483 x1=16 y1=14 x2=87.2132 y2=44.5982 gradientUnits=userSpaceOnUse><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><linearGradient id=paint5_linear_1677_11483 x1=16 y1=14 x2=87.2132 y2=44.5982 gradientUnits=userSpaceOnUse><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><filter id=filter0_f_1677_11483 x=23 y=-25 width=100 height=100 filterUnits=userSpaceOnUse color-interpolation-filters=sRGB><feFlood flood-opacity=0 result=BackgroundImageFix /><feBlend mode=normal in=SourceGraphic in2=BackgroundImageFix result=shape /><feGaussianBlur stdDeviation=12 result=effect1_foregroundBlur_1677_11483 /></filter><filter id=filter1_f_1677_11483 x=-24 y=19 width=100 height=100 filterUnits=userSpaceOnUse color-interpolation-filters=sRGB><feFlood flood-opacity=0 result=BackgroundImageFix /><feBlend mode=normal in=SourceGraphic in2=BackgroundImageFix result=shape /><feGaussianBlur stdDeviation=12 result=effect1_foregroundBlur_1677_11483 /></filter><linearGradient id=paint6_linear_1677_11483 x1=30 y1=28 x2=66.1645 y2=44.4363 gradientUnits=userSpaceOnUse gradientTransform="matrix(8.139854, 0, 0, 8.139854, -130.346407, -113.25101)"><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><filter id=filter2_f_1677_11483 x=-12 y=-44 width=100 height=100 filterUnits=userSpaceOnUse color-interpolation-filters=sRGB><feFlood flood-opacity=0 result=BackgroundImageFix /><feBlend mode=normal in=SourceGraphic in2=BackgroundImageFix result=shape /><feGaussianBlur stdDeviation=12 result=effect1_foregroundBlur_1677_11483 /></filter><filter id=filter3_f_1677_11483 x=13 y=19 width=100 height=100 filterUnits=userSpaceOnUse color-interpolation-filters=sRGB><feFlood flood-opacity=0 result=BackgroundImageFix /><feBlend mode=normal in=SourceGraphic in2=BackgroundImageFix result=shape /><feGaussianBlur stdDeviation=12 result=effect1_foregroundBlur_1677_11483 /></filter></defs><mask id=mask0_1677_11483 style=mask-type:alpha maskUnits=userSpaceOnUse x=16 y=14 width=58 height=62><path d="M21 25.3501C21.7279 25.3501 22.4195 25.5056 23.0433 25.7853L42.1439 14.8C43.0439 14.3 44.1439 14 45.1439 14C46.2439 14 47.2439 14.3 48.1439 14.8L64.5439 24.3C63.3439 25.1 62.4439 26.3 61.8439 27.7L45.9438 18.5C45.6439 18.3 45.344 18.3 45.0441 18.3C44.7441 18.3 44.4439 18.4 44.1439 18.5L25.8225 29.0251C25.9382 29.4471 26 29.8914 26 30.3501C26 33.1115 23.7614 35.3501 21 35.3501C18.2386 35.3501 16 33.1115 16 30.3501C16 27.5887 18.2386 25.3501 21 25.3501Z" fill=url(#paint3_linear_1677_11483) /><path d="M67.2438 35.0329C65.3487 34.3219 64 32.4934 64 30.35C64 27.5886 66.2386 25.35 69 25.35C71.7614 25.35 74 27.5886 74 30.35C74 32.1825 73.0142 33.7848 71.5439 34.6554V55.2C71.5439 57.4 70.3439 59.4 68.5439 60.5L52.1439 69.9C52.1439 68.4 51.6438 66.9 50.7438 65.8L66.3439 56.8C66.9439 56.5 67.2438 55.9 67.2438 55.2V35.0329Z" fill=url(#paint4_linear_1677_11483) /><path d="M49.8439 69.1055C49.9458 69.5034 50 69.9204 50 70.3501C50 73.1115 47.7614 75.3501 45 75.3501C42.5102 75.3501 40.4454 73.5302 40.0633 71.1481L21.8439 60.6C19.9439 59.5 18.8439 57.5 18.8439 55.3V36.8C19.5439 37 20.3439 37.2 21.0439 37.2C21.7439 37.2 22.4439 37.1 23.0439 36.9V55.3C23.0439 56 23.4438 56.6 23.9438 56.9L41.3263 66.9583C42.2398 65.9694 43.5476 65.3501 45 65.3501C47.3291 65.3501 49.2862 66.9426 49.8419 69.0981L49.8436 69.0997L49.8439 69.1055Z" fill=url(#paint5_linear_1677_11483) /></mask><mask id=mask1_1677_11483 style=mask-type:alpha maskUnits=userSpaceOnUse x=30 y=28 width=30 height=30><path fill-rule=evenodd clip-rule=evenodd d="M49.3945 32.3945C49.3945 34.7088 47.5796 38.5469 45 38.5469C42.4271 38.5469 40.6055 34.7112 40.6055 32.3945C40.6055 29.9714 42.5769 28 45 28C47.4231 28 49.3945 29.9714 49.3945 32.3945ZM35.332 49.0433V48.2148C35.332 42.8117 37.8535 41.0004 39.8796 39.545L39.8801 39.5447C40.3928 39.1767 40.8604 38.8404 41.2488 38.4742C42.3293 39.6642 43.626 40.3047 45 40.3047C46.3752 40.3047 47.6725 39.6642 48.7529 38.4754C49.1408 38.841 49.6078 39.1773 50.1199 39.5447L50.1204 39.545C52.1465 41.0004 54.668 42.8117 54.668 48.2148V49.0433L53.8406 49.092C49.9848 49.3185 46.8646 46.9002 45 43.5777C43.1159 46.935 39.9847 49.318 36.1594 49.092L35.332 49.0433ZM58.1463 51.0747L58.1463 51.0746C57.0179 50.891 50.0128 49.7507 45.0007 55.693C40.0116 49.7553 33.1965 50.8592 31.9095 51.0677L31.9095 51.0677C31.7906 51.087 31.7189 51.0986 31.7002 51.0963C31.7005 51.0969 31.7011 51.1045 31.7023 51.1187C31.726 51.4003 31.9682 54.2745 34.0566 56.2422L30 58H60L55.8956 56.2422C57.8537 54.4764 58.1396 52.2685 58.2508 51.4092V51.4091C58.2697 51.2628 58.2836 51.1556 58.2998 51.0963C58.2881 51.0977 58.2356 51.0892 58.1463 51.0747ZM40.4836 50.104C42.3956 49.3212 43.6746 48.1737 45 46.61C46.332 48.1841 47.6159 49.3259 49.5164 50.104C49.5356 50.1425 49.5557 50.1805 49.5756 50.2182C49.5793 50.2253 49.583 50.2323 49.5867 50.2393C48.0911 50.8127 46.4264 51.825 45.0047 53.1444C43.5906 51.8221 41.9673 50.8196 40.4256 50.2153C40.4455 50.1784 40.4648 50.1415 40.4836 50.104Z" fill=black /></mask><path d="M 40.59 93.095 C 46.517 93.095 52.14 94.365 57.22 96.635 L 212.7 7.22 C 220.025 3.149 228.978 0.706 237.12 0.706 C 246.073 0.706 254.213 3.149 261.54 7.22 L 395.032 84.547 C 385.264 91.059 377.939 100.827 373.055 112.224 L 243.631 37.338 C 241.19 35.71 238.747 35.71 236.305 35.71 C 233.863 35.71 231.42 36.523 228.978 37.338 L 79.84 123.009 C 80.786 126.443 81.29 130.058 81.29 133.793 C 81.29 156.269 63.065 174.493 40.59 174.493 C 18.116 174.493 -0.109 156.269 -0.109 133.793 C -0.109 111.32 18.116 93.095 40.59 93.095 Z" fill=url(#paint0_linear_1677_11483) /><path d="M 417.01 171.913 C 401.585 166.126 390.603 151.238 390.603 133.793 C 390.603 111.32 408.83 93.095 431.303 93.095 C 453.777 93.095 472.001 111.32 472.001 133.793 C 472.001 148.706 463.976 161.755 452.011 168.835 L 452.011 336.07 C 452.011 353.977 442.243 370.258 427.591 379.21 L 294.098 455.726 C 294.098 443.516 290.029 431.306 282.703 422.353 L 409.683 349.093 C 414.568 346.651 417.01 341.767 417.01 336.07 L 417.01 171.913 Z" fill=url(#paint1_linear_1677_11483) /><path d="M 275.376 449.253 C 276.206 452.495 276.646 455.889 276.646 459.389 C 276.646 481.863 258.422 500.087 235.947 500.087 C 215.679 500.087 198.87 485.272 195.761 465.883 L 47.46 380.025 C 31.995 371.071 23.041 354.792 23.041 336.884 L 23.041 186.296 C 28.738 187.923 35.25 189.553 40.948 189.553 C 46.646 189.553 52.345 188.738 57.228 187.111 L 57.228 336.884 C 57.228 342.582 60.485 347.465 64.554 349.908 L 206.042 431.777 C 213.481 423.728 224.127 418.689 235.947 418.689 C 254.905 418.689 270.833 431.656 275.36 449.196 L 275.376 449.214 L 275.376 449.253 Z" fill=url(#paint2_linear_1677_11483) /><g mask=url(#mask0_1677_11483) transform="matrix(8.139854, 0, 0, 8.139854, -130.346375, -113.251038)"><g filter=url(#filter0_f_1677_11483)><circle cx=73 cy=25 r=26 fill=#ED2E7E /></g><g filter=url(#filter1_f_1677_11483)><circle cx=26 cy=69 r=26 fill=#1CC8EE /></g></g><path fill-rule=evenodd clip-rule=evenodd d="M 271.713 150.431 C 271.713 169.275 256.948 200.517 235.947 200.517 C 215.003 200.517 200.172 169.292 200.172 150.431 C 200.172 130.708 216.225 114.666 235.947 114.666 C 255.67 114.666 271.713 130.708 271.713 150.431 Z M 157.251 285.952 L 157.251 279.212 C 157.251 235.233 177.771 220.485 194.27 208.641 C 198.447 205.644 202.247 202.901 205.414 199.923 C 214.204 209.608 224.763 214.826 235.947 214.826 C 247.138 214.826 257.697 209.608 266.496 199.931 C 269.653 202.911 273.456 205.644 277.622 208.641 C 294.114 220.485 314.642 235.233 314.642 279.212 L 314.642 285.952 L 307.912 286.351 C 276.525 288.191 251.128 268.509 235.947 241.468 C 220.611 268.795 195.126 288.191 163.981 286.351 L 157.251 285.952 Z M 342.953 302.492 C 333.771 300.994 276.751 291.715 235.955 340.082 C 195.345 291.749 139.865 300.734 129.389 302.436 C 128.428 302.59 127.841 302.688 127.687 302.665 C 127.687 302.673 127.695 302.729 127.702 302.85 C 127.897 305.138 129.867 328.532 146.872 344.55 L 113.849 358.862 L 358.044 358.862 L 324.639 344.55 C 340.576 330.177 342.905 312.202 343.807 305.212 C 343.962 304.022 344.077 303.153 344.206 302.665 C 344.108 302.68 343.686 302.606 342.953 302.492 Z M 199.188 294.59 C 214.751 288.215 225.161 278.879 235.947 266.15 C 246.788 278.96 257.241 288.255 272.707 294.59 C 272.869 294.898 273.031 295.207 273.196 295.518 C 273.219 295.574 273.252 295.631 273.285 295.688 C 261.107 300.361 247.555 308.598 235.989 319.334 C 224.477 308.573 211.258 300.417 198.715 295.493 C 198.87 295.191 199.033 294.891 199.188 294.59 Z" fill=url(#paint6_linear_1677_11483) /><g mask=url(#mask1_1677_11483) transform="matrix(8.139854, 0, 0, 8.139854, -130.346375, -113.251038)"><g filter=url(#filter2_f_1677_11483)><circle cx=38 cy=6 r=26 fill=#ED2E7E /></g><g filter=url(#filter3_f_1677_11483)><circle cx=63 cy=69 r=26 fill=#1CC8EE /></g></g></svg></div><h1>GraphQL Yoga</h1></div><h2>The batteries-included cross-platform GraphQL Server.</h2><div class=buttons><a href=https://www.the-guild.dev/graphql/yoga-server/v3 class=docs>Read the Docs</a> <a href=https://www.the-guild.dev/graphql/yoga-server/tutorial/basic class=tutorial>Start the Tutorial </a><a href=__GRAPHIQL_LINK__ class=graphiql>Visit GraphiQL</a></div></section><section class=not-what-your-looking-for><h2>Not the page you are looking for? \uD83D\uDC40</h2><p>This page is shown be default whenever a 404 is hit.<br>You can disable this by behavior via the <code>landingPage</code> option.</p><pre>\n          <code>\nimport { createYoga } from \'graphql-yoga\';\n\nconst yoga = createYoga({\n  landingPage: false\n})\n          </code>\n        </pre><p>If you expected this page to be the GraphQL route, you need to configure Yoga. Currently, the GraphQL route is configured to be on <code>__GRAPHIQL_LINK__</code>.</p><pre>\n          <code>\nimport { createYoga } from \'graphql-yoga\';\n\nconst yoga = createYoga({\n  graphqlEndpoint: \'__REQUEST_PATH__\',\n})\n          </code>\n        </pre></section></main></body></html>';


/***/ }),

/***/ 7458:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.parseGETRequest = exports.isGETRequest = void 0;
const utils_js_1 = __webpack_require__(1459);
const fetch_1 = __webpack_require__(8130);
function isGETRequest(request) {
    return request.method === "GET";
}
exports.isGETRequest = isGETRequest;
function parseGETRequest(request) {
    const [, queryString = ""] = request.url.split("?");
    const searchParams = new fetch_1.URLSearchParams(queryString);
    return (0, utils_js_1.handleURLSearchParams)(searchParams);
}
exports.parseGETRequest = parseGETRequest;


/***/ }),

/***/ 8504:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.parsePOSTFormUrlEncodedRequest = exports.isPOSTFormUrlEncodedRequest = void 0;
const utils_js_1 = __webpack_require__(1459);
function isPOSTFormUrlEncodedRequest(request) {
    return request.method === "POST" && (0, utils_js_1.isContentTypeMatch)(request, "application/x-www-form-urlencoded");
}
exports.isPOSTFormUrlEncodedRequest = isPOSTFormUrlEncodedRequest;
async function parsePOSTFormUrlEncodedRequest(request) {
    const requestBody = await request.text();
    return (0, utils_js_1.parseURLSearchParams)(requestBody);
}
exports.parsePOSTFormUrlEncodedRequest = parsePOSTFormUrlEncodedRequest;


/***/ }),

/***/ 1777:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.parsePOSTGraphQLStringRequest = exports.isPOSTGraphQLStringRequest = void 0;
const utils_js_1 = __webpack_require__(1459);
function isPOSTGraphQLStringRequest(request) {
    return request.method === "POST" && (0, utils_js_1.isContentTypeMatch)(request, "application/graphql");
}
exports.isPOSTGraphQLStringRequest = isPOSTGraphQLStringRequest;
async function parsePOSTGraphQLStringRequest(request) {
    const requestBody = await request.text();
    return {
        query: requestBody
    };
}
exports.parsePOSTGraphQLStringRequest = parsePOSTGraphQLStringRequest;


/***/ }),

/***/ 4677:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.parsePOSTJsonRequest = exports.isPOSTJsonRequest = void 0;
const utils_1 = __webpack_require__(6887);
const utils_js_1 = __webpack_require__(1459);
function isPOSTJsonRequest(request) {
    return request.method === "POST" && ((0, utils_js_1.isContentTypeMatch)(request, "application/json") || (0, utils_js_1.isContentTypeMatch)(request, "application/graphql+json"));
}
exports.isPOSTJsonRequest = isPOSTJsonRequest;
async function parsePOSTJsonRequest(request) {
    let requestBody;
    try {
        requestBody = await request.json();
    } catch (err) {
        const extensions = {
            http: {
                spec: true,
                status: 400
            }
        };
        if (err instanceof Error) {
            extensions.originalError = {
                name: err.name,
                message: err.message
            };
        }
        throw (0, utils_1.createGraphQLError)("POST body sent invalid JSON.", {
            extensions
        });
    }
    if (requestBody == null) {
        throw (0, utils_1.createGraphQLError)(`POST body is expected to be object but received ${requestBody}`, {
            extensions: {
                http: {
                    status: 400
                }
            }
        });
    }
    const requestBodyTypeof = typeof requestBody;
    if (requestBodyTypeof !== "object") {
        throw (0, utils_1.createGraphQLError)(`POST body is expected to be object but received ${requestBodyTypeof}`, {
            extensions: {
                http: {
                    status: 400
                }
            }
        });
    }
    return requestBody;
}
exports.parsePOSTJsonRequest = parsePOSTJsonRequest;


/***/ }),

/***/ 8087:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.parsePOSTMultipartRequest = exports.isPOSTMultipartRequest = void 0;
const utils_1 = __webpack_require__(6887);
const dset_1 = __webpack_require__(332);
const utils_js_1 = __webpack_require__(1459);
function isPOSTMultipartRequest(request) {
    return request.method === "POST" && (0, utils_js_1.isContentTypeMatch)(request, "multipart/form-data");
}
exports.isPOSTMultipartRequest = isPOSTMultipartRequest;
async function parsePOSTMultipartRequest(request) {
    let requestBody;
    try {
        requestBody = await request.formData();
    } catch (e) {
        if (e instanceof Error && e.message.startsWith("File size limit exceeded: ")) {
            throw (0, utils_1.createGraphQLError)(e.message, {
                extensions: {
                    http: {
                        status: 413
                    }
                }
            });
        }
        throw e;
    }
    const operationsStr = requestBody.get("operations");
    if (!operationsStr) {
        throw (0, utils_1.createGraphQLError)('Missing multipart form field "operations"');
    }
    if (typeof operationsStr !== "string") {
        throw (0, utils_1.createGraphQLError)('Multipart form field "operations" must be a string');
    }
    let operations;
    try {
        operations = JSON.parse(operationsStr);
    } catch (err) {
        throw (0, utils_1.createGraphQLError)('Multipart form field "operations" must be a valid JSON string');
    }
    const mapStr = requestBody.get("map");
    if (mapStr != null) {
        if (typeof mapStr !== "string") {
            throw (0, utils_1.createGraphQLError)('Multipart form field "map" must be a string');
        }
        let map;
        try {
            map = JSON.parse(mapStr);
        } catch (err) {
            throw (0, utils_1.createGraphQLError)('Multipart form field "map" must be a valid JSON string');
        }
        for(const fileIndex in map){
            const file = requestBody.get(fileIndex);
            const keys = map[fileIndex];
            for (const key of keys){
                (0, dset_1.dset)(operations, key, file);
            }
        }
    }
    return operations;
}
exports.parsePOSTMultipartRequest = parsePOSTMultipartRequest;


/***/ }),

/***/ 1459:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.isContentTypeMatch = exports.parseURLSearchParams = exports.handleURLSearchParams = void 0;
const fetch_1 = __webpack_require__(8130);
function handleURLSearchParams(searchParams) {
    const operationName = searchParams.get("operationName") || undefined;
    const query = searchParams.get("query") || undefined;
    const variablesStr = searchParams.get("variables") || undefined;
    const extensionsStr = searchParams.get("extensions") || undefined;
    return {
        operationName,
        query,
        variables: variablesStr ? JSON.parse(variablesStr) : undefined,
        extensions: extensionsStr ? JSON.parse(extensionsStr) : undefined
    };
}
exports.handleURLSearchParams = handleURLSearchParams;
function parseURLSearchParams(requestBody) {
    const searchParams = new fetch_1.URLSearchParams(requestBody);
    return handleURLSearchParams(searchParams);
}
exports.parseURLSearchParams = parseURLSearchParams;
function isContentTypeMatch(request, expectedContentType) {
    let contentType = request.headers.get("content-type");
    // a list of content-types is not valid as per HTTP spec, but some clients dont care
    contentType = contentType?.split(",")[0] || null;
    return contentType === expectedContentType || !!contentType?.startsWith(`${expectedContentType};`);
}
exports.isContentTypeMatch = isContentTypeMatch;


/***/ }),

/***/ 307:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useCheckGraphQLQueryParams = exports.isValidGraphQLParams = exports.checkGraphQLQueryParams = exports.assertInvalidParams = void 0;
const utils_1 = __webpack_require__(6887);
const expectedParameters = new Set([
    "query",
    "variables",
    "operationName",
    "extensions"
]);
function assertInvalidParams(params) {
    if (params == null || typeof params !== "object") {
        throw (0, utils_1.createGraphQLError)('Invalid "params" in the request body', {
            extensions: {
                http: {
                    spec: true,
                    status: 400
                }
            }
        });
    }
    for(const paramKey in params){
        if (params[paramKey] == null) {
            continue;
        }
        if (!expectedParameters.has(paramKey)) {
            throw (0, utils_1.createGraphQLError)(`Unexpected parameter "${paramKey}" in the request body.`, {
                extensions: {
                    http: {
                        status: 400
                    }
                }
            });
        }
    }
}
exports.assertInvalidParams = assertInvalidParams;
function checkGraphQLQueryParams(params) {
    if (!isObject(params)) {
        throw (0, utils_1.createGraphQLError)(`Expected params to be an object but given ${extendedTypeof(params)}.`, {
            extensions: {
                http: {
                    status: 400,
                    headers: {
                        Allow: "GET, POST"
                    }
                }
            }
        });
    }
    assertInvalidParams(params);
    if (params.query == null) {
        throw (0, utils_1.createGraphQLError)("Must provide query string.", {
            extensions: {
                http: {
                    spec: true,
                    status: 400,
                    headers: {
                        Allow: "GET, POST"
                    }
                }
            }
        });
    }
    const queryType = extendedTypeof(params.query);
    if (queryType !== "string") {
        throw (0, utils_1.createGraphQLError)(`Expected "query" param to be a string, but given ${queryType}.`, {
            extensions: {
                http: {
                    status: 400,
                    headers: {
                        Allow: "GET, POST"
                    }
                }
            }
        });
    }
    const variablesParamType = extendedTypeof(params.variables);
    if (![
        "object",
        "null",
        "undefined"
    ].includes(variablesParamType)) {
        throw (0, utils_1.createGraphQLError)(`Expected "variables" param to be empty or an object, but given ${variablesParamType}.`, {
            extensions: {
                http: {
                    status: 400,
                    headers: {
                        Allow: "GET, POST"
                    }
                }
            }
        });
    }
    const extensionsParamType = extendedTypeof(params.extensions);
    if (![
        "object",
        "null",
        "undefined"
    ].includes(extensionsParamType)) {
        throw (0, utils_1.createGraphQLError)(`Expected "extensions" param to be empty or an object, but given ${extensionsParamType}.`, {
            extensions: {
                http: {
                    status: 400,
                    headers: {
                        Allow: "GET, POST"
                    }
                }
            }
        });
    }
    return params;
}
exports.checkGraphQLQueryParams = checkGraphQLQueryParams;
function isValidGraphQLParams(params) {
    try {
        checkGraphQLQueryParams(params);
        return true;
    } catch  {
        return false;
    }
}
exports.isValidGraphQLParams = isValidGraphQLParams;
function useCheckGraphQLQueryParams() {
    return {
        onParams ({ params  }) {
            checkGraphQLQueryParams(params);
        }
    };
}
exports.useCheckGraphQLQueryParams = useCheckGraphQLQueryParams;
function extendedTypeof(val) {
    if (val === null) {
        return "null";
    }
    if (Array.isArray(val)) {
        return "array";
    }
    return typeof val;
}
function isObject(val) {
    return extendedTypeof(val) === "object";
}


/***/ }),

/***/ 4279:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useCheckMethodForGraphQL = exports.isValidMethodForGraphQL = void 0;
const utils_1 = __webpack_require__(6887);
function isValidMethodForGraphQL(method) {
    return method === "GET" || method === "POST";
}
exports.isValidMethodForGraphQL = isValidMethodForGraphQL;
function useCheckMethodForGraphQL() {
    return {
        onRequestParse ({ request  }) {
            if (!isValidMethodForGraphQL(request.method)) {
                throw (0, utils_1.createGraphQLError)("GraphQL only supports GET and POST requests.", {
                    extensions: {
                        http: {
                            status: 405,
                            headers: {
                                Allow: "GET, POST"
                            }
                        }
                    }
                });
            }
        }
    };
}
exports.useCheckMethodForGraphQL = useCheckMethodForGraphQL;


/***/ }),

/***/ 8478:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useHTTPValidationError = void 0;
function useHTTPValidationError() {
    return {
        onValidate () {
            return ({ valid , result  })=>{
                if (!valid) {
                    result.forEach((error)=>{
                        error.extensions.http = {
                            spec: true,
                            status: 400
                        };
                    });
                }
            };
        }
    };
}
exports.useHTTPValidationError = useHTTPValidationError;


/***/ }),

/***/ 9920:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useLimitBatching = void 0;
const error_js_1 = __webpack_require__(2497);
function useLimitBatching(limit) {
    return {
        onRequestParse () {
            return {
                onRequestParseDone ({ requestParserResult  }) {
                    if (Array.isArray(requestParserResult)) {
                        if (!limit) {
                            throw (0, error_js_1.createGraphQLError)(`Batching is not supported.`, {
                                extensions: {
                                    http: {
                                        status: 400
                                    }
                                }
                            });
                        }
                        if (requestParserResult.length > limit) {
                            throw (0, error_js_1.createGraphQLError)(`Batching is limited to ${limit} operations per request.`, {
                                extensions: {
                                    http: {
                                        status: 413
                                    }
                                }
                            });
                        }
                    }
                }
            };
        }
    };
}
exports.useLimitBatching = useLimitBatching;


/***/ }),

/***/ 2659:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.usePreventMutationViaGET = exports.assertMutationViaGet = void 0;
const graphql_1 = __webpack_require__(5736);
const utils_1 = __webpack_require__(6887);
function assertMutationViaGet(method, document, operationName) {
    const operation = document ? (0, graphql_1.getOperationAST)(document, operationName) ?? undefined : undefined;
    if (!operation) {
        throw (0, utils_1.createGraphQLError)("Could not determine what operation to execute.", {
            extensions: {
                http: {
                    status: 400
                }
            }
        });
    }
    if (operation.operation === "mutation" && method === "GET") {
        throw (0, utils_1.createGraphQLError)("Can only perform a mutation operation from a POST request.", {
            extensions: {
                http: {
                    status: 405,
                    headers: {
                        Allow: "POST"
                    }
                }
            }
        });
    }
}
exports.assertMutationViaGet = assertMutationViaGet;
function usePreventMutationViaGET() {
    return {
        onParse () {
            // We should improve this by getting Yoga stuff from the hook params directly instead of the context
            return ({ result , context: { request , // the `params` might be missing in cases where the user provided
            // malformed context to getEnveloped (like `yoga.getEnveloped({})`)
            params: { operationName  } = {}  }  })=>{
                // Run only if this is a Yoga request
                // the `request` might be missing when using graphql-ws for example
                // in which case throwing an error would abruptly close the socket
                if (!request) {
                    return;
                }
                if (result instanceof Error) {
                    if (result instanceof graphql_1.GraphQLError) {
                        result.extensions.http = {
                            spec: true,
                            status: 400
                        };
                    }
                    throw result;
                }
                assertMutationViaGet(request.method, result, operationName);
            };
        }
    };
}
exports.usePreventMutationViaGET = usePreventMutationViaGET;


/***/ }),

/***/ 8687:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.isMatchingMediaType = exports.getMediaTypesForRequestInOrder = void 0;
function getMediaTypesForRequestInOrder(request) {
    const accepts = (request.headers.get("accept") || "*/*").replace(/\s/g, "").toLowerCase().split(",");
    const mediaTypes = [];
    for (const accept of accepts){
        const [mediaType, ...params] = accept.split(";");
        const charset = params?.find((param)=>param.includes("charset=")) || "charset=utf-8"; // utf-8 is assumed when not specified;
        if (charset !== "charset=utf-8") {
            continue;
        }
        mediaTypes.push(mediaType);
    }
    return mediaTypes.reverse();
}
exports.getMediaTypesForRequestInOrder = getMediaTypesForRequestInOrder;
function isMatchingMediaType(askedMediaType, processorMediaType) {
    const [askedPre, askedSuf] = askedMediaType.split("/");
    const [pre, suf] = processorMediaType.split("/");
    if ((pre === "*" || pre === askedPre) && (suf === "*" || suf === askedSuf)) {
        return true;
    }
    return false;
}
exports.isMatchingMediaType = isMatchingMediaType;


/***/ }),

/***/ 3602:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.processMultipartResult = void 0;
const core_1 = __webpack_require__(686);
const error_js_1 = __webpack_require__(2497);
const stringify_js_1 = __webpack_require__(5535);
function processMultipartResult(result, fetchAPI) {
    const headersInit = {
        Connection: "keep-alive",
        "Content-Type": 'multipart/mixed; boundary="-"',
        "Transfer-Encoding": "chunked"
    };
    const responseInit = (0, error_js_1.getResponseInitByRespectingErrors)(result, headersInit);
    let iterator;
    const textEncoder = new fetchAPI.TextEncoder();
    const readableStream = new fetchAPI.ReadableStream({
        start (controller) {
            if ((0, core_1.isAsyncIterable)(result)) {
                iterator = result[Symbol.asyncIterator]();
            } else {
                let finished = false;
                iterator = {
                    next: ()=>{
                        if (finished) {
                            return Promise.resolve({
                                done: true,
                                value: null
                            });
                        }
                        finished = true;
                        return Promise.resolve({
                            done: false,
                            value: result
                        });
                    }
                };
            }
            controller.enqueue(textEncoder.encode(`---`));
        },
        async pull (controller) {
            const { done , value  } = await iterator.next();
            if (value != null) {
                controller.enqueue(textEncoder.encode("\r\n"));
                controller.enqueue(textEncoder.encode("Content-Type: application/json; charset=utf-8"));
                controller.enqueue(textEncoder.encode("\r\n"));
                const chunk = (0, stringify_js_1.jsonStringifyResultWithoutInternals)(value);
                const encodedChunk = textEncoder.encode(chunk);
                controller.enqueue(textEncoder.encode("Content-Length: " + encodedChunk.byteLength));
                controller.enqueue(textEncoder.encode("\r\n"));
                controller.enqueue(textEncoder.encode("\r\n"));
                controller.enqueue(encodedChunk);
                controller.enqueue(textEncoder.encode("\r\n"));
                controller.enqueue(textEncoder.encode("---"));
            }
            if (done) {
                controller.enqueue(textEncoder.encode("--\r\n"));
                controller.close();
            }
        },
        async cancel (e) {
            await iterator.return?.(e);
        }
    });
    return new fetchAPI.Response(readableStream, responseInit);
}
exports.processMultipartResult = processMultipartResult;


/***/ }),

/***/ 1757:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.processRegularResult = void 0;
const utils_1 = __webpack_require__(6887);
const error_js_1 = __webpack_require__(2497);
const stringify_js_1 = __webpack_require__(5535);
function processRegularResult(executionResult, fetchAPI, acceptedHeader) {
    if ((0, utils_1.isAsyncIterable)(executionResult)) {
        return new fetchAPI.Response(null, {
            status: 406,
            statusText: "Not Acceptable",
            headers: {
                accept: "application/json; charset=utf-8, application/graphql-response+json; charset=utf-8"
            }
        });
    }
    const headersInit = {
        "Content-Type": acceptedHeader + "; charset=utf-8"
    };
    const responseInit = (0, error_js_1.getResponseInitByRespectingErrors)(executionResult, headersInit, // prefer 200 only if accepting application/json and all errors are exclusively GraphQL errors
    acceptedHeader === "application/json" && !Array.isArray(executionResult) && (0, error_js_1.areGraphQLErrors)(executionResult.errors) && executionResult.errors.some((err)=>!err.extensions.originalError || (0, error_js_1.isGraphQLError)(err.extensions.originalError)));
    const responseBody = (0, stringify_js_1.jsonStringifyResultWithoutInternals)(executionResult);
    return new fetchAPI.Response(responseBody, responseInit);
}
exports.processRegularResult = processRegularResult;


/***/ }),

/***/ 6960:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getSSEProcessor = void 0;
const core_1 = __webpack_require__(686);
const error_js_1 = __webpack_require__(2497);
const stringify_js_1 = __webpack_require__(5535);
function getSSEProcessor(opts) {
    return function processSSEResult(result, fetchAPI) {
        let pingIntervalMs = 12000;
        // for testing the pings, reduce the timeout
        if (globalThis.process?.env?.NODE_ENV === "test") {
            pingIntervalMs = 300;
        }
        const headersInit = {
            "Content-Type": "text/event-stream",
            Connection: "keep-alive",
            "Cache-Control": "no-cache",
            "Content-Encoding": "none"
        };
        const responseInit = (0, error_js_1.getResponseInitByRespectingErrors)(result, headersInit, !opts.legacySSE);
        let iterator;
        let pingInterval;
        const textEncoder = new fetchAPI.TextEncoder();
        const readableStream = new fetchAPI.ReadableStream({
            start (controller) {
                // ping client every 12 seconds to keep the connection alive
                pingInterval = setInterval(()=>{
                    if (!controller.desiredSize) {
                        clearInterval(pingInterval);
                        return;
                    }
                    controller.enqueue(textEncoder.encode(":\n\n"));
                }, pingIntervalMs);
                if ((0, core_1.isAsyncIterable)(result)) {
                    iterator = result[Symbol.asyncIterator]();
                } else {
                    let finished = false;
                    iterator = {
                        next: ()=>{
                            if (finished) {
                                return Promise.resolve({
                                    done: true,
                                    value: null
                                });
                            }
                            finished = true;
                            return Promise.resolve({
                                done: false,
                                value: result
                            });
                        }
                    };
                }
            },
            async pull (controller) {
                const { done , value  } = await iterator.next();
                if (value != null) {
                    if (!opts.legacySSE) {
                        controller.enqueue(textEncoder.encode(`event: next\n`));
                    }
                    const chunk = (0, stringify_js_1.jsonStringifyResultWithoutInternals)(value);
                    controller.enqueue(textEncoder.encode(`data: ${chunk}\n\n`));
                }
                if (done) {
                    controller.enqueue(textEncoder.encode(`event: complete\n\n`));
                    clearInterval(pingInterval);
                    controller.close();
                }
            },
            async cancel (e) {
                clearInterval(pingInterval);
                await iterator.return?.(e);
            }
        });
        return new fetchAPI.Response(readableStream, responseInit);
    };
}
exports.getSSEProcessor = getSSEProcessor;


/***/ }),

/***/ 5535:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.jsonStringifyResultWithoutInternals = void 0;
const error_js_1 = __webpack_require__(2497);
// JSON stringifier that adjusts the result error extensions while serialising
function jsonStringifyResultWithoutInternals(result) {
    return JSON.stringify(Array.isArray(result) ? result.map(omitInternalsFromResultErrors) : omitInternalsFromResultErrors(result));
}
exports.jsonStringifyResultWithoutInternals = jsonStringifyResultWithoutInternals;
function omitInternalsFromResultErrors(result) {
    if (result.errors?.length || result.extensions?.http) {
        const newResult = {
            ...result
        };
        newResult.errors && (newResult.errors = newResult.errors.map(omitInternalsFromError));
        if (newResult.extensions) {
            // eslint-disable-next-line @typescript-eslint/no-unused-vars -- TS should check for unused vars instead
            const { http , ...extensions } = result.extensions;
            newResult.extensions = Object.keys(extensions).length ? extensions : undefined;
        }
        return newResult;
    }
    return result;
}
function omitInternalsFromError(err) {
    if ((0, error_js_1.isGraphQLError)(err)) {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars -- TS should check for unused vars instead
        const { http , unexpected , ...extensions } = err.extensions;
        return (0, error_js_1.createGraphQLError)(err.message, {
            nodes: err.nodes,
            source: err.source,
            positions: err.positions,
            path: err.path,
            originalError: omitInternalsFromError(err.originalError),
            extensions: Object.keys(extensions).length ? extensions : undefined
        });
    }
    return err;
}


/***/ }),

/***/ 1879:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useGraphiQL = exports.renderGraphiQL = exports.shouldRenderGraphiQL = void 0;
const tslib_1 = __webpack_require__(4479);
const graphiql_html_js_1 = tslib_1.__importDefault(__webpack_require__(4403));
function shouldRenderGraphiQL({ headers , method  }) {
    return method === "GET" && !!headers?.get("accept")?.includes("text/html");
}
exports.shouldRenderGraphiQL = shouldRenderGraphiQL;
const renderGraphiQL = (opts)=>graphiql_html_js_1.default.replace("__TITLE__", opts?.title || "Yoga GraphiQL").replace("__OPTS__", JSON.stringify(opts ?? {}));
exports.renderGraphiQL = renderGraphiQL;
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function useGraphiQL(config) {
    const logger = config.logger ?? console;
    let graphiqlOptionsFactory;
    if (typeof config?.options === "function") {
        graphiqlOptionsFactory = config?.options;
    } else if (typeof config?.options === "object") {
        graphiqlOptionsFactory = ()=>config?.options;
    } else if (config?.options === false) {
        graphiqlOptionsFactory = ()=>false;
    } else {
        graphiqlOptionsFactory = ()=>({});
    }
    const renderer = config?.render ?? exports.renderGraphiQL;
    let urlPattern;
    const getUrlPattern = ({ URLPattern  })=>{
        urlPattern || (urlPattern = new URLPattern({
            pathname: config.graphqlEndpoint
        }));
        return urlPattern;
    };
    return {
        async onRequest ({ request , serverContext , fetchAPI , endResponse , url  }) {
            if (shouldRenderGraphiQL(request) && (request.url.endsWith(config.graphqlEndpoint) || url.pathname === config.graphqlEndpoint || getUrlPattern(fetchAPI).test(url))) {
                logger.debug(`Rendering GraphiQL`);
                const graphiqlOptions = await graphiqlOptionsFactory(request, serverContext);
                if (graphiqlOptions) {
                    const graphiQLBody = await renderer({
                        ...graphiqlOptions === true ? {} : graphiqlOptions
                    });
                    const response = new fetchAPI.Response(graphiQLBody, {
                        headers: {
                            "Content-Type": "text/html"
                        },
                        status: 200
                    });
                    endResponse(response);
                }
            }
        }
    };
}
exports.useGraphiQL = useGraphiQL;


/***/ }),

/***/ 3445:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useHealthCheck = void 0;
function useHealthCheck({ id =Date.now().toString() , logger =console , endpoint ="/health"  } = {}) {
    return {
        onRequest ({ endResponse , fetchAPI , request  }) {
            if (request.url.endsWith(endpoint)) {
                logger.debug("Responding Health Check");
                const response = new fetchAPI.Response(null, {
                    status: 200,
                    headers: {
                        "x-yoga-id": id
                    }
                });
                endResponse(response);
            }
        }
    };
}
exports.useHealthCheck = useHealthCheck;


/***/ }),

/***/ 6783:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useParserAndValidationCache = void 0;
const create_lru_cache_js_1 = __webpack_require__(7503);
function useParserAndValidationCache({ documentCache =(0, create_lru_cache_js_1.createLRUCache)() , errorCache =(0, create_lru_cache_js_1.createLRUCache)() , validationCache =true  }) {
    const validationCacheByRules = (0, create_lru_cache_js_1.createLRUCache)();
    return {
        onParse ({ params , setParsedDocument  }) {
            const strDocument = params.source.toString();
            const document = documentCache.get(strDocument);
            if (document) {
                setParsedDocument(document);
                return;
            }
            const parserError = errorCache.get(strDocument);
            if (parserError) {
                throw parserError;
            }
            return ({ result  })=>{
                if (result != null) {
                    if (result instanceof Error) {
                        errorCache.set(strDocument, result);
                    } else {
                        documentCache.set(strDocument, result);
                    }
                }
            };
        },
        onValidate ({ params: { schema , documentAST , rules  } , setResult  }) {
            if (validationCache !== false) {
                const rulesKey = rules?.map((rule)=>rule.name).join(",") || "";
                let validationCacheBySchema = validationCacheByRules.get(rulesKey);
                if (!validationCacheBySchema) {
                    validationCacheBySchema = new WeakMap();
                    validationCacheByRules.set(rulesKey, validationCacheBySchema);
                }
                let validationCacheByDocument = validationCacheBySchema.get(schema);
                if (!validationCacheByDocument) {
                    validationCacheByDocument = new WeakMap();
                    validationCacheBySchema.set(schema, validationCacheByDocument);
                }
                const cachedResult = validationCacheByDocument.get(documentAST);
                if (cachedResult) {
                    setResult(cachedResult);
                    return;
                }
                return ({ result  })=>{
                    if (result != null) {
                        validationCacheByDocument?.set(documentAST, result);
                    }
                };
            }
        }
    };
}
exports.useParserAndValidationCache = useParserAndValidationCache;


/***/ }),

/***/ 8613:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useReadinessCheck = void 0;
/**
 * Adds a readiness check for Yoga by simply implementing the `check` option.
 */ function useReadinessCheck({ endpoint ="/ready" , check  }) {
    let urlPattern;
    return {
        onYogaInit ({ yoga  }) {
            urlPattern = new yoga.fetchAPI.URLPattern({
                pathname: endpoint
            });
        },
        async onRequest ({ request , endResponse , fetchAPI , url  }) {
            if (request.url.endsWith(endpoint) || url.pathname === endpoint || urlPattern.test(url)) {
                let response;
                try {
                    const readyOrResponse = await check({
                        request,
                        fetchAPI
                    });
                    if (typeof readyOrResponse === "object") {
                        response = readyOrResponse;
                    } else {
                        response = new fetchAPI.Response(null, {
                            status: readyOrResponse === false ? 503 : 200
                        });
                    }
                } catch (err) {
                    const isError = err instanceof Error;
                    response = new fetchAPI.Response(isError ? err.message : null, {
                        status: 503,
                        headers: isError ? {
                            "content-type": "text/plain; charset=utf-8"
                        } : {}
                    });
                }
                endResponse(response);
            }
        }
    };
}
exports.useReadinessCheck = useReadinessCheck;


/***/ }),

/***/ 6261:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useRequestParser = void 0;
const DEFAULT_MATCHER = ()=>true;
function useRequestParser(options) {
    const matchFn = options.match || DEFAULT_MATCHER;
    return {
        onRequestParse ({ request , setRequestParser  }) {
            if (matchFn(request)) {
                setRequestParser(options.parse);
            }
        }
    };
}
exports.useRequestParser = useRequestParser;


/***/ }),

/***/ 3634:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useResultProcessors = void 0;
const core_1 = __webpack_require__(686);
const accept_js_1 = __webpack_require__(8687);
const multipart_js_1 = __webpack_require__(3602);
const sse_js_1 = __webpack_require__(6960);
const regular_js_1 = __webpack_require__(1757);
const multipart = {
    mediaTypes: [
        "multipart/mixed"
    ],
    asyncIterables: true,
    processResult: multipart_js_1.processMultipartResult
};
function getSSEProcessorConfig(opts) {
    return {
        mediaTypes: [
            "text/event-stream"
        ],
        asyncIterables: true,
        processResult: (0, sse_js_1.getSSEProcessor)(opts)
    };
}
const regular = {
    mediaTypes: [
        "application/graphql-response+json",
        "application/json"
    ],
    asyncIterables: false,
    processResult: regular_js_1.processRegularResult
};
function useResultProcessors(opts) {
    const isSubscriptionRequestMap = new WeakMap();
    const sse = getSSEProcessorConfig(opts);
    const defaultList = [
        sse,
        multipart,
        regular
    ];
    const subscriptionList = [
        multipart,
        sse,
        regular
    ];
    return {
        onSubscribe ({ args: { contextValue  }  }) {
            if (contextValue.request) {
                isSubscriptionRequestMap.set(contextValue.request, true);
            }
        },
        onResultProcess ({ request , result , acceptableMediaTypes , setResultProcessor  }) {
            const isSubscriptionRequest = isSubscriptionRequestMap.get(request);
            const processorConfigList = isSubscriptionRequest ? subscriptionList : defaultList;
            const requestMediaTypes = (0, accept_js_1.getMediaTypesForRequestInOrder)(request);
            const isAsyncIterableResult = (0, core_1.isAsyncIterable)(result);
            for (const resultProcessorConfig of processorConfigList){
                for (const requestMediaType of requestMediaTypes){
                    if (isAsyncIterableResult && !resultProcessorConfig.asyncIterables) {
                        continue;
                    }
                    for (const processorMediaType of resultProcessorConfig.mediaTypes){
                        acceptableMediaTypes.push(processorMediaType);
                        if ((0, accept_js_1.isMatchingMediaType)(processorMediaType, requestMediaType)) {
                            setResultProcessor(resultProcessorConfig.processResult, processorMediaType);
                        }
                    }
                }
            }
        }
    };
}
exports.useResultProcessors = useResultProcessors;


/***/ }),

/***/ 3838:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useSchema = void 0;
const graphql_1 = __webpack_require__(5736);
const useSchema = (schemaDef)=>{
    if (schemaDef == null) {
        return {};
    }
    if ((0, graphql_1.isSchema)(schemaDef)) {
        return {
            onPluginInit ({ setSchema  }) {
                setSchema(schemaDef);
            }
        };
    }
    if ("then" in schemaDef) {
        let schema;
        return {
            onRequestParse () {
                return {
                    async onRequestParseDone () {
                        if (!schema) {
                            schema = await schemaDef;
                        }
                    }
                };
            },
            onEnveloped ({ setSchema  }) {
                if (!schema) {
                    throw new Error(`You provide a promise of a schema but it hasn't been resolved yet. Make sure you use this plugin with GraphQL Yoga.`);
                }
                setSchema(schema);
            }
        };
    }
    const schemaByRequest = new WeakMap();
    return {
        onRequestParse ({ request , serverContext  }) {
            return {
                async onRequestParseDone () {
                    const schema = await schemaDef({
                        ...serverContext,
                        request
                    });
                    schemaByRequest.set(request, schema);
                }
            };
        },
        onEnveloped ({ setSchema , context  }) {
            if (context?.request == null) {
                throw new Error("Request object is not available in the context. Make sure you use this plugin with GraphQL Yoga.");
            }
            const schema = schemaByRequest.get(context.request);
            if (schema == null) {
                throw new Error(`No schema found for this request. Make sure you use this plugin with GraphQL Yoga.`);
            }
            setSchema(schema);
        }
    };
};
exports.useSchema = useSchema;


/***/ }),

/***/ 5492:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useUnhandledRoute = void 0;
const tslib_1 = __webpack_require__(4479);
const landing_page_html_js_1 = tslib_1.__importDefault(__webpack_require__(4139));
function useUnhandledRoute(args) {
    let urlPattern;
    function getUrlPattern({ URLPattern  }) {
        urlPattern || (urlPattern = new URLPattern({
            pathname: args.graphqlEndpoint
        }));
        return urlPattern;
    }
    return {
        onRequest ({ request , fetchAPI , endResponse , url  }) {
            if (!request.url.endsWith(args.graphqlEndpoint) && url.pathname !== args.graphqlEndpoint && !getUrlPattern(fetchAPI).test(url)) {
                if (args.showLandingPage === true && request.method === "GET" && !!request.headers?.get("accept")?.includes("text/html")) {
                    endResponse(new fetchAPI.Response(landing_page_html_js_1.default.replace(/__GRAPHIQL_LINK__/g, args.graphqlEndpoint).replace(/__REQUEST_PATH__/g, url.pathname), {
                        status: 200,
                        statusText: "OK",
                        headers: {
                            "Content-Type": "text/html"
                        }
                    }));
                    return;
                }
                endResponse(new fetchAPI.Response("", {
                    status: 404,
                    statusText: "Not Found"
                }));
            }
        }
    };
}
exports.useUnhandledRoute = useUnhandledRoute;


/***/ }),

/***/ 9624:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.processRequest = exports.processResult = void 0;
const graphql_1 = __webpack_require__(5736);
async function processResult({ request , result , fetchAPI , onResultProcessHooks  }) {
    let resultProcessor;
    const acceptableMediaTypes = [];
    let acceptedMediaType = "*/*";
    for (const onResultProcessHook of onResultProcessHooks){
        await onResultProcessHook({
            request,
            acceptableMediaTypes,
            result,
            setResult (newResult) {
                result = newResult;
            },
            resultProcessor,
            setResultProcessor (newResultProcessor, newAcceptedMimeType) {
                resultProcessor = newResultProcessor;
                acceptedMediaType = newAcceptedMimeType;
            }
        });
    }
    // If no result processor found for this result, return an error
    if (!resultProcessor) {
        return new fetchAPI.Response(null, {
            status: 406,
            statusText: "Not Acceptable",
            headers: {
                accept: acceptableMediaTypes.join("; charset=utf-8, ")
            }
        });
    }
    return resultProcessor(result, fetchAPI, acceptedMediaType);
}
exports.processResult = processResult;
async function processRequest({ params , enveloped  }) {
    // Parse GraphQLParams
    const document = enveloped.parse(params.query);
    // Validate parsed Document Node
    const errors = enveloped.validate(enveloped.schema, document);
    if (errors.length > 0) {
        return {
            errors
        };
    }
    // Build the context for the execution
    const contextValue = await enveloped.contextFactory();
    const executionArgs = {
        schema: enveloped.schema,
        document,
        contextValue,
        variableValues: params.variables,
        operationName: params.operationName
    };
    // Get the actual operation
    const operation = (0, graphql_1.getOperationAST)(document, params.operationName);
    // Choose the right executor
    const executeFn = operation?.operation === "subscription" ? enveloped.subscribe : enveloped.execute;
    // Get the result to be processed
    return executeFn(executionArgs);
}
exports.processRequest = processRequest;


/***/ }),

/***/ 2481:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.createSchema = void 0;
const schema_1 = __webpack_require__(4372);
// eslint-disable-next-line @typescript-eslint/ban-types
function createSchema(opts) {
    return (0, schema_1.makeExecutableSchema)(opts);
}
exports.createSchema = createSchema;


/***/ }),

/***/ 3689:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.createYoga = exports.YogaServer = void 0;
const tslib_1 = __webpack_require__(4479);
/* eslint-disable @typescript-eslint/no-explicit-any */ const core_1 = __webpack_require__(686);
const validation_cache_1 = __webpack_require__(6815);
const executor_1 = __webpack_require__(2729);
const defaultFetchAPI = tslib_1.__importStar(__webpack_require__(8130));
const server_1 = __webpack_require__(9862);
const graphql_1 = __webpack_require__(5736);
const error_js_1 = __webpack_require__(2497);
const logger_1 = __webpack_require__(4521);
const GET_js_1 = __webpack_require__(7458);
const POSTFormUrlEncoded_js_1 = __webpack_require__(8504);
const POSTGraphQLString_js_1 = __webpack_require__(1777);
const POSTJson_js_1 = __webpack_require__(4677);
const POSTMultipart_js_1 = __webpack_require__(8087);
const useCheckGraphQLQueryParams_js_1 = __webpack_require__(307);
const useCheckMethodForGraphQL_js_1 = __webpack_require__(4279);
const useHTTPValidationError_js_1 = __webpack_require__(8478);
const useLimitBatching_js_1 = __webpack_require__(9920);
const usePreventMutationViaGET_js_1 = __webpack_require__(2659);
const useGraphiQL_js_1 = __webpack_require__(1879);
const useHealthCheck_js_1 = __webpack_require__(3445);
const useParserAndValidationCache_js_1 = __webpack_require__(6783);
const useRequestParser_js_1 = __webpack_require__(6261);
const useResultProcessor_js_1 = __webpack_require__(3634);
const useSchema_js_1 = __webpack_require__(3838);
const useUnhandledRoute_js_1 = __webpack_require__(5492);
const process_request_js_1 = __webpack_require__(9624);
const mask_error_js_1 = __webpack_require__(5984);
/**
 * Base class that can be extended to create a GraphQL server with any HTTP server framework.
 * @internal
 */ class YogaServer {
    constructor(options){
        this.handle = async (request, serverContext)=>{
            let url = new Proxy({}, {
                get: (_target, prop, _receiver)=>{
                    url = new this.fetchAPI.URL(request.url, "http://localhost");
                    return Reflect.get(url, prop, url);
                }
            });
            let requestParser;
            const onRequestParseDoneList = [];
            for (const onRequestParse of this.onRequestParseHooks){
                const onRequestParseResult = await onRequestParse({
                    request,
                    url,
                    requestParser,
                    serverContext,
                    setRequestParser (parser) {
                        requestParser = parser;
                    }
                });
                if (onRequestParseResult?.onRequestParseDone != null) {
                    onRequestParseDoneList.push(onRequestParseResult.onRequestParseDone);
                }
            }
            this.logger.debug(`Parsing request to extract GraphQL parameters`);
            if (!requestParser) {
                return new this.fetchAPI.Response(null, {
                    status: 415,
                    statusText: "Unsupported Media Type"
                });
            }
            let requestParserResult = await requestParser(request);
            for (const onRequestParseDone of onRequestParseDoneList){
                await onRequestParseDone({
                    requestParserResult,
                    setRequestParserResult (newParams) {
                        requestParserResult = newParams;
                    }
                });
            }
            const result = await (Array.isArray(requestParserResult) ? Promise.all(requestParserResult.map((params)=>this.getResultForParams({
                    params,
                    request
                }, serverContext))) : this.getResultForParams({
                params: requestParserResult,
                request
            }, serverContext));
            return (0, process_request_js_1.processResult)({
                request,
                result,
                fetchAPI: this.fetchAPI,
                onResultProcessHooks: this.onResultProcessHooks
            });
        };
        this.id = options?.id ?? "yoga";
        this.fetchAPI = {
            ...defaultFetchAPI
        };
        if (options?.fetchAPI) {
            for(const key in options.fetchAPI){
                if (options.fetchAPI[key]) {
                    this.fetchAPI[key] = options.fetchAPI[key];
                }
            }
        }
        const logger = options?.logging == null ? true : options.logging;
        this.logger = typeof logger === "boolean" ? logger === true ? (0, logger_1.createLogger)() : (0, logger_1.createLogger)("silent") : typeof logger === "string" ? (0, logger_1.createLogger)(logger) : logger;
        const maskErrorFn = typeof options?.maskedErrors === "object" && options.maskedErrors.maskError || mask_error_js_1.maskError;
        const maskedErrorSet = new WeakSet();
        this.maskedErrorsOpts = options?.maskedErrors === false ? null : {
            errorMessage: "Unexpected error.",
            ...typeof options?.maskedErrors === "object" ? options.maskedErrors : {},
            maskError: (error, message)=>{
                if (maskedErrorSet.has(error)) {
                    return error;
                }
                const newError = maskErrorFn(error, message, this.maskedErrorsOpts?.isDev);
                if (newError !== error) {
                    this.logger.error(error);
                }
                maskedErrorSet.add(newError);
                return newError;
            }
        };
        const maskedErrors = this.maskedErrorsOpts == null ? null : this.maskedErrorsOpts;
        let batchingLimit = 0;
        if (options?.batching) {
            if (typeof options.batching === "boolean") {
                batchingLimit = 10;
            } else {
                batchingLimit = options.batching.limit ?? 10;
            }
        }
        this.graphqlEndpoint = options?.graphqlEndpoint || "/graphql";
        const graphqlEndpoint = this.graphqlEndpoint;
        this.plugins = [
            (0, core_1.useEngine)({
                parse: graphql_1.parse,
                validate: graphql_1.validate,
                execute: executor_1.normalizedExecutor,
                subscribe: executor_1.normalizedExecutor,
                specifiedRules: graphql_1.specifiedRules
            }),
            // Use the schema provided by the user
            !!options?.schema && (0, useSchema_js_1.useSchema)(options.schema),
            options?.context != null && (0, core_1.useExtendContext)((initialContext)=>{
                if (options?.context) {
                    if (typeof options.context === "function") {
                        return options.context(initialContext);
                    }
                    return options.context;
                }
                return {};
            }),
            // Middlewares before processing the incoming HTTP request
            (0, useHealthCheck_js_1.useHealthCheck)({
                id: this.id,
                logger: this.logger,
                endpoint: options?.healthCheckEndpoint
            }),
            options?.cors !== false && (0, server_1.useCORS)(options?.cors),
            options?.graphiql !== false && (0, useGraphiQL_js_1.useGraphiQL)({
                graphqlEndpoint,
                options: options?.graphiql,
                render: options?.renderGraphiQL,
                logger: this.logger
            }),
            // Middlewares before the GraphQL execution
            (0, useRequestParser_js_1.useRequestParser)({
                match: GET_js_1.isGETRequest,
                parse: GET_js_1.parseGETRequest
            }),
            (0, useRequestParser_js_1.useRequestParser)({
                match: POSTJson_js_1.isPOSTJsonRequest,
                parse: POSTJson_js_1.parsePOSTJsonRequest
            }),
            options?.multipart !== false && (0, useRequestParser_js_1.useRequestParser)({
                match: POSTMultipart_js_1.isPOSTMultipartRequest,
                parse: POSTMultipart_js_1.parsePOSTMultipartRequest
            }),
            (0, useRequestParser_js_1.useRequestParser)({
                match: POSTGraphQLString_js_1.isPOSTGraphQLStringRequest,
                parse: POSTGraphQLString_js_1.parsePOSTGraphQLStringRequest
            }),
            (0, useRequestParser_js_1.useRequestParser)({
                match: POSTFormUrlEncoded_js_1.isPOSTFormUrlEncodedRequest,
                parse: POSTFormUrlEncoded_js_1.parsePOSTFormUrlEncodedRequest
            }),
            // Middlewares after the GraphQL execution
            (0, useResultProcessor_js_1.useResultProcessors)({
                legacySSE: options?.legacySse !== false
            }),
            (0, server_1.useErrorHandling)((error, request)=>{
                const errors = (0, error_js_1.handleError)(error, this.maskedErrorsOpts, this.logger);
                const result = {
                    errors
                };
                return (0, process_request_js_1.processResult)({
                    request,
                    result,
                    fetchAPI: this.fetchAPI,
                    onResultProcessHooks: this.onResultProcessHooks
                });
            }),
            ...options?.plugins ?? [],
            // To make sure those are called at the end
            {
                onPluginInit ({ addPlugin  }) {
                    // Performance things
                    if (options?.parserCache !== false) {
                        const parserAndValidationCacheOptions = {};
                        if (typeof options?.parserCache === "object") {
                            parserAndValidationCacheOptions.documentCache = options.parserCache.documentCache;
                            parserAndValidationCacheOptions.errorCache = options.parserCache.errorCache;
                        }
                        if (options?.validationCache === false) {
                            parserAndValidationCacheOptions.validationCache = false;
                        } else if (typeof options?.validationCache === "object") {
                            // TODO: Remove this in the next major version
                            // Backward compatibility for the old API
                            parserAndValidationCacheOptions.validationCache = false;
                            addPlugin(// @ts-expect-error Add plugins has context but this hook doesn't care
                            (0, validation_cache_1.useValidationCache)({
                                cache: options.validationCache
                            }));
                        }
                        addPlugin(// @ts-expect-error Add plugins has context but this hook doesn't care
                        (0, useParserAndValidationCache_js_1.useParserAndValidationCache)(parserAndValidationCacheOptions));
                    }
                    // @ts-expect-error Add plugins has context but this hook doesn't care
                    addPlugin((0, useLimitBatching_js_1.useLimitBatching)(batchingLimit));
                    // @ts-expect-error Add plugins has context but this hook doesn't care
                    addPlugin((0, useCheckGraphQLQueryParams_js_1.useCheckGraphQLQueryParams)());
                    addPlugin(// @ts-expect-error Add plugins has context but this hook doesn't care
                    (0, useUnhandledRoute_js_1.useUnhandledRoute)({
                        graphqlEndpoint,
                        showLandingPage: options?.landingPage ?? true
                    }));
                    // We check the method after user-land plugins because the plugin might support more methods (like graphql-sse).
                    // @ts-expect-error Add plugins has context but this hook doesn't care
                    addPlugin((0, useCheckMethodForGraphQL_js_1.useCheckMethodForGraphQL)());
                    // We make sure that the user doesn't send a mutation with GET
                    // @ts-expect-error Add plugins has context but this hook doesn't care
                    addPlugin((0, usePreventMutationViaGET_js_1.usePreventMutationViaGET)());
                    if (maskedErrors) {
                        addPlugin((0, core_1.useMaskedErrors)(maskedErrors));
                    }
                    addPlugin(// We handle validation errors at the end
                    (0, useHTTPValidationError_js_1.useHTTPValidationError)());
                }
            }
        ];
        this.getEnveloped = (0, core_1.envelop)({
            plugins: this.plugins
        });
        this.plugins = this.getEnveloped._plugins;
        this.onRequestParseHooks = [];
        this.onParamsHooks = [];
        this.onResultProcessHooks = [];
        for (const plugin of this.plugins){
            if (plugin) {
                if (plugin.onYogaInit) {
                    plugin.onYogaInit({
                        yoga: this
                    });
                }
                if (plugin.onRequestParse) {
                    this.onRequestParseHooks.push(plugin.onRequestParse);
                }
                if (plugin.onParams) {
                    this.onParamsHooks.push(plugin.onParams);
                }
                if (plugin.onResultProcess) {
                    this.onResultProcessHooks.push(plugin.onResultProcess);
                }
            }
        }
    }
    async getResultForParams({ params , request  }, // eslint-disable-next-line @typescript-eslint/ban-types
    ...args) {
        try {
            let result;
            for (const onParamsHook of this.onParamsHooks){
                await onParamsHook({
                    params,
                    request,
                    setParams (newParams) {
                        params = newParams;
                    },
                    setResult (newResult) {
                        result = newResult;
                    },
                    fetchAPI: this.fetchAPI
                });
            }
            if (result == null) {
                const serverContext = args[0];
                const initialContext = {
                    ...serverContext,
                    request,
                    params
                };
                const enveloped = this.getEnveloped(initialContext);
                this.logger.debug(`Processing GraphQL Parameters`);
                result = await (0, process_request_js_1.processRequest)({
                    params,
                    enveloped
                });
                this.logger.debug(`Processing GraphQL Parameters done.`);
            }
            return result;
        } catch (error) {
            const errors = (0, error_js_1.handleError)(error, this.maskedErrorsOpts, this.logger);
            const result = {
                errors
            };
            return result;
        }
    }
}
exports.YogaServer = YogaServer;
function createYoga(options) {
    const server = new YogaServer(options);
    return (0, server_1.createServerAdapter)(server, {
        fetchAPI: server.fetchAPI,
        plugins: server["plugins"]
    });
// TODO: Fix in @whatwg-node/server later
}
exports.createYoga = createYoga;


/***/ }),

/***/ 9456:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(4479);
tslib_1.__exportStar(__webpack_require__(7047), exports);


/***/ }),

/***/ 8929:
/***/ (() => {



/***/ }),

/***/ 7503:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.createLRUCache = void 0;
const tslib_1 = __webpack_require__(4479);
const lru_cache_1 = tslib_1.__importDefault(__webpack_require__(7263));
const DEFAULT_MAX = 1024;
const DEFAULT_TTL = 3600000;
function createLRUCache() {
    return new lru_cache_1.default({
        max: DEFAULT_MAX,
        ttl: DEFAULT_TTL
    });
}
exports.createLRUCache = createLRUCache;


/***/ }),

/***/ 5984:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.maskError = void 0;
const utils_1 = __webpack_require__(6887);
const error_js_1 = __webpack_require__(2497);
const maskError = (error, message, isDev = globalThis.process?.env?.NODE_ENV === "development")=>{
    if ((0, error_js_1.isGraphQLError)(error)) {
        if (error.originalError) {
            if (error.originalError.name === "GraphQLError") {
                return error;
            }
            // Original error should be removed
            const extensions = {
                ...error.extensions,
                unexpected: true
            };
            if (isDev) {
                extensions.originalError = {
                    message: error.originalError.message,
                    stack: error.originalError.stack
                };
            }
            return (0, utils_1.createGraphQLError)(message, {
                nodes: error.nodes,
                source: error.source,
                positions: error.positions,
                path: error.path,
                extensions
            });
        }
        return error;
    }
    return (0, utils_1.createGraphQLError)(message, {
        extensions: {
            unexpected: true,
            originalError: isDev ? error instanceof Error ? {
                message: error.message,
                stack: error.stack
            } : error : undefined
        }
    });
};
exports.maskError = maskError;


/***/ }),

/***/ 7724:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "vq": () => (/* reexport */ BasePlugin),
  "O_": () => (/* binding */ esm_InterfaceRef),
  "lK": () => (/* binding */ esm_ObjectRef),
  "ZP": () => (/* binding */ esm)
});

// UNUSED EXPORTS: BaseTypeRef, BuildCache, BuiltinScalarRef, EnumRef, FieldBuilder, FieldRef, ImplementableInputObjectRef, ImplementableInterfaceRef, ImplementableObjectRef, InputFieldBuilder, InputFieldRef, InputListRef, InputObjectRef, InputTypeRef, InterfaceFieldBuilder, ListRef, MergedPlugins, MutationFieldBuilder, ObjectFieldBuilder, OutputTypeRef, PothosError, PothosSchemaError, PothosValidationError, QueryFieldBuilder, RootFieldBuilder, ScalarRef, SubscriptionFieldBuilder, UnionRef, abstractReturnShapeKey, assertArray, assertNever, brandWithType, classDepth, completeValue, contextCacheSymbol, createContextCache, createInputValueMapper, decodeBase64, encodeBase64, getTypeBrand, initContextCache, inputFieldShapeKey, inputShapeKey, inputTypeFromParam, isThenable, mapInputFields, normalizeEnumValues, outputFieldShapeKey, outputShapeKey, parentShapeKey, resolveInputTypeConfig, sortClasses, typeBrandKey, typeFromParam, unwrapInputFieldType, unwrapInputListParam, unwrapListParam, unwrapOutputFieldType, unwrapOutputListParam, valuesFromEnum, verifyInterfaces, verifyRef

// EXTERNAL MODULE: ../../node_modules/graphql/index.js
var graphql = __webpack_require__(5736);
;// CONCATENATED MODULE: ../../node_modules/@pothos/core/esm/errors.js
/* eslint-disable max-classes-per-file */ class PothosError extends Error {
    constructor(message){
        super(message);
        this.name = "PothosError";
    }
}
class errors_PothosSchemaError extends PothosError {
    constructor(message){
        super(message);
        this.name = "PothosSchemaError";
    }
}
class errors_PothosValidationError extends (/* unused pure expression or super */ null && (PothosError)) {
    constructor(message){
        super(message);
        this.name = "PothosValidationError";
    }
} //# sourceMappingURL=errors.js.map

;// CONCATENATED MODULE: ../../node_modules/@pothos/core/esm/utils/context-cache.js
const contextCacheSymbol = Symbol.for("Pothos.contextCache");
function initContextCache() {
    return {
        [contextCacheSymbol]: {}
    };
}
function createContextCache(create) {
    const cache = new WeakMap();
    return (context, ...args)=>{
        const cacheKey = context[contextCacheSymbol] || context;
        if (cache.has(cacheKey)) {
            return cache.get(cacheKey);
        }
        const entry = create(context, ...args);
        cache.set(cacheKey, entry);
        return entry;
    };
} //# sourceMappingURL=context-cache.js.map

;// CONCATENATED MODULE: ../../node_modules/@pothos/core/esm/plugins/plugin.js
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}


const runCache = new WeakMap();
class BasePlugin {
    /**
   * Called for each type defined with the SchemaBuilder
   * @param  {PothosTypeConfig} typeConfig - Config object describing the added type
   * @return {PothosTypeConfig} Original or updated `typeConfig`
   */ onTypeConfig(typeConfig) {
        return typeConfig;
    }
    /**
   * Called for each field on an Object or Interface type
   * @param  {PothosOutputFieldConfig} fieldConfig - Config object describing the added field
   * @return {PothosOutputFieldConfig} Original or updated `fieldConfig`
   */ onOutputFieldConfig(fieldConfig) {
        return fieldConfig;
    }
    /**
   * Called for each argument or field on an Input object defined in your schema
   * @param  {PothosInputFieldConfig} fieldConfig - Config object describing the added field
   * @return {PothosInputFieldConfig} Original or updated `fieldConfig`
   */ onInputFieldConfig(fieldConfig) {
        return fieldConfig;
    }
    /**
   * Called for each Enum value defined in your schema
   * @param  {PothosEnumValueConfig} valueConfig - Config object describing the enum value
   * @return {PothosEnumValueConfig} Original or updated `valueConfig`
   */ onEnumValueConfig(valueConfig) {
        return valueConfig;
    }
    /**
   * Called before builder.toSchema() schema is called
   */ beforeBuild() {}
    /**
   * Called after all fields and types have been built during `builder.toSchema()`
   * @param  {GraphQLSchema} schema - the generated schema
   * @return {PothosEnumValueConfig} Original or updated `schema`
   */ afterBuild(schema) {
        return schema;
    }
    /**
   * Called with the resolver for each field in the schema
   * @param  {GraphQLFieldResolver} resolve - the resolve function
   * @param  {PothosOutputFieldConfig} fieldConfig - the config object for the field associated with this resolve function
   * @return {GraphQLFieldResolver} - Either the original, or a new resolver function to use for this field
   */ wrapResolve(resolver, fieldConfig) {
        return resolver;
    }
    /**
   * Called with the subscribe for each field on the Subscription type
   * @param  {GraphQLFieldResolver} subscribe - the subscribe function
   * @param  {PothosOutputFieldConfig} fieldConfig - the config object for the field associated with this subscribe function
   * @return {GraphQLFieldResolver} - Either the original, or a new subscribe function to use for this field
   */ wrapSubscribe(subscribe, fieldConfig) {
        return subscribe;
    }
    /**
   * Called with the resolveType for each Interface or Union type
   * @param  {GraphQLTypeResolver} resolveType - the resolveType function
   * @param  {PothosInterfaceTypeConfig | PothosUnionTypeConfig} typeConfig - the config object for the Interface or Union type
   * @return {GraphQLTypeResolver} - Either the original, or a new resolveType function to use for this field
   */ wrapResolveType(resolveType, typeConfig) {
        return resolveType;
    }
    /**
   * Called with the isTypeOf for each Object type
   * @param  {GraphQLTypeResolver} resolveType - the resolveType function
   * @param  {PothosObjectTypeConfig} typeConfig - the config object for the Interface or Union type
   * @return {GraphQLTypeResolver} - Either the original, or a new resolveType function to use for this field
   */ wrapIsTypeOf(isTypeOf, typeConfig) {
        return isTypeOf;
    }
    runUnique(key, cb) {
        if (!runCache.has(this.builder)) {
            runCache.set(this.builder, new Map());
        }
        if (!runCache.get(this.builder).has(key)) {
            const result = cb();
            runCache.get(this.builder).set(key, result);
            return result;
        }
        return runCache.get(this.builder).get(key);
    }
    /**
   * Creates a data object unique to the current request for use by this plugin
   * @param  {Types['Context']} context - the context object for the current request
   * @return {object} - The data object for the current request
   */ createRequestData(context) {
        throw new PothosError("createRequestData not implemented");
    }
    /**
   * Returns a data object for the current request.  requires `createRequestData` to be implemented
   * @param  {Types['Context']} context - the context object for the current request
   * @return {object} - The data object for the current request
   */ requestData(context) {
        return this.requestDataMap(context);
    }
    constructor(buildCache, name){
        _defineProperty(this, "name", void 0);
        _defineProperty(this, "builder", void 0);
        _defineProperty(this, "buildCache", void 0);
        _defineProperty(this, "options", void 0);
        _defineProperty(this, "requestDataMap", createContextCache((ctx)=>this.createRequestData(ctx)));
        this.name = name;
        this.builder = buildCache.builder;
        this.buildCache = buildCache;
        this.options = buildCache.options;
    }
} //# sourceMappingURL=plugin.js.map

;// CONCATENATED MODULE: ../../node_modules/@pothos/core/esm/plugins/merge-plugins.js
function merge_plugins_defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}

class MergedPlugins extends BasePlugin {
    onTypeConfig(typeConfig) {
        return this.plugins.reduceRight((config, plugin)=>config === null ? config : plugin.onTypeConfig(config), typeConfig);
    }
    onInputFieldConfig(fieldConfig) {
        return this.plugins.reduceRight((config, plugin)=>config === null ? config : plugin.onInputFieldConfig(config), fieldConfig);
    }
    onOutputFieldConfig(fieldConfig) {
        return this.plugins.reduceRight((config, plugin)=>config === null ? config : plugin.onOutputFieldConfig(config), fieldConfig);
    }
    onEnumValueConfig(valueConfig) {
        return this.plugins.reduceRight((config, plugin)=>config === null ? config : plugin.onEnumValueConfig(config), valueConfig);
    }
    beforeBuild() {
        for (const plugin of this.plugins){
            plugin.beforeBuild();
        }
    }
    afterBuild(schema) {
        return this.plugins.reduceRight((nextSchema, plugin)=>plugin.afterBuild(nextSchema), schema);
    }
    wrapResolve(resolve, fieldConfig) {
        return this.plugins.reduceRight((nextResolve, plugin)=>plugin.wrapResolve(nextResolve, fieldConfig), resolve);
    }
    wrapSubscribe(subscribe, fieldConfig) {
        return this.plugins.reduceRight((nextSubscribe, plugin)=>plugin.wrapSubscribe(nextSubscribe, fieldConfig), subscribe);
    }
    wrapResolveType(resolveType, typeConfig) {
        return this.plugins.reduceRight((nextResolveType, plugin)=>plugin.wrapResolveType(nextResolveType, typeConfig), resolveType);
    }
    wrapIsTypeOf(isTypeOf, typeConfig) {
        return this.plugins.reduceRight((nextResolveType, plugin)=>plugin.wrapIsTypeOf(nextResolveType, typeConfig), isTypeOf);
    }
    constructor(buildCache, plugins){
        super(buildCache, "PothosMergedPlugin");
        merge_plugins_defineProperty(this, "plugins", void 0);
        this.plugins = plugins;
    }
} //# sourceMappingURL=merge-plugins.js.map

;// CONCATENATED MODULE: ../../node_modules/@pothos/core/esm/plugins/index.js

 //# sourceMappingURL=index.js.map

;// CONCATENATED MODULE: ../../node_modules/@pothos/core/esm/types/type-params.js
const outputShapeKey = Symbol.for("Pothos.outputShapeKey");
const parentShapeKey = Symbol.for("Pothos.parentShapeKey");
const abstractReturnShapeKey = Symbol.for("Pothos.abstractReturnShapeKey");
const inputShapeKey = Symbol.for("Pothos.inputShapeKey");
const inputFieldShapeKey = Symbol.for("Pothos.inputFieldShapeKey");
const outputFieldShapeKey = Symbol.for("Pothos.outputFieldShapeKey");
const type_params_typeBrandKey = Symbol.for("Pothos.typeBrandKey"); //# sourceMappingURL=type-params.js.map

;// CONCATENATED MODULE: ../../node_modules/@pothos/core/esm/types/index.js






 //# sourceMappingURL=index.js.map

;// CONCATENATED MODULE: ../../node_modules/@pothos/core/esm/refs/base.js
function base_defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
class BaseTypeRef {
    toString() {
        return `${this.kind}Ref<${this.name}>`;
    }
    constructor(kind, name){
        base_defineProperty(this, "kind", void 0);
        base_defineProperty(this, "name", void 0);
        this.kind = kind;
        this.name = name;
    }
}
 //# sourceMappingURL=base.js.map

;// CONCATENATED MODULE: ../../node_modules/@pothos/core/esm/refs/scalar.js
function scalar_defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}


let _outputShapeKey = outputShapeKey, _parentShapeKey = parentShapeKey, _inputShapeKey = inputShapeKey;
class ScalarRef extends BaseTypeRef {
    constructor(name){
        super("Scalar", name);
        scalar_defineProperty(this, "kind", "Scalar");
        scalar_defineProperty(this, _outputShapeKey, void 0);
        scalar_defineProperty(this, _parentShapeKey, void 0);
        scalar_defineProperty(this, _inputShapeKey, void 0);
    }
}
 //# sourceMappingURL=scalar.js.map

;// CONCATENATED MODULE: ../../node_modules/@pothos/core/esm/refs/builtin-scalar.js
function builtin_scalar_defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}

class BuiltinScalarRef extends ScalarRef {
    constructor(type){
        super(type.name);
        builtin_scalar_defineProperty(this, "type", void 0);
        this.type = type;
    }
}
 //# sourceMappingURL=builtin-scalar.js.map

;// CONCATENATED MODULE: ../../node_modules/@pothos/core/esm/refs/input-object.js
/* eslint-disable max-classes-per-file */ function input_object_defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}


let input_object_inputShapeKey = inputShapeKey;
class InputObjectRef extends BaseTypeRef {
    constructor(name){
        super("InputObject", name);
        input_object_defineProperty(this, "kind", "InputObject");
        input_object_defineProperty(this, input_object_inputShapeKey, void 0);
    }
}

class ImplementableInputObjectRef extends InputObjectRef {
    implement(options) {
        this.builder.inputType(this, options);
        return this;
    }
    constructor(builder, name){
        super(name);
        input_object_defineProperty(this, "builder", void 0);
        this.builder = builder;
    }
} //# sourceMappingURL=input-object.js.map

;// CONCATENATED MODULE: ../../node_modules/@pothos/core/esm/refs/input-list.js
function input_list_defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}


let input_list_inputShapeKey = inputShapeKey;
class input_list_InputObjectRef extends BaseTypeRef {
    constructor(listType, required){
        super("InputList", `InputList<${String(listType)}>`);
        input_list_defineProperty(this, "kind", "InputList");
        input_list_defineProperty(this, input_list_inputShapeKey, void 0);
        input_list_defineProperty(this, "listType", void 0);
        input_list_defineProperty(this, "required", void 0);
        this.listType = listType;
        this.required = required;
    }
}
 //# sourceMappingURL=input-list.js.map

;// CONCATENATED MODULE: ../../node_modules/@pothos/core/esm/refs/list.js
function list_defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}


let list_outputShapeKey = outputShapeKey, list_parentShapeKey = parentShapeKey;
class list_ListRef extends BaseTypeRef {
    constructor(listType, nullable){
        super("List", `List<${String(listType)}>`);
        list_defineProperty(this, "kind", "List");
        list_defineProperty(this, list_outputShapeKey, void 0);
        list_defineProperty(this, list_parentShapeKey, void 0);
        list_defineProperty(this, "listType", void 0);
        list_defineProperty(this, "nullable", void 0);
        this.listType = listType;
        this.nullable = nullable;
    }
}
 //# sourceMappingURL=list.js.map

;// CONCATENATED MODULE: ../../node_modules/@pothos/core/esm/utils/enums.js
function normalizeEnumValues(values) {
    const result = {};
    if (Array.isArray(values)) {
        values.forEach((key)=>{
            result[String(key)] = {
                pothosOptions: {}
            };
        });
    } else {
        Object.entries(values).forEach(([key, value])=>{
            if (value && typeof value === "object") {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                result[key] = {
                    ...value,
                    pothosOptions: value
                };
            } else if (typeof value === "string") {
                result[value] = {
                    pothosOptions: {}
                };
            }
        });
    }
    return result;
}
function valuesFromEnum(Enum, values) {
    const result = {};
    Object.keys(Enum).filter((key)=>typeof Enum[Enum[key]] !== "number").forEach((key)=>{
        result[key] = {
            value: Enum[key],
            pothosOptions: {},
            ...values === null || values === void 0 ? void 0 : values[key]
        };
    });
    return result;
} //# sourceMappingURL=enums.js.map

;// CONCATENATED MODULE: ../../node_modules/@pothos/core/esm/utils/params.js




function unwrapOutputFieldType(type) {
    if (type.kind === "List") {
        return unwrapOutputFieldType(type.type);
    }
    return type.ref;
}
function typeFromParam(param, configStore, nullableOption) {
    const itemNullable = typeof nullableOption === "object" ? nullableOption.items : false;
    const nullable = typeof nullableOption === "object" ? nullableOption.list : !!nullableOption;
    if (Array.isArray(param)) {
        return {
            kind: "List",
            type: typeFromParam(param[0], configStore, itemNullable),
            nullable
        };
    }
    if (param instanceof list_ListRef) {
        return {
            kind: "List",
            type: typeFromParam(param.listType, configStore, param.nullable),
            nullable
        };
    }
    const ref = configStore.getOutputTypeRef(param);
    const kind = ref instanceof BaseTypeRef ? ref.kind : configStore.getTypeConfig(ref).graphqlKind;
    const name = ref instanceof BaseTypeRef ? ref.name : configStore.getTypeConfig(ref).name;
    if (kind !== "InputObject" && kind !== "List" && kind !== "InputList") {
        return {
            kind,
            ref,
            nullable
        };
    }
    throw new errors_PothosSchemaError(`Expected input param ${name} to be an output type but got ${kind}`);
}
function params_unwrapInputFieldType(type) {
    if (type.kind === "List") {
        return params_unwrapInputFieldType(type.type);
    }
    return type.ref;
}
function inputTypeFromParam(param, configStore, requiredOption) {
    const itemRequired = typeof requiredOption === "object" ? requiredOption.items : true;
    const required = typeof requiredOption === "object" ? requiredOption.list : !!requiredOption;
    if (Array.isArray(param)) {
        return {
            kind: "List",
            type: inputTypeFromParam(param[0], configStore, itemRequired),
            required
        };
    }
    if (param instanceof input_list_InputObjectRef) {
        return {
            kind: "List",
            type: inputTypeFromParam(param.listType, configStore, param.required),
            required
        };
    }
    const ref = configStore.getInputTypeRef(param);
    const kind = ref instanceof BaseTypeRef ? ref.kind : configStore.getTypeConfig(ref).graphqlKind;
    const name = ref instanceof BaseTypeRef ? ref.name : configStore.getTypeConfig(ref).name;
    if (kind === "InputObject" || kind === "Enum" || kind === "Scalar") {
        return {
            kind,
            ref,
            required
        };
    }
    throw new errors_PothosSchemaError(`Expected input param ${name} to be an InputObject, Enum, or Scalar but got ${kind}`);
} //# sourceMappingURL=params.js.map

;// CONCATENATED MODULE: ../../node_modules/@pothos/core/esm/utils/input.js


function resolveInputTypeConfig(type, buildCache) {
    if (type.kind === "List") {
        return resolveInputTypeConfig(type.type, buildCache);
    }
    const config = buildCache.getTypeConfig(type.ref);
    if (config.kind === "Enum" || config.kind === "Scalar" || config.kind === "InputObject") {
        return config;
    }
    throw new PothosSchemaError(`Unexpected config type ${config.kind} for input ref ${String(type.ref)}`);
}
function mapInputFields(inputs, buildCache, mapper) {
    const filterMappings = new Map();
    return filterMapped(internalMapInputFields(inputs, buildCache, mapper, new Map()));
    function filterMapped(map) {
        if (filterMappings.has(map)) {
            return filterMappings.get(map);
        }
        const filtered = new Map();
        filterMappings.set(map, filtered);
        map.forEach((mapping, fieldName)=>{
            if (mapping.kind === "Enum" || mapping.kind === "Scalar") {
                filtered.set(fieldName, mapping);
                return;
            }
            const hasNestedMappings = checkForMappings(mapping.fields.map);
            if (mapping.value !== null || hasNestedMappings) {
                const filteredTypeFields = filterMapped(mapping.fields.map);
                const mappingForType = {
                    ...mapping,
                    fields: {
                        configs: mapping.fields.configs,
                        map: filteredTypeFields
                    }
                };
                filtered.set(fieldName, mappingForType);
            }
        });
        return filtered.size > 0 ? filtered : null;
    }
    function checkForMappings(map, hasMappings = new Map()) {
        if (hasMappings.has(map)) {
            return hasMappings.get(map);
        }
        hasMappings.set(map, false);
        let result = false;
        map.forEach((mapping)=>{
            if (mapping.value !== null) {
                result = true;
            } else if (mapping.kind === "InputObject" && mapping.fields.map && checkForMappings(mapping.fields.map, hasMappings)) {
                result = true;
            }
        });
        hasMappings.set(map, result);
        return result;
    }
}
function internalMapInputFields(inputs, buildCache, mapper, seenTypes) {
    const map = new Map();
    Object.keys(inputs).forEach((fieldName)=>{
        const inputField = inputs[fieldName];
        const typeConfig = resolveInputTypeConfig(inputField.type, buildCache);
        const fieldMapping = mapper(inputField);
        if (typeConfig.kind === "Enum" || typeConfig.kind === "Scalar") {
            if (fieldMapping !== null) {
                map.set(fieldName, {
                    kind: typeConfig.kind,
                    isList: inputField.type.kind === "List",
                    config: inputField,
                    value: fieldMapping
                });
            }
            return;
        }
        const inputFieldConfigs = buildCache.getInputTypeFieldConfigs(unwrapInputFieldType(inputField.type));
        if (!seenTypes.has(typeConfig.name)) {
            const typeEntry = {
                configs: inputFieldConfigs,
                map: new Map()
            };
            seenTypes.set(typeConfig.name, typeEntry);
            typeEntry.map = internalMapInputFields(inputFieldConfigs, buildCache, mapper, seenTypes);
        }
        const typeFields = seenTypes.get(typeConfig.name);
        map.set(fieldName, {
            kind: typeConfig.kind,
            isList: inputField.type.kind === "List",
            config: inputField,
            value: fieldMapping,
            fields: typeFields
        });
    });
    return map;
}
function createInputValueMapper(argMap, mapValue) {
    return function mapObject(obj, map = argMap, ...args) {
        const mapped = {
            ...obj
        };
        map.forEach((field, fieldName)=>{
            let fieldVal = obj[fieldName];
            if (fieldVal === null || fieldVal === undefined) {
                return;
            }
            if (field.kind === "InputObject" && field.fields.map) {
                fieldVal = field.isList ? fieldVal.map((val)=>val && mapObject(val, field.fields.map, ...args)) : mapObject(fieldVal, field.fields.map, ...args);
                mapped[fieldName] = fieldVal;
            }
            if (field.kind !== "InputObject" || field.value !== null) {
                mapped[fieldName] = field.isList ? fieldVal.map((val)=>mapValue(val, field, ...args)) : mapValue(fieldVal, field, ...args);
            }
        });
        return mapped;
    };
} //# sourceMappingURL=input.js.map

;// CONCATENATED MODULE: ../../node_modules/@pothos/core/esm/utils/index.js










function assertNever(value) {
    throw new TypeError(`Unexpected value: ${value}`);
}
function assertArray(value) {
    if (!Array.isArray(value)) {
        throw new PothosValidationError("List resolvers must return arrays");
    }
    return true;
}
function isThenable(value) {
    return !!(value && (typeof value === "object" || typeof value === "function") && typeof value.then === "function");
}
function verifyRef(ref) {
    if (ref === undefined) {
        throw new errors_PothosSchemaError(`Received undefined as a type ref.

This is often caused by a circular import
If this ref is imported from a file that re-exports it (like index.ts)
you may be able to resolve this by importing it directly from the file that defines it.
`);
    }
}
function verifyInterfaces(interfaces) {
    if (!interfaces || typeof interfaces === "function") {
        return;
    }
    if (!Array.isArray(interfaces)) {
        throw new errors_PothosSchemaError("interfaces must be an array or function");
    }
    for (const iface of interfaces){
        if (iface === undefined) {
            throw new errors_PothosSchemaError(`Received undefined in list of interfaces.

This is often caused by a circular import
If this ref is imported from a file that re-exports it (like index.ts)
you may be able to resolve this by importing it directly from the file that defines it.

Alternatively you can define interfaces with a function that will be lazily evaluated,
which may resolver issues with circular dependencies:

Example:
builder.objectType('MyObject', {
  interface: () => [Interface1, Interface2],
  ...
});
`);
        }
    }
}
function brandWithType(val, type) {
    if (typeof val !== "object" || val === null) {
        return;
    }
    Object.defineProperty(val, typeBrandKey, {
        enumerable: false,
        value: type
    });
}
function getTypeBrand(val) {
    if (typeof val === "object" && val !== null && type_params_typeBrandKey in val) {
        return val[type_params_typeBrandKey];
    }
    return null;
}
function unwrapListParam(param) {
    if (Array.isArray(param)) {
        return unwrapListParam(param[0]);
    }
    if (param instanceof list_ListRef || param instanceof input_list_InputObjectRef) {
        return unwrapListParam(param.listType);
    }
    return param;
}
function unwrapOutputListParam(param) {
    if (Array.isArray(param)) {
        return unwrapOutputListParam(param[0]);
    }
    if (param instanceof ListRef) {
        return unwrapOutputListParam(param.listType);
    }
    return param;
}
function unwrapInputListParam(param) {
    if (Array.isArray(param)) {
        return unwrapInputListParam(param[0]);
    }
    if (param instanceof InputListRef) {
        return unwrapInputListParam(param.listType);
    }
    return param;
}
/**
 * Helper for allowing plugins to fulfill the return of the `next` resolver, without paying the cost of the
 * Promise if not required.
 */ function completeValue(valOrPromise, onSuccess, onError) {
    if (isThenable(valOrPromise)) {
        return Promise.resolve(valOrPromise).then(onSuccess, onError);
    }
    // No need to handle onError, this should just be a try/catch inside the `onSuccess` block
    const result = onSuccess(valOrPromise);
    // If the result of the synchronous call is a promise like, convert to a promise
    // for consistency
    if (isThenable(result)) {
        return Promise.resolve(result);
    }
    return result;
} //# sourceMappingURL=index.js.map

;// CONCATENATED MODULE: ../../node_modules/@pothos/core/esm/build-cache.js
/* eslint-disable no-continue */ function build_cache_defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}







class BuildCache {
    getTypeConfig(ref, kind) {
        const baseConfig = this.configStore.getTypeConfig(ref, kind);
        if (!this.typeConfigs.has(baseConfig.name)) {
            this.typeConfigs.set(baseConfig.name, this.plugin.onTypeConfig(baseConfig));
        }
        const typeConfig = this.typeConfigs.get(baseConfig.name);
        return typeConfig;
    }
    getInputTypeFieldConfigs(ref) {
        const typeConfig = this.getTypeConfig(ref, "InputObject");
        const builtType = this.types.get(typeConfig.name);
        if (!builtType) {
            throw new errors_PothosSchemaError(`Input type ${typeConfig.name} has not been built yet`);
        }
        const fields = builtType.getFields();
        const fieldConfigs = {};
        Object.keys(fields).forEach((fieldName)=>{
            var _fields_fieldName_extensions;
            fieldConfigs[fieldName] = (_fields_fieldName_extensions = fields[fieldName].extensions) === null || _fields_fieldName_extensions === void 0 ? void 0 : _fields_fieldName_extensions.pothosConfig;
        });
        return fieldConfigs;
    }
    getImplementers(iface) {
        if (this.implementers.has(iface.name)) {
            return this.implementers.get(iface.name);
        }
        const implementers = [
            ...this.configStore.typeConfigs.values()
        ].filter((type)=>type.kind === "Object" && type.interfaces.find((i)=>this.configStore.getTypeConfig(i).name === iface.name));
        this.implementers.set(iface.name, implementers);
        return implementers;
    }
    buildAll() {
        this.configStore.prepareForBuild();
        this.configStore.typeConfigs.forEach((baseConfig)=>{
            if (baseConfig.kind === "Enum" || baseConfig.kind === "Scalar") {
                this.buildTypeFromConfig(baseConfig);
            }
        });
        this.configStore.typeConfigs.forEach((baseConfig)=>{
            if (baseConfig.kind === "InputObject") {
                this.buildTypeFromConfig(baseConfig);
            }
        });
        this.types.forEach((type)=>{
            if (type instanceof graphql.GraphQLInputObjectType) {
                type.getFields();
            }
        });
        this.configStore.typeConfigs.forEach((baseConfig)=>{
            if (baseConfig.kind === "Interface") {
                this.buildTypeFromConfig(baseConfig);
            }
        });
        this.configStore.typeConfigs.forEach((baseConfig)=>{
            if (baseConfig.kind === "Object") {
                this.buildTypeFromConfig(baseConfig);
            }
        });
        this.configStore.typeConfigs.forEach((baseConfig)=>{
            if (baseConfig.kind === "Union") {
                this.buildTypeFromConfig(baseConfig);
            }
        });
        this.configStore.typeConfigs.forEach((baseConfig)=>{
            if (baseConfig.kind === "Query" || baseConfig.kind === "Mutation" || baseConfig.kind === "Subscription") {
                this.buildTypeFromConfig(baseConfig);
            }
        });
        this.types.forEach((type)=>{
            if (type instanceof graphql.GraphQLObjectType || type instanceof graphql.GraphQLInterfaceType) {
                type.getFields();
            } else if (type instanceof graphql.GraphQLUnionType) {
                type.getTypes();
            }
        });
    }
    buildTypeFromConfig(baseConfig) {
        const config = this.getTypeConfig(baseConfig.name);
        const { name  } = config;
        this.typeConfigs.set(name, config);
        switch(config.kind){
            case "Enum":
                this.addType(name, this.buildEnum(config));
                break;
            case "InputObject":
                this.addType(name, this.buildInputObject(config));
                break;
            case "Interface":
                this.addType(name, this.buildInterface(config));
                break;
            case "Scalar":
                this.addType(name, this.buildScalar(config));
                break;
            case "Union":
                this.addType(name, this.buildUnion(config));
                break;
            case "Object":
            case "Query":
            case "Mutation":
            case "Subscription":
                this.addType(name, this.buildObject(config));
                break;
            default:
                assertNever(config);
        }
    }
    addType(ref, type) {
        if (this.types.has(ref)) {
            throw new errors_PothosSchemaError(`reference or name has already been used to create another type (${type.name})`);
        }
        this.types.set(ref, type);
    }
    buildOutputTypeParam(type) {
        if (type.kind === "List") {
            if (type.nullable) {
                return new graphql.GraphQLList(this.buildOutputTypeParam(type.type));
            }
            return new graphql.GraphQLNonNull(new graphql.GraphQLList(this.buildOutputTypeParam(type.type)));
        }
        if (type.nullable) {
            return this.getOutputType(type.ref);
        }
        return new graphql.GraphQLNonNull(this.getOutputType(type.ref));
    }
    buildInputTypeParam(type) {
        if (type.kind === "List") {
            if (type.required) {
                return new graphql.GraphQLNonNull(new graphql.GraphQLList(this.buildInputTypeParam(type.type)));
            }
            return new graphql.GraphQLList(this.buildInputTypeParam(type.type));
        }
        if (type.required) {
            return new graphql.GraphQLNonNull(this.getInputType(type.ref));
        }
        return this.getInputType(type.ref);
    }
    buildFields(fields) {
        const built = {};
        for (const [fieldName, originalConfig] of fields){
            if (!this.outputFieldConfigs.has(originalConfig)) {
                this.outputFieldConfigs.set(originalConfig, this.plugin.onOutputFieldConfig(originalConfig));
            }
            const updatedConfig = this.outputFieldConfigs.get(originalConfig);
            if (!updatedConfig) {
                continue;
            }
            const config = {
                ...updatedConfig
            };
            const argMap = new Map();
            Object.keys(config.args).forEach((argName)=>{
                argMap.set(argName, config.args[argName]);
            });
            const args = this.buildInputFields(argMap);
            const argConfigs = {};
            Object.keys(config.args).forEach((argName)=>{
                argConfigs[argName] = this.inputFieldConfigs.get(config.args[argName]);
            });
            config.args = argConfigs;
            var _config_resolve;
            const resolve = this.plugin.wrapResolve((_config_resolve = config.resolve) !== null && _config_resolve !== void 0 ? _config_resolve : graphql.defaultFieldResolver, config);
            const subscribe = this.plugin.wrapSubscribe(config.subscribe, config);
            var _config_resolve1;
            built[fieldName] = {
                ...config,
                type: this.buildOutputTypeParam(config.type),
                args,
                extensions: {
                    ...config.extensions,
                    pothosResolveWrapped: resolve !== ((_config_resolve1 = config.resolve) !== null && _config_resolve1 !== void 0 ? _config_resolve1 : graphql.defaultFieldResolver),
                    pothosSubscribeWrapped: subscribe !== config.subscribe,
                    pothosOptions: config.pothosOptions,
                    pothosConfig: config
                },
                resolve: resolve === graphql.defaultFieldResolver ? undefined : resolve,
                subscribe
            };
        }
        return built;
    }
    buildInputFields(fields) {
        const built = {};
        for (const [fieldName, originalConfig] of fields){
            if (!this.inputFieldConfigs.has(originalConfig)) {
                this.inputFieldConfigs.set(originalConfig, this.plugin.onInputFieldConfig(originalConfig));
            }
            const config = this.inputFieldConfigs.get(originalConfig);
            if (config) {
                built[fieldName] = {
                    ...config,
                    type: this.buildInputTypeParam(config.type),
                    extensions: {
                        ...config.extensions,
                        pothosOptions: config.pothosOptions,
                        pothosConfig: config
                    }
                };
            }
        }
        return built;
    }
    getInterfaceFields(type) {
        const interfaceFields = type.getInterfaces().reduce((all, iface)=>({
                ...this.getFields(iface),
                ...all
            }), {});
        const configs = this.configStore.getFields(type.name, "Interface");
        const fields = this.buildFields(configs);
        return {
            ...interfaceFields,
            ...fields
        };
    }
    getObjectFields(type) {
        const interfaceFields = type.getInterfaces().reduce((all, iface)=>({
                ...this.getFields(iface),
                ...all
            }), {});
        const objectFields = this.buildFields(this.configStore.getFields(type.name, "Object"));
        return {
            ...interfaceFields,
            ...objectFields
        };
    }
    getRootFields(type) {
        return this.buildFields(this.configStore.getFields(type.name, "Object"));
    }
    getFields(type) {
        if (type instanceof graphql.GraphQLObjectType) {
            if (type.name === "Query" || type.name === "Mutation" || type.name === "Subscription") {
                return this.getRootFields(type);
            }
            return this.getObjectFields(type);
        }
        if (type instanceof graphql.GraphQLInterfaceType) {
            return this.getInterfaceFields(type);
        }
        throw new errors_PothosSchemaError(`Type ${type.name} does not have fields to resolve`);
    }
    getInputFields(type) {
        return this.buildInputFields(this.configStore.getFields(type.name, "InputObject"));
    }
    getType(ref) {
        if (ref instanceof BuiltinScalarRef) {
            return ref.type;
        }
        const typeConfig = this.configStore.getTypeConfig(ref);
        const type = this.types.get(typeConfig.name);
        if (!type) {
            this.buildTypeFromConfig(typeConfig);
            return this.types.get(typeConfig.name);
        }
        return type;
    }
    getOutputType(ref) {
        const type = this.getType(ref);
        if (type instanceof graphql.GraphQLInputObjectType) {
            throw new errors_PothosSchemaError(`Expected ${String(ref)} to be an output type but it was defined as an InputObject`);
        }
        return type;
    }
    getInputType(ref) {
        const type = this.getType(ref);
        if (!type) {
            throw new errors_PothosSchemaError(`Missing implementation of for type ${String(ref)}`);
        }
        if (type instanceof graphql.GraphQLObjectType) {
            throw new errors_PothosSchemaError(`Expected ${ImplementableInputObjectRef} to be an input type but it was defined as a GraphQLObjectType`);
        }
        if (type instanceof graphql.GraphQLInterfaceType) {
            throw new errors_PothosSchemaError(`Expected ${ImplementableInputObjectRef} to be an input type but it was defined as a GraphQLInterfaceType`);
        }
        if (type instanceof graphql.GraphQLUnionType) {
            throw new errors_PothosSchemaError(`Expected ${String(ref)} to be an input type but it was defined as an GraphQLUnionType`);
        }
        return type;
    }
    getTypeOfKind(ref, kind) {
        const type = this.getType(ref);
        switch(kind){
            case "Object":
            case "Query":
            case "Mutation":
            case "Subscription":
                if (type instanceof graphql.GraphQLObjectType) {
                    return type;
                }
                break;
            case "Interface":
                if (type instanceof graphql.GraphQLInterfaceType) {
                    return type;
                }
                break;
            case "Union":
                if (type instanceof graphql.GraphQLUnionType) {
                    return type;
                }
                break;
            case "Enum":
                if (type instanceof graphql.GraphQLEnumType) {
                    return type;
                }
                break;
            case "Scalar":
                if (type instanceof graphql.GraphQLScalarType) {
                    return type;
                }
                break;
            case "InputObject":
                if (type instanceof graphql.GraphQLScalarType) {
                    return type;
                }
                break;
            default:
                break;
        }
        throw new errors_PothosSchemaError(`Expected ${String(ref)} to be of type ${kind}`);
    }
    buildObject(config) {
        var _config_isTypeOf;
        const type = new graphql.GraphQLObjectType({
            ...config,
            extensions: {
                ...config.extensions,
                pothosOptions: config.pothosOptions,
                pothosConfig: config
            },
            fields: ()=>this.getFields(type),
            isTypeOf: config.kind === "Object" ? this.plugin.wrapIsTypeOf((_config_isTypeOf = config.isTypeOf) !== null && _config_isTypeOf !== void 0 ? _config_isTypeOf : undefined, config) : undefined,
            interfaces: config.kind === "Object" ? ()=>config.interfaces.map((iface)=>this.getTypeOfKind(iface, "Interface")) : undefined
        });
        return type;
    }
    buildInterface(config) {
        const resolveType = (parent, context, info)=>{
            const typeBrand = getTypeBrand(parent);
            if (typeBrand) {
                if (typeof typeBrand === "string") {
                    return typeBrand;
                }
                return this.getTypeConfig(typeBrand).name;
            }
            var _config_resolveType;
            const resolver = (_config_resolveType = config.resolveType) !== null && _config_resolveType !== void 0 ? _config_resolveType : graphql.defaultTypeResolver;
            return resolver(parent, context, info, type);
        };
        const type = new graphql.GraphQLInterfaceType({
            ...config,
            extensions: {
                ...config.extensions,
                pothosOptions: config.pothosOptions,
                pothosConfig: config
            },
            interfaces: ()=>config.interfaces.map((iface)=>this.getTypeOfKind(iface, "Interface")),
            fields: ()=>this.getFields(type),
            resolveType: this.plugin.wrapResolveType(resolveType, config)
        });
        return type;
    }
    buildUnion(config) {
        const resolveType = (parent, context, info, type)=>{
            if (typeof parent === "object" && parent !== null && type_params_typeBrandKey in parent) {
                const typeBrand = parent[type_params_typeBrandKey];
                if (typeof typeBrand === "string") {
                    return typeBrand;
                }
                return this.getTypeConfig(typeBrand).name;
            }
            if (!config.resolveType) {
                return (0,graphql.defaultTypeResolver)(parent, context, info, type);
            }
            const resultOrPromise = config.resolveType(parent, context, info, type);
            const getResult = (result)=>{
                if (typeof result === "string" || !result) {
                    return result;
                }
                if (result instanceof graphql.GraphQLObjectType) {
                    return result.name;
                }
                try {
                    const typeConfig = this.configStore.getTypeConfig(result);
                    return typeConfig.name;
                } catch  {
                // ignore
                }
                return result;
            };
            return isThenable(resultOrPromise) ? resultOrPromise.then(getResult) : getResult(resultOrPromise);
        };
        return new graphql.GraphQLUnionType({
            ...config,
            extensions: {
                ...config.extensions,
                pothosOptions: config.pothosOptions,
                pothosConfig: config
            },
            types: ()=>config.types.map((member)=>this.getTypeOfKind(member, "Object")),
            resolveType: this.plugin.wrapResolveType(resolveType, config)
        });
    }
    buildInputObject(config) {
        const type = new graphql.GraphQLInputObjectType({
            ...config,
            extensions: {
                ...config.extensions,
                pothosOptions: config.pothosOptions,
                pothosConfig: config
            },
            fields: ()=>this.getInputFields(type)
        });
        return type;
    }
    buildScalar(config) {
        if (config.name === "ID") {
            return graphql.GraphQLID;
        }
        if (config.name === "Int") {
            return graphql.GraphQLInt;
        }
        if (config.name === "Float") {
            return graphql.GraphQLFloat;
        }
        if (config.name === "Boolean") {
            return graphql.GraphQLBoolean;
        }
        if (config.name === "String") {
            return graphql.GraphQLString;
        }
        return new graphql.GraphQLScalarType({
            ...config,
            extensions: {
                ...config.extensions,
                pothosOptions: config.pothosOptions,
                pothosConfig: config
            }
        });
    }
    buildEnum(config) {
        const values = {};
        for (const key of Object.keys(config.values)){
            const original = config.values[key];
            if (!this.enumValueConfigs.has(original)) {
                this.enumValueConfigs.set(original, this.plugin.onEnumValueConfig(original));
            }
            const valueConfig = this.enumValueConfigs.get(original);
            if (valueConfig) {
                values[key] = this.enumValueConfigs.get(original);
            }
        }
        return new graphql.GraphQLEnumType({
            ...config,
            values,
            extensions: {
                ...config.extensions,
                pothosOptions: config.pothosOptions,
                pothosConfig: config
            }
        });
    }
    constructor(builder, options){
        build_cache_defineProperty(this, "types", new Map());
        build_cache_defineProperty(this, "builder", void 0);
        build_cache_defineProperty(this, "plugin", void 0);
        build_cache_defineProperty(this, "options", void 0);
        build_cache_defineProperty(this, "configStore", void 0);
        build_cache_defineProperty(this, "pluginMap", void 0);
        build_cache_defineProperty(this, "pluginList", void 0);
        build_cache_defineProperty(this, "implementers", new Map());
        build_cache_defineProperty(this, "typeConfigs", new Map());
        build_cache_defineProperty(this, "enumValueConfigs", new Map());
        build_cache_defineProperty(this, "outputFieldConfigs", new Map());
        build_cache_defineProperty(this, "inputFieldConfigs", new Map());
        this.builder = builder;
        this.configStore = builder.configStore;
        this.options = options;
        const plugins = {};
        var _builder_options_plugins;
        this.pluginList = ((_builder_options_plugins = builder.options.plugins) !== null && _builder_options_plugins !== void 0 ? _builder_options_plugins : []).map((pluginName)=>{
            const Plugin = this.builder.constructor.plugins[pluginName];
            if (!Plugin) {
                throw new PothosError(`No plugin named ${pluginName} was registered`);
            }
            plugins[pluginName] = new Plugin(this, pluginName);
            return plugins[pluginName];
        });
        this.pluginMap = plugins;
        this.plugin = new MergedPlugins(this, this.pluginList);
    }
}
 //# sourceMappingURL=build-cache.js.map

;// CONCATENATED MODULE: ../../node_modules/@pothos/core/esm/refs/input.js
function input_defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}


let input_inputShapeKey = inputShapeKey;
class InputTypeRef extends BaseTypeRef {
    constructor(kind, name){
        super(kind, name);
        input_defineProperty(this, "kind", void 0);
        input_defineProperty(this, input_inputShapeKey, void 0);
        this.kind = kind;
    }
}
 //# sourceMappingURL=input.js.map

;// CONCATENATED MODULE: ../../node_modules/@pothos/core/esm/refs/output.js
function output_defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}


let output_outputShapeKey = outputShapeKey, output_parentShapeKey = parentShapeKey;
class OutputTypeRef extends BaseTypeRef {
    constructor(kind, name){
        super(kind, name);
        output_defineProperty(this, "kind", void 0);
        output_defineProperty(this, output_outputShapeKey, void 0);
        output_defineProperty(this, output_parentShapeKey, void 0);
        this.kind = kind;
    }
}
 //# sourceMappingURL=output.js.map

;// CONCATENATED MODULE: ../../node_modules/@pothos/core/esm/config-store.js
/* eslint-disable @typescript-eslint/no-redundant-type-constituents */ /* eslint-disable node/no-callback-literal */ function config_store_defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}









class ConfigStore {
    hasConfig(typeParam) {
        if (typeof typeParam === "string") {
            return this.typeConfigs.has(typeParam);
        }
        return this.refsToName.has(typeParam);
    }
    addUnionTypes(typeName, unionTypes) {
        this.onPrepare(()=>{
            const typeConfig = this.getTypeConfig(typeName);
            if (typeConfig.graphqlKind !== "Union") {
                throw new errors_PothosSchemaError(`Can not add types to ${typeName} because it is a ${typeConfig.kind}`);
            }
            typeConfig.types = [
                ...typeConfig.types,
                ...typeof unionTypes === "function" ? unionTypes() : unionTypes
            ];
        });
    }
    addInterfaces(typeName, interfaces) {
        this.onPrepare(()=>{
            const typeConfig = this.getTypeConfig(typeName);
            if (typeConfig.graphqlKind !== "Object" && typeConfig.graphqlKind !== "Interface" || typeConfig.kind === "Query" || typeConfig.kind === "Mutation" || typeConfig.kind === "Subscription") {
                throw new errors_PothosSchemaError(`Can not add interfaces to ${typeName} because it is a ${typeConfig.kind}`);
            }
            typeConfig.interfaces = [
                ...typeConfig.interfaces,
                ...typeof interfaces === "function" ? interfaces() : interfaces
            ];
        });
    }
    addFieldRef(ref, typeParam, args, getConfig) {
        if (this.fieldRefs.has(ref)) {
            throw new errors_PothosSchemaError(`FieldRef ${String(ref)} has already been added to config store`);
        }
        const typeRefOrName = unwrapListParam(typeParam);
        const argRefs = Object.keys(args).map((argName)=>{
            const argRef = args[argName];
            argRef.fieldName = argName;
            argRef.argFor = ref;
            return argRef;
        });
        const checkArgs = ()=>{
            for (const arg of argRefs){
                if (this.pendingFields.has(arg)) {
                    const unresolvedArgType = this.pendingFields.get(arg);
                    this.pendingFields.set(ref, unresolvedArgType);
                    this.onTypeConfig(unresolvedArgType, checkArgs);
                    return;
                }
            }
            this.pendingFields.delete(ref);
            this.fieldRefs.set(ref, getConfig);
        };
        if (this.hasConfig(typeRefOrName) || typeRefOrName instanceof BaseTypeRef || this.scalarsToRefs.has(typeRefOrName)) {
            checkArgs();
        } else {
            this.pendingFields.set(ref, typeRefOrName);
            this.onTypeConfig(typeRefOrName, ()=>{
                checkArgs();
            });
        }
    }
    createFieldConfig(ref, name, typeConfig, parentField, kind) {
        if (!this.fieldRefs.has(ref)) {
            if (this.pendingFields.has(ref)) {
                throw new errors_PothosSchemaError(`Missing implementation for ${this.describeRef(this.pendingFields.get(ref))}`);
            }
            throw new errors_PothosSchemaError(`Missing definition for ${String(ref)}`);
        }
        const config = this.fieldRefs.get(ref)(name, parentField, typeConfig);
        if (kind && config.graphqlKind !== kind) {
            throw new PothosError(`Expected ref for field named ${name} to resolve to a ${kind} type, but got ${config.graphqlKind}`);
        }
        return config;
    }
    associateRefWithName(ref, name) {
        if (!this.typeConfigs.has(name)) {
            throw new errors_PothosSchemaError(`${name} has not been implemented yet`);
        }
        this.refsToName.set(ref, name);
        if (this.pendingRefResolutions.has(ref)) {
            const cbs = this.pendingRefResolutions.get(ref);
            this.pendingRefResolutions.delete(ref);
            cbs.forEach((cb)=>void cb(this.typeConfigs.get(name)));
        }
    }
    addTypeConfig(config, ref) {
        const { name  } = config;
        if (this.typeConfigs.has(name)) {
            throw new errors_PothosSchemaError(`Duplicate typename: Another type with name ${name} already exists.`);
        }
        this.typeConfigs.set(config.name, config);
        if (ref) {
            this.associateRefWithName(ref, name);
        }
        if (this.pendingRefResolutions.has(name)) {
            const cbs = this.pendingRefResolutions.get(name);
            this.pendingRefResolutions.delete(name);
            cbs.forEach((cb)=>void cb(config));
        }
    }
    getTypeConfig(ref, kind) {
        let config;
        if (typeof ref === "string") {
            if (!this.typeConfigs.has(ref)) {
                throw new errors_PothosSchemaError(`Type ${String(ref)} has not been implemented`);
            }
            config = this.typeConfigs.get(ref);
        } else if (this.refsToName.has(ref)) {
            config = this.typeConfigs.get(this.refsToName.get(ref));
        } else if (ref instanceof list_ListRef || ref instanceof input_list_InputObjectRef) {
            throw new errors_PothosSchemaError(`Expected a base type but got a ${ref.kind} of ${String(ref.listType)}`);
        } else {
            throw new errors_PothosSchemaError(`Ref ${String(ref)} has not been implemented`);
        }
        if (kind && config.graphqlKind !== kind) {
            throw new errors_PothosSchemaError(`Expected ref to resolve to a ${kind} type, but got ${config.kind}`);
        }
        return config;
    }
    getInputTypeRef(ref) {
        if (ref instanceof BaseTypeRef) {
            if (ref.kind !== "InputObject" && ref.kind !== "Enum" && ref.kind !== "Scalar") {
                throw new errors_PothosSchemaError(`Expected ${ref.name} to be an input type but got ${ref.kind}`);
            }
            return ref;
        }
        if (typeof ref === "string") {
            if (this.scalarsToRefs.has(ref)) {
                return this.scalarsToRefs.get(ref);
            }
            if (this.typeConfigs.has(ref)) {
                const config = this.typeConfigs.get(ref);
                if (config.graphqlKind !== "InputObject" && config.graphqlKind !== "Enum" && config.graphqlKind !== "Scalar") {
                    throw new errors_PothosSchemaError(`Expected ${config.name} to be an input type but got ${config.graphqlKind}`);
                }
                const newRef = new InputTypeRef(config.graphqlKind, config.name);
                this.refsToName.set(newRef, config.name);
                return newRef;
            }
        }
        return ref;
    }
    getOutputTypeRef(ref) {
        if (ref instanceof BaseTypeRef) {
            if (ref.kind === "InputObject" || ref.kind === "InputList") {
                throw new errors_PothosSchemaError(`Expected ${ref.name} to be an output type but got ${ref.kind}`);
            }
            if (ref.kind === "List") {
                throw new errors_PothosSchemaError(`Expected ${ref.name} to be a base type but got a ${ref.kind}`);
            }
            return ref;
        }
        if (typeof ref === "string") {
            if (this.scalarsToRefs.has(ref)) {
                return this.scalarsToRefs.get(ref);
            }
            if (this.typeConfigs.has(ref)) {
                const config = this.typeConfigs.get(ref);
                if (config.graphqlKind === "InputObject") {
                    throw new errors_PothosSchemaError(`Expected ${config.name} to be an output type but got ${config.graphqlKind}`);
                }
                const newRef = new OutputTypeRef(config.graphqlKind, config.name);
                this.refsToName.set(newRef, config.name);
                return newRef;
            }
        }
        return ref;
    }
    onTypeConfig(ref, cb) {
        if (!ref) {
            throw new errors_PothosSchemaError(`${String(ref)} is not a valid type ref`);
        }
        if (this.refsToName.has(ref)) {
            cb(this.getTypeConfig(ref));
        } else if (typeof ref === "string" && this.typeConfigs.has(ref)) {
            cb(this.typeConfigs.get(ref));
        } else if (!this.pending) {
            throw new errors_PothosSchemaError(`Ref ${String(ref)} has not been implemented`);
        } else if (this.pendingRefResolutions.has(ref)) {
            this.pendingRefResolutions.get(ref).push(cb);
        } else {
            this.pendingRefResolutions.set(ref, [
                cb
            ]);
        }
    }
    onFieldUse(ref, cb) {
        if (!this.fieldRefCallbacks.has(ref)) {
            this.fieldRefCallbacks.set(ref, []);
        }
        this.fieldRefCallbacks.get(ref).push(cb);
        if (this.fieldRefsToConfigs.has(ref)) {
            this.fieldRefsToConfigs.get(ref).forEach((config)=>void cb(config));
        }
    }
    getFields(name, kind) {
        const typeConfig = this.getTypeConfig(name);
        if (!this.fields.has(name)) {
            this.fields.set(name, new Map());
        }
        const fields = this.fields.get(name);
        if (kind && typeConfig.graphqlKind !== kind) {
            throw new errors_PothosSchemaError(`Expected ${name} to be a ${kind} type, but found ${typeConfig.graphqlKind}`);
        }
        return fields;
    }
    prepareForBuild() {
        this.pending = false;
        const { pendingActions  } = this;
        this.pendingActions = [];
        pendingActions.forEach((fn)=>void fn());
        if (this.pendingRefResolutions.size > 0) {
            throw new errors_PothosSchemaError(`Missing implementations for some references (${[
                ...this.pendingRefResolutions.keys()
            ].map((ref)=>this.describeRef(ref)).join(", ")}).`);
        }
    }
    onPrepare(cb) {
        if (this.pending) {
            this.pendingActions.push(cb);
        } else {
            cb();
        }
    }
    addFields(typeRef, fields) {
        this.onPrepare(()=>void this.onTypeConfig(typeRef, (config)=>{
                this.buildFields(typeRef, typeof fields === "function" ? fields() : fields);
            }));
    }
    getImplementers(ref) {
        const typeConfig = this.getTypeConfig(ref, "Interface");
        const implementers = [
            ...this.typeConfigs.values()
        ].filter((type)=>type.kind === "Object" && type.interfaces.find((i)=>this.getTypeConfig(i).name === typeConfig.name));
        return implementers;
    }
    describeRef(ref) {
        var _find;
        if (typeof ref === "string") {
            return ref;
        }
        if (ref.toString !== ({}).toString) {
            return String(ref);
        }
        const usedBy = (_find = [
            ...this.pendingFields.entries()
        ].find(([fieldRef, typeRef])=>typeRef === ref)) === null || _find === void 0 ? void 0 : _find[0];
        if (usedBy) {
            return `<unnamed ref or enum: used by ${usedBy}>`;
        }
        return `<unnamed ref or enum>`;
    }
    buildFields(typeRef, fields) {
        Object.keys(fields).forEach((fieldName)=>{
            const fieldRef = fields[fieldName];
            fieldRef.fieldName = fieldName;
            if (this.pendingFields.has(fieldRef)) {
                this.onTypeConfig(this.pendingFields.get(fieldRef), ()=>{
                    this.buildField(typeRef, fieldRef, fieldName);
                });
            } else {
                this.buildField(typeRef, fieldRef, fieldName);
            }
        });
    }
    buildField(typeRef, field, fieldName) {
        const typeConfig = this.getTypeConfig(typeRef);
        const fieldConfig = this.createFieldConfig(field, fieldName, typeConfig);
        const existingFields = this.getFields(typeConfig.name);
        if (existingFields.has(fieldName)) {
            throw new errors_PothosSchemaError(`Duplicate field definition for field ${fieldName} in ${typeConfig.name}`);
        }
        if (fieldConfig.graphqlKind !== typeConfig.graphqlKind) {
            throw new errors_PothosSchemaError(`${typeConfig.name}.${fieldName} was defined as a ${fieldConfig.graphqlKind} field but ${typeConfig.name} is a ${typeConfig.graphqlKind}`);
        }
        existingFields.set(fieldName, fieldConfig);
        if (!this.fieldRefsToConfigs.has(field)) {
            this.fieldRefsToConfigs.set(field, []);
        }
        this.fieldRefsToConfigs.get(field).push(fieldConfig);
        if (this.fieldRefCallbacks.has(field)) {
            this.fieldRefCallbacks.get(field).forEach((cb)=>void cb(fieldConfig));
        }
    }
    constructor(){
        config_store_defineProperty(this, "typeConfigs", new Map());
        config_store_defineProperty(this, "fieldRefs", new WeakMap());
        config_store_defineProperty(this, "fields", new Map());
        config_store_defineProperty(this, "pendingActions", []);
        config_store_defineProperty(this, "refsToName", new Map());
        config_store_defineProperty(this, "scalarsToRefs", new Map());
        config_store_defineProperty(this, "fieldRefsToConfigs", new Map());
        config_store_defineProperty(this, "pendingFields", new Map());
        config_store_defineProperty(this, "pendingRefResolutions", new Map());
        config_store_defineProperty(this, "fieldRefCallbacks", new Map());
        config_store_defineProperty(this, "pending", true);
        const scalars = [
            graphql.GraphQLID,
            graphql.GraphQLInt,
            graphql.GraphQLFloat,
            graphql.GraphQLString,
            graphql.GraphQLBoolean
        ];
        scalars.forEach((scalar)=>{
            const ref = new BuiltinScalarRef(scalar);
            this.scalarsToRefs.set(scalar.name, ref);
            this.refsToName.set(ref, scalar.name);
        });
    }
}
 //# sourceMappingURL=config-store.js.map

;// CONCATENATED MODULE: ../../node_modules/@pothos/core/esm/refs/input-field.js
function input_field_defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}

let _inputFieldShapeKey = inputFieldShapeKey;
class InputFieldRef {
    toString() {
        var _this_argFor;
        if (this.kind !== "Arg") {
            if (this.fieldName) {
                return `${this.parentTypename}.${this.fieldName}`;
            }
            return this.parentTypename;
        }
        var _this_argFor_fieldName;
        const fieldName = (_this_argFor_fieldName = (_this_argFor = this.argFor) === null || _this_argFor === void 0 ? void 0 : _this_argFor.fieldName) !== null && _this_argFor_fieldName !== void 0 ? _this_argFor_fieldName : "[unnamed field]";
        var _this_fieldName;
        const argName = (_this_fieldName = this.fieldName) !== null && _this_fieldName !== void 0 ? _this_fieldName : "[unnamed argument]";
        return `${this.parentTypename}.${fieldName}(${argName})`;
    }
    constructor(kind, parentTypename){
        input_field_defineProperty(this, "kind", void 0);
        input_field_defineProperty(this, "parentTypename", void 0);
        input_field_defineProperty(this, "fieldName", void 0);
        input_field_defineProperty(this, "argFor", void 0);
        input_field_defineProperty(this, _inputFieldShapeKey, void 0);
        this.kind = kind;
        this.parentTypename = parentTypename;
    }
}
 //# sourceMappingURL=input-field.js.map

;// CONCATENATED MODULE: ../../node_modules/@pothos/core/esm/fieldUtils/input.js
function fieldUtils_input_defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}



class InputFieldBuilder {
    argBuilder() {
        const builder = this.field.bind(this);
        const protoKeys = Object.keys(Object.getPrototypeOf(this)).filter((key)=>typeof this[key] === "function" && Function.prototype[key] === undefined);
        [
            ...Object.keys(this),
            ...protoKeys
        ].forEach((key)=>{
            builder[key] = typeof this[key] === "function" ? this[key].bind(this) : this[key];
        });
        return builder;
    }
    /**
   * Create in input field or argument for the current type
   * @param {PothosSchemaTypes.InputFieldOptions} [options={}] - Options for this field
   */ field(options) {
        const ref = new InputFieldRef(this.kind, this.typename);
        var _options_required;
        this.builder.configStore.addFieldRef(ref, options.type, {}, (name, parentField, typeConfig)=>({
                name,
                parentField,
                kind: this.kind,
                graphqlKind: this.kind,
                parentType: typeConfig.name,
                type: inputTypeFromParam(options.type, this.builder.configStore, (_options_required = options.required) !== null && _options_required !== void 0 ? _options_required : this.builder.defaultInputFieldRequiredness),
                pothosOptions: options,
                description: options.description,
                deprecationReason: options.deprecationReason,
                defaultValue: options.defaultValue,
                extensions: options.extensions
            }));
        return ref;
    }
    helper(type) {
        return (...args)=>{
            const [options = {}] = args;
            return this.field({
                ...options,
                type
            });
        };
    }
    constructor(builder, kind, typename){
        fieldUtils_input_defineProperty(this, "builder", void 0);
        fieldUtils_input_defineProperty(this, "kind", void 0);
        fieldUtils_input_defineProperty(this, "typename", void 0);
        /**
   * Create a Boolean input field
   * @param {PothosSchemaTypes.InputFieldOptions} [options={}] - Options for this field
   */ fieldUtils_input_defineProperty(this, "boolean", this.helper("Boolean"));
        /**
   * Create a Float input field
   * @param {PothosSchemaTypes.InputFieldOptions} [options={}] - Options for this field
   */ fieldUtils_input_defineProperty(this, "float", this.helper("Float"));
        /**
   * Create a ID input field
   * @param {PothosSchemaTypes.InputFieldOptions} [options={}] - Options for this field
   */ fieldUtils_input_defineProperty(this, "id", this.helper("ID"));
        /**
   * Create a Int input field
   * @param {PothosSchemaTypes.InputFieldOptions} [options={}] - Options for this field
   */ fieldUtils_input_defineProperty(this, "int", this.helper("Int"));
        /**
   * Create a String input field
   * @param {PothosSchemaTypes.InputFieldOptions} [options={}] - Options for this field
   */ fieldUtils_input_defineProperty(this, "string", this.helper("String"));
        /**
   * Create a Boolean list input field
   * @param {PothosSchemaTypes.InputFieldOptions} [options={}] - Options for this field
   */ fieldUtils_input_defineProperty(this, "booleanList", this.helper([
            "Boolean"
        ]));
        /**
   * Create a Float list input field
   * @param {PothosSchemaTypes.InputFieldOptions} [options={}] - Options for this field
   */ fieldUtils_input_defineProperty(this, "floatList", this.helper([
            "Float"
        ]));
        /**
   * Create a ID list input field
   * @param {PothosSchemaTypes.InputFieldOptions} [options={}] - Options for this field
   */ fieldUtils_input_defineProperty(this, "idList", this.helper([
            "ID"
        ]));
        /**
   * Create a Int list input field
   * @param {PothosSchemaTypes.InputFieldOptions} [options={}] - Options for this field
   */ fieldUtils_input_defineProperty(this, "intList", this.helper([
            "Int"
        ]));
        /**
   * Create a String list input field
   * @param {PothosSchemaTypes.InputFieldOptions} [options={}] - Options for this field
   */ fieldUtils_input_defineProperty(this, "stringList", this.helper([
            "String"
        ]));
        var _options_required;
        fieldUtils_input_defineProperty(this, "listRef", (type, options)=>{
            return new input_list_InputObjectRef(type, (_options_required = options === null || options === void 0 ? void 0 : options.required) !== null && _options_required !== void 0 ? _options_required : true);
        });
        this.builder = builder;
        this.kind = kind;
        this.typename = typename;
    }
}
 //# sourceMappingURL=input.js.map

;// CONCATENATED MODULE: ../../node_modules/@pothos/core/esm/refs/field.js
function field_defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}

let _outputFieldShapeKey = outputFieldShapeKey;
class FieldRef {
    toString() {
        if (this.fieldName) {
            return `${this.parentTypename}.${this.fieldName}`;
        }
        return this.parentTypename;
    }
    constructor(kind, parentTypename){
        field_defineProperty(this, "kind", void 0);
        field_defineProperty(this, "parentTypename", void 0);
        field_defineProperty(this, "fieldName", void 0);
        field_defineProperty(this, _outputFieldShapeKey, void 0);
        this.kind = kind;
        this.parentTypename = parentTypename;
    }
}
 //# sourceMappingURL=field.js.map

;// CONCATENATED MODULE: ../../node_modules/@pothos/core/esm/fieldUtils/base.js
function fieldUtils_base_defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}




class BaseFieldUtil {
    createField(options) {
        const ref = new FieldRef(this.kind, this.typename);
        var _options_args;
        this.builder.configStore.addFieldRef(ref, options.type, (_options_args = options.args) !== null && _options_args !== void 0 ? _options_args : {}, (name, parentField, typeConfig)=>{
            var _options_extensions;
            const args = {};
            if (options.args) {
                Object.keys(options.args).forEach((argName)=>{
                    const argRef = options.args[argName];
                    args[argName] = this.builder.configStore.createFieldConfig(argRef, argName, typeConfig, name, "Arg");
                });
            }
            var _options_resolve;
            let resolve = (_options_resolve = options.resolve) !== null && _options_resolve !== void 0 ? _options_resolve : ()=>{
                throw new errors_PothosSchemaError(`Not implemented: No resolver found for ${this.typename}.${name}`);
            };
            if (((_options_extensions = options.extensions) === null || _options_extensions === void 0 ? void 0 : _options_extensions.pothosExposedField) === name) {
                resolve = graphql.defaultFieldResolver;
            }
            const { subscribe  } = options;
            var _options_nullable;
            return {
                kind: this.kind,
                graphqlKind: this.graphqlKind,
                parentType: typeConfig.name,
                name,
                args,
                type: typeFromParam(options.type, this.builder.configStore, (_options_nullable = options.nullable) !== null && _options_nullable !== void 0 ? _options_nullable : this.builder.defaultFieldNullability),
                pothosOptions: options,
                extensions: {
                    pothosOriginalResolve: resolve,
                    pothosOriginalSubscribe: subscribe,
                    ...options.extensions
                },
                description: options.description,
                deprecationReason: options.deprecationReason,
                resolve,
                subscribe
            };
        });
        return ref;
    }
    exposeField(name, { extensions , ...options }) {
        return this.createField({
            ...options,
            extensions: {
                pothosExposedField: name,
                ...extensions
            },
            resolve: (parent)=>parent[name]
        });
    }
    constructor(name, builder, kind, graphqlKind){
        fieldUtils_base_defineProperty(this, "typename", void 0);
        fieldUtils_base_defineProperty(this, "builder", void 0);
        fieldUtils_base_defineProperty(this, "kind", void 0);
        fieldUtils_base_defineProperty(this, "graphqlKind", void 0);
        this.typename = name;
        this.builder = builder;
        this.kind = kind;
        this.graphqlKind = graphqlKind;
    }
}
 //# sourceMappingURL=base.js.map

;// CONCATENATED MODULE: ../../node_modules/@pothos/core/esm/fieldUtils/root.js
function root_defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}



class RootFieldBuilder extends BaseFieldUtil {
    /**
   * Create a Boolean field
   * @param {PothosSchemaTypes.FieldOptions} options - Options for this field
   */ boolean(...args) {
        const [options = {}] = args;
        return this.createField({
            resolve: undefined,
            ...options,
            type: "Boolean"
        });
    }
    /**
   * Create a Float field
   * @param {PothosSchemaTypes.FieldOptions} options - Options for this field
   */ float(...args) {
        const [options = {}] = args;
        return this.createField({
            resolve: undefined,
            ...options,
            type: "Float"
        });
    }
    /**
   * Create a ID field
   * @param {PothosSchemaTypes.FieldOptions} options - Options for this field
   */ id(...args) {
        const [options = {}] = args;
        return this.createField({
            resolve: undefined,
            ...options,
            type: "ID"
        });
    }
    /**
   * Create a Int field
   * @param {PothosSchemaTypes.FieldOptions} options - Options for this field
   */ int(...args) {
        const [options = {}] = args;
        return this.createField({
            resolve: undefined,
            ...options,
            type: "Int"
        });
    }
    /**
   * Create a String field
   * @param {PothosSchemaTypes.FieldOptions} options - Options for this field
   */ string(...args) {
        const [options = {}] = args;
        return this.createField({
            resolve: undefined,
            ...options,
            type: "String"
        });
    }
    /**
   * Create a Boolean list field
   * @param {PothosSchemaTypes.FieldOptions} options - Options for this field
   */ booleanList(...args) {
        const [options = {}] = args;
        return this.createField({
            resolve: undefined,
            ...options,
            type: [
                "Boolean"
            ]
        });
    }
    /**
   * Create a Float list field
   * @param {PothosSchemaTypes.FieldOptions} options - Options for this field
   */ floatList(...args) {
        const [options = {}] = args;
        return this.createField({
            resolve: undefined,
            ...options,
            type: [
                "Float"
            ]
        });
    }
    /**
   * Create a ID list field
   * @param {PothosSchemaTypes.FieldOptions} options - Options for this field
   */ idList(...args) {
        const [options = {}] = args;
        return this.createField({
            resolve: undefined,
            ...options,
            type: [
                "ID"
            ]
        });
    }
    /**
   * Create a Int list field
   * @param {PothosSchemaTypes.FieldOptions} options - Options for this field
   */ intList(...args) {
        const [options = {}] = args;
        return this.createField({
            resolve: undefined,
            ...options,
            type: [
                "Int"
            ]
        });
    }
    /**
   * Create a String list field
   * @param {PothosSchemaTypes.FieldOptions} options - Options for this field
   */ stringList(...args) {
        const [options = {}] = args;
        return this.createField({
            resolve: undefined,
            ...options,
            type: [
                "String"
            ]
        });
    }
    /**
   * create a new field for the current type
   * @param {PothosSchemaTypes.FieldOptions} options - options for this field
   */ field(options) {
        return this.createField(options);
    }
    listRef(type, options) {
        var _options_nullable;
        return new list_ListRef(type, (_options_nullable = options === null || options === void 0 ? void 0 : options.nullable) !== null && _options_nullable !== void 0 ? _options_nullable : false);
    }
    constructor(...args){
        super(...args);
        root_defineProperty(this, "arg", new InputFieldBuilder(this.builder, "Arg", this.typename).argBuilder());
    }
}
 //# sourceMappingURL=root.js.map

;// CONCATENATED MODULE: ../../node_modules/@pothos/core/esm/fieldUtils/builder.js

class FieldBuilder extends RootFieldBuilder {
    /**
   * Create a Boolean field from a boolean property on the parent object
   * @param {string} name - the name of the property on the source object (does not need to match the field name).
   * @param {object} [options={}] - Options for this field
   */ exposeBoolean(name, ...args) {
        const [options = {}] = args;
        return this.exposeField(name, {
            ...options,
            type: "Boolean"
        });
    }
    /**
   * Create a Float field from a numeric property on the parent object
   * @param {string} name - the name of the property on the source object (does not need to match the field name).
   * @param {object} [options={}] - Options for this field
   */ exposeFloat(name, ...args) {
        const [options = {}] = args;
        return this.exposeField(name, {
            ...options,
            type: "Float"
        });
    }
    /**
   * Create an ID field from a property on the parent object
   * @param {string} name - the name of the property on the source object (does not need to match the field name).
   * @param {object} [options={}] - Options for this field
   */ exposeID(name, ...args) {
        const [options = {}] = args;
        return this.exposeField(name, {
            ...options,
            type: "ID"
        });
    }
    /**
   * Create an Int field from a numeric property on the parent object
   * @param {string} name - the name of the property on the source object (does not need to match the field name).
   * @param {object} [options={}] - Options for this field
   */ exposeInt(name, ...args) {
        const [options = {}] = args;
        return this.exposeField(name, {
            ...options,
            type: "Int"
        });
    }
    /**
   * Create a String field from a string property on the parent object
   * @param {string} name - the name of the property on the source object (does not need to match the field name).
   * @param {object} [options={}] - Options for this field
   */ exposeString(name, ...args) {
        const [options = {}] = args;
        return this.exposeField(name, {
            ...options,
            type: "String"
        });
    }
    /**
   * Create a Boolean list field from a boolean[] property on the parent object
   * @param {string} name - the name of the property on the source object (does not need to match the field name).
   * @param {object} [options={}] - Options for this field
   */ exposeBooleanList(name, ...args) {
        const [options = {}] = args;
        return this.exposeField(name, {
            ...options,
            type: [
                "Boolean"
            ]
        });
    }
    /**
   * Create a Float list field from a number[] property on the parent object
   * @param {string} name - the name of the property on the source object (does not need to match the field name).
   * @param {object} [options={}] - Options for this field
   */ exposeFloatList(name, ...args) {
        const [options = {}] = args;
        return this.exposeField(name, {
            ...options,
            type: [
                "Float"
            ]
        });
    }
    /**
   * Create an ID list field from an id[] property on the parent object
   * @param {string} name - the name of the property on the source object (does not need to match the field name).
   * @param {object} [options={}] - Options for this field
   */ exposeIDList(name, ...args) {
        const [options = {}] = args;
        return this.exposeField(name, {
            ...options,
            type: [
                "ID"
            ]
        });
    }
    /**
   * Create a Int list field from a number[] property on the parent object
   * @param {string} name - the name of the property on the source object (does not need to match the field name).
   * @param {object} [options={}] - Options for this field
   */ exposeIntList(name, ...args) {
        const [options = {}] = args;
        return this.exposeField(name, {
            ...options,
            type: [
                "Int"
            ]
        });
    }
    /**
   * Create a String list field from a string[] property on the parent object
   * @param {string} name - the name of the property on the source object (does not need to match the field name).
   * @param {object} [options={}] - Options for this field
   */ exposeStringList(name, ...args) {
        const [options = {}] = args;
        return this.exposeField(name, {
            ...options,
            type: [
                "String"
            ]
        });
    }
    /**
   * Create a field that resolves to a property of the corresponding type on the parent object
   * @param {string} name - the name of the property on the source object (does not need to match the field name).
   * @param {object} [options={}] - Options for this field
   */ expose(name, ...args) {
        const [options = {}] = args;
        return this.exposeField(name, options);
    }
}
 //# sourceMappingURL=builder.js.map

;// CONCATENATED MODULE: ../../node_modules/@pothos/core/esm/fieldUtils/interface.js

class InterfaceFieldBuilder extends FieldBuilder {
    constructor(name, builder){
        super(name, builder, "Interface", "Interface");
    }
}
 //# sourceMappingURL=interface.js.map

;// CONCATENATED MODULE: ../../node_modules/@pothos/core/esm/fieldUtils/mutation.js

class MutationFieldBuilder extends RootFieldBuilder {
    constructor(builder){
        super("Mutation", builder, "Mutation", "Object");
    }
}
 //# sourceMappingURL=mutation.js.map

;// CONCATENATED MODULE: ../../node_modules/@pothos/core/esm/fieldUtils/object.js

class ObjectFieldBuilder extends FieldBuilder {
    constructor(name, builder){
        super(name, builder, "Object", "Object");
    }
}
 //# sourceMappingURL=object.js.map

;// CONCATENATED MODULE: ../../node_modules/@pothos/core/esm/fieldUtils/query.js

class QueryFieldBuilder extends RootFieldBuilder {
    constructor(builder){
        super("Query", builder, "Query", "Object");
    }
}
 //# sourceMappingURL=query.js.map

;// CONCATENATED MODULE: ../../node_modules/@pothos/core/esm/fieldUtils/subscription.js

class SubscriptionFieldBuilder extends RootFieldBuilder {
    constructor(builder){
        super("Subscription", builder, "Subscription", "Object");
    }
}
 //# sourceMappingURL=subscription.js.map

;// CONCATENATED MODULE: ../../node_modules/@pothos/core/esm/refs/enum.js
function enum_defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}


let enum_outputShapeKey = outputShapeKey, enum_inputShapeKey = inputShapeKey;
class EnumRef extends BaseTypeRef {
    constructor(name){
        super("Enum", name);
        enum_defineProperty(this, "kind", "Enum");
        enum_defineProperty(this, enum_outputShapeKey, void 0);
        enum_defineProperty(this, enum_inputShapeKey, void 0);
    }
}
 //# sourceMappingURL=enum.js.map

;// CONCATENATED MODULE: ../../node_modules/@pothos/core/esm/refs/interface.js
/* eslint-disable max-classes-per-file */ function interface_defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}


let interface_outputShapeKey = outputShapeKey, interface_parentShapeKey = parentShapeKey;
class InterfaceRef extends BaseTypeRef {
    constructor(name){
        super("Interface", name);
        interface_defineProperty(this, "kind", "Interface");
        interface_defineProperty(this, interface_outputShapeKey, void 0);
        interface_defineProperty(this, interface_parentShapeKey, void 0);
    }
}

class ImplementableInterfaceRef extends InterfaceRef {
    implement(options) {
        return this.builder.interfaceType(this, options);
    }
    constructor(builder, name){
        super(name);
        interface_defineProperty(this, "builder", void 0);
        this.builder = builder;
    }
} //# sourceMappingURL=interface.js.map

;// CONCATENATED MODULE: ../../node_modules/@pothos/core/esm/refs/object.js
/* eslint-disable max-classes-per-file */ function object_defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}


let object_outputShapeKey = outputShapeKey, object_parentShapeKey = parentShapeKey;
class ObjectRef extends BaseTypeRef {
    constructor(name){
        super("Object", name);
        object_defineProperty(this, "kind", "Object");
        object_defineProperty(this, object_outputShapeKey, void 0);
        object_defineProperty(this, object_parentShapeKey, void 0);
    }
}

class ImplementableObjectRef extends ObjectRef {
    implement(options) {
        return this.builder.objectType(this, options);
    }
    constructor(builder, name){
        super(name);
        object_defineProperty(this, "builder", void 0);
        this.builder = builder;
    }
} //# sourceMappingURL=object.js.map

;// CONCATENATED MODULE: ../../node_modules/@pothos/core/esm/refs/union.js
function union_defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}


let union_outputShapeKey = outputShapeKey, union_parentShapeKey = parentShapeKey;
class UnionRef extends BaseTypeRef {
    constructor(name){
        super("Union", name);
        union_defineProperty(this, "kind", "Union");
        union_defineProperty(this, union_outputShapeKey, void 0);
        union_defineProperty(this, union_parentShapeKey, void 0);
    }
}
 //# sourceMappingURL=union.js.map

;// CONCATENATED MODULE: ../../node_modules/@pothos/core/esm/builder.js
function builder_defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}


















class SchemaBuilder {
    static registerPlugin(name, plugin) {
        if (!this.allowPluginReRegistration && this.plugins[name]) {
            throw new PothosError(`Received multiple implementations for plugin ${name}`);
        }
        this.plugins[name] = plugin;
    }
    objectType(param, options, fields) {
        verifyRef(param);
        verifyInterfaces(options.interfaces);
        var _options_name;
        const name = typeof param === "string" ? param : (_options_name = options.name) !== null && _options_name !== void 0 ? _options_name : param.name;
        if (name === "Query" || name === "Mutation" || name === "Subscription") {
            throw new errors_PothosSchemaError(`Invalid object name ${name} use .create${name}Type() instead`);
        }
        const ref = param instanceof BaseTypeRef ? param : new ObjectRef(name);
        const config = {
            kind: "Object",
            graphqlKind: "Object",
            name,
            interfaces: [],
            description: options.description,
            extensions: options.extensions,
            isTypeOf: options.isTypeOf,
            pothosOptions: options
        };
        this.configStore.addTypeConfig(config, ref);
        if (options.interfaces) {
            this.configStore.addInterfaces(name, options.interfaces);
        }
        if (typeof param === "function") {
            this.configStore.associateRefWithName(param, name);
        }
        if (fields) {
            this.configStore.addFields(ref, ()=>fields(new ObjectFieldBuilder(name, this)));
        }
        if (options.fields) {
            this.configStore.addFields(ref, ()=>{
                const t = new ObjectFieldBuilder(name, this);
                return options.fields(t);
            });
        }
        return ref;
    }
    objectFields(ref, fields) {
        verifyRef(ref);
        this.configStore.onTypeConfig(ref, ({ name  })=>{
            this.configStore.addFields(ref, ()=>fields(new ObjectFieldBuilder(name, this)));
        });
    }
    objectField(ref, fieldName, field) {
        verifyRef(ref);
        this.configStore.onTypeConfig(ref, ({ name  })=>{
            this.configStore.addFields(ref, ()=>({
                    [fieldName]: field(new ObjectFieldBuilder(name, this))
                }));
        });
    }
    queryType(...args) {
        const [options = {}, fields] = args;
        const config = {
            kind: "Query",
            graphqlKind: "Object",
            name: "Query",
            description: options.description,
            pothosOptions: options,
            extensions: options.extensions
        };
        const ref = new ObjectRef("Query");
        this.configStore.addTypeConfig(config, ref);
        if (fields) {
            this.configStore.addFields("Query", ()=>fields(new QueryFieldBuilder(this)));
        }
        if (options.fields) {
            this.configStore.addFields("Query", ()=>options.fields(new QueryFieldBuilder(this)));
        }
        return ref;
    }
    queryFields(fields) {
        this.configStore.addFields("Query", ()=>fields(new QueryFieldBuilder(this)));
    }
    queryField(name, field) {
        this.configStore.addFields("Query", ()=>({
                [name]: field(new QueryFieldBuilder(this))
            }));
    }
    mutationType(...args) {
        const [options = {}, fields] = args;
        const config = {
            kind: "Mutation",
            graphqlKind: "Object",
            name: "Mutation",
            description: options.description,
            pothosOptions: options,
            extensions: options.extensions
        };
        this.configStore.addTypeConfig(config);
        if (fields) {
            this.configStore.addFields("Mutation", ()=>fields(new MutationFieldBuilder(this)));
        }
        if (options.fields) {
            this.configStore.addFields("Mutation", ()=>options.fields(new MutationFieldBuilder(this)));
        }
    }
    mutationFields(fields) {
        this.configStore.addFields("Mutation", ()=>fields(new MutationFieldBuilder(this)));
    }
    mutationField(name, field) {
        this.configStore.addFields("Mutation", ()=>({
                [name]: field(new MutationFieldBuilder(this))
            }));
    }
    subscriptionType(...args) {
        const [options = {}, fields] = args;
        const config = {
            kind: "Subscription",
            graphqlKind: "Object",
            name: "Subscription",
            description: options.description,
            pothosOptions: options,
            extensions: options.extensions
        };
        this.configStore.addTypeConfig(config);
        if (fields) {
            this.configStore.addFields("Subscription", ()=>fields(new SubscriptionFieldBuilder(this)));
        }
        if (options.fields) {
            this.configStore.addFields("Subscription", ()=>options.fields(new SubscriptionFieldBuilder(this)));
        }
    }
    subscriptionFields(fields) {
        this.configStore.addFields("Subscription", ()=>fields(new SubscriptionFieldBuilder(this)));
    }
    subscriptionField(name, field) {
        this.configStore.addFields("Subscription", ()=>({
                [name]: field(new SubscriptionFieldBuilder(this))
            }));
    }
    args(fields) {
        return fields(new InputFieldBuilder(this, "Arg", "[unknown]"));
    }
    interfaceType(param, options, fields) {
        verifyRef(param);
        verifyInterfaces(options.interfaces);
        var _options_name;
        const name = typeof param === "string" ? param : (_options_name = options.name) !== null && _options_name !== void 0 ? _options_name : param.name;
        const ref = param instanceof BaseTypeRef ? param : new InterfaceRef(name);
        const typename = ref.name;
        const config = {
            kind: "Interface",
            graphqlKind: "Interface",
            name: typename,
            interfaces: [],
            description: options.description,
            pothosOptions: options,
            extensions: options.extensions,
            resolveType: options.resolveType
        };
        this.configStore.addTypeConfig(config, ref);
        if (options.interfaces) {
            this.configStore.addInterfaces(typename, options.interfaces);
        }
        if (typeof param === "function") {
            this.configStore.associateRefWithName(param, name);
        }
        if (fields) {
            this.configStore.addFields(ref, ()=>fields(new InterfaceFieldBuilder(typename, this)));
        }
        if (options.fields) {
            this.configStore.addFields(ref, ()=>options.fields(new InterfaceFieldBuilder(typename, this)));
        }
        return ref;
    }
    interfaceFields(ref, fields) {
        verifyRef(ref);
        this.configStore.onTypeConfig(ref, ({ name  })=>{
            this.configStore.addFields(ref, ()=>fields(new InterfaceFieldBuilder(name, this)));
        });
    }
    interfaceField(ref, fieldName, field) {
        verifyRef(ref);
        this.configStore.onTypeConfig(ref, ({ name  })=>{
            this.configStore.addFields(ref, ()=>({
                    [fieldName]: field(new InterfaceFieldBuilder(name, this))
                }));
        });
    }
    unionType(name, options) {
        const ref = new UnionRef(name);
        if (Array.isArray(options.types)) {
            options.types.forEach((type)=>{
                verifyRef(type);
            });
        }
        const config = {
            kind: "Union",
            graphqlKind: "Union",
            name,
            types: [],
            description: options.description,
            resolveType: options.resolveType,
            pothosOptions: options,
            extensions: options.extensions
        };
        this.configStore.addTypeConfig(config, ref);
        this.configStore.addUnionTypes(name, options.types);
        return ref;
    }
    enumType(param, options) {
        verifyRef(param);
        const name = typeof param === "string" ? param : options.name;
        const ref = new EnumRef(name);
        const values = typeof param === "object" ? valuesFromEnum(param, options === null || options === void 0 ? void 0 : options.values) : normalizeEnumValues(options.values);
        const config = {
            kind: "Enum",
            graphqlKind: "Enum",
            name,
            values,
            description: options.description,
            pothosOptions: options,
            extensions: options.extensions
        };
        this.configStore.addTypeConfig(config, ref);
        if (typeof param !== "string") {
            // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
            this.configStore.associateRefWithName(param, name);
        }
        return ref;
    }
    scalarType(name, options) {
        const ref = new ScalarRef(name);
        const config = {
            kind: "Scalar",
            graphqlKind: "Scalar",
            name,
            description: options.description,
            parseLiteral: options.parseLiteral,
            parseValue: options.parseValue,
            serialize: options.serialize,
            pothosOptions: options,
            extensions: options.extensions
        };
        this.configStore.addTypeConfig(config, ref);
        return ref;
    }
    addScalarType(name, scalar, options) {
        const config = scalar.toConfig();
        return this.scalarType(name, {
            ...config,
            ...options,
            extensions: {
                ...config.extensions,
                ...options.extensions
            }
        });
    }
    inputType(param, options) {
        verifyRef(param);
        const name = typeof param === "string" ? param : param.name;
        const ref = typeof param === "string" ? new InputObjectRef(name) : param;
        const config = {
            kind: "InputObject",
            graphqlKind: "InputObject",
            name,
            description: options.description,
            pothosOptions: options,
            extensions: options.extensions
        };
        this.configStore.addTypeConfig(config, ref);
        this.configStore.addFields(ref, ()=>options.fields(new InputFieldBuilder(this, "InputObject", name)));
        return ref;
    }
    inputRef(name) {
        return new ImplementableInputObjectRef(this, name);
    }
    objectRef(name) {
        return new ImplementableObjectRef(this, name);
    }
    interfaceRef(name) {
        return new ImplementableInterfaceRef(this, name);
    }
    toSchema(...args) {
        const [options = {}] = args;
        const { directives , extensions  } = options;
        const scalars = [
            graphql.GraphQLID,
            graphql.GraphQLInt,
            graphql.GraphQLFloat,
            graphql.GraphQLString,
            graphql.GraphQLBoolean
        ];
        scalars.forEach((scalar)=>{
            if (!this.configStore.hasConfig(scalar.name)) {
                this.addScalarType(scalar.name, scalar, {});
            }
        });
        const buildCache = new BuildCache(this, options);
        buildCache.plugin.beforeBuild();
        buildCache.buildAll();
        const builtTypes = [
            ...buildCache.types.values()
        ];
        const schema = new graphql.GraphQLSchema({
            query: buildCache.types.get("Query"),
            mutation: buildCache.types.get("Mutation"),
            subscription: buildCache.types.get("Subscription"),
            extensions: extensions !== null && extensions !== void 0 ? extensions : {},
            directives: directives,
            types: builtTypes
        });
        const processedSchema = buildCache.plugin.afterBuild(schema);
        return options.sortSchema === false ? processedSchema : (0,graphql.lexicographicSortSchema)(processedSchema);
    }
    constructor(options){
        builder_defineProperty(this, "configStore", void 0);
        builder_defineProperty(this, "options", void 0);
        builder_defineProperty(this, "defaultFieldNullability", void 0);
        builder_defineProperty(this, "defaultInputFieldRequiredness", void 0);
        this.options = options;
        this.configStore = new ConfigStore();
        var _options_defaultFieldNullability;
        this.defaultFieldNullability = (_options_defaultFieldNullability = options.defaultFieldNullability) !== null && _options_defaultFieldNullability !== void 0 ? _options_defaultFieldNullability : false;
        var _options_defaultInputFieldRequiredness;
        this.defaultInputFieldRequiredness = (_options_defaultInputFieldRequiredness = options.defaultInputFieldRequiredness) !== null && _options_defaultInputFieldRequiredness !== void 0 ? _options_defaultInputFieldRequiredness : false;
    }
}
builder_defineProperty(SchemaBuilder, "plugins", {});
builder_defineProperty(SchemaBuilder, "allowPluginReRegistration", false);
 //# sourceMappingURL=builder.js.map

;// CONCATENATED MODULE: ../../node_modules/@pothos/core/esm/index.js
/* eslint-disable @typescript-eslint/no-redeclare */ 






















const esm_SchemaBuilder = SchemaBuilder;
/* harmony default export */ const esm = (esm_SchemaBuilder);
const esm_FieldBuilder = (/* unused pure expression or super */ null && (InternalFieldBuilder));
const esm_RootFieldBuilder = (/* unused pure expression or super */ null && (InternalRootFieldBuilder));
const esm_QueryFieldBuilder = (/* unused pure expression or super */ null && (InternalQueryFieldBuilder));
const esm_MutationFieldBuilder = (/* unused pure expression or super */ null && (InternalMutationFieldBuilder));
const esm_SubscriptionFieldBuilder = (/* unused pure expression or super */ null && (InternalSubscriptionFieldBuilder));
const esm_ObjectFieldBuilder = (/* unused pure expression or super */ null && (InternalObjectFieldBuilder));
const esm_InterfaceFieldBuilder = (/* unused pure expression or super */ null && (InternalInterfaceFieldBuilder));
const esm_InputFieldBuilder = (/* unused pure expression or super */ null && (InternalInputFieldBuilder));
const esm_BaseTypeRef = (/* unused pure expression or super */ null && (InternalBaseTypeRef));
const esm_EnumRef = (/* unused pure expression or super */ null && (InternalEnumRef));
const esm_InputObjectRef = (/* unused pure expression or super */ null && (InternalInputObjectRef));
const esm_InputListRef = (/* unused pure expression or super */ null && (InternalInputListRef));
const esm_InterfaceRef = InterfaceRef;
const esm_ObjectRef = ObjectRef;
const esm_ScalarRef = (/* unused pure expression or super */ null && (InternalScalarRef));
const esm_UnionRef = (/* unused pure expression or super */ null && (InternalUnionRef));
const esm_ListRef = (/* unused pure expression or super */ null && (InternalListRef));








 //# sourceMappingURL=index.js.map


/***/ }),

/***/ 4742:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* unused harmony export PothosSimpleObjectsPlugin */
/* harmony import */ var _pothos_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7724);


const pluginName = "simpleObjects";
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (pluginName);
class PothosSimpleObjectsPlugin extends _pothos_core__WEBPACK_IMPORTED_MODULE_0__/* .BasePlugin */ .vq {
}
_pothos_core__WEBPACK_IMPORTED_MODULE_0__/* ["default"].registerPlugin */ .ZP.registerPlugin(pluginName, PothosSimpleObjectsPlugin);
const proto = _pothos_core__WEBPACK_IMPORTED_MODULE_0__/* ["default"].prototype */ .ZP.prototype;
proto.simpleObject = function simpleObject(name, options) {
    const ref = new _pothos_core__WEBPACK_IMPORTED_MODULE_0__/* .ObjectRef */ .lK(name);
    if (options.fields) {
        const originalFields = options.fields;
        // eslint-disable-next-line no-param-reassign
        options.fields = (t)=>{
            const fields = originalFields(t);
            Object.keys(fields).forEach((key)=>{
                this.configStore.onFieldUse(fields[key], (config)=>{
                    if (config.kind === "Object") {
                        // eslint-disable-next-line no-param-reassign
                        config.resolve = (parent)=>parent[key];
                    }
                });
            });
            return fields;
        };
    }
    this.objectType(ref, options);
    return ref;
};
proto.simpleInterface = function simpleInterface(name, options) {
    const ref = new _pothos_core__WEBPACK_IMPORTED_MODULE_0__/* .InterfaceRef */ .O_(name);
    if (options.fields) {
        const originalFields = options.fields;
        // eslint-disable-next-line no-param-reassign
        options.fields = (t)=>{
            const fields = originalFields(t);
            Object.keys(fields).forEach((key)=>{
                this.configStore.onFieldUse(fields[key], (config)=>{
                    if (config.kind === "Interface") {
                        // eslint-disable-next-line no-param-reassign
                        config.resolve = (parent)=>parent[key];
                    }
                });
            });
            return fields;
        };
    }
    this.interfaceType(ref, options);
    return ref;
}; //# sourceMappingURL=index.js.map


/***/ }),

/***/ 332:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "dset": () => (/* binding */ dset)
/* harmony export */ });
function dset(obj, keys, val) {
    keys.split && (keys = keys.split("."));
    var i = 0, l = keys.length, t = obj, x, k;
    while(i < l){
        k = keys[i++];
        if (k === "__proto__" || k === "constructor" || k === "prototype") break;
        t = t[k] = i === l ? val : typeof (x = t[k]) === typeof keys ? x : keys[i] * 0 !== 0 || !!~("" + keys[i]).indexOf(".") ? {} : [];
    }
}


/***/ }),

/***/ 7263:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
const hasAbortController = typeof AbortController === "function";
// minimal backwards-compatibility polyfill
// this doesn't have nearly all the checks and whatnot that
// actual AbortController/Signal has, but it's enough for
// our purposes, and if used properly, behaves the same.
const AC = hasAbortController ? AbortController : class AbortController1 {
    constructor(){
        this.signal = new AS();
    }
    abort(reason = new Error("This operation was aborted")) {
        this.signal.reason = this.signal.reason || reason;
        this.signal.aborted = true;
        this.signal.dispatchEvent({
            type: "abort",
            target: this.signal
        });
    }
};
const hasAbortSignal = typeof AbortSignal === "function";
// Some polyfills put this on the AC class, not global
const hasACAbortSignal = typeof AC.AbortSignal === "function";
const AS = hasAbortSignal ? AbortSignal : hasACAbortSignal ? AC.AbortController : class AbortSignal1 {
    constructor(){
        this.reason = undefined;
        this.aborted = false;
        this._listeners = [];
    }
    dispatchEvent(e) {
        if (e.type === "abort") {
            this.aborted = true;
            this.onabort(e);
            this._listeners.forEach((f)=>f(e), this);
        }
    }
    onabort() {}
    addEventListener(ev, fn) {
        if (ev === "abort") {
            this._listeners.push(fn);
        }
    }
    removeEventListener(ev, fn) {
        if (ev === "abort") {
            this._listeners = this._listeners.filter((f)=>f !== fn);
        }
    }
};
const warned = new Set();
const deprecatedOption = (opt, instead)=>{
    const code = `LRU_CACHE_OPTION_${opt}`;
    if (shouldWarn(code)) {
        warn(code, `${opt} option`, `options.${instead}`, LRUCache);
    }
};
const deprecatedMethod = (method, instead)=>{
    const code = `LRU_CACHE_METHOD_${method}`;
    if (shouldWarn(code)) {
        const { prototype  } = LRUCache;
        const { get  } = Object.getOwnPropertyDescriptor(prototype, method);
        warn(code, `${method} method`, `cache.${instead}()`, get);
    }
};
const deprecatedProperty = (field, instead)=>{
    const code = `LRU_CACHE_PROPERTY_${field}`;
    if (shouldWarn(code)) {
        const { prototype  } = LRUCache;
        const { get  } = Object.getOwnPropertyDescriptor(prototype, field);
        warn(code, `${field} property`, `cache.${instead}`, get);
    }
};
const emitWarning = (...a)=>{
    typeof process === "object" && process && typeof process.emitWarning === "function" ? process.emitWarning(...a) : console.error(...a);
};
const shouldWarn = (code)=>!warned.has(code);
const warn = (code, what, instead, fn)=>{
    warned.add(code);
    const msg = `The ${what} is deprecated. Please use ${instead} instead.`;
    emitWarning(msg, "DeprecationWarning", code, fn);
};
const isPosInt = (n)=>n && n === Math.floor(n) && n > 0 && isFinite(n);
/* istanbul ignore next - This is a little bit ridiculous, tbh.
 * The maximum array length is 2^32-1 or thereabouts on most JS impls.
 * And well before that point, you're caching the entire world, I mean,
 * that's ~32GB of just integers for the next/prev links, plus whatever
 * else to hold that many keys and values.  Just filling the memory with
 * zeroes at init time is brutal when you get that big.
 * But why not be complete?
 * Maybe in the future, these limits will have expanded. */ const getUintArray = (max)=>!isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
class ZeroArray extends Array {
    constructor(size){
        super(size);
        this.fill(0);
    }
}
class Stack {
    constructor(max){
        if (max === 0) {
            return [];
        }
        const UintArray = getUintArray(max);
        this.heap = new UintArray(max);
        this.length = 0;
    }
    push(n) {
        this.heap[this.length++] = n;
    }
    pop() {
        return this.heap[--this.length];
    }
}
class LRUCache {
    constructor(options = {}){
        const { max =0 , ttl , ttlResolution =1 , ttlAutopurge , updateAgeOnGet , updateAgeOnHas , allowStale , dispose , disposeAfter , noDisposeOnSet , noUpdateTTL , maxSize =0 , maxEntrySize =0 , sizeCalculation , fetchMethod , fetchContext , noDeleteOnFetchRejection , noDeleteOnStaleGet , allowStaleOnFetchRejection , allowStaleOnFetchAbort , ignoreFetchAbort  } = options;
        // deprecated options, don't trigger a warning for getting them if
        // the thing being passed in is another LRUCache we're copying.
        const { length , maxAge , stale  } = options instanceof LRUCache ? {} : options;
        if (max !== 0 && !isPosInt(max)) {
            throw new TypeError("max option must be a nonnegative integer");
        }
        const UintArray = max ? getUintArray(max) : Array;
        if (!UintArray) {
            throw new Error("invalid max value: " + max);
        }
        this.max = max;
        this.maxSize = maxSize;
        this.maxEntrySize = maxEntrySize || this.maxSize;
        this.sizeCalculation = sizeCalculation || length;
        if (this.sizeCalculation) {
            if (!this.maxSize && !this.maxEntrySize) {
                throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
            }
            if (typeof this.sizeCalculation !== "function") {
                throw new TypeError("sizeCalculation set to non-function");
            }
        }
        this.fetchMethod = fetchMethod || null;
        if (this.fetchMethod && typeof this.fetchMethod !== "function") {
            throw new TypeError("fetchMethod must be a function if specified");
        }
        this.fetchContext = fetchContext;
        if (!this.fetchMethod && fetchContext !== undefined) {
            throw new TypeError("cannot set fetchContext without fetchMethod");
        }
        this.keyMap = new Map();
        this.keyList = new Array(max).fill(null);
        this.valList = new Array(max).fill(null);
        this.next = new UintArray(max);
        this.prev = new UintArray(max);
        this.head = 0;
        this.tail = 0;
        this.free = new Stack(max);
        this.initialFill = 1;
        this.size = 0;
        if (typeof dispose === "function") {
            this.dispose = dispose;
        }
        if (typeof disposeAfter === "function") {
            this.disposeAfter = disposeAfter;
            this.disposed = [];
        } else {
            this.disposeAfter = null;
            this.disposed = null;
        }
        this.noDisposeOnSet = !!noDisposeOnSet;
        this.noUpdateTTL = !!noUpdateTTL;
        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
        this.ignoreFetchAbort = !!ignoreFetchAbort;
        // NB: maxEntrySize is set to maxSize if it's set
        if (this.maxEntrySize !== 0) {
            if (this.maxSize !== 0) {
                if (!isPosInt(this.maxSize)) {
                    throw new TypeError("maxSize must be a positive integer if specified");
                }
            }
            if (!isPosInt(this.maxEntrySize)) {
                throw new TypeError("maxEntrySize must be a positive integer if specified");
            }
            this.initializeSizeTracking();
        }
        this.allowStale = !!allowStale || !!stale;
        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
        this.updateAgeOnGet = !!updateAgeOnGet;
        this.updateAgeOnHas = !!updateAgeOnHas;
        this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
        this.ttlAutopurge = !!ttlAutopurge;
        this.ttl = ttl || maxAge || 0;
        if (this.ttl) {
            if (!isPosInt(this.ttl)) {
                throw new TypeError("ttl must be a positive integer if specified");
            }
            this.initializeTTLTracking();
        }
        // do not allow completely unbounded caches
        if (this.max === 0 && this.ttl === 0 && this.maxSize === 0) {
            throw new TypeError("At least one of max, maxSize, or ttl is required");
        }
        if (!this.ttlAutopurge && !this.max && !this.maxSize) {
            const code = "LRU_CACHE_UNBOUNDED";
            if (shouldWarn(code)) {
                warned.add(code);
                const msg = "TTL caching without ttlAutopurge, max, or maxSize can " + "result in unbounded memory consumption.";
                emitWarning(msg, "UnboundedCacheWarning", code, LRUCache);
            }
        }
        if (stale) {
            deprecatedOption("stale", "allowStale");
        }
        if (maxAge) {
            deprecatedOption("maxAge", "ttl");
        }
        if (length) {
            deprecatedOption("length", "sizeCalculation");
        }
    }
    getRemainingTTL(key) {
        return this.has(key, {
            updateAgeOnHas: false
        }) ? Infinity : 0;
    }
    initializeTTLTracking() {
        this.ttls = new ZeroArray(this.max);
        this.starts = new ZeroArray(this.max);
        this.setItemTTL = (index, ttl, start = perf.now())=>{
            this.starts[index] = ttl !== 0 ? start : 0;
            this.ttls[index] = ttl;
            if (ttl !== 0 && this.ttlAutopurge) {
                const t = setTimeout(()=>{
                    if (this.isStale(index)) {
                        this.delete(this.keyList[index]);
                    }
                }, ttl + 1);
                /* istanbul ignore else - unref() not supported on all platforms */ if (t.unref) {
                    t.unref();
                }
            }
        };
        this.updateItemAge = (index)=>{
            this.starts[index] = this.ttls[index] !== 0 ? perf.now() : 0;
        };
        this.statusTTL = (status, index)=>{
            if (status) {
                status.ttl = this.ttls[index];
                status.start = this.starts[index];
                status.now = cachedNow || getNow();
                status.remainingTTL = status.now + status.ttl - status.start;
            }
        };
        // debounce calls to perf.now() to 1s so we're not hitting
        // that costly call repeatedly.
        let cachedNow = 0;
        const getNow = ()=>{
            const n = perf.now();
            if (this.ttlResolution > 0) {
                cachedNow = n;
                const t = setTimeout(()=>cachedNow = 0, this.ttlResolution);
                /* istanbul ignore else - not available on all platforms */ if (t.unref) {
                    t.unref();
                }
            }
            return n;
        };
        this.getRemainingTTL = (key)=>{
            const index = this.keyMap.get(key);
            if (index === undefined) {
                return 0;
            }
            return this.ttls[index] === 0 || this.starts[index] === 0 ? Infinity : this.starts[index] + this.ttls[index] - (cachedNow || getNow());
        };
        this.isStale = (index)=>{
            return this.ttls[index] !== 0 && this.starts[index] !== 0 && (cachedNow || getNow()) - this.starts[index] > this.ttls[index];
        };
    }
    updateItemAge(_index) {}
    statusTTL(_status, _index) {}
    setItemTTL(_index, _ttl, _start) {}
    isStale(_index) {
        return false;
    }
    initializeSizeTracking() {
        this.calculatedSize = 0;
        this.sizes = new ZeroArray(this.max);
        this.removeItemSize = (index)=>{
            this.calculatedSize -= this.sizes[index];
            this.sizes[index] = 0;
        };
        this.requireSize = (k, v, size, sizeCalculation)=>{
            // provisionally accept background fetches.
            // actual value size will be checked when they return.
            if (this.isBackgroundFetch(v)) {
                return 0;
            }
            if (!isPosInt(size)) {
                if (sizeCalculation) {
                    if (typeof sizeCalculation !== "function") {
                        throw new TypeError("sizeCalculation must be a function");
                    }
                    size = sizeCalculation(v, k);
                    if (!isPosInt(size)) {
                        throw new TypeError("sizeCalculation return invalid (expect positive integer)");
                    }
                } else {
                    throw new TypeError("invalid size value (must be positive integer). " + "When maxSize or maxEntrySize is used, sizeCalculation or size " + "must be set.");
                }
            }
            return size;
        };
        this.addItemSize = (index, size, status)=>{
            this.sizes[index] = size;
            if (this.maxSize) {
                const maxSize = this.maxSize - this.sizes[index];
                while(this.calculatedSize > maxSize){
                    this.evict(true);
                }
            }
            this.calculatedSize += this.sizes[index];
            if (status) {
                status.entrySize = size;
                status.totalCalculatedSize = this.calculatedSize;
            }
        };
    }
    removeItemSize(_index) {}
    addItemSize(_index, _size) {}
    requireSize(_k, _v, size, sizeCalculation) {
        if (size || sizeCalculation) {
            throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
        }
    }
    *indexes({ allowStale =this.allowStale  } = {}) {
        if (this.size) {
            for(let i = this.tail; true;){
                if (!this.isValidIndex(i)) {
                    break;
                }
                if (allowStale || !this.isStale(i)) {
                    yield i;
                }
                if (i === this.head) {
                    break;
                } else {
                    i = this.prev[i];
                }
            }
        }
    }
    *rindexes({ allowStale =this.allowStale  } = {}) {
        if (this.size) {
            for(let i = this.head; true;){
                if (!this.isValidIndex(i)) {
                    break;
                }
                if (allowStale || !this.isStale(i)) {
                    yield i;
                }
                if (i === this.tail) {
                    break;
                } else {
                    i = this.next[i];
                }
            }
        }
    }
    isValidIndex(index) {
        return index !== undefined && this.keyMap.get(this.keyList[index]) === index;
    }
    *entries() {
        for (const i of this.indexes()){
            if (this.valList[i] !== undefined && this.keyList[i] !== undefined && !this.isBackgroundFetch(this.valList[i])) {
                yield [
                    this.keyList[i],
                    this.valList[i]
                ];
            }
        }
    }
    *rentries() {
        for (const i of this.rindexes()){
            if (this.valList[i] !== undefined && this.keyList[i] !== undefined && !this.isBackgroundFetch(this.valList[i])) {
                yield [
                    this.keyList[i],
                    this.valList[i]
                ];
            }
        }
    }
    *keys() {
        for (const i of this.indexes()){
            if (this.keyList[i] !== undefined && !this.isBackgroundFetch(this.valList[i])) {
                yield this.keyList[i];
            }
        }
    }
    *rkeys() {
        for (const i of this.rindexes()){
            if (this.keyList[i] !== undefined && !this.isBackgroundFetch(this.valList[i])) {
                yield this.keyList[i];
            }
        }
    }
    *values() {
        for (const i of this.indexes()){
            if (this.valList[i] !== undefined && !this.isBackgroundFetch(this.valList[i])) {
                yield this.valList[i];
            }
        }
    }
    *rvalues() {
        for (const i of this.rindexes()){
            if (this.valList[i] !== undefined && !this.isBackgroundFetch(this.valList[i])) {
                yield this.valList[i];
            }
        }
    }
    [Symbol.iterator]() {
        return this.entries();
    }
    find(fn, getOptions) {
        for (const i of this.indexes()){
            const v = this.valList[i];
            const value = this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;
            if (value === undefined) continue;
            if (fn(value, this.keyList[i], this)) {
                return this.get(this.keyList[i], getOptions);
            }
        }
    }
    forEach(fn, thisp = this) {
        for (const i of this.indexes()){
            const v = this.valList[i];
            const value = this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;
            if (value === undefined) continue;
            fn.call(thisp, value, this.keyList[i], this);
        }
    }
    rforEach(fn, thisp = this) {
        for (const i of this.rindexes()){
            const v = this.valList[i];
            const value = this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;
            if (value === undefined) continue;
            fn.call(thisp, value, this.keyList[i], this);
        }
    }
    get prune() {
        deprecatedMethod("prune", "purgeStale");
        return this.purgeStale;
    }
    purgeStale() {
        let deleted = false;
        for (const i of this.rindexes({
            allowStale: true
        })){
            if (this.isStale(i)) {
                this.delete(this.keyList[i]);
                deleted = true;
            }
        }
        return deleted;
    }
    dump() {
        const arr = [];
        for (const i of this.indexes({
            allowStale: true
        })){
            const key = this.keyList[i];
            const v = this.valList[i];
            const value = this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;
            if (value === undefined) continue;
            const entry = {
                value
            };
            if (this.ttls) {
                entry.ttl = this.ttls[i];
                // always dump the start relative to a portable timestamp
                // it's ok for this to be a bit slow, it's a rare operation.
                const age = perf.now() - this.starts[i];
                entry.start = Math.floor(Date.now() - age);
            }
            if (this.sizes) {
                entry.size = this.sizes[i];
            }
            arr.unshift([
                key,
                entry
            ]);
        }
        return arr;
    }
    load(arr) {
        this.clear();
        for (const [key, entry] of arr){
            if (entry.start) {
                // entry.start is a portable timestamp, but we may be using
                // node's performance.now(), so calculate the offset.
                // it's ok for this to be a bit slow, it's a rare operation.
                const age = Date.now() - entry.start;
                entry.start = perf.now() - age;
            }
            this.set(key, entry.value, entry);
        }
    }
    dispose(_v, _k, _reason) {}
    set(k, v, { ttl =this.ttl , start , noDisposeOnSet =this.noDisposeOnSet , size =0 , sizeCalculation =this.sizeCalculation , noUpdateTTL =this.noUpdateTTL , status  } = {}) {
        size = this.requireSize(k, v, size, sizeCalculation);
        // if the item doesn't fit, don't do anything
        // NB: maxEntrySize set to maxSize by default
        if (this.maxEntrySize && size > this.maxEntrySize) {
            if (status) {
                status.set = "miss";
                status.maxEntrySizeExceeded = true;
            }
            // have to delete, in case a background fetch is there already.
            // in non-async cases, this is a no-op
            this.delete(k);
            return this;
        }
        let index = this.size === 0 ? undefined : this.keyMap.get(k);
        if (index === undefined) {
            // addition
            index = this.newIndex();
            this.keyList[index] = k;
            this.valList[index] = v;
            this.keyMap.set(k, index);
            this.next[this.tail] = index;
            this.prev[index] = this.tail;
            this.tail = index;
            this.size++;
            this.addItemSize(index, size, status);
            if (status) {
                status.set = "add";
            }
            noUpdateTTL = false;
        } else {
            // update
            this.moveToTail(index);
            const oldVal = this.valList[index];
            if (v !== oldVal) {
                if (this.isBackgroundFetch(oldVal)) {
                    oldVal.__abortController.abort(new Error("replaced"));
                } else {
                    if (!noDisposeOnSet) {
                        this.dispose(oldVal, k, "set");
                        if (this.disposeAfter) {
                            this.disposed.push([
                                oldVal,
                                k,
                                "set"
                            ]);
                        }
                    }
                }
                this.removeItemSize(index);
                this.valList[index] = v;
                this.addItemSize(index, size, status);
                if (status) {
                    status.set = "replace";
                    const oldValue = oldVal && this.isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
                    if (oldValue !== undefined) status.oldValue = oldValue;
                }
            } else if (status) {
                status.set = "update";
            }
        }
        if (ttl !== 0 && this.ttl === 0 && !this.ttls) {
            this.initializeTTLTracking();
        }
        if (!noUpdateTTL) {
            this.setItemTTL(index, ttl, start);
        }
        this.statusTTL(status, index);
        if (this.disposeAfter) {
            while(this.disposed.length){
                this.disposeAfter(...this.disposed.shift());
            }
        }
        return this;
    }
    newIndex() {
        if (this.size === 0) {
            return this.tail;
        }
        if (this.size === this.max && this.max !== 0) {
            return this.evict(false);
        }
        if (this.free.length !== 0) {
            return this.free.pop();
        }
        // initial fill, just keep writing down the list
        return this.initialFill++;
    }
    pop() {
        if (this.size) {
            const val = this.valList[this.head];
            this.evict(true);
            return val;
        }
    }
    evict(free) {
        const head = this.head;
        const k = this.keyList[head];
        const v = this.valList[head];
        if (this.isBackgroundFetch(v)) {
            v.__abortController.abort(new Error("evicted"));
        } else {
            this.dispose(v, k, "evict");
            if (this.disposeAfter) {
                this.disposed.push([
                    v,
                    k,
                    "evict"
                ]);
            }
        }
        this.removeItemSize(head);
        // if we aren't about to use the index, then null these out
        if (free) {
            this.keyList[head] = null;
            this.valList[head] = null;
            this.free.push(head);
        }
        this.head = this.next[head];
        this.keyMap.delete(k);
        this.size--;
        return head;
    }
    has(k, { updateAgeOnHas =this.updateAgeOnHas , status  } = {}) {
        const index = this.keyMap.get(k);
        if (index !== undefined) {
            if (!this.isStale(index)) {
                if (updateAgeOnHas) {
                    this.updateItemAge(index);
                }
                if (status) status.has = "hit";
                this.statusTTL(status, index);
                return true;
            } else if (status) {
                status.has = "stale";
                this.statusTTL(status, index);
            }
        } else if (status) {
            status.has = "miss";
        }
        return false;
    }
    // like get(), but without any LRU updating or TTL expiration
    peek(k, { allowStale =this.allowStale  } = {}) {
        const index = this.keyMap.get(k);
        if (index !== undefined && (allowStale || !this.isStale(index))) {
            const v = this.valList[index];
            // either stale and allowed, or forcing a refresh of non-stale value
            return this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        }
    }
    backgroundFetch(k, index, options, context) {
        const v = index === undefined ? undefined : this.valList[index];
        if (this.isBackgroundFetch(v)) {
            return v;
        }
        const ac = new AC();
        if (options.signal) {
            options.signal.addEventListener("abort", ()=>ac.abort(options.signal.reason));
        }
        const fetchOpts = {
            signal: ac.signal,
            options,
            context
        };
        const cb = (v, updateCache = false)=>{
            const { aborted  } = ac.signal;
            const ignoreAbort = options.ignoreFetchAbort && v !== undefined;
            if (options.status) {
                if (aborted && !updateCache) {
                    options.status.fetchAborted = true;
                    options.status.fetchError = ac.signal.reason;
                    if (ignoreAbort) options.status.fetchAbortIgnored = true;
                } else {
                    options.status.fetchResolved = true;
                }
            }
            if (aborted && !ignoreAbort && !updateCache) {
                return fetchFail(ac.signal.reason);
            }
            // either we didn't abort, and are still here, or we did, and ignored
            if (this.valList[index] === p) {
                if (v === undefined) {
                    if (p.__staleWhileFetching) {
                        this.valList[index] = p.__staleWhileFetching;
                    } else {
                        this.delete(k);
                    }
                } else {
                    if (options.status) options.status.fetchUpdated = true;
                    this.set(k, v, fetchOpts.options);
                }
            }
            return v;
        };
        const eb = (er)=>{
            if (options.status) {
                options.status.fetchRejected = true;
                options.status.fetchError = er;
            }
            return fetchFail(er);
        };
        const fetchFail = (er)=>{
            const { aborted  } = ac.signal;
            const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
            const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
            const noDelete = allowStale || options.noDeleteOnFetchRejection;
            if (this.valList[index] === p) {
                // if we allow stale on fetch rejections, then we need to ensure that
                // the stale value is not removed from the cache when the fetch fails.
                const del = !noDelete || p.__staleWhileFetching === undefined;
                if (del) {
                    this.delete(k);
                } else if (!allowStaleAborted) {
                    // still replace the *promise* with the stale value,
                    // since we are done with the promise at this point.
                    // leave it untouched if we're still waiting for an
                    // aborted background fetch that hasn't yet returned.
                    this.valList[index] = p.__staleWhileFetching;
                }
            }
            if (allowStale) {
                if (options.status && p.__staleWhileFetching !== undefined) {
                    options.status.returnedStale = true;
                }
                return p.__staleWhileFetching;
            } else if (p.__returned === p) {
                throw er;
            }
        };
        const pcall = (res, rej)=>{
            this.fetchMethod(k, v, fetchOpts).then((v)=>res(v), rej);
            // ignored, we go until we finish, regardless.
            // defer check until we are actually aborting,
            // so fetchMethod can override.
            ac.signal.addEventListener("abort", ()=>{
                if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
                    res();
                    // when it eventually resolves, update the cache.
                    if (options.allowStaleOnFetchAbort) {
                        res = (v)=>cb(v, true);
                    }
                }
            });
        };
        if (options.status) options.status.fetchDispatched = true;
        const p = new Promise(pcall).then(cb, eb);
        p.__abortController = ac;
        p.__staleWhileFetching = v;
        p.__returned = null;
        if (index === undefined) {
            // internal, don't expose status.
            this.set(k, p, {
                ...fetchOpts.options,
                status: undefined
            });
            index = this.keyMap.get(k);
        } else {
            this.valList[index] = p;
        }
        return p;
    }
    isBackgroundFetch(p) {
        return p && typeof p === "object" && typeof p.then === "function" && Object.prototype.hasOwnProperty.call(p, "__staleWhileFetching") && Object.prototype.hasOwnProperty.call(p, "__returned") && (p.__returned === p || p.__returned === null);
    }
    // this takes the union of get() and set() opts, because it does both
    async fetch(k, { // get options
    allowStale =this.allowStale , updateAgeOnGet =this.updateAgeOnGet , noDeleteOnStaleGet =this.noDeleteOnStaleGet , // set options
    ttl =this.ttl , noDisposeOnSet =this.noDisposeOnSet , size =0 , sizeCalculation =this.sizeCalculation , noUpdateTTL =this.noUpdateTTL , // fetch exclusive options
    noDeleteOnFetchRejection =this.noDeleteOnFetchRejection , allowStaleOnFetchRejection =this.allowStaleOnFetchRejection , ignoreFetchAbort =this.ignoreFetchAbort , allowStaleOnFetchAbort =this.allowStaleOnFetchAbort , fetchContext =this.fetchContext , forceRefresh =false , status , signal  } = {}) {
        if (!this.fetchMethod) {
            if (status) status.fetch = "get";
            return this.get(k, {
                allowStale,
                updateAgeOnGet,
                noDeleteOnStaleGet,
                status
            });
        }
        const options = {
            allowStale,
            updateAgeOnGet,
            noDeleteOnStaleGet,
            ttl,
            noDisposeOnSet,
            size,
            sizeCalculation,
            noUpdateTTL,
            noDeleteOnFetchRejection,
            allowStaleOnFetchRejection,
            allowStaleOnFetchAbort,
            ignoreFetchAbort,
            status,
            signal
        };
        let index = this.keyMap.get(k);
        if (index === undefined) {
            if (status) status.fetch = "miss";
            const p = this.backgroundFetch(k, index, options, fetchContext);
            return p.__returned = p;
        } else {
            // in cache, maybe already fetching
            const v = this.valList[index];
            if (this.isBackgroundFetch(v)) {
                const stale = allowStale && v.__staleWhileFetching !== undefined;
                if (status) {
                    status.fetch = "inflight";
                    if (stale) status.returnedStale = true;
                }
                return stale ? v.__staleWhileFetching : v.__returned = v;
            }
            // if we force a refresh, that means do NOT serve the cached value,
            // unless we are already in the process of refreshing the cache.
            const isStale = this.isStale(index);
            if (!forceRefresh && !isStale) {
                if (status) status.fetch = "hit";
                this.moveToTail(index);
                if (updateAgeOnGet) {
                    this.updateItemAge(index);
                }
                this.statusTTL(status, index);
                return v;
            }
            // ok, it is stale or a forced refresh, and not already fetching.
            // refresh the cache.
            const p = this.backgroundFetch(k, index, options, fetchContext);
            const hasStale = p.__staleWhileFetching !== undefined;
            const staleVal = hasStale && allowStale;
            if (status) {
                status.fetch = hasStale && isStale ? "stale" : "refresh";
                if (staleVal && isStale) status.returnedStale = true;
            }
            return staleVal ? p.__staleWhileFetching : p.__returned = p;
        }
    }
    get(k, { allowStale =this.allowStale , updateAgeOnGet =this.updateAgeOnGet , noDeleteOnStaleGet =this.noDeleteOnStaleGet , status  } = {}) {
        const index = this.keyMap.get(k);
        if (index !== undefined) {
            const value = this.valList[index];
            const fetching = this.isBackgroundFetch(value);
            this.statusTTL(status, index);
            if (this.isStale(index)) {
                if (status) status.get = "stale";
                // delete only if not an in-flight background fetch
                if (!fetching) {
                    if (!noDeleteOnStaleGet) {
                        this.delete(k);
                    }
                    if (status) status.returnedStale = allowStale;
                    return allowStale ? value : undefined;
                } else {
                    if (status) {
                        status.returnedStale = allowStale && value.__staleWhileFetching !== undefined;
                    }
                    return allowStale ? value.__staleWhileFetching : undefined;
                }
            } else {
                if (status) status.get = "hit";
                // if we're currently fetching it, we don't actually have it yet
                // it's not stale, which means this isn't a staleWhileRefetching.
                // If it's not stale, and fetching, AND has a __staleWhileFetching
                // value, then that means the user fetched with {forceRefresh:true},
                // so it's safe to return that value.
                if (fetching) {
                    return value.__staleWhileFetching;
                }
                this.moveToTail(index);
                if (updateAgeOnGet) {
                    this.updateItemAge(index);
                }
                return value;
            }
        } else if (status) {
            status.get = "miss";
        }
    }
    connect(p, n) {
        this.prev[n] = p;
        this.next[p] = n;
    }
    moveToTail(index) {
        // if tail already, nothing to do
        // if head, move head to next[index]
        // else
        //   move next[prev[index]] to next[index] (head has no prev)
        //   move prev[next[index]] to prev[index]
        // prev[index] = tail
        // next[tail] = index
        // tail = index
        if (index !== this.tail) {
            if (index === this.head) {
                this.head = this.next[index];
            } else {
                this.connect(this.prev[index], this.next[index]);
            }
            this.connect(this.tail, index);
            this.tail = index;
        }
    }
    get del() {
        deprecatedMethod("del", "delete");
        return this.delete;
    }
    delete(k) {
        let deleted = false;
        if (this.size !== 0) {
            const index = this.keyMap.get(k);
            if (index !== undefined) {
                deleted = true;
                if (this.size === 1) {
                    this.clear();
                } else {
                    this.removeItemSize(index);
                    const v = this.valList[index];
                    if (this.isBackgroundFetch(v)) {
                        v.__abortController.abort(new Error("deleted"));
                    } else {
                        this.dispose(v, k, "delete");
                        if (this.disposeAfter) {
                            this.disposed.push([
                                v,
                                k,
                                "delete"
                            ]);
                        }
                    }
                    this.keyMap.delete(k);
                    this.keyList[index] = null;
                    this.valList[index] = null;
                    if (index === this.tail) {
                        this.tail = this.prev[index];
                    } else if (index === this.head) {
                        this.head = this.next[index];
                    } else {
                        this.next[this.prev[index]] = this.next[index];
                        this.prev[this.next[index]] = this.prev[index];
                    }
                    this.size--;
                    this.free.push(index);
                }
            }
        }
        if (this.disposed) {
            while(this.disposed.length){
                this.disposeAfter(...this.disposed.shift());
            }
        }
        return deleted;
    }
    clear() {
        for (const index of this.rindexes({
            allowStale: true
        })){
            const v = this.valList[index];
            if (this.isBackgroundFetch(v)) {
                v.__abortController.abort(new Error("deleted"));
            } else {
                const k = this.keyList[index];
                this.dispose(v, k, "delete");
                if (this.disposeAfter) {
                    this.disposed.push([
                        v,
                        k,
                        "delete"
                    ]);
                }
            }
        }
        this.keyMap.clear();
        this.valList.fill(null);
        this.keyList.fill(null);
        if (this.ttls) {
            this.ttls.fill(0);
            this.starts.fill(0);
        }
        if (this.sizes) {
            this.sizes.fill(0);
        }
        this.head = 0;
        this.tail = 0;
        this.initialFill = 1;
        this.free.length = 0;
        this.calculatedSize = 0;
        this.size = 0;
        if (this.disposed) {
            while(this.disposed.length){
                this.disposeAfter(...this.disposed.shift());
            }
        }
    }
    get reset() {
        deprecatedMethod("reset", "clear");
        return this.clear;
    }
    get length() {
        deprecatedProperty("length", "size");
        return this.size;
    }
    static get AbortController() {
        return AC;
    }
    static get AbortSignal() {
        return AS;
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LRUCache);


/***/ }),

/***/ 2956:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "URLPattern": () => (/* reexport */ URLPattern)
});

;// CONCATENATED MODULE: ../../node_modules/urlpattern-polyfill/dist/urlpattern.js
// src/path-to-regex-modified.ts
var regexIdentifierStart = /[$_\p{ID_Start}]/u;
var regexIdentifierPart = /[$_\u200C\u200D\p{ID_Continue}]/u;
function isASCII(str, extended) {
    return (extended ? /^[\x00-\xFF]*$/ : /^[\x00-\x7F]*$/).test(str);
}
function lexer(str, lenient = false) {
    const tokens = [];
    let i = 0;
    while(i < str.length){
        const char = str[i];
        const ErrorOrInvalid = function(msg) {
            if (!lenient) throw new TypeError(msg);
            tokens.push({
                type: "INVALID_CHAR",
                index: i,
                value: str[i++]
            });
        };
        if (char === "*") {
            tokens.push({
                type: "ASTERISK",
                index: i,
                value: str[i++]
            });
            continue;
        }
        if (char === "+" || char === "?") {
            tokens.push({
                type: "MODIFIER",
                index: i,
                value: str[i++]
            });
            continue;
        }
        if (char === "\\") {
            tokens.push({
                type: "ESCAPED_CHAR",
                index: i++,
                value: str[i++]
            });
            continue;
        }
        if (char === "{") {
            tokens.push({
                type: "OPEN",
                index: i,
                value: str[i++]
            });
            continue;
        }
        if (char === "}") {
            tokens.push({
                type: "CLOSE",
                index: i,
                value: str[i++]
            });
            continue;
        }
        if (char === ":") {
            let name = "";
            let j = i + 1;
            while(j < str.length){
                const code = str.substr(j, 1);
                if (j === i + 1 && regexIdentifierStart.test(code) || j !== i + 1 && regexIdentifierPart.test(code)) {
                    name += str[j++];
                    continue;
                }
                break;
            }
            if (!name) {
                ErrorOrInvalid(`Missing parameter name at ${i}`);
                continue;
            }
            tokens.push({
                type: "NAME",
                index: i,
                value: name
            });
            i = j;
            continue;
        }
        if (char === "(") {
            let count = 1;
            let pattern = "";
            let j = i + 1;
            let error = false;
            if (str[j] === "?") {
                ErrorOrInvalid(`Pattern cannot start with "?" at ${j}`);
                continue;
            }
            while(j < str.length){
                if (!isASCII(str[j], false)) {
                    ErrorOrInvalid(`Invalid character '${str[j]}' at ${j}.`);
                    error = true;
                    break;
                }
                if (str[j] === "\\") {
                    pattern += str[j++] + str[j++];
                    continue;
                }
                if (str[j] === ")") {
                    count--;
                    if (count === 0) {
                        j++;
                        break;
                    }
                } else if (str[j] === "(") {
                    count++;
                    if (str[j + 1] !== "?") {
                        ErrorOrInvalid(`Capturing groups are not allowed at ${j}`);
                        error = true;
                        break;
                    }
                }
                pattern += str[j++];
            }
            if (error) {
                continue;
            }
            if (count) {
                ErrorOrInvalid(`Unbalanced pattern at ${i}`);
                continue;
            }
            if (!pattern) {
                ErrorOrInvalid(`Missing pattern at ${i}`);
                continue;
            }
            tokens.push({
                type: "PATTERN",
                index: i,
                value: pattern
            });
            i = j;
            continue;
        }
        tokens.push({
            type: "CHAR",
            index: i,
            value: str[i++]
        });
    }
    tokens.push({
        type: "END",
        index: i,
        value: ""
    });
    return tokens;
}
function parse(str, options = {}) {
    const tokens = lexer(str);
    const { prefixes ="./"  } = options;
    const defaultPattern = `[^${escapeString(options.delimiter === void 0 ? "/#?" : options.delimiter)}]+?`;
    const result = [];
    let key = 0;
    let i = 0;
    let path = "";
    let nameSet = /* @__PURE__ */ new Set();
    const tryConsume = (type)=>{
        if (i < tokens.length && tokens[i].type === type) return tokens[i++].value;
    };
    const tryConsumeModifier = ()=>{
        const r = tryConsume("MODIFIER");
        if (r) {
            return r;
        }
        return tryConsume("ASTERISK");
    };
    const mustConsume = (type)=>{
        const value = tryConsume(type);
        if (value !== void 0) return value;
        const { type: nextType , index  } = tokens[i];
        throw new TypeError(`Unexpected ${nextType} at ${index}, expected ${type}`);
    };
    const consumeText = ()=>{
        let result2 = "";
        let value;
        while(value = tryConsume("CHAR") || tryConsume("ESCAPED_CHAR")){
            result2 += value;
        }
        return result2;
    };
    const DefaultEncodePart = (value)=>{
        return value;
    };
    const encodePart = options.encodePart || DefaultEncodePart;
    while(i < tokens.length){
        const char = tryConsume("CHAR");
        const name = tryConsume("NAME");
        let pattern = tryConsume("PATTERN");
        if (!name && !pattern && tryConsume("ASTERISK")) {
            pattern = ".*";
        }
        if (name || pattern) {
            let prefix = char || "";
            if (prefixes.indexOf(prefix) === -1) {
                path += prefix;
                prefix = "";
            }
            if (path) {
                result.push(encodePart(path));
                path = "";
            }
            const finalName = name || key++;
            if (nameSet.has(finalName)) {
                throw new TypeError(`Duplicate name '${finalName}'.`);
            }
            nameSet.add(finalName);
            result.push({
                name: finalName,
                prefix: encodePart(prefix),
                suffix: "",
                pattern: pattern || defaultPattern,
                modifier: tryConsumeModifier() || ""
            });
            continue;
        }
        const value = char || tryConsume("ESCAPED_CHAR");
        if (value) {
            path += value;
            continue;
        }
        const open = tryConsume("OPEN");
        if (open) {
            const prefix = consumeText();
            const name2 = tryConsume("NAME") || "";
            let pattern2 = tryConsume("PATTERN") || "";
            if (!name2 && !pattern2 && tryConsume("ASTERISK")) {
                pattern2 = ".*";
            }
            const suffix = consumeText();
            mustConsume("CLOSE");
            const modifier = tryConsumeModifier() || "";
            if (!name2 && !pattern2 && !modifier) {
                path += prefix;
                continue;
            }
            if (!name2 && !pattern2 && !prefix) {
                continue;
            }
            if (path) {
                result.push(encodePart(path));
                path = "";
            }
            result.push({
                name: name2 || (pattern2 ? key++ : ""),
                pattern: name2 && !pattern2 ? defaultPattern : pattern2,
                prefix: encodePart(prefix),
                suffix: encodePart(suffix),
                modifier
            });
            continue;
        }
        if (path) {
            result.push(encodePart(path));
            path = "";
        }
        mustConsume("END");
    }
    return result;
}
function escapeString(str) {
    return str.replace(/([.+*?^${}()[\]|/\\])/g, "\\$1");
}
function flags(options) {
    return options && options.ignoreCase ? "ui" : "u";
}
function regexpToRegexp(path, keys) {
    if (!keys) return path;
    const groupsRegex = /\((?:\?<(.*?)>)?(?!\?)/g;
    let index = 0;
    let execResult = groupsRegex.exec(path.source);
    while(execResult){
        keys.push({
            name: execResult[1] || index++,
            prefix: "",
            suffix: "",
            modifier: "",
            pattern: ""
        });
        execResult = groupsRegex.exec(path.source);
    }
    return path;
}
function arrayToRegexp(paths, keys, options) {
    const parts = paths.map((path)=>pathToRegexp(path, keys, options).source);
    return new RegExp(`(?:${parts.join("|")})`, flags(options));
}
function stringToRegexp(path, keys, options) {
    return tokensToRegexp(parse(path, options), keys, options);
}
function tokensToRegexp(tokens, keys, options = {}) {
    const { strict =false , start =true , end =true , encode =(x)=>x  } = options;
    const endsWith = `[${escapeString(options.endsWith === void 0 ? "" : options.endsWith)}]|$`;
    const delimiter = `[${escapeString(options.delimiter === void 0 ? "/#?" : options.delimiter)}]`;
    let route = start ? "^" : "";
    for (const token of tokens){
        if (typeof token === "string") {
            route += escapeString(encode(token));
        } else {
            const prefix = escapeString(encode(token.prefix));
            const suffix = escapeString(encode(token.suffix));
            if (token.pattern) {
                if (keys) keys.push(token);
                if (prefix || suffix) {
                    if (token.modifier === "+" || token.modifier === "*") {
                        const mod = token.modifier === "*" ? "?" : "";
                        route += `(?:${prefix}((?:${token.pattern})(?:${suffix}${prefix}(?:${token.pattern}))*)${suffix})${mod}`;
                    } else {
                        route += `(?:${prefix}(${token.pattern})${suffix})${token.modifier}`;
                    }
                } else {
                    if (token.modifier === "+" || token.modifier === "*") {
                        route += `((?:${token.pattern})${token.modifier})`;
                    } else {
                        route += `(${token.pattern})${token.modifier}`;
                    }
                }
            } else {
                route += `(?:${prefix}${suffix})${token.modifier}`;
            }
        }
    }
    if (end) {
        if (!strict) route += `${delimiter}?`;
        route += !options.endsWith ? "$" : `(?=${endsWith})`;
    } else {
        const endToken = tokens[tokens.length - 1];
        const isEndDelimited = typeof endToken === "string" ? delimiter.indexOf(endToken[endToken.length - 1]) > -1 : endToken === void 0;
        if (!strict) {
            route += `(?:${delimiter}(?=${endsWith}))?`;
        }
        if (!isEndDelimited) {
            route += `(?=${delimiter}|${endsWith})`;
        }
    }
    return new RegExp(route, flags(options));
}
function pathToRegexp(path, keys, options) {
    if (path instanceof RegExp) return regexpToRegexp(path, keys);
    if (Array.isArray(path)) return arrayToRegexp(path, keys, options);
    return stringToRegexp(path, keys, options);
}
// src/url-utils.ts
var DEFAULT_OPTIONS = {
    delimiter: "",
    prefixes: "",
    sensitive: true,
    strict: true
};
var HOSTNAME_OPTIONS = {
    delimiter: ".",
    prefixes: "",
    sensitive: true,
    strict: true
};
var PATHNAME_OPTIONS = {
    delimiter: "/",
    prefixes: "/",
    sensitive: true,
    strict: true
};
function isAbsolutePathname(pathname, isPattern) {
    if (!pathname.length) {
        return false;
    }
    if (pathname[0] === "/") {
        return true;
    }
    if (!isPattern) {
        return false;
    }
    if (pathname.length < 2) {
        return false;
    }
    if ((pathname[0] == "\\" || pathname[0] == "{") && pathname[1] == "/") {
        return true;
    }
    return false;
}
function maybeStripPrefix(value, prefix) {
    if (value.startsWith(prefix)) {
        return value.substring(prefix.length, value.length);
    }
    return value;
}
function maybeStripSuffix(value, suffix) {
    if (value.endsWith(suffix)) {
        return value.substr(0, value.length - suffix.length);
    }
    return value;
}
function treatAsIPv6Hostname(value) {
    if (!value || value.length < 2) {
        return false;
    }
    if (value[0] === "[") {
        return true;
    }
    if ((value[0] === "\\" || value[0] === "{") && value[1] === "[") {
        return true;
    }
    return false;
}
var SPECIAL_SCHEMES = [
    "ftp",
    "file",
    "http",
    "https",
    "ws",
    "wss"
];
function isSpecialScheme(protocol_regexp) {
    if (!protocol_regexp) {
        return true;
    }
    for (const scheme of SPECIAL_SCHEMES){
        if (protocol_regexp.test(scheme)) {
            return true;
        }
    }
    return false;
}
function canonicalizeHash(hash, isPattern) {
    hash = maybeStripPrefix(hash, "#");
    if (isPattern || hash === "") {
        return hash;
    }
    const url = new URL("https://example.com");
    url.hash = hash;
    return url.hash ? url.hash.substring(1, url.hash.length) : "";
}
function canonicalizeSearch(search, isPattern) {
    search = maybeStripPrefix(search, "?");
    if (isPattern || search === "") {
        return search;
    }
    const url = new URL("https://example.com");
    url.search = search;
    return url.search ? url.search.substring(1, url.search.length) : "";
}
function canonicalizeHostname(hostname, isPattern) {
    if (isPattern || hostname === "") {
        return hostname;
    }
    if (treatAsIPv6Hostname(hostname)) {
        return ipv6HostnameEncodeCallback(hostname);
    } else {
        return hostnameEncodeCallback(hostname);
    }
}
function canonicalizePassword(password, isPattern) {
    if (isPattern || password === "") {
        return password;
    }
    const url = new URL("https://example.com");
    url.password = password;
    return url.password;
}
function canonicalizeUsername(username, isPattern) {
    if (isPattern || username === "") {
        return username;
    }
    const url = new URL("https://example.com");
    url.username = username;
    return url.username;
}
function canonicalizePathname(pathname, protocol, isPattern) {
    if (isPattern || pathname === "") {
        return pathname;
    }
    if (protocol && !SPECIAL_SCHEMES.includes(protocol)) {
        const url = new URL(`${protocol}:${pathname}`);
        return url.pathname;
    }
    const leadingSlash = pathname[0] == "/";
    pathname = new URL(!leadingSlash ? "/-" + pathname : pathname, "https://example.com").pathname;
    if (!leadingSlash) {
        pathname = pathname.substring(2, pathname.length);
    }
    return pathname;
}
function canonicalizePort(port, protocol, isPattern) {
    if (defaultPortForProtocol(protocol) === port) {
        port = "";
    }
    if (isPattern || port === "") {
        return port;
    }
    return portEncodeCallback(port);
}
function canonicalizeProtocol(protocol, isPattern) {
    protocol = maybeStripSuffix(protocol, ":");
    if (isPattern || protocol === "") {
        return protocol;
    }
    return protocolEncodeCallback(protocol);
}
function defaultPortForProtocol(protocol) {
    switch(protocol){
        case "ws":
        case "http":
            return "80";
        case "wws":
        case "https":
            return "443";
        case "ftp":
            return "21";
        default:
            return "";
    }
}
function protocolEncodeCallback(input) {
    if (input === "") {
        return input;
    }
    if (/^[-+.A-Za-z0-9]*$/.test(input)) return input.toLowerCase();
    throw new TypeError(`Invalid protocol '${input}'.`);
}
function usernameEncodeCallback(input) {
    if (input === "") {
        return input;
    }
    const url = new URL("https://example.com");
    url.username = input;
    return url.username;
}
function passwordEncodeCallback(input) {
    if (input === "") {
        return input;
    }
    const url = new URL("https://example.com");
    url.password = input;
    return url.password;
}
function hostnameEncodeCallback(input) {
    if (input === "") {
        return input;
    }
    if (/[\t\n\r #%/:<>?@[\]^\\|]/g.test(input)) {
        throw new TypeError(`Invalid hostname '${input}'`);
    }
    const url = new URL("https://example.com");
    url.hostname = input;
    return url.hostname;
}
function ipv6HostnameEncodeCallback(input) {
    if (input === "") {
        return input;
    }
    if (/[^0-9a-fA-F[\]:]/g.test(input)) {
        throw new TypeError(`Invalid IPv6 hostname '${input}'`);
    }
    return input.toLowerCase();
}
function portEncodeCallback(input) {
    if (input === "") {
        return input;
    }
    if (/^[0-9]*$/.test(input) && parseInt(input) <= 65535) {
        return input;
    }
    throw new TypeError(`Invalid port '${input}'.`);
}
function standardURLPathnameEncodeCallback(input) {
    if (input === "") {
        return input;
    }
    const url = new URL("https://example.com");
    url.pathname = input[0] !== "/" ? "/-" + input : input;
    if (input[0] !== "/") {
        return url.pathname.substring(2, url.pathname.length);
    }
    return url.pathname;
}
function pathURLPathnameEncodeCallback(input) {
    if (input === "") {
        return input;
    }
    const url = new URL(`data:${input}`);
    return url.pathname;
}
function searchEncodeCallback(input) {
    if (input === "") {
        return input;
    }
    const url = new URL("https://example.com");
    url.search = input;
    return url.search.substring(1, url.search.length);
}
function hashEncodeCallback(input) {
    if (input === "") {
        return input;
    }
    const url = new URL("https://example.com");
    url.hash = input;
    return url.hash.substring(1, url.hash.length);
}
// src/url-pattern-parser.ts
var Parser = class {
    constructor(input){
        this.tokenList = [];
        this.internalResult = {};
        this.tokenIndex = 0;
        this.tokenIncrement = 1;
        this.componentStart = 0;
        this.state = 0 /* INIT */ ;
        this.groupDepth = 0;
        this.hostnameIPv6BracketDepth = 0;
        this.shouldTreatAsStandardURL = false;
        this.input = input;
    }
    get result() {
        return this.internalResult;
    }
    parse() {
        this.tokenList = lexer(this.input, true);
        for(; this.tokenIndex < this.tokenList.length; this.tokenIndex += this.tokenIncrement){
            this.tokenIncrement = 1;
            if (this.tokenList[this.tokenIndex].type === "END") {
                if (this.state === 0 /* INIT */ ) {
                    this.rewind();
                    if (this.isHashPrefix()) {
                        this.changeState(9 /* HASH */ , 1);
                    } else if (this.isSearchPrefix()) {
                        this.changeState(8 /* SEARCH */ , 1);
                        this.internalResult.hash = "";
                    } else {
                        this.changeState(7 /* PATHNAME */ , 0);
                        this.internalResult.search = "";
                        this.internalResult.hash = "";
                    }
                    continue;
                } else if (this.state === 2 /* AUTHORITY */ ) {
                    this.rewindAndSetState(5 /* HOSTNAME */ );
                    continue;
                }
                this.changeState(10 /* DONE */ , 0);
                break;
            }
            if (this.groupDepth > 0) {
                if (this.isGroupClose()) {
                    this.groupDepth -= 1;
                } else {
                    continue;
                }
            }
            if (this.isGroupOpen()) {
                this.groupDepth += 1;
                continue;
            }
            switch(this.state){
                case 0 /* INIT */ :
                    if (this.isProtocolSuffix()) {
                        this.internalResult.username = "";
                        this.internalResult.password = "";
                        this.internalResult.hostname = "";
                        this.internalResult.port = "";
                        this.internalResult.pathname = "";
                        this.internalResult.search = "";
                        this.internalResult.hash = "";
                        this.rewindAndSetState(1 /* PROTOCOL */ );
                    }
                    break;
                case 1 /* PROTOCOL */ :
                    if (this.isProtocolSuffix()) {
                        this.computeShouldTreatAsStandardURL();
                        let nextState = 7 /* PATHNAME */ ;
                        let skip = 1;
                        if (this.shouldTreatAsStandardURL) {
                            this.internalResult.pathname = "/";
                        }
                        if (this.nextIsAuthoritySlashes()) {
                            nextState = 2 /* AUTHORITY */ ;
                            skip = 3;
                        } else if (this.shouldTreatAsStandardURL) {
                            nextState = 2 /* AUTHORITY */ ;
                        }
                        this.changeState(nextState, skip);
                    }
                    break;
                case 2 /* AUTHORITY */ :
                    if (this.isIdentityTerminator()) {
                        this.rewindAndSetState(3 /* USERNAME */ );
                    } else if (this.isPathnameStart() || this.isSearchPrefix() || this.isHashPrefix()) {
                        this.rewindAndSetState(5 /* HOSTNAME */ );
                    }
                    break;
                case 3 /* USERNAME */ :
                    if (this.isPasswordPrefix()) {
                        this.changeState(4 /* PASSWORD */ , 1);
                    } else if (this.isIdentityTerminator()) {
                        this.changeState(5 /* HOSTNAME */ , 1);
                    }
                    break;
                case 4 /* PASSWORD */ :
                    if (this.isIdentityTerminator()) {
                        this.changeState(5 /* HOSTNAME */ , 1);
                    }
                    break;
                case 5 /* HOSTNAME */ :
                    if (this.isIPv6Open()) {
                        this.hostnameIPv6BracketDepth += 1;
                    } else if (this.isIPv6Close()) {
                        this.hostnameIPv6BracketDepth -= 1;
                    }
                    if (this.isPortPrefix() && !this.hostnameIPv6BracketDepth) {
                        this.changeState(6 /* PORT */ , 1);
                    } else if (this.isPathnameStart()) {
                        this.changeState(7 /* PATHNAME */ , 0);
                    } else if (this.isSearchPrefix()) {
                        this.changeState(8 /* SEARCH */ , 1);
                    } else if (this.isHashPrefix()) {
                        this.changeState(9 /* HASH */ , 1);
                    }
                    break;
                case 6 /* PORT */ :
                    if (this.isPathnameStart()) {
                        this.changeState(7 /* PATHNAME */ , 0);
                    } else if (this.isSearchPrefix()) {
                        this.changeState(8 /* SEARCH */ , 1);
                    } else if (this.isHashPrefix()) {
                        this.changeState(9 /* HASH */ , 1);
                    }
                    break;
                case 7 /* PATHNAME */ :
                    if (this.isSearchPrefix()) {
                        this.changeState(8 /* SEARCH */ , 1);
                    } else if (this.isHashPrefix()) {
                        this.changeState(9 /* HASH */ , 1);
                    }
                    break;
                case 8 /* SEARCH */ :
                    if (this.isHashPrefix()) {
                        this.changeState(9 /* HASH */ , 1);
                    }
                    break;
                case 9 /* HASH */ :
                    break;
                case 10 /* DONE */ :
                    break;
            }
        }
    }
    changeState(newState, skip) {
        switch(this.state){
            case 0 /* INIT */ :
                break;
            case 1 /* PROTOCOL */ :
                this.internalResult.protocol = this.makeComponentString();
                break;
            case 2 /* AUTHORITY */ :
                break;
            case 3 /* USERNAME */ :
                this.internalResult.username = this.makeComponentString();
                break;
            case 4 /* PASSWORD */ :
                this.internalResult.password = this.makeComponentString();
                break;
            case 5 /* HOSTNAME */ :
                this.internalResult.hostname = this.makeComponentString();
                break;
            case 6 /* PORT */ :
                this.internalResult.port = this.makeComponentString();
                break;
            case 7 /* PATHNAME */ :
                this.internalResult.pathname = this.makeComponentString();
                break;
            case 8 /* SEARCH */ :
                this.internalResult.search = this.makeComponentString();
                break;
            case 9 /* HASH */ :
                this.internalResult.hash = this.makeComponentString();
                break;
            case 10 /* DONE */ :
                break;
        }
        this.changeStateWithoutSettingComponent(newState, skip);
    }
    changeStateWithoutSettingComponent(newState, skip) {
        this.state = newState;
        this.componentStart = this.tokenIndex + skip;
        this.tokenIndex += skip;
        this.tokenIncrement = 0;
    }
    rewind() {
        this.tokenIndex = this.componentStart;
        this.tokenIncrement = 0;
    }
    rewindAndSetState(newState) {
        this.rewind();
        this.state = newState;
    }
    safeToken(index) {
        if (index < 0) {
            index = this.tokenList.length - index;
        }
        if (index < this.tokenList.length) {
            return this.tokenList[index];
        }
        return this.tokenList[this.tokenList.length - 1];
    }
    isNonSpecialPatternChar(index, value) {
        const token = this.safeToken(index);
        return token.value === value && (token.type === "CHAR" || token.type === "ESCAPED_CHAR" || token.type === "INVALID_CHAR");
    }
    isProtocolSuffix() {
        return this.isNonSpecialPatternChar(this.tokenIndex, ":");
    }
    nextIsAuthoritySlashes() {
        return this.isNonSpecialPatternChar(this.tokenIndex + 1, "/") && this.isNonSpecialPatternChar(this.tokenIndex + 2, "/");
    }
    isIdentityTerminator() {
        return this.isNonSpecialPatternChar(this.tokenIndex, "@");
    }
    isPasswordPrefix() {
        return this.isNonSpecialPatternChar(this.tokenIndex, ":");
    }
    isPortPrefix() {
        return this.isNonSpecialPatternChar(this.tokenIndex, ":");
    }
    isPathnameStart() {
        return this.isNonSpecialPatternChar(this.tokenIndex, "/");
    }
    isSearchPrefix() {
        if (this.isNonSpecialPatternChar(this.tokenIndex, "?")) {
            return true;
        }
        if (this.tokenList[this.tokenIndex].value !== "?") {
            return false;
        }
        const previousToken = this.safeToken(this.tokenIndex - 1);
        return previousToken.type !== "NAME" && previousToken.type !== "PATTERN" && previousToken.type !== "CLOSE" && previousToken.type !== "ASTERISK";
    }
    isHashPrefix() {
        return this.isNonSpecialPatternChar(this.tokenIndex, "#");
    }
    isGroupOpen() {
        return this.tokenList[this.tokenIndex].type == "OPEN";
    }
    isGroupClose() {
        return this.tokenList[this.tokenIndex].type == "CLOSE";
    }
    isIPv6Open() {
        return this.isNonSpecialPatternChar(this.tokenIndex, "[");
    }
    isIPv6Close() {
        return this.isNonSpecialPatternChar(this.tokenIndex, "]");
    }
    makeComponentString() {
        const token = this.tokenList[this.tokenIndex];
        const componentCharStart = this.safeToken(this.componentStart).index;
        return this.input.substring(componentCharStart, token.index);
    }
    computeShouldTreatAsStandardURL() {
        const options = {};
        Object.assign(options, DEFAULT_OPTIONS);
        options.encodePart = protocolEncodeCallback;
        const regexp = pathToRegexp(this.makeComponentString(), void 0, options);
        this.shouldTreatAsStandardURL = isSpecialScheme(regexp);
    }
};
// src/url-pattern.ts
var COMPONENTS = [
    "protocol",
    "username",
    "password",
    "hostname",
    "port",
    "pathname",
    "search",
    "hash"
];
var DEFAULT_PATTERN = "*";
function extractValues(url, baseURL) {
    if (typeof url !== "string") {
        throw new TypeError(`parameter 1 is not of type 'string'.`);
    }
    const o = new URL(url, baseURL);
    return {
        protocol: o.protocol.substring(0, o.protocol.length - 1),
        username: o.username,
        password: o.password,
        hostname: o.hostname,
        port: o.port,
        pathname: o.pathname,
        search: o.search != "" ? o.search.substring(1, o.search.length) : void 0,
        hash: o.hash != "" ? o.hash.substring(1, o.hash.length) : void 0
    };
}
function processBaseURLString(input, isPattern) {
    if (!isPattern) {
        return input;
    }
    return escapePatternString(input);
}
function applyInit(o, init, isPattern) {
    let baseURL;
    if (typeof init.baseURL === "string") {
        try {
            baseURL = new URL(init.baseURL);
            o.protocol = processBaseURLString(baseURL.protocol.substring(0, baseURL.protocol.length - 1), isPattern);
            o.username = processBaseURLString(baseURL.username, isPattern);
            o.password = processBaseURLString(baseURL.password, isPattern);
            o.hostname = processBaseURLString(baseURL.hostname, isPattern);
            o.port = processBaseURLString(baseURL.port, isPattern);
            o.pathname = processBaseURLString(baseURL.pathname, isPattern);
            o.search = processBaseURLString(baseURL.search.substring(1, baseURL.search.length), isPattern);
            o.hash = processBaseURLString(baseURL.hash.substring(1, baseURL.hash.length), isPattern);
        } catch  {
            throw new TypeError(`invalid baseURL '${init.baseURL}'.`);
        }
    }
    if (typeof init.protocol === "string") {
        o.protocol = canonicalizeProtocol(init.protocol, isPattern);
    }
    if (typeof init.username === "string") {
        o.username = canonicalizeUsername(init.username, isPattern);
    }
    if (typeof init.password === "string") {
        o.password = canonicalizePassword(init.password, isPattern);
    }
    if (typeof init.hostname === "string") {
        o.hostname = canonicalizeHostname(init.hostname, isPattern);
    }
    if (typeof init.port === "string") {
        o.port = canonicalizePort(init.port, o.protocol, isPattern);
    }
    if (typeof init.pathname === "string") {
        o.pathname = init.pathname;
        if (baseURL && !isAbsolutePathname(o.pathname, isPattern)) {
            const slashIndex = baseURL.pathname.lastIndexOf("/");
            if (slashIndex >= 0) {
                o.pathname = processBaseURLString(baseURL.pathname.substring(0, slashIndex + 1), isPattern) + o.pathname;
            }
        }
        o.pathname = canonicalizePathname(o.pathname, o.protocol, isPattern);
    }
    if (typeof init.search === "string") {
        o.search = canonicalizeSearch(init.search, isPattern);
    }
    if (typeof init.hash === "string") {
        o.hash = canonicalizeHash(init.hash, isPattern);
    }
    return o;
}
function escapePatternString(value) {
    return value.replace(/([+*?:{}()\\])/g, "\\$1");
}
function escapeRegexpString(value) {
    return value.replace(/([.+*?^${}()[\]|/\\])/g, "\\$1");
}
function tokensToPattern(tokens, options) {
    const wildcardPattern = ".*";
    const segmentWildcardPattern = `[^${escapeRegexpString(options.delimiter === void 0 ? "/#?" : options.delimiter)}]+?`;
    const regexIdentifierPart2 = /[$_\u200C\u200D\p{ID_Continue}]/u;
    let result = "";
    for(let i = 0; i < tokens.length; ++i){
        const token = tokens[i];
        const lastToken = i > 0 ? tokens[i - 1] : null;
        const nextToken = i < tokens.length - 1 ? tokens[i + 1] : null;
        if (typeof token === "string") {
            result += escapePatternString(token);
            continue;
        }
        if (token.pattern === "") {
            if (token.modifier === "") {
                result += escapePatternString(token.prefix);
                continue;
            }
            result += `{${escapePatternString(token.prefix)}}${token.modifier}`;
            continue;
        }
        const customName = typeof token.name !== "number";
        const optionsPrefixes = options.prefixes !== void 0 ? options.prefixes : "./";
        let needsGrouping = token.suffix !== "" || token.prefix !== "" && (token.prefix.length !== 1 || !optionsPrefixes.includes(token.prefix));
        if (!needsGrouping && customName && token.pattern === segmentWildcardPattern && token.modifier === "" && nextToken && !nextToken.prefix && !nextToken.suffix) {
            if (typeof nextToken === "string") {
                const code = nextToken.length > 0 ? nextToken[0] : "";
                needsGrouping = regexIdentifierPart2.test(code);
            } else {
                needsGrouping = typeof nextToken.name === "number";
            }
        }
        if (!needsGrouping && token.prefix === "" && lastToken && typeof lastToken === "string" && lastToken.length > 0) {
            const code = lastToken[lastToken.length - 1];
            needsGrouping = optionsPrefixes.includes(code);
        }
        if (needsGrouping) {
            result += "{";
        }
        result += escapePatternString(token.prefix);
        if (customName) {
            result += `:${token.name}`;
        }
        if (token.pattern === wildcardPattern) {
            if (!customName && (!lastToken || typeof lastToken === "string" || lastToken.modifier || needsGrouping || token.prefix !== "")) {
                result += "*";
            } else {
                result += `(${wildcardPattern})`;
            }
        } else if (token.pattern === segmentWildcardPattern) {
            if (!customName) {
                result += `(${segmentWildcardPattern})`;
            }
        } else {
            result += `(${token.pattern})`;
        }
        if (token.pattern === segmentWildcardPattern && customName && token.suffix !== "") {
            if (regexIdentifierPart2.test(token.suffix[0])) {
                result += "\\";
            }
        }
        result += escapePatternString(token.suffix);
        if (needsGrouping) {
            result += "}";
        }
        result += token.modifier;
    }
    return result;
}
var URLPattern = class {
    constructor(init = {}, baseURLOrOptions, options){
        this.regexp = {};
        this.keys = {};
        this.component_pattern = {};
        try {
            let baseURL = void 0;
            if (typeof baseURLOrOptions === "string") {
                baseURL = baseURLOrOptions;
            } else {
                options = baseURLOrOptions;
            }
            if (typeof init === "string") {
                const parser = new Parser(init);
                parser.parse();
                init = parser.result;
                if (baseURL === void 0 && typeof init.protocol !== "string") {
                    throw new TypeError(`A base URL must be provided for a relative constructor string.`);
                }
                init.baseURL = baseURL;
            } else {
                if (!init || typeof init !== "object") {
                    throw new TypeError(`parameter 1 is not of type 'string' and cannot convert to dictionary.`);
                }
                if (baseURL) {
                    throw new TypeError(`parameter 1 is not of type 'string'.`);
                }
            }
            if (typeof options === "undefined") {
                options = {
                    ignoreCase: false
                };
            }
            const ignoreCaseOptions = {
                ignoreCase: options.ignoreCase === true
            };
            const defaults = {
                pathname: DEFAULT_PATTERN,
                protocol: DEFAULT_PATTERN,
                username: DEFAULT_PATTERN,
                password: DEFAULT_PATTERN,
                hostname: DEFAULT_PATTERN,
                port: DEFAULT_PATTERN,
                search: DEFAULT_PATTERN,
                hash: DEFAULT_PATTERN
            };
            this.pattern = applyInit(defaults, init, true);
            if (defaultPortForProtocol(this.pattern.protocol) === this.pattern.port) {
                this.pattern.port = "";
            }
            let component;
            for (component of COMPONENTS){
                if (!(component in this.pattern)) continue;
                const options2 = {};
                const pattern = this.pattern[component];
                this.keys[component] = [];
                switch(component){
                    case "protocol":
                        Object.assign(options2, DEFAULT_OPTIONS);
                        options2.encodePart = protocolEncodeCallback;
                        break;
                    case "username":
                        Object.assign(options2, DEFAULT_OPTIONS);
                        options2.encodePart = usernameEncodeCallback;
                        break;
                    case "password":
                        Object.assign(options2, DEFAULT_OPTIONS);
                        options2.encodePart = passwordEncodeCallback;
                        break;
                    case "hostname":
                        Object.assign(options2, HOSTNAME_OPTIONS);
                        if (treatAsIPv6Hostname(pattern)) {
                            options2.encodePart = ipv6HostnameEncodeCallback;
                        } else {
                            options2.encodePart = hostnameEncodeCallback;
                        }
                        break;
                    case "port":
                        Object.assign(options2, DEFAULT_OPTIONS);
                        options2.encodePart = portEncodeCallback;
                        break;
                    case "pathname":
                        if (isSpecialScheme(this.regexp.protocol)) {
                            Object.assign(options2, PATHNAME_OPTIONS, ignoreCaseOptions);
                            options2.encodePart = standardURLPathnameEncodeCallback;
                        } else {
                            Object.assign(options2, DEFAULT_OPTIONS, ignoreCaseOptions);
                            options2.encodePart = pathURLPathnameEncodeCallback;
                        }
                        break;
                    case "search":
                        Object.assign(options2, DEFAULT_OPTIONS, ignoreCaseOptions);
                        options2.encodePart = searchEncodeCallback;
                        break;
                    case "hash":
                        Object.assign(options2, DEFAULT_OPTIONS, ignoreCaseOptions);
                        options2.encodePart = hashEncodeCallback;
                        break;
                }
                try {
                    const tokens = parse(pattern, options2);
                    this.regexp[component] = tokensToRegexp(tokens, this.keys[component], options2);
                    this.component_pattern[component] = tokensToPattern(tokens, options2);
                } catch  {
                    throw new TypeError(`invalid ${component} pattern '${this.pattern[component]}'.`);
                }
            }
        } catch (err) {
            throw new TypeError(`Failed to construct 'URLPattern': ${err.message}`);
        }
    }
    test(input = {}, baseURL) {
        let values = {
            pathname: "",
            protocol: "",
            username: "",
            password: "",
            hostname: "",
            port: "",
            search: "",
            hash: ""
        };
        if (typeof input !== "string" && baseURL) {
            throw new TypeError(`parameter 1 is not of type 'string'.`);
        }
        if (typeof input === "undefined") {
            return false;
        }
        try {
            if (typeof input === "object") {
                values = applyInit(values, input, false);
            } else {
                values = applyInit(values, extractValues(input, baseURL), false);
            }
        } catch (err) {
            return false;
        }
        let component;
        for (component of COMPONENTS){
            if (!this.regexp[component].exec(values[component])) {
                return false;
            }
        }
        return true;
    }
    exec(input = {}, baseURL) {
        let values = {
            pathname: "",
            protocol: "",
            username: "",
            password: "",
            hostname: "",
            port: "",
            search: "",
            hash: ""
        };
        if (typeof input !== "string" && baseURL) {
            throw new TypeError(`parameter 1 is not of type 'string'.`);
        }
        if (typeof input === "undefined") {
            return;
        }
        try {
            if (typeof input === "object") {
                values = applyInit(values, input, false);
            } else {
                values = applyInit(values, extractValues(input, baseURL), false);
            }
        } catch (err) {
            return null;
        }
        let result = {};
        if (baseURL) {
            result.inputs = [
                input,
                baseURL
            ];
        } else {
            result.inputs = [
                input
            ];
        }
        let component;
        for (component of COMPONENTS){
            let match = this.regexp[component].exec(values[component]);
            if (!match) {
                return null;
            }
            let groups = {};
            for (let [i, key] of this.keys[component].entries()){
                if (typeof key.name === "string" || typeof key.name === "number") {
                    let value = match[i + 1];
                    groups[key.name] = value;
                }
            }
            result[component] = {
                input: values[component] || "",
                groups
            };
        }
        return result;
    }
    get protocol() {
        return this.component_pattern.protocol;
    }
    get username() {
        return this.component_pattern.username;
    }
    get password() {
        return this.component_pattern.password;
    }
    get hostname() {
        return this.component_pattern.hostname;
    }
    get port() {
        return this.component_pattern.port;
    }
    get pathname() {
        return this.component_pattern.pathname;
    }
    get search() {
        return this.component_pattern.search;
    }
    get hash() {
        return this.component_pattern.hash;
    }
};


;// CONCATENATED MODULE: ../../node_modules/urlpattern-polyfill/index.js


if (!globalThis.URLPattern) {
    globalThis.URLPattern = URLPattern;
}


/***/ })

};
;